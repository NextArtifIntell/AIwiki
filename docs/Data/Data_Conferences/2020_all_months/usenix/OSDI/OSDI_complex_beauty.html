<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>OSDI_complex_beauty</title>
  <style>
    html {font-size: 22px;}
    body {margin: 0 auto; max-width: 76em;}
    #copyID {font-size: 18px;}
  </style>
  <script>
    function copy(element) {
      if (element.type == "button"){
      element.type="text";
      }
      element.style.color="black";
      element.style.backgroundColor="#C7EDCC";
      element.select();
      element.setSelectionRange(0, 99999);
      navigator.clipboard.writeText(element.value);
      window.getSelection().removeAllRanges();
      element.type="button";
    }
  </script>
</head>
<body>

<h2 id="osdi---70">OSDI - 70</h2>
<ul>
<li><details>
<summary>
(2020). Thunderbolt: <span
class="nocase">Throughput-optimized</span>, <span
class="nocase">Quality-of-service-aware</span> power capping at scale.
<em>OSDI</em>, 1241–1255. (<a
href="https://www.usenix.org/conference/osdi20/presentation/li-shaohong">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Shaohong Li, Xi Wang, Xiao Zhang, Vasileios Kontorinis, Sreekumar Kodakara, David Lo, and Parthasarathy Ranganathan, Google LLC As the demand for data center capacity continues to grow, hyperscale providers have used power oversubscription to increase efficiency and reduce costs. Power oversubscription requires power capping systems to smooth out the spikes that risk overloading power equipment by throttling workloads. Modern compute clusters run latency-sensitive serving and throughput-oriented batch workloads on the same servers, provisioning resources to ensure low latency for the former while using the latter to achieve high server utilization. When power capping occurs, it is desirable to maintain low latency for serving tasks and throttle the throughput of batch tasks. To achieve this, we seek a system that can gracefully throttle batch workloads and has task-level quality-of-service (QoS) differentiation. In this paper we present Thunderbolt, a hardware-agnostic power capping system that ensures safe power oversubscription while minimizing impact on both long-running throughput-oriented tasks and latency-sensitive tasks. It uses a two-threshold, randomized unthrottling/multiplicative decrease control policy to ensure power safety with minimized performance degradation. It leverages the Linux kernel&#39;s CPU bandwidth control feature to achieve task-level QoS-aware throttling. It is robust even in the face of power telemetry unavailability. Evaluation results at the node and cluster levels demonstrate the system&#39;s responsiveness, effectiveness for reducing power, capability of QoS differentiation, and minimal impact on latency and task health. We have deployed this system at scale, in multiple production clusters. As a result, we enabled power oversubscription gains of 9%--25%, where none was previously possible.},
  archive   = {C_OSDI},
  author    = {Shaohong Li and Xi Wang and Xiao Zhang and Vasileios Kontorinis and Sreekumar Kodakara and David Lo and Parthasarathy Ranganathan},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {1241-1255},
  title     = {Thunderbolt: {Throughput-optimized}, {Quality-of-service-aware} power capping at scale},
  url       = {https://www.usenix.org/conference/osdi20/presentation/li-shaohong},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). RackSched: A <span class="nocase">Microsecond-scale</span>
scheduler for <span class="nocase">Rack-scale</span> computers.
<em>OSDI</em>, 1225–1240. (<a
href="https://www.usenix.org/conference/osdi20/presentation/zhu">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Hang Zhu, Johns Hopkins University; Kostis Kaffes, Stanford University; Zixu Chen, Johns Hopkins University; Zhenming Liu, College of William and Mary; Christos Kozyrakis, Stanford University; Ion Stoica, UC Berkeley; Xin Jin, Johns Hopkins University Low-latency online services have strict Service Level Objectives (SLOs) that require datacenter systems to support high throughput at microsecond-scale tail latency. Dataplane operating systems have been designed to scale up multi-core servers with minimal overhead for such SLOs. However, as application demands continue to increase, scaling up is not enough, and serving larger demands requires these systems to scale out to multiple servers in a rack. We present RackSched, the first rack-level microsecond-scale scheduler that provides the abstraction of a rack-scale computer (i.e., a huge server with hundreds to thousands of cores) to an external service with network-system co-design. The core of RackSched is a two-layer scheduling framework that integrates inter-server scheduling in the top-of-rack (ToR) switch with intra-server scheduling in each server. We use a combination of analytical results and simulations to show that it provides near-optimal performance as centralized scheduling policies, and is robust for both low-dispersion and high-dispersion workloads. We design a custom switch data plane for the inter-server scheduler, which realizes power-of-k- choices, ensures request affinity, and tracks server loads accurately and efficiently. We implement a RackSched prototype on a cluster of commodity servers connected by a Barefoot Tofino switch. End-to-end experiments on a twelve-server testbed show that RackSched improves the throughput by up to 1.44x, and scales out the throughput near linearly, while maintaining the same tail latency as one server until the system is saturated.},
  archive   = {C_OSDI},
  author    = {Hang Zhu and Kostis Kaffes and Zixu Chen and Zhenming Liu and Christos Kozyrakis and Ion Stoica and Xin Jin},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {1225-1240},
  title     = {{RackSched}: A {Microsecond-scale} scheduler for {Rack-scale} computers},
  url       = {https://www.usenix.org/conference/osdi20/presentation/zhu},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Unearthing inter-job dependencies for better cluster
scheduling. <em>OSDI</em>, 1205–1223. (<a
href="https://www.usenix.org/conference/osdi20/presentation/chung">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Andrew Chung, Carnegie Mellon University; Subru Krishnan, Konstantinos Karanasos, and Carlo Curino, Microsoft; Gregory R. Ganger, Carnegie Mellon University Inter-job dependencies pervade shared data analytics infrastructures (so-called ``data lakes&#39;&#39;), as jobs read output files written by previous jobs, yet are often invisible to current cluster schedulers. Jobs are submitted one-by-one, without indicating dependencies, and the scheduler considers them independently based on priority, fairness, etc. This paper analyzes hidden inter-job dependencies in a 50k+ node analytics cluster at Microsoft, based on job and data provenance logs, finding that nearly 80% of all jobs depend on at least one other job. Yet, even in a business-critical setting, we see jobs that fail because they depend on not-yet-completed jobs, jobs that depend on jobs of lower priority, and other difficulties with hidden inter-job dependencies. The Wing dependency profiler analyzes job and data provenance logs to find hidden inter-job dependencies, characterizes them, and provides improved guidance to a cluster scheduler. Specifically, for the 68% of jobs (in the analyzed data~lake) that exhibit their dependencies in a recurring fashion, Wing predicts the impact of a pending job on subsequent jobs and user downloads, and uses that information to refine valuation of that job by the scheduler. In simulations driven by real job logs, we find that a traditional YARN scheduler that uses Wing-provided valuations in place of user-specified priorities extracts more value (in terms of successful dependent jobs and user downloads) from a heavily-loaded cluster. By relying completely on Wing for guidance, YARN can achieve nearly 100% of value at constrained cluster capacities, almost 2x that achieved by using the user-provided job priorities.},
  archive   = {C_OSDI},
  author    = {Andrew Chung and Subru Krishnan and Konstantinos Karanasos and Carlo Curino and Gregory R. Ganger},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {1205-1223},
  title     = {Unearthing inter-job dependencies for better cluster scheduling},
  url       = {https://www.usenix.org/conference/osdi20/presentation/chung},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Fault-tolerant and transactional stateful serverless
workflows. <em>OSDI</em>, 1187–1204. (<a
href="https://www.usenix.org/conference/osdi20/presentation/zhang-haoran">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Haoran Zhang, University of Pennsylvania; Adney Cardoza, Rutgers University–Camden; Peter Baile Chen, Sebastian Angel, and Vincent Liu, University of Pennsylvania This paper introduces Beldi, a library and runtime system for writing and composing fault-tolerant and transactional stateful serverless functions. Beldi runs on existing providers and lets developers write complex stateful applications that require fault tolerance and transactional semantics without the need to deal with tasks such as load balancing or maintaining virtual machines. Beldi’s contributions include extending the log-based fault-tolerant approach in Olive (OSDI 2016) with new data structures, transaction protocols, function invocations, and garbage collection. They also include adapting the resulting framework to work over a federated environment where each serverless function has sovereignty over its own data. We implement three applications on Beldi, including a movie review service, a travel reservation system, and a social media site. Our evaluation on 1,000 AWS Lambdas shows that Beldi’s approach is effective and affordable.},
  archive   = {C_OSDI},
  author    = {Haoran Zhang and Adney Cardoza and Peter Baile Chen and Sebastian Angel and Vincent Liu},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {1187-1204},
  title     = {Fault-tolerant and transactional stateful serverless workflows},
  url       = {https://www.usenix.org/conference/osdi20/presentation/zhang-haoran},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Sundial: Fault-tolerant clock synchronization for
datacenters. <em>OSDI</em>, 1171–1186. (<a
href="https://www.usenix.org/conference/osdi20/presentation/li-yuliang">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Yuliang Li, Google Inc. and Harvard University; Gautam Kumar, Hema Hariharan, Hassan Wassel, Peter Hochschild, and Dave Platt, Google Inc.; Simon Sabato, Lilac Cloud; Minlan Yu, Harvard University; Nandita Dukkipati, Prashant Chandra, and Amin Vahdat, Google Inc. Clock synchronization is critical for many datacenter applications such as distributed transactional databases, consistent snapshots, and network telemetry. As applications have increasing performance requirements and datacenter networks get into ultra-low latency, we need submicrosecond-level bound on time-uncertainty to reduce transaction delay and enable new network management applications (e.g., measuring one-way delay for congestion control). The state-of-the-art clock synchronization solutions focus on improving clock precision but may incur significant time-uncertainty bound due to the presence of failures. This significantly affects applications because in large-scale datacenters, temperature-related, link, device, and domain failures are common. We present Sundial, a fault-tolerant clock-synchronization system for datacenters that achieves ~100ns time-uncertainty bound under various types of failures. Sundial provides fast failure detection based on frequent synchronization messages in hardware. Sundial enables fast failure recovery using a novel graph-based algorithm to precompute a backup plan that is generic to failures. Through experiments in a &gt;500-machine testbed and large-scale simulations, we show that Sundial can achieve ~100ns time-uncertainty bound under different types of failures, which is more than two orders of magnitude lower than the state-of-the-art solutions. We also demonstrate the benefit of Sundial on applications such as Spanner and Swift congestion control.},
  archive   = {C_OSDI},
  author    = {Yuliang Li and Gautam Kumar and Hema Hariharan and Hassan Wassel and Peter Hochschild and Dave Platt and Simon Sabato and Minlan Yu and Nandita Dukkipati and Prashant Chandra and Amin Vahdat},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {1171-1186},
  title     = {Sundial: Fault-tolerant clock synchronization for datacenters},
  url       = {https://www.usenix.org/conference/osdi20/presentation/li-yuliang},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Predictive and adaptive failure mitigation to avert
production cloud VM interruptions. <em>OSDI</em>, 1155–1170. (<a
href="https://www.usenix.org/conference/osdi20/presentation/levy">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Sebastien Levy, Randolph Yao, Youjiang Wu, and Yingnong Dang, Microsoft Azure; Peng Huang, Johns Hopkins University; Zheng Mu, Microsoft Azure; Pu Zhao, Microsoft Research; Tarun Ramani, Naga Govindaraju, and Xukun Li, Microsoft Azure; Qingwei Lin, Microsoft Research; Gil Lapid Shafriri and Murali Chintalapati, Microsoft Azure When a failure occurs in production systems, the highest priority is to quickly mitigate it. Despite its importance, failure mitigation is done in a reactive and ad-hoc way: taking some fixed actions only after a severe symptom is observed. For cloud systems, such a strategy is inadequate. In this paper, we propose a preventive and adaptive failure mitigation service, Narya, that is integrated in a production cloud, Microsoft Azure&#39;s compute platform. Narya predicts imminent host failures based on multi-layer system signals and then decides smart mitigation actions. The goal is to avert VM failures. Narya&#39;s decision engine takes a novel online experimentation approach to continually explore the best mitigation action. Narya further enhances the adaptive decision capability through reinforcement learning. Narya has been running in production for 15 months. It on average reduces VM interruptions by 26% compared to the previous static strategy.},
  archive   = {C_OSDI},
  author    = {Sebastien Levy and Randolph Yao and Youjiang Wu and Yingnong Dang and Peng Huang and Zheng Mu and Pu Zhao and Tarun Ramani and Naga Govindaraju and Xukun Li and Qingwei Lin and Gil Lapid Shafriri and Murali Chintalapati},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {1155-1170},
  title     = {Predictive and adaptive failure mitigation to avert production cloud {VM} interruptions},
  url       = {https://www.usenix.org/conference/osdi20/presentation/levy},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Efficiently mitigating transient execution attacks using the
unmapped speculation contract. <em>OSDI</em>, 1139–1154. (<a
href="https://www.usenix.org/conference/osdi20/presentation/behrens">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Jonathan Behrens, Anton Cao, Cel Skeggs, Adam Belay, M. Frans Kaashoek, and Nickolai Zeldovich, MIT CSAIL Today’s kernels pay a performance penalty for mitigations—such as KPTI, retpoline, return stack stuffing, speculation barriers—to protect against transient execution side-channel attacks such as Meltdown and Spectre. To address this performance penalty, this paper articulates the unmapped speculation contract, an observation that memory that isn’t mapped in a page table cannot be leaked through transient execution. To demonstrate the value of this contract, the paper presents Ward, a new kernel design that maintains a separate kernel page table for every process. This page table contains mappings for kernel memory that is safe to expose to that process. Because a process doesn’t map data of other processes, this design allows for many system calls to execute without any mitigation overhead. When a process needs access to sensitive data, Ward switches to a kernel page table that provides access to all of memory and executes with all mitigations. An evaluation of the Ward design implemented in the sv6 research kernel shows that can execute many system calls without mitigations. For some hardware generations, this results in performance improvement ranging from a few percent (huge page fault) to several factors (getpid), compared to a standard design with mitigations.},
  archive   = {C_OSDI},
  author    = {Jonathan Behrens and Anton Cao and Cel Skeggs and Adam Belay and M. Frans Kaashoek and Nickolai Zeldovich},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {1139-1154},
  title     = {Efficiently mitigating transient execution attacks using the unmapped speculation contract},
  url       = {https://www.usenix.org/conference/osdi20/presentation/behrens},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). SafetyPin: Encrypted backups with <span
class="nocase">Human-memorable</span> secrets. <em>OSDI</em>, 1121–1138.
(<a
href="https://www.usenix.org/conference/osdi20/presentation/dauterman-safetypin">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Emma Dauterman, UC Berkeley; Henry Corrigan-Gibbs, EPFL and MIT CSAIL; David Mazières, Stanford University We present the design and implementation of SafetyPin, a system for encrypted mobile-device backups. Like existing cloud-based mobile-backup systems, including those of Apple and Google, SafetyPin requires users to remember only a short PIN and defends against brute-force PIN-guessing attacks using hardware security protections. Unlike today&#39;s systems, SafetyPin splits trust over a cluster of hardware security modules (HSMs) in order to provide security guarantees that scale with the number of HSMs. In this way, SafetyPin protects backed-up user data even against an attacker that can adaptively compromise many of the system&#39;s constituent HSMs. SafetyPin provides this protection without sacrificing scalability or fault tolerance. Decentralizing trust while respecting the resource limits of today&#39;s HSMs requires a synthesis of systems-design principles and cryptographic tools. We evaluate SafetyPin on a cluster of 100 low-cost HSMs and show that a SafetyPin-protected recovery takes 1.01 seconds. To process 1B recoveries a year, we estimate that a SafetyPin deployment would need 3,100 low-cost HSMs.},
  archive   = {C_OSDI},
  author    = {Emma Dauterman and Henry Corrigan-Gibbs and David Mazières},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {1121-1138},
  title     = {{SafetyPin}: Encrypted backups with {Human-memorable} secrets},
  url       = {https://www.usenix.org/conference/osdi20/presentation/dauterman-safetypin},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). DORY: An encrypted search system with distributed trust.
<em>OSDI</em>, 1101–1119. (<a
href="https://www.usenix.org/conference/osdi20/presentation/dauterman-dory">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Emma Dauterman, Eric Feng, Ellen Luo, Raluca Ada Popa, and Ion Stoica, University of California, Berkeley Efficient, leakage-free search on encrypted data has remained an unsolved problem for the last two decades; efficient schemes are vulnerable to leakage-abuse attacks, and schemes that eliminate leakage are impractical to deploy. To overcome this tradeoff, we reexamine the system model. We surveyed five companies providing end-to-end encrypted filesharing to better understand what they require from an encrypted search system. Based on our findings, we design and build DORY, an encrypted search system that addresses real-world requirements and protects search access patterns; namely, when a user searches for a keyword over the files within a folder, the server learns only that a search happens in that folder, but does not learn which documents match the search, the number of documents that match, or other information about the keyword. DORY splits trust between multiple servers to protect against a malicious attacker who controls all but one of the servers. We develop new cryptographic and systems techniques to meet the efficiency and trust model requirements outlined by the companies we surveyed. We implement DORY and show that it performs orders of magnitude better than a baseline built on ORAM. Parallelized across 8 servers, each with 16 CPUs, DORY takes 116ms to search roughly 50K documents and 862ms to search over 1M documents.},
  archive   = {C_OSDI},
  author    = {Emma Dauterman and Eric Feng and Ellen Luo and Raluca Ada Popa and Ion Stoica},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {1101-1119},
  title     = {{DORY}: An encrypted search system with distributed trust},
  url       = {https://www.usenix.org/conference/osdi20/presentation/dauterman-dory},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Achieving 100Gbps intrusion prevention on a single server.
<em>OSDI</em>, 1083–1100. (<a
href="https://www.usenix.org/conference/osdi20/presentation/zhao-zhipeng">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Zhipeng Zhao, Hugo Sadok, Nirav Atre, James C. Hoe, Vyas Sekar, and Justine Sherry, Carnegie Mellon University Intrusion Detection and Prevention Systems (IDS/IPS) are among the most demanding stateful network functions. Today&#39;s network operators are faced with securing 100Gbps networks with 100K+ concurrent connections by deploying IDS/IPSes to search for 10K+ rules concurrently. In this paper we set an ambitious goal: Can we do all of the above in a single server? Through the Pigasus IDS/IPS, we show that this goal is achievable, perhaps for the first time, by building on recent advances in FPGA-capable SmartNICs. Pigasus&#39; design takes an FPGA-first approach, where the majority of processing, and all state and control flow are managed on the FPGA. However, doing so requires careful design of algorithms and data structures to ensure fast common-case performance while densely utilizing system memory resources. Our experiments with a variety of traces show that Pigasus can support 100Gbps using an average of 5 cores and 1 FPGA, using 38x less power than a CPU-only approach.},
  archive   = {C_OSDI},
  author    = {Zhipeng Zhao and Hugo Sadok and Nirav Atre and James C. Hoe and Vyas Sekar and Justine Sherry},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {1083-1100},
  title     = {Achieving 100Gbps intrusion prevention on a single server},
  url       = {https://www.usenix.org/conference/osdi20/presentation/zhao-zhipeng},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Orchard: Differentially private analytics at scale.
<em>OSDI</em>, 1065–1081. (<a
href="https://www.usenix.org/conference/osdi20/presentation/roth">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Edo Roth, Hengchu Zhang, Andreas Haeberlen, and Benjamin C. Pierce, University of Pennsylvania This paper presents Orchard, a system that can answer queries about sensitive data that is held by millions of user devices, with strong differential privacy guarantees. Orchard combines high accuracy with good scalability, and it uses only a single untrusted party to facilitate the query. Moreover, whereas previous solutions that shared these properties were custom-built for specific queries, Orchard is general and can accept a wide range of queries. Orchard accomplishes this by rewriting queries into a distributed protocol that can be executed efficiently at scale, using cryptographic primitives. Our prototype of Orchard can execute 14 out of 17 queries chosen from the literature; to our knowledge, no other system can handle more than one of them in this setting. And the costs are moderate: each user device typically needs only a few megabytes of traffic and a few minutes of computation time. Orchard also includes a novel defense against malicious users who attempt to distort the results of a query.},
  archive   = {C_OSDI},
  author    = {Edo Roth and Hengchu Zhang and Andreas Haeberlen and Benjamin C. Pierce},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {1065-1081},
  title     = {Orchard: Differentially private analytics at scale},
  url       = {https://www.usenix.org/conference/osdi20/presentation/roth},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). AGAMOTTO: How persistent is your persistent memory
application? <em>OSDI</em>, 1047–1064. (<a
href="https://www.usenix.org/conference/osdi20/presentation/neal">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Ian Neal, Ben Reeves, Ben Stoler, and Andrew Quinn, University of Michigan; Youngjin Kwon, KAIST; Simon Peter, University of Texas at Austin; Baris Kasikci, University of Michigan Persistent Memory (PM) can be used by applications to directly and quickly persist any data structure, without the overhead of a file system. However, writing PM applications that are simultaneously correct and efficient is challenging. As a result, PM applications contain correctness and performance bugs. Prior work on testing PM systems has low bug coverage as it relies primarily on extensive test cases and developer annotations. In this paper we aim to build a system for more thoroughly testing PM applications. We inform our design using a detailed study of 63 bugs from popular PM projects. We identify two application-independent patterns of PM misuse which account for the majority of bugs in our study and can be detected automatically. The remaining application-specific bugs can be detected using compact custom oracles provided by developers. We then present AGAMOTTO, a generic and extensible system for discovering misuse of persistent memory in PM applications. Unlike existing tools that rely on extensive test cases or annotations, AGAMOTTO symbolically executes PM systems to discover bugs. AGAMOTTO introduces a new symbolic memory model that is able to represent whether or not PM state has been made persistent. AGAMOTTO uses a state space exploration algorithm, which drives symbolic execution towards program locations that are susceptible to persistency bugs. AGAMOTTO has so far identified 84 new bugs in 5 different PM applications and frameworks while incurring no false positives.},
  archive   = {C_OSDI},
  author    = {Ian Neal and Ben Reeves and Ben Stoler and Andrew Quinn and Youngjin Kwon and Simon Peter and Baris Kasikci},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {1047-1064},
  title     = {{AGAMOTTO}: How persistent is your persistent memory application?},
  url       = {https://www.usenix.org/conference/osdi20/presentation/neal},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Persistent state machines for recoverable in-memory storage
systems with NVRam. <em>OSDI</em>, 1029–1046. (<a
href="https://www.usenix.org/conference/osdi20/presentation/zhang-wen">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Wen Zhang, UC Berkeley; Scott Shenker, UC Berkeley/ICSI; Irene Zhang, Microsoft Research/University of Washington Distributed in-memory storage systems are crucial for meeting the low latency requirements of modern datacenter services. However, they lose all state on failure, so recovery is expensive and data loss is always a risk. Persistent memory (PM) offers the possibility of building fast, persistent in-memory storage; however, existing PM systems are built from scratch or require heavy modification of existing systems. To rectify these problems, this paper presents Persimmon, a PM-based system that converts existing distributed in-memory storage systems into persistent, crash-consistent versions with low overhead and minimal code changes.},
  archive   = {C_OSDI},
  author    = {Wen Zhang and Scott Shenker and Irene Zhang},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {1029-1046},
  title     = {Persistent state machines for recoverable in-memory storage systems with {NVRam}},
  url       = {https://www.usenix.org/conference/osdi20/presentation/zhang-wen},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Assise: Performance and availability via client-local NVM in
a distributed file system. <em>OSDI</em>, 1011–1027. (<a
href="https://www.usenix.org/conference/osdi20/presentation/anderson">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Thomas E. Anderson, University of Washington; Marco Canini, KAUST; Jongyul Kim, KAIST; Dejan Kostić, KTH Royal Institute of Technology; Youngjin Kwon, KAIST; Simon Peter, The University of Texas at Austin; Waleed Reda, KTH Royal Institute of Technology and Université catholique de Louvain; Henry N. Schuh, University of Washington; Emmett Witchel, The University of Texas at Austin The adoption of low latency persistent memory modules (PMMs) upends the long-established model of remote storage for distributed file systems. Instead, by colocating computation with PMM storage, we can provide applications with much higher IO performance, sub-second application failover, and strong consistency. To demonstrate this, we built the Assise distributed file system, based on a persistent, replicated coherence protocol that manages client-local PMM as a linearizable and crash-recoverable cache between applications and slower (and possibly remote) storage. Assise maximizes locality for all file IO by carrying out IO on process-local, socket-local, and client-local PMM whenever possible. Assise minimizes coherence overhead by maintaining consistency at IO operation granularity, rather than at fixed block sizes. We compare Assise to Ceph/BlueStore, NFS, and Octopus on a cluster with Intel Optane DC PMMs and SSDs for common cloud applications and benchmarks, such as LevelDB, Postfix, and FileBench. We find that Assise improves write latency up to 22x, throughput up to 56x, fail-over time up to 103x, and scales up to 6x better than its counterparts, while providing stronger consistency semantics.},
  archive   = {C_OSDI},
  author    = {Thomas E. Anderson and Marco Canini and Jongyul Kim and Dejan Kostić and Youngjin Kwon and Simon Peter and Waleed Reda and Henry N. Schuh and Emmett Witchel},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {1011-1027},
  title     = {Assise: Performance and availability via client-local {NVM} in a distributed file system},
  url       = {https://www.usenix.org/conference/osdi20/presentation/anderson},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Do OS abstractions make sense on FPGAs? <em>OSDI</em>,
991–1010. (<a
href="https://www.usenix.org/conference/osdi20/presentation/roscoe">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Dario Korolija, Timothy Roscoe, and Gustavo Alonso, ETH Zurich Hybrid computing systems, consisting of a CPU server coupled with a Field-Programmable Gate Array (FPGA) for application acceleration, are today a common facility in datacenters and clouds. FPGAs can deliver tremendous improvements in performance and energy efficiency for a range or workloads, but development and deployment of FPGA-based applications remains cumbersome, leading to recent work which replicates subsets of the traditional OS execution environment (virtual memory, processes, etc.) on the FPGA. In this paper we ask a different question: to what extent do traditional OS abstractions make sense in the context of an FPGA as part of a hybrid system, particularly when taken as a complete package , as they would be in an OS? To answer this, we built and evaluated Coyote, an open source, portable, configurable &quot;shell&quot;&#39; for FPGAs which provides a full suite of OS abstractions, working with the host OS. Coyote supports secure spatial and temporal multiplexing of the FPGA between tenants, virtual memory, communication, and memory management inside a uniform execution environment. The overhead of Coyote is small and the performance benefit is significant, but more importantly it allows us to reflect on whether importing OS abstractions wholesale to FPGAs is the best way forward.},
  archive   = {C_OSDI},
  author    = {Dario Korolija and Timothy Roscoe and Gustavo Alonso},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {991-1010},
  title     = {Do {OS} abstractions make sense on {FPGAs}?},
  url       = {https://www.usenix.org/conference/osdi20/presentation/roscoe},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). <span class="nocase">hXDP</span>: Efficient software packet
processing on FPGA NICs. <em>OSDI</em>, 973–990. (<a
href="https://www.usenix.org/conference/osdi20/presentation/brunella">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Marco Spaziani Brunella and Giacomo Belocchi, Axbryd/University of Rome Tor Vergata; Marco Bonola, Axbryd/CNIT; Salvatore Pontarelli, Axbryd; Giuseppe Siracusano, NEC Laboratories Europe; Giuseppe Bianchi, University of Rome Tor Vergata; Aniello Cammarano, Alessandro Palumbo, and Luca Petrucci, CNIT/University of Rome Tor Vergata; Roberto Bifulco, NEC Laboratories Europe Awarded Best Paper! FPGA accelerators on the NIC enable the offloading of expensive packet processing tasks from the CPU. However, FPGAs have limited resources that may need to be shared among diverse applications, and programming them is difficult. We present a solution to run Linux&#39;s eXpress Data Path programs written in eBPF on FPGAs, using only a fraction of the available hardware resources while matching the performance of high-end CPUs. The iterative execution model of eBPF is not a good fit for FPGA accelerators. Nonetheless, we show that many of the instructions of an eBPF program can be compressed, parallelized or completely removed, when targeting a purpose-built FPGA executor, thereby significantly improving performance. We leverage that to design hXDP, which includes (i) an optimizing-compiler that parallelizes and translates eBPF bytecode to an extended eBPF Instruction-set Architecture defined by us; a (ii) soft-processor to execute such instructions on FPGA; and (iii) an FPGA-based infrastructure to provide XDP&#39;s maps and helper functions as defined within the Linux kernel. We implement hXDP on an FPGA NIC and evaluate it running real-world unmodified eBPF programs. Our implementation is clocked at 156.25MHz, uses about 15% of the FPGA resources, and can run dynamically loaded programs. Despite these modest requirements, it achieves the packet processing throughput of a high-end CPU core and provides a 10x lower packet forwarding latency.},
  archive   = {C_OSDI},
  author    = {Marco Spaziani Brunella and Giacomo Belocchi and Marco Bonola and Salvatore Pontarelli and Giuseppe Siracusano and Giuseppe Bianchi and Aniello Cammarano and Alessandro Palumbo and Luca Petrucci and Roberto Bifulco},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {973-990},
  title     = {{hXDP}: Efficient software packet processing on {FPGA} {NICs}},
  url       = {https://www.usenix.org/conference/osdi20/presentation/brunella},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). FVM: <span class="nocase">FPGA-assisted</span> virtual
device emulation for fast, scalable, and flexible storage
virtualization. <em>OSDI</em>, 955–971. (<a
href="https://www.usenix.org/conference/osdi20/presentation/kwon">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Dongup Kwon, Department of Electrical and Computer Engineering, Seoul National University / Memory Solutions Lab, Samsung Semiconductor Inc.; Junehyuk Boo and Dongryeong Kim, Department of Electrical and Computer Engineering, Seoul National University; Jangwoo Kim, Department of Electrical and Computer Engineering, Seoul National University / Memory Solutions Lab, Samsung Semiconductor Inc. Emerging big-data workloads with massive I/O processing require fast, scalable, and flexible storage virtualization support. Hardware-assisted virtualization can achieve reasonable performance for fast storage devices, but it comes at the expense of limited functionalities in a virtualized environment (e.g., migration, replication, caching). To restore the VM features with minimal performance degradation, recent advances propose to implement a new software-based virtualization layer by dedicating computing cores to virtual device emulation. However, due to the dedication of expensive general-purpose cores and the nature of host-driven storage device management, the proposed schemes raise the critical performance and scalability issues with the increasing number and performance of storage devices per server. In this paper, we propose FVM, a new hardware-assisted storage virtualization mechanism to achieve high performance and scalability while maintaining the flexibility to support various VM features. The key idea is to implement (1) a storage virtualization layer on an FPGA card (FVM-engine) decoupled from the host resources and (2) a device-control method to have the card directly manage the physical storage devices. In this way, a server equipped with FVM-engine can save the invaluable host-side resources (i.e., CPU, memory bandwidth) from virtual and physical device management and utilize the decoupled FPGA resources for virtual device emulation. Our FVM-engine prototype outperforms existing storage virtualization schemes while maintaining the same flexibility and programmability as software implementations.},
  archive   = {C_OSDI},
  author    = {Dongup Kwon and Junehyuk Boo and Dongryeong Kim and Jangwoo Kim},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {955-971},
  title     = {{FVM}: {FPGA-assisted} virtual device emulation for fast, scalable, and flexible storage virtualization},
  url       = {https://www.usenix.org/conference/osdi20/presentation/kwon},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). KungFu: Making training in distributed machine learning
adaptive. <em>OSDI</em>, 937–954. (<a
href="https://www.usenix.org/conference/osdi20/presentation/mai">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Luo Mai, Guo Li, Marcel Wagenländer, Konstantinos Fertakis, Andrei-Octavian Brabete, and Peter Pietzuch, Imperial College London When using distributed machine learning (ML) systems to train models on a cluster of worker machines, users must configure a large number of parameters: hyper-parameters (e.g. the batch size and the learning rate) affect model convergence; system parameters (e.g. the number of workers and their communication topology) impact training performance. In current systems, adapting such parameters during training is ill-supported. Users must set system parameters at deployment time, and provide fixed adaptation schedules for hyper-parameters in the training program. We describe KungFu, a distributed ML library for TensorFlow that is designed to enable adaptive training. KungFu allows users to express high-level Adaptation Policies (APs) that describe how to change hyper- and system parameters during training. APs take real-time monitored metrics (e.g. signal-to-noise ratios and noise scale) as input and trigger control actions (e.g. cluster rescaling or synchronisation strategy updates). For execution, APs are translated into monitoring and control operators, which are embedded in the dataflow graph. APs exploit an efficient asynchronous collective communication layer, which ensures concurrency and consistency of monitoring and adaptation operations.},
  archive   = {C_OSDI},
  author    = {Luo Mai and Guo Li and Marcel Wagenländer and Konstantinos Fertakis and Andrei-Octavian Brabete and Peter Pietzuch},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {937-954},
  title     = {{KungFu}: Making training in distributed machine learning adaptive},
  url       = {https://www.usenix.org/conference/osdi20/presentation/mai},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Retiarii: A deep learning <span
class="nocase">Exploratory-training</span> framework. <em>OSDI</em>,
919–936. (<a
href="https://www.usenix.org/conference/osdi20/presentation/zhang-quanlu">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Quanlu Zhang, Zhenhua Han, Fan Yang, Yuge Zhang, Zhe Liu, Mao Yang, and Lidong Zhou, Microsoft Research Traditional deep learning frameworks such as TensorFlow and PyTorch support training on a single deep neural network (DNN) model, which involves computing the weights iteratively for the DNN model. Designing a DNN model for a task remains an experimental science and is typically a practice of deep learning model exploration, dovetailed with training and validation, aiming to find the best model among a set that yields the best result. Retrofitting such exploratory-training into the training process of a single DNN model, as supported by current deep learning frameworks, is unintuitive, cumbersome, and inefficient, because of the fundamental mismatch between exploring a set of models and training a single one. Retiarii is the first framework to support deep learning exploratory-training. In particular, Retiarii (i) provides a new programming interface to specify a DNN model space for exploration, as well as an interface to describe the exploration strategy that decides which order to instantiate and train models in, how to prioritize model training, and when to terminate training of certain models; (ii) offers a Just-In-Time (JIT) engine that instantiates models, manages the training of the instantiated models, gathers the information for the exploration strategy to consume, and executes the decisions accordingly; (iii) identifies the correlations between the instantiated models and develops a set of cross-model optimizations to improve the overall exploratory-training process. Retiarii does so by introducing a key abstraction, Mutator, that connects the specifications of DNN model spaces and exploration strategies, while exposing the correlations between models for optimization. As a result, Retiarii’s clean separation of DNN model space specification, exploration strategy, and cross-model optimizations, connected through the single mutator abstraction, leads to ease of programming, reuse of components, and vastly improved (up to 8.58x) overall exploratory-training efficiency.},
  archive   = {C_OSDI},
  author    = {Quanlu Zhang and Zhenhua Han and Fan Yang and Yuge Zhang and Zhe Liu and Mao Yang and Lidong Zhou},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {919-936},
  title     = {Retiarii: A deep learning {Exploratory-training} framework},
  url       = {https://www.usenix.org/conference/osdi20/presentation/zhang-quanlu},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). A tensor compiler for unified machine learning prediction
serving. <em>OSDI</em>, 899–917. (<a
href="https://www.usenix.org/conference/osdi20/presentation/nakandala">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Supun Nakandala, UC San Diego; Karla Saur, Microsoft; Gyeong-In Yu, Seoul National University; Konstantinos Karanasos, Carlo Curino, Markus Weimer, and Matteo Interlandi, Microsoft Machine Learning (ML) adoption in the enterprise requires simpler and more efficient software infrastructure—the bespoke solutions typical in large web companies are simply untenable. Model scoring, the process of obtaining predictions from a trained model over new data, is a primary contributor to infrastructure complexity and cost as models are trained once but used many times. In this paper we propose Hummingbird, a novel approach to model scoring, which compiles featurization operators and traditional ML models (e.g., decision trees) into a small set of tensor operations. This approach inherently reduces infrastructure complexity and directly leverages existing investments in Neural Network compilers and runtimes to generate efficient computations for both CPU and hardware accelerators. Our performance results are intriguing: despite replacing imperative computations (e.g., tree traversals) with tensor computation abstractions, Hummingbird is competitive and often outperforms hand-crafted kernels on micro-benchmarks on both CPU and GPU, while enabling seamless end-to-end acceleration of ML pipelines. We have released Hummingbird as open source.},
  archive   = {C_OSDI},
  author    = {Supun Nakandala and Karla Saur and Gyeong-In Yu and Konstantinos Karanasos and Carlo Curino and Markus Weimer and Matteo Interlandi},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {899-917},
  title     = {A tensor compiler for unified machine learning prediction serving},
  url       = {https://www.usenix.org/conference/osdi20/presentation/nakandala},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Rammer: Enabling holistic deep learning compiler
optimizations with <span class="nocase">rTasks</span>. <em>OSDI</em>,
881–897. (<a
href="https://www.usenix.org/conference/osdi20/presentation/ma">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Lingxiao Ma, Peking University and Microsoft Research; Zhiqiang Xie, ShanghaiTech University and Microsoft Research; Zhi Yang, Peking University; Jilong Xue, Youshan Miao, Wei Cui, Wenxiang Hu, Fan Yang, Lintao Zhang, and Lidong Zhou, Microsoft Research Performing Deep Neural Network (DNN) computation on hardware accelerators efficiently is challenging. Existing DNN frameworks and compilers often treat the DNN operators in a data flow graph (DFG) as opaque library functions and schedule them onto accelerators to be executed individually. They rely on another layer of scheduler, often implemented in hardware, to exploit the parallelism available in the operators. Such a two-layered approach incurs significant scheduling overhead and often cannot fully utilize the available hardware resources. In this paper, we propose Rammer, a DNN compiler design that optimizes the execution of DNN workloads on massively parallel accelerators. Rammer generates an efficient static spatio-temporal schedule for a DNN at compile time to minimize scheduling overhead. It maximizes hardware utilization by holistically exploiting parallelism through inter- and intra- operator co-scheduling. Rammer achieves this by proposing several novel, hardware neutral, and clean abstractions for the computation tasks and the hardware accelerators. These abstractions expose a much richer scheduling space to Rammer, which employs several heuristics to explore this space and finds efficient schedules. We implement Rammer for multiple hardware backends such as NVIDIA GPUs, AMD GPUs, and Graphcore IPU. Experiments show Rammer significantly outperforms state-of-the-art compilers such as TensorFlow XLA and TVM by up to 20.1X. It also outperforms TensorRT, a vendor optimized proprietary DNN inference library from NVIDIA, by up to 3.1X.},
  archive   = {C_OSDI},
  author    = {Lingxiao Ma and Zhiqiang Xie and Zhi Yang and Jilong Xue and Youshan Miao and Wei Cui and Wenxiang Hu and Fan Yang and Lintao Zhang and Lidong Zhou},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {881-897},
  title     = {Rammer: Enabling holistic deep learning compiler optimizations with {rTasks}},
  url       = {https://www.usenix.org/conference/osdi20/presentation/ma},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Ansor: Generating <span
class="nocase">High-performance</span> tensor programs for deep
learning. <em>OSDI</em>, 863–879. (<a
href="https://www.usenix.org/conference/osdi20/presentation/zheng">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Lianmin Zheng, UC Berkeley; Chengfan Jia, Minmin Sun, and Zhao Wu, Alibaba Group; Cody Hao Yu, Amazon Web Services; Ameer Haj-Ali, UC Berkeley; Yida Wang, Amazon Web Services; Jun Yang, Alibaba Group; Danyang Zhuo, UC Berkeley and Duke University; Koushik Sen, Joseph E. Gonzalez, and Ion Stoica, UC Berkeley High-performance tensor programs are crucial to guarantee efficient execution of deep neural networks. However, obtaining performant tensor programs for different operators on various hardware platforms is notoriously challenging. Currently, deep learning systems rely on vendor-provided kernel libraries or various search strategies to get performant tensor programs. These approaches either require significant engineering effort to develop platform-specific optimization code or fall short of finding high-performance programs due to restricted search space and ineffective exploration strategy. We present Ansor, a tensor program generation framework for deep learning applications. Compared with existing search strategies, Ansor explores many more optimization combinations by sampling programs from a hierarchical representation of the search space. Ansor then fine-tunes the sampled programs with evolutionary search and a learned cost model to identify the best programs. Ansor can find high-performance programs that are outside the search space of existing state-of-the-art approaches. In addition, Ansor utilizes a task scheduler to simultaneously optimize multiple subgraphs in deep neural networks. We show that Ansor improves the execution performance of deep neural networks relative to the state-of-the-art on the Intel CPU, ARM CPU, and NVIDIA GPU by up to 3.8x, 2.6x, and 1.7x, respectively.},
  archive   = {C_OSDI},
  author    = {Lianmin Zheng and Chengfan Jia and Minmin Sun and Zhao Wu and Cody Hao Yu and Ameer Haj-Ali and Yida Wang and Jun Yang and Danyang Zhuo and Koushik Sen and Joseph E. Gonzalez and Ion Stoica},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {863-879},
  title     = {Ansor: Generating {High-performance} tensor programs for deep learning},
  url       = {https://www.usenix.org/conference/osdi20/presentation/zheng},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Protean: VM allocation service at scale. <em>OSDI</em>,
845–861. (<a
href="https://www.usenix.org/conference/osdi20/presentation/hadary">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Ori Hadary, Luke Marshall, Ishai Menache, Abhisek Pan, Esaias E Greeff, David Dion, Star Dorminey, Shailesh Joshi, Yang Chen, Mark Russinovich, and Thomas Moscibroda, Microsoft Azure and Microsoft Research We describe the design and implementation of Protean -- the Microsoft Azure service responsible for allocating Virtual Machines (VMs) to millions of servers around the globe. A single instance of Protean serves an entire availability zone (10-100k machines), facilitating seamless failover and scale-out to customers. The design has proven robust, enabling a substantial expansion of VM offerings and features with minimal changes to the core infrastructure. In particular, Protean preserves a clear separation between policy and mechanisms . From a policy perspective, a flexible rule-based Allocation Agent (AA) allows Protean to efficiently address multiple constraints and performance criteria, and adapt to different conditions. On the system side, a multi-layer caching mechanism expedites the allocation process, achieving turnaround times of few milliseconds. A slight compromise on allocation quality enables multiple AAs to run concurrently on the same inventory, resulting in increased throughput with negligible conflict rate. Our results from both simulations and production demonstrate that Protean achieves high throughput and utilization (85-90% on a key utilization metric), while satisfying user-specific requirements. We also demonstrate how Protean is adapted to handle capacity crunch conditions, by zooming in on spikes caused by COVID-19.},
  archive   = {C_OSDI},
  author    = {Ori Hadary and Luke Marshall and Ishai Menache and Abhisek Pan and Esaias E Greeff and David Dion and Star Dorminey and Shailesh Joshi and Yang Chen and Mark Russinovich and Thomas Moscibroda},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {845-861},
  title     = {Protean: {VM} allocation service at scale},
  url       = {https://www.usenix.org/conference/osdi20/presentation/hadary},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Building scalable and flexible cluster managers using
declarative programming. <em>OSDI</em>, 827–844. (<a
href="https://www.usenix.org/conference/osdi20/presentation/suresh">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Lalith Suresh, VMware; João Loff, IST (ULisboa) / INESC-ID; Faria Kalim, UIUC; Sangeetha Abdu Jyothi, UC Irvine and VMware; Nina Narodytska, Leonid Ryzhyk, Sahan Gamage, Brian Oki, Pranshu Jain, and Michael Gasch, VMware Cluster managers like Kubernetes and OpenStack are notoriously hard to develop, given that they routinely grapple with hard combinatorial optimization problems like load balancing, placement, scheduling, and configuration. Today, cluster manager developers tackle these problems by developing system-specific best effort heuristics, which achieve scalability by significantly sacrificing the cluster manager&#39;s decision quality, feature set, and extensibility over time. This is proving untenable, as solutions for cluster management problems are routinely developed from scratch in the industry to solve largely similar problems across different settings. We propose DCM, a radically different architecture where developers specify the cluster manager&#39;s behavior declaratively, using SQL queries over cluster state stored in a relational database. From the SQL specification, the DCM compiler synthesizes a program that, at runtime, can be invoked to compute policy-compliant cluster management decisions given the latest cluster state. Under the covers, the generated program efficiently encodes the cluster state as an optimization problem that can be solved using off-the-shelf solvers, freeing developers from having to design ad-hoc heuristics. We show that DCM significantly lowers the barrier to building scalable and extensible cluster managers. We validate our claim by powering three production-grade systems with it: a Kubernetes scheduler, a virtual machine management solution, and a distributed transactional datastore.},
  archive   = {C_OSDI},
  author    = {Lalith Suresh and João Loff and Faria Kalim and Sangeetha Abdu Jyothi and Nina Narodytska and Leonid Ryzhyk and Sahan Gamage and Brian Oki and Pranshu Jain and Michael Gasch},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {827-844},
  title     = {Building scalable and flexible cluster managers using declarative programming},
  url       = {https://www.usenix.org/conference/osdi20/presentation/suresh},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). FIRM: An intelligent fine-grained resource management
framework for <span class="nocase">SLO-oriented</span> microservices.
<em>OSDI</em>, 805–825. (<a
href="https://www.usenix.org/conference/osdi20/presentation/qiu">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Haoran Qiu, Subho S. Banerjee, Saurabh Jha, Zbigniew T. Kalbarczyk, and Ravishankar K. Iyer, University of Illinois at Urbana-Champaign User-facing latency-sensitive web services include numerous distributed, intercommunicating microservices that promise to simplify software development and operation. However, multiplexing of compute resources across microservices is still challenging in production because contention for shared resources can cause latency spikes that violate the service-level objectives (SLOs) of user requests. This paper presents FIRM, an intelligent fine-grained resource management framework for predictable sharing of resources across microservices to drive up overall utilization. FIRM leverages online telemetry data and machine-learning methods to adaptively (a) detect/localize microservices that cause SLO violations, (b) identify low-level resources in contention, and (c) take actions to mitigate SLO violations via dynamic reprovisioning. Experiments across four microservice benchmarks demonstrate that FIRM reduces SLO violations by up to 16x while reducing the overall requested CPU limit by up to 62%. Moreover, FIRM improves performance predictability by reducing tail latencies by up to 11x.},
  archive   = {C_OSDI},
  author    = {Haoran Qiu and Subho S. Banerjee and Saurabh Jha and Zbigniew T. Kalbarczyk and Ravishankar K. Iyer},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {805-825},
  title     = {{FIRM}: An intelligent fine-grained resource management framework for {SLO-oriented} microservices},
  url       = {https://www.usenix.org/conference/osdi20/presentation/qiu},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Twine: A unified cluster management system for shared
infrastructure. <em>OSDI</em>, 787–803. (<a
href="https://www.usenix.org/conference/osdi20/presentation/tang">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Chunqiang Tang, Kenny Yu, Kaushik Veeraraghavan, Jonathan Kaldor, Scott Michelson, Thawan Kooburat, Aravind Anbudurai, Matthew Clark, Kabir Gogia, Long Cheng, Ben Christensen, Alex Gartrell, Maxim Khutornenko, Sachin Kulkarni, Marcin Pawlowski, Tuomas Pelkonen, Andre Rodrigues, Rounak Tibrewal, Vaishnavi Venkatesan, and Peter Zhang, Facebook Inc. We present Twine, Facebook&#39;s cluster management system which has been running in production for the past decade. Twine has helped convert our infrastructure from a collection of siloed pools of customized machines dedicated to individual workloads, into a large-scale shared infrastructure with fungible hardware. Our goal of ubiquitous shared infrastructure leads us to some decisions counter to common practices. For instance, rather than deploying an isolated control plane per cluster, Twine scales a single control plane to manage one million machines across all data centers in a geographic region and transparently move jobs across clusters. Twine accommodates workload-specific customization in shared infrastructure, and this approach further departs from common practices. The TaskControl API allows an application to collaborate with Twine to handle container lifecycle events, e.g., restarting a ZooKeeper deployment&#39;s followers first and its leader last during a rolling upgrade. Host profiles capture hardware and OS settings that workloads can tune to improve performance and reliability; Twine dynamically allocates machines to workloads and switches host profiles accordingly. Finally, going against the conventional wisdom of prioritizing stacking workloads on big machines to increase utilization, we universally deploy power-efficient small machines outfit with a single CPU and 64GB RAM to achieve higher performance per watt, and we leverage autoscaling to improve machine utilization. We describe the design of Twine and share our experience in migrating Facebook&#39;s workloads onto shared infrastructure.},
  archive   = {C_OSDI},
  author    = {Chunqiang Tang and Kenny Yu and Kaushik Veeraraghavan and Jonathan Kaldor and Scott Michelson and Thawan Kooburat and Aravind Anbudurai and Matthew Clark and Kabir Gogia and Long Cheng and Ben Christensen and Alex Gartrell and Maxim Khutornenko and Sachin Kulkarni and Marcin Pawlowski and Tuomas Pelkonen and Andre Rodrigues and Rounak Tibrewal and Vaishnavi Venkatesan and Peter Zhang},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {787-803},
  title     = {Twine: A unified cluster management system for shared infrastructure},
  url       = {https://www.usenix.org/conference/osdi20/presentation/tang},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). The CacheLib caching engine: Design and experiences at
scale. <em>OSDI</em>, 753–768. (<a
href="https://www.usenix.org/conference/osdi20/presentation/berg">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Benjamin Berg, Carnegie Mellon University; Daniel S. Berger, Carnegie Mellon University and Microsoft Research; Sara McAllister and Isaac Grosof, Carnegie Mellon University; Sathya Gunasekar, Jimmy Lu, Michael Uhlar, and Jim Carrig, Facebook; Nathan Beckmann, Mor Harchol-Balter, and Gregory R. Ganger, Carnegie Mellon University Web services rely on caching at nearly every layer of the system architecture. Commonly, each cache is implemented and maintained independently by a distinct team and is highly specialized to its function. For example, an application-data cache would be independent from a CDN cache. However, this approach ignores the difficult challenges that different caching systems have in common, greatly increasing the overall effort required to deploy, maintain, and scale each cache. This paper presents a different approach to cache development, successfully employed at Facebook, which extracts a core set of common requirements and functionality from otherwise disjoint caching systems. CacheLib is a general-purpose caching engine, designed based on experiences with a range of caching use cases at Facebook, that facilitates the easy development and maintenance of caches. CacheLib was first deployed at Facebook in 2017 and today powers over 70 services including CDN, storage, and application-data caches. This paper describes our experiences during the transition from independent, specialized caches to the widespread adoption of CacheLib. We explain how the characteristics of production workloads and use cases at Facebook drove important design decisions. We describe how caches at Facebook have evolved over time, including the significant benefits seen from deploying CacheLib. We also discuss the implications our experiences have for future caching design and research.},
  archive   = {C_OSDI},
  author    = {Benjamin Berg and Daniel S. Berger and Sara McAllister and Isaac Grosof and Sathya Gunasekar and Jimmy Lu and Michael Uhlar and Jim Carrig and Nathan Beckmann and Mor Harchol-Balter and Gregory R. Ganger},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {753-768},
  title     = {The {CacheLib} caching engine: Design and experiences at scale},
  url       = {https://www.usenix.org/conference/osdi20/presentation/berg},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Providing SLOs for <span
class="nocase">Resource-harvesting</span> VMs in cloud platforms.
<em>OSDI</em>, 735–751. (<a
href="https://www.usenix.org/conference/osdi20/presentation/ambati">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Pradeep Ambati, Íñigo Goiri, and Felipe Frujeri, Microsoft Research; Alper Gun, Ke Wang, Brian Dolan, Brian Corell, Sekhar Pasupuleti, and Thomas Moscibroda, Microsoft Azure; Sameh Elnikety, Microsoft Research; Marcus Fontoura, Microsoft Azure; Ricardo Bianchini, Microsoft Research Cloud providers rent the resources they do not allocate as evictable virtual machines (VMs), like spot instances. In this paper, we first characterize the unallocated resources in Microsoft Azure, and show that they are plenty but may vary widely over time and across servers. Based on the characterization, we propose a new class of VM, called Harvest VM, to harvest and monetize the unallocated resources. A Harvest VM is more flexible and efficient than a spot instance, because it grows and shrinks according to the amount of unallocated resources at its underlying server; it is only evicted/killed when the provider needs its minimum set of resources. Next, we create models that predict the availability of the unallocated resources for Harvest VM deployments. Based on these predictions, we provide Service Level Objectives (SLOs) for the survival rate (e.g., 65% of the Harvest VMs will survive more than a week) and the average number of cores that can be harvested. Our short-term predictions have an average error under 2% and less than 6% for longer terms. We also extend a popular cluster scheduling framework to leverage the harvested resources. Using our SLOs and framework, we can offset the rare evictions with extra harvested cores and achieve the same computational power as regular-priority VMs, but at 91% lower cost. Finally, we outline lessons and results from running Harvest VMs and our framework in production.},
  archive   = {C_OSDI},
  author    = {Pradeep Ambati and Íñigo Goiri and Felipe Frujeri and Alper Gun and Ke Wang and Brian Dolan and Brian Corell and Sekhar Pasupuleti and Thomas Moscibroda and Sameh Elnikety and Marcus Fontoura and Ricardo Bianchini},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {735-751},
  title     = {Providing {SLOs} for {Resource-harvesting} {VMs} in cloud platforms},
  url       = {https://www.usenix.org/conference/osdi20/presentation/ambati},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Testing configuration changes in context to prevent
production failures. <em>OSDI</em>, 735–751. (<a
href="https://www.usenix.org/conference/osdi20/presentation/sun">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Xudong Sun, Runxiang Cheng, Jianyan Chen, and Elaine Ang, University of Illinois at Urbana-Champaign; Owolabi Legunsen, Cornell University; Tianyin Xu, University of Illinois at Urbana-Champaign Large-scale cloud services deploy hundreds of configuration changes to production systems daily. At such velocity, configuration changes have inevitably become prevalent causes of production failures. Existing misconfiguration detection and configuration validation techniques only check configuration values. These techniques cannot detect common types of failure-inducing configuration changes, such as those that cause code to fail or those that violate hidden constraints. We present ctests, a new type of tests for detecting failure-inducing configuration changes to prevent production failures. The idea behind ctests is simple---connecting production system configurations to software tests so that configuration changes can be tested in the context of code affected by the changes. So, ctests can detect configuration changes that expose dormant software bugs and diverse misconfigurations. We show how to generate ctests by transforming the many existing tests in mature systems. The key challenge that we address is the automated identification of test logic and oracles that can be reused in ctests. We generated thousands of ctests from the existing tests in five cloud systems. Our results show that ctests are effective in detecting failure-inducing configuration changes before deployment. We evaluate ctests on real-world failure-inducing configuration changes, injected misconfigurations, and deployed configuration files from public Docker images. Ctests effectively detect real-world failure-inducing configuration changes and misconfigurations in the deployed files.},
  archive   = {C_OSDI},
  author    = {Xudong Sun and Runxiang Cheng and Jianyan Chen and Elaine Ang and Owolabi Legunsen and Tianyin Xu},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {735-751},
  title     = {Testing configuration changes in context to prevent production failures},
  url       = {https://www.usenix.org/conference/osdi20/presentation/sun},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Automated reasoning and detection of specious configuration
in large systems with symbolic execution. <em>OSDI</em>, 719–734. (<a
href="https://www.usenix.org/conference/osdi20/presentation/hu">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Yigong Hu, Gongqi Huang, and Peng Huang, Johns Hopkins University Misconfiguration is a major cause of system failures. Prior solutions focus on detecting invalid settings that are introduced by user mistakes. But another type of misconfiguration that continues to haunt production services is specious configuration---settings that are valid but lead to unexpectedly poor performance in production. Such misconfigurations are subtle, so even careful administrators may fail to foresee them. We propose a tool called Violet to detect specious configuration. We realize the crux of specious configuration is that it causes some slow code path to be executed, but the bad performance effect cannot always be triggered. Violet thus takes a novel approach that uses selective symbolic execution to systematically reason about the performance effect of configuration parameters, their combination effect, and the relationship with input. Violet outputs a performance impact model for the automatic detection of poor configuration settings. We applied Violet on four large systems. To evaluate the effectiveness of Violet, we collect 17 real-world specious configuration cases. Violet detects 15 of them. Violet also identifies 11 unknown specious configurations.},
  archive   = {C_OSDI},
  author    = {Yigong Hu and Gongqi Huang and Peng Huang},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {719-734},
  title     = {Automated reasoning and detection of specious configuration in large systems with symbolic execution},
  url       = {https://www.usenix.org/conference/osdi20/presentation/hu},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Aragog: Scalable runtime verification of shardable networked
systems. <em>OSDI</em>, 701–718. (<a
href="https://www.usenix.org/conference/osdi20/presentation/yaseen">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Nofel Yaseen, University of Pennsylvania; Behnaz Arzani and Ryan Beckett, Microsoft Research; Selim Ciraci, Microsoft; Vincent Liu, University of Pennsylvania Network functions like firewalls, proxies, and NATs are instances of distributed systems that lie on the critical path for a substantial fraction of today&#39;s cloud applications. Unfortunately, validating these systems remains difficult due to their complex stateful, timed, and distributed behaviors. In this paper, we present the design and implementation of Aragog, a runtime verification system for distributed network functions that achieves high expressiveness, fidelity, and scalability. Given a property of interest, Aragogefficiently checks running systems for violations of the property with a scale-out architecture consisting of a collection of global verifiers and local monitors. To improve performance and reduce communication overhead, Aragog includes an array of optimizations that leverage properties of networked systems to suppress provably unnecessary system events and to shard verification over every available local and global component. We evaluate Aragog over several network functions including a NAT Gateway that powers Azure, identifying both design and implementation bugs in the process.},
  archive   = {C_OSDI},
  author    = {Nofel Yaseen and Behnaz Arzani and Ryan Beckett and Selim Ciraci and Vincent Liu},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {701-718},
  title     = {Aragog: Scalable runtime verification of shardable networked systems},
  url       = {https://www.usenix.org/conference/osdi20/presentation/yaseen},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Gauntlet: Finding bugs in compilers for programmable packet
processing. <em>OSDI</em>, 683–699. (<a
href="https://www.usenix.org/conference/osdi20/presentation/ruffy">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Fabian Ruffy, Tao Wang, and Anirudh Sivaraman, New York University Programmable packet-processing devices such as programmable switches and network interface cards are becoming mainstream. These devices are configured in a domain-specific language such as P4, using a compiler to translate packet-processing programs into instructions for different targets. As networks with programmable devices become widespread, it is critical that these compilers be dependable. This paper considers the problem of finding bugs in compilers for packet processing in the context of P4-16. We introduce domain-specific techniques to induce both abnormal termination of the compiler (crash bugs) and miscompilation (semantic bugs). We apply these techniques to (1) the opensource P4 compiler (P4C) infrastructure, which serves as a common base for different P4 back ends; (2) the P4 back end for the P4 reference software switch; and (3) the P4 back end for the Barefoot Tofino switch. Across the 3 platforms, over 8 months of bug finding, our tool Gauntlet detected 96 new and distinct bugs (62 crash and 34 semantic), which we confirmed with the respective compiler developers. 54 have been fixed (31 crash and 23 semantic); the remaining have been assigned to a developer. Our bug-finding efforts also led to 6 P4 specification changes. We have open sourced Gauntlet at p4gauntlet.github.io and it now runs within P4C’s continuous integration pipeline.},
  archive   = {C_OSDI},
  author    = {Fabian Ruffy and Tao Wang and Anirudh Sivaraman},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {683-699},
  title     = {Gauntlet: Finding bugs in compilers for programmable packet processing},
  url       = {https://www.usenix.org/conference/osdi20/presentation/ruffy},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Testing database engines via pivoted query synthesis.
<em>OSDI</em>, 667–682. (<a
href="https://www.usenix.org/conference/osdi20/presentation/rigger">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Manuel Rigger and Zhendong Su, ETH Zurich Distinguished Artifact Award Winner Database Management Systems (DBMSs) are used widely, and have been extensively tested by fuzzers, which are successful in finding crash bugs. However, approaches to finding logic bugs, such as when a DBMS computes an incorrect result set, have remained mostly untackled. To this end, we devised a novel and general approach that we have termed Pivoted Query Synthesis. The core idea of this approach is to automatically generate queries for which we ensure that they fetch a specific, randomly selected row, called the pivot row. If the DBMS fails to fetch the pivot row, the likely cause is a bug in the DBMS. We tested our approach on three widely-used and mature DBMSs, namely SQLite, MySQL, and PostgreSQL. In total, we found 121 unique bugs in these DBMSs, 96 of which have been fixed or verified, demonstrating that the approach is highly effective and general. We expect that the wide applicability and simplicity of our approach will enable improving the robustness of many DBMSs.},
  archive   = {C_OSDI},
  author    = {Manuel Rigger and Zhendong Su},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {667-682},
  title     = {Testing database engines via pivoted query synthesis},
  url       = {https://www.usenix.org/conference/osdi20/presentation/rigger},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). From global to local quiescence: <span
class="nocase">Wait-free</span> code patching of <span
class="nocase">Multi-threaded</span> processes. <em>OSDI</em>, 651–666.
(<a
href="https://www.usenix.org/conference/osdi20/presentation/rommel">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Florian Rommel and Christian Dietrich, Leibniz Universität Hannover; Birte Friesel, Marcel Köppen, Christoph Borchert, Michael Müller, and Olaf Spinczyk, Universität Osnabrück; Daniel Lohmann, Leibniz Universität Hannover Live patching has become a common technique to keep long-running system services secure and up-to-date without causing downtimes during patch application. However, to safely apply a patch, existing live-update methods require the entire process to enter a state of quiescence, which can be highly disruptive for multi-threaded programs: Having to halt all threads (e.g., at a global barrier) for patching not only hampers quality of service, but can also be tremendously difficult to implement correctly without causing deadlocks or other synchronization issues. In this paper, we present WfPatch , a wait-free approach to inject code changes into running multi-threaded programs. Instead of having to stop the world before applying a patch, WfPatch can gradually apply it to each thread individually at a local point of quiescence, while all other threads can make uninterrupted progress. We have implemented WfPatch as a kernel service and user-space library for Linux 5.1 and evaluated it with OpenLDAP, Apache, Memcached, Samba, Node.js, and MariaDB on Debian 10 (“buster”). In total, we successfully applied 33 different binary patches into running programs while they were actively servicing requests; 15 patches had a CVE number or were other critical updates. Applying a patch with WfPatch did not lead to any noticeable increase in request latencies — even under high load — while applying the same patch after reaching global quiescence increases tail latencies by a factor of up to 41x for MariaDB.},
  archive   = {C_OSDI},
  author    = {Florian Rommel and Christian Dietrich and Birte Friesel and Marcel Köppen and Christoph Borchert and Michael Müller and Olaf Spinczyk and Daniel Lohmann},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {651-666},
  title     = {From global to local quiescence: {Wait-free} code patching of {Multi-threaded} processes},
  url       = {https://www.usenix.org/conference/osdi20/presentation/rommel},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Byzantine ordered consensus without byzantine oligarchy.
<em>OSDI</em>, 633–649. (<a
href="https://www.usenix.org/conference/osdi20/presentation/zhang-yunhao">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Yunhao Zhang, Cornell University; Srinath Setty, Qi Chen, and Lidong Zhou, Microsoft Research; Lorenzo Alvisi, Cornell University Awarded Best Paper! The specific order of commands agreed upon when running state machine replication (SMR) is immaterial to fault-tolerance: all that is required is for all correct deterministic replicas to follow it. In the permissioned blockchains that rely on Byzantine fault tolerant (BFT) SMR, however, nodes have a stake in the specific sequence that ledger records, as well as in preventing other parties from manipulating the sequencing to their advantage. The traditional specification of SMR correctness, however, has no language to express these concerns. This paper introduces Byzantine ordered consensus, a new primitive that augments the correctness specification of BFT SMR to include specific guarantees on the total orders it produces; and a new architecture for BFT SMR that, by factoring out ordering from consensus, can enforce these guarantees and prevent Byzantine nodes from controlling ordering decisions (a Byzantine oligarchy). These contributions are instantiated in Pompe, a BFT SMR protocol that is guaranteed to order commands in a way that respects a natural extension of linearizability.},
  archive   = {C_OSDI},
  author    = {Yunhao Zhang and Srinath Setty and Qi Chen and Lidong Zhou and Lorenzo Alvisi},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {633-649},
  title     = {Byzantine ordered consensus without byzantine oligarchy},
  url       = {https://www.usenix.org/conference/osdi20/presentation/zhang-yunhao},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Virtual consensus in delos. <em>OSDI</em>, 617–632. (<a
href="https://www.usenix.org/conference/osdi20/presentation/balakrishnan">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Mahesh Balakrishnan, Jason Flinn, Chen Shen, Mihir Dharamshi, Ahmed Jafri, Xiao Shi, Santosh Ghosh, Hazem Hassan, Aaryaman Sagar, Rhed Shi, Jingming Liu, Filip Gruszczynski, Xianan Zhang, Huy Hoang, Ahmed Yossef, Francois Richard, and Yee Jiun Song, Facebook, Inc. Awarded Best Paper! Consensus-based replicated systems are complex, monolithic, and difficult to upgrade once deployed. As a result, deployed systems do not benefit from innovative research, and new consensus protocols rarely reach production. We propose virtualizing consensus by virtualizing the shared log API, allowing services to change consensus protocols without downtime. Virtualization splits the logic of consensus into the VirtualLog, a generic and reusable reconfiguration layer; and pluggable ordering protocols called Loglets. Loglets are simple, since they do not need to support reconfiguration or leader election; diverse, consisting of different protocols, codebases, and even deployment modes; and composable, via RAID-like stacking and striping. We describe a production database called Delos which leverages virtual consensus for rapid, incremental development and deployment. Delos reached production within 8 months, and 4 months later upgraded its consensus protocol without downtime for a 10X latency improvement. Delos can dynamically change its performance properties by changing consensus protocols: we can scale throughput by up to 10X by switching to a disaggregated Loglet, and double the failure threshold of an instance without sacrificing throughput via a striped Loglet.},
  archive   = {C_OSDI},
  author    = {Mahesh Balakrishnan and Jason Flinn and Chen Shen and Mihir Dharamshi and Ahmed Jafri and Xiao Shi and Santosh Ghosh and Hazem Hassan and Aaryaman Sagar and Rhed Shi and Jingming Liu and Filip Gruszczynski and Xianan Zhang and Huy Hoang and Ahmed Yossef and Francois Richard and Yee Jiun Song},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {617-632},
  title     = {Virtual consensus in delos},
  url       = {https://www.usenix.org/conference/osdi20/presentation/balakrishnan},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Microsecond consensus for microsecond applications.
<em>OSDI</em>, 599–616. (<a
href="https://www.usenix.org/conference/osdi20/presentation/aguilera">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Marcos K. Aguilera and Naama Ben-David, VMware Research; Rachid Guerraoui, EPFL; Virendra J. Marathe, Oracle Labs; Athanasios Xygkis and Igor Zablotchi, EPFL We consider the problem of making apps fault-tolerant through replication, when apps operate at the microsecond scale, as in finance, embedded computing, and microservices apps. These apps need a replication scheme that also operates at the microsecond scale, otherwise replication becomes a burden. We propose Mu, a system that takes less than 1.3 microseconds to replicate a (small) request in memory, and less than a millisecond to fail-over the system—this cuts the replication and fail-over latencies of the prior systems by at least 61% and 90%. Mu implements bona fide state machine replication/consensus (SMR) with strong consistency for a generic app, but it really shines on microsecond apps, where even the smallest overhead is significant. To provide this performance, Mu introduces a new SMR protocol that care-fully leverages RDMA. Roughly, in Mu a leader replicates a request by simply writing it directly to the log of other replicas using RDMA, without any additional communication. Doing so, however, introduces the challenge of handling concurrent leaders, changing leaders, garbage collecting the logs, and more—challenges that we address in this paper through a judicious combination of RDMA permissions and distributed algorithmic design. We implemented Mu and used it to replicate several systems: a financial exchange app called Liquibook, Redis, Memcached, and HERD. Our evaluation shows that Mu incurs a small replication latency, in some cases being the only viable replication system that incurs an acceptable overhead.},
  archive   = {C_OSDI},
  author    = {Marcos K. Aguilera and Naama Ben-David and Rachid Guerraoui and Virendra J. Marathe and Athanasios Xygkis and Igor Zablotchi},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {599-616},
  title     = {Microsecond consensus for microsecond applications},
  url       = {https://www.usenix.org/conference/osdi20/presentation/aguilera},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Tolerating slowdowns in replicated state machines using
copilots. <em>OSDI</em>, 583–598. (<a
href="https://www.usenix.org/conference/osdi20/presentation/ngo">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Khiem Ngo, Princeton University; Siddhartha Sen, Microsoft Research; Wyatt Lloyd, Princeton University Replicated state machines are linearizable, fault-tolerant groups of replicas that are coordinated using a consensus algorithm. Copilot replication is the first 1-slowdown-tolerant consensus protocol: it delivers normal latency despite the slowdown of any 1 replica. Copilot uses two distinguished replicas—the pilot and copilot—to proactively add redundancy to all stages of processing a client’s command. Copilot uses dependencies and deduplication to resolve potentially differing orderings proposed by the pilots. To avoid dependencies leading to either pilot being able to slow down the group, Copilot uses fast takeovers that allow a fast pilot to complete the ongoing work of a slow pilot. Copilot includes two optimizations—ping-pong batching and null dependency elimination—that improve its performance when there are 0 and 1 slow pilots respectively. Our evaluation of Copilot shows its performance is lower but competitive with Multi-Paxos and EPaxos when no replicas are slow. When a replica is slow, Copilot is the only protocol that avoids high latencies.},
  archive   = {C_OSDI},
  author    = {Khiem Ngo and Siddhartha Sen and Wyatt Lloyd},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {583-598},
  title     = {Tolerating slowdowns in replicated state machines using copilots},
  url       = {https://www.usenix.org/conference/osdi20/presentation/ngo},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Blockene: A high-throughput blockchain over mobile devices.
<em>OSDI</em>, 567–582. (<a
href="https://www.usenix.org/conference/osdi20/presentation/satija">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Sambhav Satija and Apurv Mehra, Microsoft Research India; Sudheesh Singanamalla, University of Washington; Karan Grover, Muthian Sivathanu, Nishanth Chandran, Divya Gupta, and Satya Lokam, Microsoft Research India We introduce Blockene, a blockchain that reduces resource usage at member nodes by orders of magnitude, requiring only a smartphone to participate in block validation and consensus. Despite being lightweight, Blockene provides high throughput and scales to millions of participants. Blockene consumes negligible battery and data in smartphones, enabling millions of users to participate in the blockchain without incentives, to secure transactions with their collective honesty. Blockene achieves these properties with a novel split-trust design based on delegating storage and gossip to untrusted nodes. We demonstrate, with a prototype implementation, that Blockene provides a throughput of more than 1000 transactions per second, and can run with very low resource usage on smartphones, pointing to a new paradigm for building trustworthy, decentralized applications},
  archive   = {C_OSDI},
  author    = {Sambhav Satija and Apurv Mehra and Sudheesh Singanamalla and Karan Grover and Muthian Sivathanu and Nishanth Chandran and Divya Gupta and Satya Lokam},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {567-582},
  title     = {Blockene: A high-throughput blockchain over mobile devices},
  url       = {https://www.usenix.org/conference/osdi20/presentation/satija},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Write dependency disentanglement with HORAE. <em>OSDI</em>,
549–565. (<a
href="https://www.usenix.org/conference/osdi20/presentation/liao">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Xiaojian Liao, Youyou Lu, Erci Xu, and Jiwu Shu, Tsinghua University Storage systems rely on write dependency to achieve atomicity and consistency. However, enforcing write dependency comes at the expense of performance; it concatenates multiple hardware queues into a single logical queue, disables the concurrency of flash storage and serializes the access to isolated devices. Such serialization prevents the storage system from taking full advantage of high-performance drives (e.g., NVMe SSD) and storage arrays. In this paper, we propose a new IO stack called Horae to alleviate the write dependency overhead for high-performance drives. Horae separates the dependency control from the data flow, and uses a dedicated interface to maintain the write dependency. Further, Horae introduces the joint flush to enable parallel FLUSH commands on individual devices, and write redirection to handle dependency loops and parallelize in-place updates. We implement Horae in Linux kernel and demonstrate its effectiveness through a wide variety of workloads. Evaluations show Horae brings up to 1.8× and 2.1× performance gain in MySQL and BlueStore, respectively.},
  archive   = {C_OSDI},
  author    = {Xiaojian Liao and Youyou Lu and Erci Xu and Jiwu Shu},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {549-565},
  title     = {Write dependency disentanglement with {HORAE}},
  url       = {https://www.usenix.org/conference/osdi20/presentation/liao},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). AntMan: Dynamic scaling on GPU clusters for deep learning.
<em>OSDI</em>, 533–548. (<a
href="https://www.usenix.org/conference/osdi20/presentation/xiao">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Wencong Xiao, Shiru Ren, Yong Li, Yang Zhang, Pengyang Hou, Zhi Li, Yihui Feng, Wei Lin, and Yangqing Jia, Alibaba Group Efficiently scheduling deep learning jobs on large-scale GPU clusters is crucial for job performance, system throughput, and hardware utilization. It is getting ever more challenging as deep learning workloads become more complex. This paper presents AntMan, a deep learning infrastructure that co-designs cluster schedulers with deep learning frameworks and has been deployed in production at Alibaba to manage tens of thousands of daily deep learning jobs across thousands of GPUs. AntMan accommodates the fluctuating resource demands of deep learning training jobs. As such, it utilizes the spare GPU resources to co-execute multiple jobs on a shared GPU. AntMan exploits unique characteristics of deep learning training to introduce dynamic scaling mechanisms for memory and computation within the deep learning frameworks. This allows fine-grained coordination between jobs and prevents job interference. Evaluations show that AntMan improves the overall GPU memory utilization by 42% and the computation unit utilization by 34% in our multi-tenant cluster without compromising fairness, presenting a new approach to efficiently utilizing GPUs at scale.},
  archive   = {C_OSDI},
  author    = {Wencong Xiao and Shiru Ren and Yong Li and Yang Zhang and Pengyang Hou and Zhi Li and Yihui Feng and Wei Lin and Yangqing Jia},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {533-548},
  title     = {{AntMan}: Dynamic scaling on {GPU} clusters for deep learning},
  url       = {https://www.usenix.org/conference/osdi20/presentation/xiao},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). HiveD: Sharing a GPU cluster for deep learning with
guarantees. <em>OSDI</em>, 515–532. (<a
href="https://www.usenix.org/conference/osdi20/presentation/zhao-hanyu">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Hanyu Zhao, Peking University and Microsoft; Zhenhua Han, The University of Hong Kong and Microsoft; Zhi Yang, Peking University; Quanlu Zhang, Fan Yang, Lidong Zhou, and Mao Yang, Microsoft; Francis C.M. Lau, The University of Hong Kong; Yuqi Wang, Yifan Xiong, and Bin Wang, Microsoft Deep learning training on a shared GPU cluster is becoming a common practice. However, we observe severe sharing anomaly in production multi-tenant clusters where jobs in some tenants experience worse queuing delay than they would have in a private cluster with their allocated shares of GPUs. This is because tenants use quota, the number of GPUs, to reserve resources, whereas deep learning jobs often use GPUs with a desirable GPU affinity, which quota cannot guarantee. HiveD is the first framework to share a GPU cluster safely, so that such anomaly would never happen by design. In HiveD, each tenant reserves resources through a Virtual Private Cluster (VC), defined in terms of multi-level cell structures corresponding to different levels of GPU affinity in a cluster. This design allows HiveD to incorporate any existing schedulers within each VC to achieve their respective design goals while sharing the cluster safely. HiveD develops an elegant buddy cell allocation algorithm to ensure sharing safety by efficiently managing the dynamic binding of cells from VCs to those in a physical cluster. A straightforward extension of buddy cell allocation can further support low-priority jobs to scavenge the unused GPU resources to improve cluster utilization. With a combination of real deployment and trace-driven simulation, we show that: (i) sharing anomaly exists in three state-of-the-art deep learning schedulers, incurring extra queuing delay of up to 1,000 minutes; (ii) HiveD can incorporate these schedulers and eliminate the sharing anomaly in all of them, achieving separation of concerns that allows the schedulers to focus on their own scheduling goals without violating sharing safety.},
  archive   = {C_OSDI},
  author    = {Hanyu Zhao and Zhenhua Han and Zhi Yang and Quanlu Zhang and Fan Yang and Lidong Zhou and Mao Yang and Francis C.M. Lau and Yuqi Wang and Yifan Xiong and Bin Wang},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {515-532},
  title     = {{HiveD}: Sharing a {GPU} cluster for deep learning with guarantees},
  url       = {https://www.usenix.org/conference/osdi20/presentation/zhao-hanyu},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). PipeSwitch: Fast pipelined context switching for deep
learning applications. <em>OSDI</em>, 499–514. (<a
href="https://www.usenix.org/conference/osdi20/presentation/bai">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Zhihao Bai and Zhen Zhang, Johns Hopkins University; Yibo Zhu, ByteDance Inc.; Xin Jin, Johns Hopkins University Deep learning (DL) workloads include throughput-intensive training tasks and latency-sensitive inference tasks. The dominant practice today is to provision dedicated GPU clusters for training and inference separately. Due to the need to meet strict Service-Level Objectives (SLOs), GPU clusters are often over-provisioned based on the peak load with limited sharing between applications and task types. We present PipeSwitch, a system that enables unused cycles of an inference application to be filled by training or other inference applications. It allows multiple DL applications to time-share the same GPU with the entire GPU memory and millisecond-scale switching overhead. With PipeSwitch, GPU utilization can be significantly improved without sacrificing SLOs. We achieve so by introducing pipelined context switching. The key idea is to leverage the layered structure of neural network models and their layer-by-layer computation pattern to pipeline model transmission over the PCIe and task execution in the GPU with model-aware grouping. We also design unified memory management and active-standby worker switching mechanisms to accompany the pipelining and ensure process-level isolation.We have built a PipeSwitch prototype and integrated it with PyTorch. Experiments on a variety of DL models and GPU cards show that PipeSwitch only incurs a task startup overhead of 3.6–6.6 ms and a total overhead of 5.4–34.6 ms (10–50× better than NVIDIA MPS), and achieves near 100% GPU utilization.},
  archive   = {C_OSDI},
  author    = {Zhihao Bai and Zhen Zhang and Yibo Zhu and Xin Jin},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {499-514},
  title     = {{PipeSwitch}: Fast pipelined context switching for deep learning applications},
  url       = {https://www.usenix.org/conference/osdi20/presentation/bai},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). <span class="nocase">Heterogeneity-aware</span> cluster
scheduling policies for deep learning workloads. <em>OSDI</em>, 481–498.
(<a
href="https://www.usenix.org/conference/osdi20/presentation/narayanan-deepak">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Deepak Narayanan and Keshav Santhanam, Stanford University and Microsoft Research; Fiodar Kazhamiaka, Stanford University; Amar Phanishayee, Microsoft Research; Matei Zaharia, Stanford University Specialized accelerators such as GPUs, TPUs, FPGAs, and custom ASICs have been increasingly deployed to train deep learning models. These accelerators exhibit heterogeneous performance behavior across model architectures. Existing schedulers for clusters of accelerators, which are used to arbitrate these expensive training resources across many users, have shown how to optimize for various multi-job, multi-user objectives, like fairness and makespan. Unfortunately, existing schedulers largely do not consider performance heterogeneity. In this paper, we propose Gavel, a heterogeneity-aware scheduler that systematically generalizes a wide range of existing scheduling policies. Gavel expresses these policies as optimization problems and then systematically transforms these problems into heterogeneity-aware versions using an abstraction we call effective throughput. Gavel then uses a round-based scheduling mechanism to ensure jobs receive their ideal allocation given the target scheduling policy. Gavel&#39;s heterogeneity-aware policies allow a heterogeneous cluster to sustain higher input load, and improve end objectives such as makespan and average job completion time by 1.4x and 3.5x compared to heterogeneity-agnostic policies.},
  archive   = {C_OSDI},
  author    = {Deepak Narayanan and Keshav Santhanam and Fiodar Kazhamiaka and Amar Phanishayee and Matei Zaharia},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {481-498},
  title     = {{Heterogeneity-aware} cluster scheduling policies for deep learning workloads},
  url       = {https://www.usenix.org/conference/osdi20/presentation/narayanan-deepak},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). A unified architecture for accelerating distributed DNN
training in heterogeneous GPU/CPU clusters. <em>OSDI</em>, 463–479. (<a
href="https://www.usenix.org/conference/osdi20/presentation/jiang">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Yimin Jiang, Tsinghua University and ByteDance; Yibo Zhu, ByteDance; Chang Lan, Google; Bairen Yi, ByteDance; Yong Cui, Tsinghua University; Chuanxiong Guo, ByteDance Data center clusters that run DNN training jobs are inherently heterogeneous. They have GPUs and CPUs for computation and network bandwidth for distributed training. However, existing distributed DNN training architectures, all-reduce and Parameter Server (PS), cannot fully utilize such heterogeneous resources. In this paper, we present a new distributed DNN training architecture called BytePS. BytePS can leverage spare CPU and bandwidth resources in the cluster to accelerate distributed DNN training tasks running on GPUs. It provides a communication framework that is both proved optimal and unified – existing all-reduce and PS become two special cases of BytePS. To achieve the proved optimality in practice, BytePS further splits the functionalities of a parameter optimizer. It introduces a Summation Service abstraction for aggregating gradients, which is common for all the optimizers. Summation Service can be accelerated by AVX instructions and can be efficiently run on CPUs, while DNN model-related optimizer algorithms are run on GPUs for computation acceleration. BytePS can accelerate DNN training for major frameworks including TensorFlow, PyTorch and MXNet. For representative DNN training jobs with up to 256 GPUs, BytePS outperforms the state-of-the-art open source all-reduce and PS by up to 84% and 245%, respectively.},
  archive   = {C_OSDI},
  author    = {Yimin Jiang and Yibo Zhu and Chang Lan and Bairen Yi and Yong Cui and Chuanxiong Guo},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {463-479},
  title     = {A unified architecture for accelerating distributed {DNN} training in heterogeneous {GPU/CPU} clusters},
  url       = {https://www.usenix.org/conference/osdi20/presentation/jiang},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Serving DNNs like clockwork: Performance predictability from
the bottom up. <em>OSDI</em>, 443–462. (<a
href="https://www.usenix.org/conference/osdi20/presentation/gujarati">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Arpan Gujarati, Max Planck Institute for Software Systems; Reza Karimi, Emory University; Safya Alzayat, Wei Hao, and Antoine Kaufmann, Max Planck Institute for Software Systems; Ymir Vigfusson, Emory University; Jonathan Mace, Max Planck Institute for Software Systems Distinguished Artifact Award Winner Machine learning inference is becoming a core building block for interactive web applications. As a result, the underlying model serving systems on which these applications depend must consistently meet low latency targets. Existing model serving architectures use well-known reactive techniques to alleviate common-case sources of latency, but cannot effectively curtail tail latency caused by unpredictable execution times. Yet the underlying execution times are not fundamentally unpredictable—on the contrary we observe that inference using Deep Neural Network (DNN) models has deterministic performance. Here, starting with the predictable execution times of individual DNN inferences, we adopt a principled design methodology to successively build a fully distributed model serving system that achieves predictable end-to-end performance. We evaluate our implementation, Clockwork, using production trace workloads, and show that Clockwork can support thousands of models while simultaneously meeting 100 ms latency targets for 99.997% of requests. We further demonstrate that Clockwork exploits predictable execution times to achieve tight request-level service-level objectives (SLOs) as well as a high degree of request-level performance isolation.},
  archive   = {C_OSDI},
  author    = {Arpan Gujarati and Reza Karimi and Safya Alzayat and Wei Hao and Antoine Kaufmann and Ymir Vigfusson and Jonathan Mace},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {443-462},
  title     = {Serving {DNNs} like clockwork: Performance predictability from the bottom up},
  url       = {https://www.usenix.org/conference/osdi20/presentation/gujarati},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Kvell+: Snapshot isolation without snapshots. <em>OSDI</em>,
425–441. (<a
href="https://www.usenix.org/conference/osdi20/presentation/lepers">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Baptiste Lepers and Oana Balmau, University of Sydney; Karan Gupta, Nutanix Inc.; Willy Zwaenepoel, University of Sydney Snapshot Isolation (SI) enables online analytical processing (OLAP) queries to observe a snapshot of the data at the time the query is issued, despite concurrent updates by online transactional processing (OLTP) transactions. The conventional implementation of SI creates a new version of a data item when it is updated, rather than overwriting the old version. Versions are garbage collected when they can no longer be read by any OLAP query. Frequent updates during long-running OLAP queries therefore create significant space amplification, and garbage collection can give rise to latency spikes for OLTP transactions. These problems are exacerbated on modern low-latency drives that can persist millions of updates per second. We observe that analytic queries often consist in large part of commutative processing of data items resulting from range scans in which each item in the range is read exactly once. We introduce Online Commutative Processing (OLCP), a new model for processing analytical queries, that takes advantage of this observation. Under OLCP, analytical queries observe the same snapshot of the data as they would under conventional SI, but space amplification and garbage collection costs are largely and oftentimes nearly entirely avoided. When an item in such a range is updated, the old version of the item is propagated to the OLCP queries that might need it instead of being kept in the store. We demonstrate OLCP’s expressiveness by showing how to formulate, among others, the TPC-H benchmark queries in OLCP. We implement OLCP in KVell+, an extension of KVell, a key-value store for NVMe SSDs. Using YCSB-T, TPC-CH and production workloads from Nutanix, we run a wide range of analytics queries concurrently with write-intensive transactions. We show that OLCP incurs little or no space amplification or garbage collection overhead. As a surprising by-product we also show that OLCP speeds up analytical queries compared to SI.},
  archive   = {C_OSDI},
  author    = {Baptiste Lepers and Oana Balmau and Karan Gupta and Willy Zwaenepoel},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {425-441},
  title     = {Kvell+: Snapshot isolation without snapshots},
  url       = {https://www.usenix.org/conference/osdi20/presentation/lepers},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). FlightTracker: Consistency across <span
class="nocase">Read-optimized</span> online stores at facebook.
<em>OSDI</em>, 407–423. (<a
href="https://www.usenix.org/conference/osdi20/presentation/shi">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Xiao Shi, Scott Pruett, Kevin Doherty, Jinyu Han, Dmitri Petrov, Jim Carrig, John Hugg, and Nathan Bronson, Facebook, Inc. Social media platforms deliver fresh personalized content by performing a large number of reads from an online data store. This store must be optimized for read efficiency, availability, and scalability. Multi-layer caches and asynchronous replication can satisfy these goals, such as in Facebook’s graph store TAO, but it is challenging for the resulting system to provide a developer-friendly consistency model. TAO originally provided read-your-writes (RYW) consistency via write-through caching, but scaling challenges with this approach have led us to a new implementation. This paper introduces FlightTracker, a family of APIs and systems which now manage consistency for online access to Facebook’s graph. FlightTracker implicitly provides RYW and can be explicitly used to provide alternative consistency guarantees for special use cases; it enables flexible communication patterns between caches, which we have found important as the number of datacenters increases; it extends the same consistency guarantees to cross-shard indexes and materialized views, allowing us to transparently optimize queries; and it provides a uniform primitive for clients to obtain desired consistency guarantees across a variety of data stores. FlightTracker delivers these advantages while preserving the efficiency, latency, and availability benefits of asynchronous replication for the underlying systems, managing consistency for billions of users and more than 10 15 queries per day.},
  archive   = {C_OSDI},
  author    = {Xiao Shi and Scott Pruett and Kevin Doherty and Jinyu Han and Dmitri Petrov and Jim Carrig and John Hugg and Nathan Bronson},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {407-423},
  title     = {{FlightTracker}: Consistency across {Read-optimized} online stores at facebook},
  url       = {https://www.usenix.org/conference/osdi20/presentation/shi},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Pegasus: Tolerating skewed workloads in distributed storage
with <span class="nocase">In-network</span> coherence directories.
<em>OSDI</em>, 387–406. (<a
href="https://www.usenix.org/conference/osdi20/presentation/li-jialin">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Jialin Li, National University of Singapore; Jacob Nelson, Microsoft Research; Ellis Michael, University of Washington; Xin Jin, Johns Hopkins University; Dan R. K. Ports, Microsoft Research High performance distributed storage systems face the challenge of load imbalance caused by skewed and dynamic workloads. This paper introduces Pegasus, a new storage system that leverages new-generation programmable switch ASICs to balance load across storage servers. Pegasus uses selective replication of the most popular objects in the data store to distribute load. Using a novel in-network coherence directory, the Pegasus switch tracks and manages the location of replicated objects. This allows it to achieve load-aware forwarding and dynamic rebalancing for replicated keys, while still guaranteeing data coherence and consistency. The Pegasus design is practical to implement as it stores only forwarding metadata in the switch data plane. The resulting system improves the throughput of a distributed in-memory key-value store by more than 10x under a latency SLO -- results which hold across a large set of workloads with varying degrees of skew, read/write ratio, object sizes, and dynamism.},
  archive   = {C_OSDI},
  author    = {Jialin Li and Jacob Nelson and Ellis Michael and Xin Jin and Dan R. K. Ports},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {387-406},
  title     = {Pegasus: Tolerating skewed workloads in distributed storage with {In-network} coherence directories},
  url       = {https://www.usenix.org/conference/osdi20/presentation/li-jialin},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). PACEMAKER: Avoiding HeART attacks in storage clusters with
disk-adaptive redundancy. <em>OSDI</em>, 369–385. (<a
href="https://www.usenix.org/conference/osdi20/presentation/kadekodi">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Saurabh Kadekodi, Francisco Maturana, Suhas Jayaram Subramanya, Juncheng Yang, K. V. Rashmi, and Gregory R. Ganger, Carnegie Mellon University Data redundancy provides resilience in large-scale storage clusters, but imposes significant cost overhead. Substantial space-savings can be realized by tuning redundancy schemes to observed disk failure rates. However, prior design proposals for such tuning are unusable in real-world clusters, because the IO load of transitions between schemes overwhelms the storage infrastructure (termed transition overload ). This paper analyzes traces for millions of disks from production systems at Google, NetApp, and Backblaze to expose and understand transition overload as a roadblock to disk-adaptive redundancy: transition IO under existing approaches can consume 100% cluster IO continuously for several weeks. Building on the insights drawn, we present PACEMAKER, a low-overhead disk-adaptive redundancy orchestrator. PACEMAKER mitigates transition overload by (1) proactively organizing data layouts to make future transitions efficient, and (2) initiating transitions proactively in a manner that avoids urgency while not compromising on space-savings. Evaluation of PACEMAKER with traces from four large (110K–450K disks) production clusters show that the transition IO requirement decreases to never needing more than 5% cluster IO bandwidth (0.2–0.4% on average). PACEMAKER achieves this while providing overall space-savings of 14–20% and never leaving data under-protected. We also describe and experiment with an integration of PACEMAKER into HDFS.},
  archive   = {C_OSDI},
  author    = {Saurabh Kadekodi and Francisco Maturana and Suhas Jayaram Subramanya and Juncheng Yang and K. V. Rashmi and Gregory R. Ganger},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {369-385},
  title     = {{PACEMAKER}: Avoiding {HeART} attacks in storage clusters with disk-adaptive redundancy},
  url       = {https://www.usenix.org/conference/osdi20/presentation/kadekodi},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Toward a generic fault tolerance technique for partial
network partitioning. <em>OSDI</em>, 351–368. (<a
href="https://www.usenix.org/conference/osdi20/presentation/alfatafta">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Mohammed Alfatafta, Basil Alkhatib, Ahmed Alquraan, and Samer Al-Kiswany, University of Waterloo, Canada We present an extensive study focused on partial network partitioning. Partial network partitions disrupt the communication between some but not all nodes in a cluster. First, we conduct a comprehensive study of system failures caused by this fault in 12 popular systems. Our study reveals that the studied failures are catastrophic (e.g., lead to data loss), easily manifest, and can manifest by partially partitioning a single node. Second, we dissect the design of eight popular systems and identify four principled approaches for tolerating partial partitions. Unfortunately, our analysis shows that implemented fault tolerance techniques are inadequate for modern systems; they either patch a particular mechanism or lead to a complete cluster shutdown, even when alternative network paths exist. Finally, our findings motivate us to build Nifty, a trans-parent communication layer that masks partial network partitions. Nifty builds an overlay between nodes to detour packets around partial partitions. Our prototype evaluation with six popular systems shows that Nifty overcomes the short comings of current fault tolerance approaches and effectively masks partial partitions while imposing negligible overhead.},
  archive   = {C_OSDI},
  author    = {Mohammed Alfatafta and Basil Alkhatib and Ahmed Alquraan and Samer Al-Kiswany},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {351-368},
  title     = {Toward a generic fault tolerance technique for partial network partitioning},
  url       = {https://www.usenix.org/conference/osdi20/presentation/alfatafta},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). <span class="nocase">Performance-optimal</span> <span
class="nocase">Read-only</span> transactions. <em>OSDI</em>, 333–349.
(<a
href="https://www.usenix.org/conference/osdi20/presentation/lu">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Haonan Lu, Princeton University; Siddhartha Sen, Microsoft Research; Wyatt Lloyd, Princeton University Read-only transactions are critical for consistently reading data spread across a distributed storage system but have worse performance than simple, non-transactional reads. We identify three properties of simple reads that are necessary for read-only transactions to be performance-optimal, i.e., come as close as possible to simple reads. We demonstrate a fundamental tradeoff in the design of read-only transactions by proving that performance optimality is impossible to achieve with strict serializability, the strongest consistency. Guided by this result, we present PORT, a performance-optimal design with the strongest consistency to date. Central to PORT are version clocks, a specialized logical clock that concisely captures the necessary ordering constraints. We show the generality of PORT with two applications. Scylla-PORT provides process-ordered serializability with simple writes and shows performance comparable to its non-transactional base system. Eiger-PORT provides causal consistency with write transactions and significantly improves the performance of its transactional base system.},
  archive   = {C_OSDI},
  author    = {Haonan Lu and Siddhartha Sen and Wyatt Lloyd},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {333-349},
  title     = {{Performance-optimal} {Read-only} transactions},
  url       = {https://www.usenix.org/conference/osdi20/presentation/lu},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). AIFM: <span class="nocase">High-performance</span>, <span
class="nocase">Application-integrated</span> far memory. <em>OSDI</em>,
315–332. (<a
href="https://www.usenix.org/conference/osdi20/presentation/ruan">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Zhenyuan Ruan, MIT CSAIL; Malte Schwarzkopf, Brown University; Marcos K. Aguilera, VMware Research; Adam Belay, MIT CSAIL Memory is the most contended and least elastic resource in datacenter servers today. Applications can use only local memory—which may be scarce—even though memory might be readily available on another server. This leads to unnecessary killings of workloads under memory pressure and reduces effective server utilization. We present application-integrated far memory (AIFM), which makes remote, “far” memory available to applications through a simple API and with high performance. AIFM achieves the same common-case access latency for far memory as for local RAM; it avoids read and write amplification that paging-based approaches suffer; it allows data structure engineers to build remoteable, hybrid near/far memory data structures; and it makes far memory transparent and easy to use for application developers. Our key insight is that exposing application-level semantics to a high-performance runtime makes efficient remoteable memory possible. Developers use AIFM’s APIs to make allocations remoteable, and AIFM’s runtime handles swapping objects in and out, prefetching, and memory evacuation. We evaluate AIFM with a prototypical web application frontend, a NYC taxi data analytics workload, a memcached-like key-value cache, and Snappy compression. Adding AIFM remoteable memory to these applications increases their available memory without performance penalty. AIFM outperforms Fastswap, a state-of-the-art kernel-integrated, paging-based far memory system by up to 61×.},
  archive   = {C_OSDI},
  author    = {Zhenyuan Ruan and Malte Schwarzkopf and Marcos K. Aguilera and Adam Belay},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {315-332},
  title     = {{AIFM}: {High-performance}, {Application-integrated} far memory},
  url       = {https://www.usenix.org/conference/osdi20/presentation/ruan},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Overload control for <span class="nocase">µs-scale</span>
RPCs with breakwater. <em>OSDI</em>, 299–314. (<a
href="https://www.usenix.org/conference/osdi20/presentation/cho">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Inho Cho, Ahmed Saeed, Joshua Fried, Seo Jin Park, Mohammad Alizadeh, and Adam Belay, MIT CSAIL Modern datacenter applications are composed of hundreds of microservices with high degrees of fanout. As a result, they are sensitive to tail latency and require high request throughputs. Maintaining these characteristics under overload is difficult, especially for RPCs with short service times. In this paper, we consider the challenging case of microsecond-scale RPCs, where the cost of communicating information and dropping a request is similar to the cost of processing a request. We present Breakwater, an overload control scheme that can prevent overload in microsecond-scale services through a new, server-driven admission control scheme that issues credits based on server-side queueing delay. Breakwater contributes several techniques to amortize communication costs. It engages in demand speculation, where it assumes clients have unmet demand and issues additional credits when the server is not overloaded. Moreover, it piggybacks client-side demand information in RPC requests and credits in RPC responses. To cope with the occasional bursts in load caused by demand speculation, Breakwater drops requests when overloaded using active queue management. When clients’ demand spikes unexpectedly to 1.4x capacity, Breakwater converges to stable performance in less than 20 ms with no congestion collapse while DAGOR and SEDA take 500 ms and 1.58 s to recover from congestion collapse, respectively.},
  archive   = {C_OSDI},
  author    = {Inho Cho and Ahmed Saeed and Joshua Fried and Seo Jin Park and Mohammad Alizadeh and Adam Belay},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {299-314},
  title     = {Overload control for {µs-scale} {RPCs} with breakwater},
  url       = {https://www.usenix.org/conference/osdi20/presentation/cho},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Caladan: Mitigating interference at microsecond timescales.
<em>OSDI</em>, 281–297. (<a
href="https://www.usenix.org/conference/osdi20/presentation/fried">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Joshua Fried and Zhenyuan Ruan, MIT CSAIL; Amy Ousterhout, UC Berkeley; Adam Belay, MIT CSAIL The conventional wisdom is that CPU resources such as cores, caches, and memory bandwidth must be partitioned to achieve performance isolation between tasks. Both the widespread availability of cache partitioning in modern CPUs and the recommended practice of pinning latency-sensitive applications to dedicated cores attest to this belief. In this paper, we show that resource partitioning is neither necessary nor sufficient. Many applications experience bursty request patterns or phased behavior, drastically changing the amount and type of resources they need. Unfortunately, partitioning-based systems fail to react quickly enough to keep up with these changes, resulting in extreme spikes in latency and lost opportunities to increase CPU utilization. Caladan is a new CPU scheduler that can achieve significantly better quality of service (tail latency, throughput, etc.) through a collection of control signals and policies that rely on fast core allocation instead of resource partitioning. Caladan consists of a centralized scheduler core that actively manages resource contention in the memory hierarchy and between hyperthreads, and a kernel module that bypasses the standard Linux Kernel scheduler to support microsecond-scale monitoring and placement of tasks. When colocating memcached with a best-effort, garbage-collected workload, Caladan outperforms Parties, a state-of-the-art resource partitioning system, by 11,000x, reducing tail latency from 580 ms to 52 μs during shifts in resource usage while maintaining high CPU utilization.},
  archive   = {C_OSDI},
  author    = {Joshua Fried and Zhenyuan Ruan and Amy Ousterhout and Adam Belay},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {281-297},
  title     = {Caladan: Mitigating interference at microsecond timescales},
  url       = {https://www.usenix.org/conference/osdi20/presentation/fried},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Semeru: A <span class="nocase">Memory-disaggregated</span>
managed runtime. <em>OSDI</em>, 261–280. (<a
href="https://www.usenix.org/conference/osdi20/presentation/wang">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Chenxi Wang, Haoran Ma, Shi Liu, and Yuanqi Li, UCLA; Zhenyuan Ruan, MIT; Khanh Nguyen, Texas A&amp;M University; Michael D. Bond, Ohio State University; Ravi Netravali, Miryung Kim, and Guoqing Harry Xu, UCLA Resource-disaggregated architectures have risen in popularity for large datacenters. However, prior disaggregation systems are designed for native applications; in addition, all of them require applications to possess excellent locality to be efficiently executed. In contrast, programs written in managed languages are subject to periodic garbage collection (GC), which is a typical graph workload with poor locality. Although most datacenter applications are written in managed languages, current systems are far from delivering acceptable performance for these applications. This paper presents Semeru, a distributed JVM that can dramatically improve the performance of managed cloud applications in a memory-disaggregated environment. Its design possesses three major innovations: (1) a universal Java heap, which provides a unified abstraction of virtual memory across CPU and memory servers and allows any legacy program to run without modifications; (2) a distributed GC, which offloads object tracing to memory servers so that tracing is performed closer to data; and (3) a swap system in the OS kernel that works with the runtime to swap page data efficiently. An evaluation of Semeru on a set of widely-deployed systems shows very promising results.},
  archive   = {C_OSDI},
  author    = {Chenxi Wang and Haoran Ma and Shi Liu and Yuanqi Li and Zhenyuan Ruan and Khanh Nguyen and Michael D. Bond and Ravi Netravali and Miryung Kim and Guoqing Harry Xu},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {261-280},
  title     = {Semeru: A {Memory-disaggregated} managed runtime},
  url       = {https://www.usenix.org/conference/osdi20/presentation/wang},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). PANIC: A <span class="nocase">High-performance</span>
programmable NIC for multi-tenant networks. <em>OSDI</em>, 243–259. (<a
href="https://www.usenix.org/conference/osdi20/presentation/lin">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Jiaxin Lin, University of Wisconsin-Madison; Kiran Patel and Brent E. Stephens, University of Illinois at Chicago; Anirudh Sivaraman, New York University (NYU); Aditya Akella, University of Wisconsin-Madison Programmable NICs have diverse uses, and there is need for a NIC platform that can offload computation from multiple co-resident applications to many different types of substrates, including hardware accelerators, embedded FPGAs, and embedded processor cores. Unfortunately, there is no existing NIC design that can simultaneously support a large number of diverse offloads while ensuring high throughput/low latency, multi-tenant isolation, flexible offload chaining, and support for offloads with variable performance. This paper presents Frenzy, a new programmable NIC. There are two new key components of the Frenzy design that enable it to overcome the limitations of existing NICs: 1) A high-performance switching interconnect that scalably connects independent engines into offload chains, and 2) A new hybrid push/pull packet scheduler that provides cross-tenant performance isolation and low-latency load-balancing across parallel offload engines. From both experiments performed on an 100Gbps FPGA-based prototype and experiments that use a combination of techniques including simulation and cost/area analysis, we find that this design overcomes the limitations of state-of-the-art programmable NICs.},
  archive   = {C_OSDI},
  author    = {Jiaxin Lin and Kiran Patel and Brent E. Stephens and Anirudh Sivaraman and Aditya Akella},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {243-259},
  title     = {{PANIC}: A {High-performance} programmable {NIC} for multi-tenant networks},
  url       = {https://www.usenix.org/conference/osdi20/presentation/lin},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). A simpler and faster NIC driver model for network functions.
<em>OSDI</em>, 225–241. (<a
href="https://www.usenix.org/conference/osdi20/presentation/pirelli">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Solal Pirelli and George Candea, EPFL The advent of software network functions calls for stronger correctness guarantees and higher performance at every level of the stack. Current network stacks trade simplicity for performance and flexibility, especially in their driver model. We show that performance and simplicity can co-exist, at the cost of some flexibility, with a new NIC driver model tailored to network functions. The key idea behind our model is that the driver can efficiently reuse packet buffers because buffers follow a single logical path. We implement a driver for the Intel 82599 network card in 550 lines of code. By merely replacing the state-of-the-art driver with our driver, formal verification of the entire software stack completes in 7x less time, while the verified functions’ throughput improves by 160%. Our driver also beats, on realistic workloads, the throughput of drivers that cannot yet be formally verified, thanks to its low variability and resource use. Our code is available at github.com/dslab-epfl/tinynf.},
  archive   = {C_OSDI},
  author    = {Solal Pirelli and George Candea},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {225-241},
  title     = {A simpler and faster {NIC} driver model for network functions},
  url       = {https://www.usenix.org/conference/osdi20/presentation/pirelli},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Generalized <span class="nocase">Sub-query</span> fusion for
eliminating redundant I/O from <span class="nocase">Big-data</span>
queries. <em>OSDI</em>, 209–224. (<a
href="https://www.usenix.org/conference/osdi20/presentation/sarthi">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Partho Sarthi, Kaushik Rajan, and Akash Lal, Microsoft Research India; Abhishek Modi, Prakhar Jain, Mo Liu, and Ashit Gosalia, Microsoft; Saurabh Kalikar, Intel SQL is the de-facto language for big-data analytics. Despite the cost of distributed SQL execution being dominated by disk and network I/O, we find that state-of-the-art optimizers produce plans that are not I/O optimal. For a significant fraction of queries (25% of popular benchmarks like TPCDS), a large amount of data is shuffled redundantly between different pairs of stages. The fundamental reason for this limitation is that optimizers do not have the right set of primitives to perform reasoning at the map-reduce level that can potentially identify and eliminate the redundant I/O. This paper proposes RESIN an optimizer extension that adds first-class support for map-reduce reasoning. RESIN uses a novel technique called Generalized Sub-Query Fusion that identifies sub-queries computing on overlapping data, and fuses them into the same map-reduce stages. The analysis is general; it does not require that the sub-queries be syntactically the same, nor are they required to produce the same output. Sub-query fusion allows RESIN to sometimes also eliminate expensive binary operations like Joins and Unions altogether for further gains. We have integrated RESIN into sparkSQL and evaluated it on TPCDS, a standard analytics benchmark suite. Our results demonstrate that the proposed optimizations apply to 40% of the queries and speed up a large fraction of them by 1.1−6x, reducing the overall execution time of the benchmark suite by 12%.},
  archive   = {C_OSDI},
  author    = {Partho Sarthi and Kaushik Rajan and Akash Lal and Abhishek Modi and Prakhar Jain and Mo Liu and Ashit Gosalia and Saurabh Kalikar},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {209-224},
  title     = {Generalized {Sub-query} fusion for eliminating redundant {I/O} from {Big-data} queries},
  url       = {https://www.usenix.org/conference/osdi20/presentation/sarthi},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). A large scale analysis of hundreds of in-memory cache
clusters at twitter. <em>OSDI</em>, 191–208. (<a
href="https://www.usenix.org/conference/osdi20/presentation/yang">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Juncheng Yang, Carnegie Mellon University; Yao Yue, Twitter; K. V. Rashmi, Carnegie Mellon University Modern web services use in-memory caching extensively to increase throughput and reduce latency. There have been several workload analyses of production systems that have fueled research in improving the effectiveness of in-memory caching systems. However, the coverage is still sparse considering the wide spectrum of industrial cache use cases. In this work, we significantly further the understanding of real-world cache workloads by collecting production traces from 153 in-memory cache clusters at Twitter, sifting through over 80 TB of data, and sometimes interpreting the workloads in the context of the business logic behind them. We perform a comprehensive analysis to characterize cache workloads based on traffic pattern, time-to-live (TTL), popularity distribution, and size distribution. A fine-grained view of different workloads uncover the diversity of use cases: many are far more write-heavy or more skewed than previously shown and some display unique temporal patterns. We also observe that TTL is an important and sometimes defining parameter of cache working sets. Our simulations show that ideal replacement strategy in production caches can be surprising, for example, FIFO works the best for a large number of workloads.},
  archive   = {C_OSDI},
  author    = {Juncheng Yang and Yao Yue and K. V. Rashmi},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {191-208},
  title     = {A large scale analysis of hundreds of in-memory cache clusters at twitter},
  url       = {https://www.usenix.org/conference/osdi20/presentation/yang},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). LinnOS: Predictability on unpredictable flash storage with a
light neural network. <em>OSDI</em>, 173–190. (<a
href="https://www.usenix.org/conference/osdi20/presentation/hao">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Mingzhe Hao, Levent Toksoz, and Nanqinqin Li, University of Chicago; Edward Edberg Halim, Surya University; Henry Hoffmann and Haryadi S. Gunawi, University of Chicago This paper presents LinnOS, an operating system that leverages a light neural network for inferring SSD performance at a very fine — per-IO — granularity and helps parallel storage applications achieve performance predictability. LinnOS supports black-box devices and real production traces without requiring any extra input from users, while outperforming industrial mechanisms and other approaches. Our evaluation shows that, compared to hedging and heuristic-based methods, LinnOS improves the average I/O latencies by 9.6-79.6% with 87-97% inference accuracy and 4-6μs inference overhead for each I/O, demonstrating that it is possible to incorporate machine learning inside operating systems for real-time decision-making.},
  archive   = {C_OSDI},
  author    = {Mingzhe Hao and Levent Toksoz and Nanqinqin Li and Edward Edberg Halim and Henry Hoffmann and Haryadi S. Gunawi},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {173-190},
  title     = {{LinnOS}: Predictability on unpredictable flash storage with a light neural network},
  url       = {https://www.usenix.org/conference/osdi20/presentation/hao},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). From WiscKey to bourbon: A learned index for <span
class="nocase">Log-structured</span> merge trees. <em>OSDI</em>,
155–171. (<a
href="https://www.usenix.org/conference/osdi20/presentation/dai">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Yifan Dai, Yien Xu, Aishwarya Ganesan, and Ramnatthan Alagappan, University of Wisconsin - Madison; Brian Kroth, Microsoft Gray Systems Lab; Andrea Arpaci-Dusseau and Remzi Arpaci-Dusseau, University of Wisconsin - Madison We introduce BOURBON, a log-structured merge (LSM) tree that utilizes machine learning to provide fast lookups. We base the design and implementation of BOURBON on empirically-grounded principles that we derive through careful analysis of LSM design. BOURBON employs greedy piecewise linear regression to learn key distributions, enabling fast lookup with minimal computation, and applies a cost-benefit strategy to decide when learning will be worthwhile. Through a series of experiments on both synthetic and real-world datasets, we show that BOURBON improves lookup performance by 1.23x-1.78x as compared to state-of-the-art production LSMs.},
  archive   = {C_OSDI},
  author    = {Yifan Dai and Yien Xu and Aishwarya Ganesan and Ramnatthan Alagappan and Brian Kroth and Andrea Arpaci-Dusseau and Remzi Arpaci-Dusseau},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {155-171},
  title     = {From {WiscKey} to bourbon: A learned index for {Log-structured} merge trees},
  url       = {https://www.usenix.org/conference/osdi20/presentation/dai},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). CrossFS: A cross-layered <span
class="nocase">Direct-access</span> file system. <em>OSDI</em>, 137–154.
(<a
href="https://www.usenix.org/conference/osdi20/presentation/ren">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Yujie Ren, Rutgers University; Changwoo Min, Virginia Tech; Sudarsun Kannan, Rutgers University We design CrossFS, a cross-layered direct-access file system disaggregated across user-level, firmware, and kernel layers for scaling I/O performance and improving concurrency. CrossFS is designed to exploit host- and device-level compute capabilities. For concurrency with or without data sharing across threads and processes, CrossFS introduces a file descriptor-based concurrency control that maps each file descriptor to one hardware-level I/O queue. This design allows CrossFS’s firmware component to process disjoint access across file descriptors concurrently. CrossFS delegates concurrency control to powerful host-CPUs, which convert the file descriptor synchronization problem into an I/O queue request ordering problem. To guarantee crash consistency in the cross-layered design, CrossFS exploits byte-addressable nonvolatile memory for I/O queue persistence and designs a lightweight firmware-level journaling mechanism. Finally, CrossFS designs a firmware-level I/O scheduler for efficient dispatch of file descriptor requests. Evaluation of emulated CrossFS on storage-class memory shows up to 4.87X concurrent access gains for benchmarks and 2.32X gains for real-world applications over the state-of-the-art kernel, user-level, and firmware file systems.},
  archive   = {C_OSDI},
  author    = {Yujie Ren and Changwoo Min and Sudarsun Kannan},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {137-154},
  title     = {{CrossFS}: A cross-layered {Direct-access} file system},
  url       = {https://www.usenix.org/conference/osdi20/presentation/ren},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Fast <span class="nocase">RDMA-based</span> ordered <span
class="nocase">Key-value</span> store using remote learned cache.
<em>OSDI</em>, 117–135. (<a
href="https://www.usenix.org/conference/osdi20/presentation/wei">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Xingda Wei, Rong Chen, and Haibo Chen, Shanghai Jiao Tong University RDMA (Remote Direct Memory Access) has gained considerable interests in network-attached in-memory key-value stores. However, traversing the remote tree-based index in ordered stores with RDMA becomes a critical obstacle, causing an order-of-magnitude slowdown and limited scalability due to multiple roundtrips. Using index cache with conventional wisdom—caching partial data and traversing them locally—usually leads to limited effect because of unavoidable capacity misses, massive random accesses, and costly cache invalidations. We argue that the machine learning (ML) model is a perfect cache structure for the tree-based index, termed learned cache. Based on it, we design and implement XSTORE, an RDMA-based ordered key-value store with a new hybrid architecture that retains a tree-based index at the server to perform dynamic workloads (e.g., inserts) and leverages a learned cache at the client to perform static workloads (e.g., gets and scans). The key idea is to decouple ML model retraining from index updating by maintaining a layer of indirection from logical to actual positions of key-value pairs. It allows a stale learned cache to continue predicting a correct position for a lookup key. XSTORE ensures correctness using a validation mechanism with a fallback path and further uses speculative execution to minimize the cost of cache misses. Evaluations with YCSB benchmarks and production workloads show that a single XSTORE server can achieve over 80 million read-only requests per second. This number outperforms state-of-the-art RDMA-based ordered key-value stores (namely, DrTM-Tree, Cell, and eRPC+Masstree) by up to 5.9× (from 3.7×). For workloads with inserts, XSTORE still provides up to 3.5× (from 2.7×) throughput speedup, achieving 53M reqs/s. The learned cache can also reduces client-side memory usage and further provides an efficient memory-performance tradeoff, e.g., saving 99% memory at the cost of 20% peak throughput.},
  archive   = {C_OSDI},
  author    = {Xingda Wei and Rong Chen and Haibo Chen},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {117-135},
  title     = {Fast {RDMA-based} ordered {Key-value} store using remote learned cache},
  url       = {https://www.usenix.org/conference/osdi20/presentation/wei},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Storage systems are distributed systems (so verify them that
Way!). <em>OSDI</em>, 99–115. (<a
href="https://www.usenix.org/conference/osdi20/presentation/hance">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Travis Hance, Carnegie Mellon University; Andrea Lattuada, ETH Zurich; Chris Hawblitzel, Microsoft Research; Jon Howell and Rob Johnson, VMware Research; Bryan Parno, Carnegie Mellon University To verify distributed systems, prior work introduced a methodology for verifying both the code running on individual machines and the correctness of the overall system when those machines interact via an asynchronous distributed environment. The methodology requires neither domain-specific logic nor tooling. However, distributed systems are only one instance of the more general phenomenon of systems code that interacts with an asynchronous environment. We argue that the software of a storage system can (and should!) be viewed similarly. We evaluate this approach in VeriSafeKV, a key-value store based on a state-of-the-art B^ε-tree. In building VeriSafeKV, we introduce new techniques to scale automated verification to larger code bases, still without introducing domain-specific logic or tooling. In particular, we show a discipline that keeps the automated verification development cycle responsive. We also combine linear types with dynamic frames to relieve the programmer from most heap-reasoning obligations while enabling them to break out of the linear type system when needed. VeriSafeKV exhibits similar query performance to unverified databases. Its insertion performance is 15× faster than unverified BerkeleyDB and 6× slower than RocksDB.},
  archive   = {C_OSDI},
  author    = {Travis Hance and Andrea Lattuada and Chris Hawblitzel and Jon Howell and Rob Johnson and Bryan Parno},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {99-115},
  title     = {Storage systems are distributed systems (So verify them that {Way!})},
  url       = {https://www.usenix.org/conference/osdi20/presentation/hance},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Determinizing crash behavior with a verified <span
class="nocase">Snapshot-consistent</span> flash translation layer.
<em>OSDI</em>, 81–97. (<a
href="https://www.usenix.org/conference/osdi20/presentation/chang">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Yun-Sheng Chang, Yao Hsiao, Tzu-Chi Lin, Che-Wei Tsao, Chun-Feng Wu, Yuan-Hao Chang, Hsiang-Shang Ko, and Yu-Fang Chen, Institute of Information Science, Academia Sinica, Taiwan This paper introduces the design of a snapshot-consistent flash translation layer (SCFTL) for flash disks, which has a stronger guarantee about the possible behavior after a crash than conventional designs. More specifically, the flush operation of SCFTL also has the functionality of making a “disk snapshot.” When a crash occurs, the flash disk is guaranteed to recover to the state right before the last flush. The major benefit of SCFTL is that it allows a more efficient design of upper layers in the storage stack. For example, the file system built on SCFTL does not require the use of a journal for crash recovery. Instead, it only needs to perform a flush operation of SCFTL at the end of each atomic transaction. We use a combination of a proof assistant, a symbolic executor, and an SMT solver, to formally verify the correctness of our SCFTL implementation. We modify the xv6 file system to support group commit and utilize SCFTL’s stronger crash guarantee. Our evaluation using file system benchmarks shows that the modified xv6 on SCFTL is 3 to 30 times faster than xv6 with logging on conventional FTLs, and is in the worst case only two times slower than the state-of-the-art setting: the ext4 file system on the Physical Block Device (pblk) FTL.},
  archive   = {C_OSDI},
  author    = {Yun-Sheng Chang and Yao Hsiao and Tzu-Chi Lin and Che-Wei Tsao and Chun-Feng Wu and Yuan-Hao Chang and Hsiang-Shang Ko and Yu-Fang Chen},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {81-97},
  title     = {Determinizing crash behavior with a verified {Snapshot-consistent} flash translation layer},
  url       = {https://www.usenix.org/conference/osdi20/presentation/chang},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Cobra: Making transactional <span
class="nocase">Key-value</span> stores verifiably serializable.
<em>OSDI</em>, 63–80. (<a
href="https://www.usenix.org/conference/osdi20/presentation/tan">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Cheng Tan and Changgeng Zhao, NYU; Shuai Mu, Stony Brook University; Michael Walfish, NYU Today’s cloud databases offer strong properties, including serializability, sometimes called the gold standard database correctness property. But cloud databases are complicated black boxes, running in a different administrative domain from their clients. Thus, clients might like to know whether the databases are meeting their contract. To that end, we introduce cobra; cobra applies to transactional key-value stores. It is the first system that combines (a) black-box checking, of (b) serializability, while (c) scaling to real-world online transactional processing workloads. The core technical challenge is that the underlying search problem is computationally expensive. Cobra tames that problem by starting with a suitable SMT solver. Cobra then introduces several new techniques, including a new encoding of the validity condition; hardware acceleration to prune inputs to the solver; and a transaction segmentation mechanism that enables scaling and garbage collection. Cobra imposes modest overhead on clients, improves over baselines by 10x in verification cost, and (unlike the baselines) supports continuous verification. Our artifact can handle 2000 transactions/sec, equivalent to 170M/day.},
  archive   = {C_OSDI},
  author    = {Cheng Tan and Changgeng Zhao and Shuai Mu and Michael Walfish},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {63-80},
  title     = {Cobra: Making transactional {Key-value} stores verifiably serializable},
  url       = {https://www.usenix.org/conference/osdi20/presentation/tan},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Specification and verification in the field: Applying formal
methods to BPF just-in-time compilers in the linux kernel.
<em>OSDI</em>, 41–61. (<a
href="https://www.usenix.org/conference/osdi20/presentation/nelson">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Luke Nelson, Jacob Van Geffen, Emina Torlak, and Xi Wang, University of Washington This paper describes our experience applying formal methods to a critical component in the Linux kernel, the just-in-time compilers (&quot;JITs&quot;) for the Berkeley Packet Filter (BPF) virtual machine. We verify these JITs using Jitterbug, the first framework to provide a precise specification of JIT correctness that is capable of ruling out real-world bugs, and an automated proof strategy that scales to practical implementations. Using Jitterbug, we have designed, implemented, and verified a new BPF JIT for 32-bit RISC-V, found and fixed 16 previously unknown bugs in five other deployed JITs, and developed new JIT optimizations; all of these changes have been upstreamed to the Linux kernel. The results show that it is possible to build a verified component within a large, unverified system with careful design of specification and proof strategy.},
  archive   = {C_OSDI},
  author    = {Luke Nelson and Jacob Van Geffen and Emina Torlak and Xi Wang},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {41-61},
  title     = {Specification and verification in the field: Applying formal methods to {BPF} just-in-time compilers in the linux kernel},
  url       = {https://www.usenix.org/conference/osdi20/presentation/nelson},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). RedLeaf: Isolation and communication in a safe operating
system. <em>OSDI</em>, 21–39. (<a
href="https://www.usenix.org/conference/osdi20/presentation/narayanan-vikram">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Vikram Narayanan, Tianjiao Huang, David Detweiler, Dan Appel, and Zhaofeng Li, University of California, Irvine; Gerd Zellweger, VMware Research; Anton Burtsev, University of California, Irvine RedLeaf is a new operating system developed from scratch in Rust to explore the impact of language safety on operating system organization. In contrast to commodity systems, RedLeaf does not rely on hardware address spaces for isolation and instead uses only type and memory safety of the Rust language. Departure from costly hardware isolation mechanisms allows us to explore the design space of systems that embrace lightweight fine-grained isolation. We develop a new abstraction of a lightweight language-based isolation domain that provides a unit of information hiding and fault isolation. Domains can be dynamically loaded and cleanly terminated, i.e., errors in one domain do not affect the execution of other domains. Building on RedLeaf isolation mechanisms, we demonstrate the possibility to implement end-to-end zero-copy, fault isolation, and transparent recovery of device drivers. To evaluate the practicality of RedLeaf abstractions, we implement Rv6, a POSIX-subset operating system as a collection of RedLeaf domains. Finally, to demonstrate that Rust and fine-grained isolation are practical—we develop efficient versions of a 10Gbps Intel ixgbe network and NVMe solid-state disk device drivers that match the performance of the fastest DPDK and SPDK equivalents.},
  archive   = {C_OSDI},
  author    = {Vikram Narayanan and Tianjiao Huang and David Detweiler and Dan Appel and Zhaofeng Li and Gerd Zellweger and Anton Burtsev},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {21-39},
  title     = {{RedLeaf}: Isolation and communication in a safe operating system},
  url       = {https://www.usenix.org/conference/osdi20/presentation/narayanan-vikram},
  year      = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Theseus: An experiment in operating system structure and
state management. <em>OSDI</em>, 1–19. (<a
href="https://www.usenix.org/conference/osdi20/presentation/boos">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@inproceedings{ ,
  abstract  = {Kevin Boos, Rice University; Namitha Liyanage, Yale University; Ramla Ijaz, Rice University; Lin Zhong, Yale University This paper describes an operating system (OS) called Theseus. Theseus is the result of multi-year experimentation to redesign and improve OS modularity by reducing the states one component holds for another, and to leverage a safe programming language, namely Rust, to shift as many OS responsibilities as possible to the compiler. Theseus embodies two primary contributions. First, an OS structure in which many tiny components with clearly-defined, runtime-persistent bounds interact without holding states for each other. Second, an intralingual approach that realizes the OS itself using language-level mechanisms such that the compiler can enforce invariants about OS semantics. Theseus’s structure, intralingual design, and state management realize live evolution and fault recovery for core OS components in ways beyond that of existing works.},
  archive   = {C_OSDI},
  author    = {Kevin Boos and Namitha Liyanage and Ramla Ijaz and Lin Zhong},
  booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation},
  month     = {11},
  pages     = {1-19},
  title     = {Theseus: An experiment in operating system structure and state management},
  url       = {https://www.usenix.org/conference/osdi20/presentation/boos},
  year      = {2020},
}
</textarea>
</details></li>
</ul>

</body>
</html>
