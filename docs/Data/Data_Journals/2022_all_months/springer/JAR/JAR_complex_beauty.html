<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>JAR_complex_beauty</title>
  <style>
    html {font-size: 22px;}
    body {margin: 0 auto; max-width: 76em;}
    #copyID {font-size: 18px;}
  </style>
  <script>
    function copy(element) {
      if (element.type == "button"){
      element.type="text";
      }
      element.style.color="black";
      element.style.backgroundColor="#C7EDCC";
      element.select();
      element.setSelectionRange(0, 99999);
      navigator.clipboard.writeText(element.value);
      window.getSelection().removeAllRanges();
      element.type="button";
    }
  </script>
</head>
<body>

<h2 id="jar---37">JAR - 37</h2>
<ul>
<li><details>
<summary>
(2022a). Correction to: Local is best: Efficient reductions to modal
logic k. <em>JAR</em>, <em>66</em>(4), 1099. (<a
href="https://doi.org/10.1007/s10817-022-09633-3">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_JAR},
  author       = {Papacchini, Fabio and Nalon, Cláudia and Hustadt, Ullrich and Dixon, Clare},
  doi          = {10.1007/s10817-022-09633-3},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {1099},
  shortjournal = {J. Auto. Reasoning},
  title        = {Correction to: local is best: efficient reductions to modal logic k},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022b). Correction to: A formalization of the smith normal form in
higher-order logic. <em>JAR</em>, <em>66</em>(4), 1097. (<a
href="https://doi.org/10.1007/s10817-022-09636-0">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_JAR},
  author       = {Divasón, Jose and Thiemann, René},
  doi          = {10.1007/s10817-022-09636-0},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {1097},
  shortjournal = {J. Auto. Reasoning},
  title        = {Correction to: A formalization of the smith normal form in higher-order logic},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022a). A formalization of the smith normal form in higher-order
logic. <em>JAR</em>, <em>66</em>(4), 1065–1095. (<a
href="https://doi.org/10.1007/s10817-022-09631-5">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This work presents formal correctness proofs in Isabelle/HOL of algorithms to transform a matrix into Smith normal form, a canonical matrix form, in a general setting: the algorithms are written in an abstract form and parameterized by very few simple operations. We formally show their soundness provided the operations exist and satisfy some conditions, which always hold on Euclidean domains. We also provide a formal proof on some results about the generality of such algorithms as well as the uniqueness of the Smith normal form. Since Isabelle/HOL does not feature dependent types, the development is carried out by switching conveniently between two different existing libraries by means of the lifting and transfer package and the use of local type definitions, a sound extension to HOL.},
  archive      = {J_JAR},
  author       = {Divasón, Jose and Thiemann, René},
  doi          = {10.1007/s10817-022-09631-5},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {1065-1095},
  shortjournal = {J. Auto. Reasoning},
  title        = {A formalization of the smith normal form in higher-order logic},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Formalization of the computational theory of a turing
complete functional language model. <em>JAR</em>, <em>66</em>(4),
1031–1063. (<a
href="https://doi.org/10.1007/s10817-021-09615-x">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This work presents a formalization in PVS of the computational theory for a computational model given as a class of partial recursive functions called PVS0. The model is built over basic operators, which, when restricted to constants, successor, projections, greater-than, and bijections from tuples of naturals to naturals, results in a proven (formalized) Turing complete model. Complete formalizations of the Recursion theorem and Rice’s theorem are discussed in detail. Other relevant results, such as the undecidability of the Halting problem and the fixed-point theorem, were also fully formalized.},
  archive      = {J_JAR},
  author       = {Ramos, Thiago Mendonça Ferreira and Almeida, Ariane Alves and Ayala-Rincón, Mauricio},
  doi          = {10.1007/s10817-021-09615-x},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {1031-1063},
  shortjournal = {J. Auto. Reasoning},
  title        = {Formalization of the computational theory of a turing complete functional language model},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). A formalization of SQL with nulls. <em>JAR</em>,
<em>66</em>(4), 989–1030. (<a
href="https://doi.org/10.1007/s10817-022-09632-4">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {SQL is the world’s most popular declarative language, forming the basis of the multi-billion-dollar database industry. Although SQL has been standardized, the full standard is based on ambiguous natural language rather than formal specification. Commercial SQL implementations interpret the standard in different ways, so that, given the same input data, the same query can yield different results depending on the SQL system it is run on. Even for a particular system, mechanically checked formalization of all widely-used features of SQL remains an open problem. The lack of a well-understood formal semantics makes it very difficult to validate the soundness of database implementations. Although formal semantics for fragments of SQL were designed in the past, they usually did not support set and bag operations, lateral joins, nested subqueries, and, crucially, null values. Null values complicate SQL’s semantics in profound ways analogous to null pointers or side-effects in other programming languages. Since certain SQL queries are equivalent in the absence of null values, but produce different results when applied to tables containing incomplete data, semantics which ignore null values are able to prove query equivalences that are unsound in realistic databases. A formal semantics of SQL supporting all the aforementioned features was only proposed recently. In this paper, we report about our mechanization of SQL semantics covering set/bag operations, lateral joins, nested subqueries, and nulls, written in the Coq proof assistant, and describe the validation of key metatheoretic properties. Additionally, we are able to use the same framework to formalize the semantics of a flat relational calculus (with null values), and show a certified translation of its normal forms into SQL.},
  archive      = {J_JAR},
  author       = {Ricciotti, Wilmer and Cheney, James},
  doi          = {10.1007/s10817-022-09632-4},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {989-1030},
  shortjournal = {J. Auto. Reasoning},
  title        = {A formalization of SQL with nulls},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Towards formalising schutz’ axioms for minkowski spacetime
in isabelle/HOL. <em>JAR</em>, <em>66</em>(4), 953–988. (<a
href="https://doi.org/10.1007/s10817-022-09643-1">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Special relativity is a cornerstone of modern physical theory. While a standard coordinate model is well known and widely taught today, multiple axiomatic systems for SR have been constructed over the past century. This paper reports on the formalisation of one such system, which is closer in spirit to Hilbert’s axiomatic approach to Euclidean geometry than to the vector space approach employed by Minkowski. We present a mechanisation in Isabelle/HOL of the system of axioms as well as theorems relating to temporal order. Some proofs are discussed, particularly where the formal work required additional steps, alternative approaches or corrections to Schutz’ prose.},
  archive      = {J_JAR},
  author       = {Schmoetten, Richard and Palmer, Jake E. and Fleuriot, Jacques D.},
  doi          = {10.1007/s10817-022-09643-1},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {953-988},
  shortjournal = {J. Auto. Reasoning},
  title        = {Towards formalising schutz’ axioms for minkowski spacetime in Isabelle/HOL},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). From specification to testing: Semantics engineering for lua
5.2. <em>JAR</em>, <em>66</em>(4), 905–952. (<a
href="https://doi.org/10.1007/s10817-022-09638-y">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We provide a formal semantics for a large subset of the Lua programming language, in its version 5.2. The semantics is a major part of an ongoing effort to construct reliable tools to analyze Lua code. In this work, we present the details of several key aspects of the language, like the semantics of its only structured data-type (tables), its meta-programming mechanism (metatables), error handling, and how these mechanisms are used to define a complex dynamic semantics that must deal with several possible erroneous situations during run time, given the nature of the language. The semantics is mechanized in Redex, a DSL specially designed to specify and debug operational semantics. We validated the mechanization in two ways: first, by executing within Redex the test suite of the reference interpreter of Lua, and second, by specifying and performing random testing of its fundamental properties using the redex-check tool. Together, they evidence that our model soundly captures the semantics of the selected fragment of the language. Additionally, we address some of the performance problems that typically arise when testing a mechanization in Redex, by using a simple implementation of a reachability-based garbage collector that captures key aspects of Lua’s. By collecting syntactic garbage, we reduce the size of configurations during run time. Finally, we briefly discuss this avenue of development of our semantics, together with the implementation of a prototype tool to perform static analysis of Lua programs.},
  archive      = {J_JAR},
  author       = {Soldevila, Mallku and Ziliani, Beta and Silvestre, Bruno},
  doi          = {10.1007/s10817-022-09638-y},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {905-952},
  shortjournal = {J. Auto. Reasoning},
  title        = {From specification to testing: Semantics engineering for lua 5.2},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Pardinus: A temporal relational model finder. <em>JAR</em>,
<em>66</em>(4), 861–904. (<a
href="https://doi.org/10.1007/s10817-022-09642-2">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This article presents $$\mathsf {Pardinus}$$ , an extension of the popular $$\mathsf {Kodkod}$$ relational model finder with linear temporal logic (including past operators), to simplify the analysis of dynamic systems. $$\mathsf {Pardinus}$$ includes a SAT-based bounded-model checking engine and an SMV-based complete model checking engine, both allowing iteration through the different instances (or counter-examples) of a specification. It also supports a decomposed parallel analysis strategy that improves the efficiency of both analysis engines on commodity multi-core machines.},
  archive      = {J_JAR},
  author       = {Macedo, Nuno and Brunel, Julien and Chemouil, David and Cunha, Alcino},
  doi          = {10.1007/s10817-022-09642-2},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {861-904},
  shortjournal = {J. Auto. Reasoning},
  title        = {Pardinus: A temporal relational model finder},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Faster linear unification algorithm. <em>JAR</em>,
<em>66</em>(4), 845–860. (<a
href="https://doi.org/10.1007/s10817-022-09635-1">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Robinson unification algorithm has exponential worst case behavior. This triggered the development of (semi-)linear versions around 1976 by Martelli and Montanari as well as by Paterson and Wegman (J Comput Syst Sci 16(2):158–167, 1978, https://doi.org/10.1016/0022-0000(78)90043-0 ). Another version emerged by Baader and Snyder around 2001. While these versions are distinctly faster on larger input pairs, the Robinson version still does better than them on small-sized inputs. This paper describes yet another (semi-)linear version that is faster and challenges also the Robinson version on small-sized inputs. All versions have been implemented and compared against each other on different types and sizes of input pairs.},
  archive      = {J_JAR},
  author       = {de Champeaux, Dennis},
  doi          = {10.1007/s10817-022-09635-1},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {845-860},
  shortjournal = {J. Auto. Reasoning},
  title        = {Faster linear unification algorithm},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Fast left kan extensions using the chase. <em>JAR</em>,
<em>66</em>(4), 805–844. (<a
href="https://doi.org/10.1007/s10817-022-09634-2">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We show how computation of left Kan extensions can be reduced to computation of free models of cartesian (finite-limit) theories. We discuss how the standard and parallel chase compute weakly free models of regular theories and free models of cartesian theories and compare the concept of “free model” with a similar concept from database theory known as “universal model”. We prove that, as algorithms for computing finite-free models of cartesian theories, the standard and parallel chase are complete under fairness assumptions. Finally, we describe an optimized implementation of the parallel chase specialized to left Kan extensions that achieves an order of magnitude improvement in our performance benchmarks compared to the next fastest left Kan extension algorithm we are aware of.},
  archive      = {J_JAR},
  author       = {Meyers, Joshua and Spivak, David I. and Wisnesky, Ryan},
  doi          = {10.1007/s10817-022-09634-2},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {805-844},
  shortjournal = {J. Auto. Reasoning},
  title        = {Fast left kan extensions using the chase},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Verifying whiley programs with boogie. <em>JAR</em>,
<em>66</em>(4), 747–803. (<a
href="https://doi.org/10.1007/s10817-022-09619-1">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The quest to develop increasingly sophisticated verification systems continues unabated. Tools such as Dafny, Spec#, ESC/Java, SPARK Ada and Whiley attempt to seamlessly integrate specification and verification into a programming language, in a similar way to type checking. A common integration approach is to generate verification conditions that are handed off to an automated theorem prover. This provides a nice separation of concerns and allows different theorem provers to be used interchangeably. However, generating verification conditions is still a difficult undertaking and the use of more “high-level” intermediate verification languages has become commonplace. In particular, Boogie provides a widely used and understood intermediate verification language. A common difficulty is the potential for an impedance mismatch between the source language and the intermediate verification language. In this paper, we explore the use of Boogie as an intermediate verification language for verifying programs in Whiley. This is noteworthy because the Whiley language has (amongst other things) a rich type system with considerable potential for an impedance mismatch. We provide a comprehensive account of translating Whiley to Boogie which demonstrates that it is possible to model most aspects of the Whiley language. Key challenges posed by the Whiley language included: the encoding of Whiley’s expressive type system and support for flow typing and generics; the implicit assumption that expressions in specifications are well defined; the ability to invoke methods from within expressions; the ability to return multiple values from a function or method; the presence of unrestricted lambda functions; and the limited syntax for framing. We demonstrate that the resulting verification tool can verify significantly more programs than the native Whiley verifier which was custom-built for Whiley verification. Furthermore, our work provides evidence that Boogie is (for the most part) sufficiently general to act as an intermediate language for a wide range of source languages.},
  archive      = {J_JAR},
  author       = {Pearce, David J. and Utting, Mark and Groves, Lindsay},
  doi          = {10.1007/s10817-022-09619-1},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {747-803},
  shortjournal = {J. Auto. Reasoning},
  title        = {Verifying whiley programs with boogie},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Theorem proving as constraint solving with coherent logic.
<em>JAR</em>, <em>66</em>(4), 689–746. (<a
href="https://doi.org/10.1007/s10817-022-09629-z">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In contrast to common automated theorem proving approaches, in which the search space is a set of some formulae and what is sought is again a (goal) formula, we propose an approach based on searching for a proof (of a given length) as a whole. Namely, a proof of a formula in a fixed logical setting can be encoded as a sequence of natural numbers meeting some conditions and a suitable constraint solver can find such a sequence. The sequence can then be decoded giving a proof in the original theory language. This approach leads to several unique features, for instance, it can provide shortest proofs. In this paper, we focus on proofs in coherent logic, an expressive fragment of first-order logic, and on SAT and SMT solvers for solving sets of constraints, but the approach could be tried in other contexts as well. We implemented the proposed method and we present its features, perspectives and performances. One of the features of the implemented prover is that it can generate human understandable proofs in natural language and also machine-verifiable proofs for the interactive prover Coq.},
  archive      = {J_JAR},
  author       = {Janičić, Predrag and Narboux, Julien},
  doi          = {10.1007/s10817-022-09629-z},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {689-746},
  shortjournal = {J. Auto. Reasoning},
  title        = {Theorem proving as constraint solving with coherent logic},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Tuple interpretations for termination of term rewriting.
<em>JAR</em>, <em>66</em>(4), 667–688. (<a
href="https://doi.org/10.1007/s10817-022-09640-4">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Interpretation methods constitute a foundation of the termination analysis of term rewriting. From time to time, remarkable instances of interpretation methods appeared, such as polynomial interpretations, matrix interpretations, arctic interpretations, and their variants. In this paper, we introduce a general framework, the tuple interpretation method, that subsumes these variants as well as many previously unknown interpretation methods as instances. Employing the notion of derivers, we prove the soundness of the proposed method in an elegant way. We implement the proposed method in the termination prover NaTT and verify its significance through experiments.},
  archive      = {J_JAR},
  author       = {Yamada, Akihisa},
  doi          = {10.1007/s10817-022-09640-4},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {667-688},
  shortjournal = {J. Auto. Reasoning},
  title        = {Tuple interpretations for termination of term rewriting},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022b). Local is best: Efficient reductions to modal logic k.
<em>JAR</em>, <em>66</em>(4), 639–666. (<a
href="https://doi.org/10.1007/s10817-022-09630-6">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present novel reductions of extensions of the basic modal logic $${\textsf {K} }$$ with axioms $$\textsf {B} $$ , $$\textsf {D} $$ , $$\textsf {T} $$ , $$\textsf {4} $$ and $$\textsf {5} $$ to Separated Normal Form with Sets of Modal Levels $$\textsf {SNF} _{sml}$$ . The reductions typically result in smaller formulae than the reductions by Kracht. The reductions to $$\textsf {SNF} _{sml}$$ combined with a reduction to $$\textsf {SNF} _{ml}$$ allow us to use the local reasoning of the prover $${\text {K}_{\text {S}}}{\text {P}}$$ to determine the satisfiability of modal formulae in the considered logics. We show experimentally that the combination of our reductions with the prover $${\text {K}_{\text {S}}}{\text {P}}$$ performs well when compared with a specialised resolution calculus for these logics, the built-in reductions of the first-order prover SPASS, and the higher-order logic prover LEO-III.},
  archive      = {J_JAR},
  author       = {Papacchini, Fabio and Nalon, Cláudia and Hustadt, Ullrich and Dixon, Clare},
  doi          = {10.1007/s10817-022-09630-6},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {639-666},
  shortjournal = {J. Auto. Reasoning},
  title        = {Local is best: Efficient reductions to modal logic k},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). A formalization of dedekind domains and class groups of
global fields. <em>JAR</em>, <em>66</em>(4), 611–637. (<a
href="https://doi.org/10.1007/s10817-022-09644-0">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Dedekind domains and their class groups are notions in commutative algebra that are essential in algebraic number theory. We formalized these structures and several fundamental properties, including number-theoretic finiteness results for class groups, in the Lean prover as part of the mathlib mathematical library. This paper describes the formalization process, noting the idioms we found useful in our development and mathlib’s decentralized collaboration processes involved in this project.},
  archive      = {J_JAR},
  author       = {Baanen, Anne and Dahmen, Sander R. and Narayanan, Ashvni and Nuccio Mortarino Majno di Capriglio, Filippo A. E.},
  doi          = {10.1007/s10817-022-09644-0},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {611-637},
  shortjournal = {J. Auto. Reasoning},
  title        = {A formalization of dedekind domains and class groups of global fields},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). A mechanized proof of the max-flow min-cut theorem for
countable networks with applications to probability theory.
<em>JAR</em>, <em>66</em>(4), 585–610. (<a
href="https://doi.org/10.1007/s10817-022-09616-4">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Aharoni et al. (J Combinat Theory, Ser B 101:1–17, 2010) proved the max-flow min-cut theorem for countable networks, namely that in every countable network with finite edge capacities, there exists a flow and a cut such that the flow saturates all outgoing edges of the cut and is zero on all incoming edges. In this paper, we formalize their proof in Isabelle/HOL and thereby identify and fix several problems with their proof. We also provide a simpler proof for networks where the total outgoing capacity of all vertices other than the source and the sink is finite. This proof is based on the max-flow min-cut theorem for finite networks. As a use case, we formalize a characterization theorem for relation lifting on discrete probability distributions and two of its applications.},
  archive      = {J_JAR},
  author       = {Lochbihler, Andreas},
  doi          = {10.1007/s10817-022-09616-4},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {585-610},
  shortjournal = {J. Auto. Reasoning},
  title        = {A mechanized proof of the max-flow min-cut theorem for countable networks with applications to probability theory},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). A posthumous contribution by larry wos: Excerpts from an
unpublished column. <em>JAR</em>, <em>66</em>(4), 575–584. (<a
href="https://doi.org/10.1007/s10817-022-09617-3">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Shortly before Larry Wos passed away, he sent a manuscript for discussion to Sophie Tourret, the editor of the AAR newsletter. We present excerpts from this final manuscript, put it in its historic context and explain its relevance for today’s research in automated reasoning.},
  archive      = {J_JAR},
  author       = {Tourret, Sophie and Weidenbach, Christoph},
  doi          = {10.1007/s10817-022-09617-3},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {575-584},
  shortjournal = {J. Auto. Reasoning},
  title        = {A posthumous contribution by larry wos: Excerpts from an unpublished column},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). A wos challenge met. <em>JAR</em>, <em>66</em>(4), 565–574.
(<a href="https://doi.org/10.1007/s10817-021-09614-y">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In his regular column in the AAR Newsletter, Larry Wos typically posed challenges to the automated reasoning community. Some of these challenges concern general research objectives, but several of them concern specific problems relevant to his own experience and attempts to solve especially difficult problems, including open questions, with an automated theorem prover. This note honors Larry’s memory by working through a solution to one of these challenges.},
  archive      = {J_JAR},
  author       = {Veroff, Robert},
  doi          = {10.1007/s10817-021-09614-y},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {565-574},
  shortjournal = {J. Auto. Reasoning},
  title        = {A wos challenge met},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Making higher-order superposition work. <em>JAR</em>,
<em>66</em>(4), 541–564. (<a
href="https://doi.org/10.1007/s10817-021-09613-z">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Superposition is among the most successful calculi for first-order logic. Its extension to higher-order logic introduces new challenges such as infinitely branching inference rules, new possibilities such as reasoning about Booleans, and the need to curb the explosion of specific higher-order rules. We describe techniques that address these issues and extensively evaluate their implementation in the Zipperposition theorem prover. Largely thanks to their use, Zipperposition won the higher-order division of the CASC-J10 competition.},
  archive      = {J_JAR},
  author       = {Vukmirović, Petar and Bentkamp, Alexander and Blanchette, Jasmin and Cruanes, Simon and Nummelin, Visa and Tourret, Sophie},
  doi          = {10.1007/s10817-021-09613-z},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {541-564},
  shortjournal = {J. Auto. Reasoning},
  title        = {Making higher-order superposition work},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). A comprehensive framework for saturation theorem proving.
<em>JAR</em>, <em>66</em>(4), 499–539. (<a
href="https://doi.org/10.1007/s10817-022-09621-7">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A crucial operation of saturation theorem provers is deletion of subsumed formulas. Designers of proof calculi, however, usually discuss this only informally, and the rare formal expositions tend to be clumsy. This is because the equivalence of dynamic and static refutational completeness holds only for derivations where all deleted formulas are redundant, but the standard notion of redundancy is too weak: A clause C does not make an instance $$C\sigma $$ redundant. We present a framework for formal refutational completeness proofs of abstract provers that implement saturation calculi, such as ordered resolution and superposition. The framework modularly extends redundancy criteria derived via a familiar ground-to-nonground lifting. It allows us to extend redundancy criteria so that they cover subsumption, and also to model entire prover architectures so that the static refutational completeness of a calculus immediately implies the dynamic refutational completeness of a prover implementing the calculus within, for instance, an Otter or DISCOUNT loop. Our framework is mechanized in Isabelle/HOL.},
  archive      = {J_JAR},
  author       = {Waldmann, Uwe and Tourret, Sophie and Robillard, Simon and Blanchette, Jasmin},
  doi          = {10.1007/s10817-022-09621-7},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {499-539},
  shortjournal = {J. Auto. Reasoning},
  title        = {A comprehensive framework for saturation theorem proving},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022a). Set of support, demodulation, paramodulation: A historical
perspective. <em>JAR</em>, <em>66</em>(4), 463–497. (<a
href="https://doi.org/10.1007/s10817-022-09628-0">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This article is a tribute to the scientific legacy of automated reasoning pioneer and JAR founder Lawrence T. (Larry) Wos. Larry’s main technical contributions were the set-of-support strategy for resolution theorem proving, and the demodulation and paramodulation inference rules for building equality into resolution. Starting from the original definitions of these concepts in Larry’s papers, this survey traces their evolution, unearthing the often forgotten trails that connect Larry’s original definitions to those that became standard in the field.},
  archive      = {J_JAR},
  author       = {Bonacina, Maria Paola},
  doi          = {10.1007/s10817-022-09628-0},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {463-497},
  shortjournal = {J. Auto. Reasoning},
  title        = {Set of support, demodulation, paramodulation: A historical perspective},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Larry wos: Visions of automated reasoning. <em>JAR</em>,
<em>66</em>(4), 439–461. (<a
href="https://doi.org/10.1007/s10817-022-09620-8">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper celebrates the scientific discoveries and the service to the automated reasoning community of Lawrence (Larry) T. Wos, who passed away in August 2020. The narrative covers Larry’s most long-lasting ideas about inference rules and search strategies for theorem proving, his work on applications of theorem proving, and a collection of personal memories and anecdotes that let readers appreciate Larry’s personality and enthusiasm for automated reasoning.},
  archive      = {J_JAR},
  author       = {Beeson, Michael and Bonacina, Maria Paola and Kinyon, Michael and Sutcliffe, Geoff},
  doi          = {10.1007/s10817-022-09620-8},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {439-461},
  shortjournal = {J. Auto. Reasoning},
  title        = {Larry wos: Visions of automated reasoning},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022b). Six decades of automated reasoning: Papers in memory of
larry wos. <em>JAR</em>, <em>66</em>(4), 437–438. (<a
href="https://doi.org/10.1007/s10817-022-09637-z">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_JAR},
  author       = {Bonacina, Maria Paola},
  doi          = {10.1007/s10817-022-09637-z},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {437-438},
  shortjournal = {J. Auto. Reasoning},
  title        = {Six decades of automated reasoning: Papers in memory of larry wos},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Combination of uniform interpolants via beth definability.
<em>JAR</em>, <em>66</em>(3), 409–435. (<a
href="https://doi.org/10.1007/s10817-022-09627-1">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Uniform interpolants were largely studied in non-classical propositional logics since the nineties, and their connection to model completeness was pointed out in the literature. A successive parallel research line inside the automated reasoning community investigated uniform quantifier-free interpolants (sometimes referred to as “covers”) in first-order theories. In this paper, we investigate cover transfer to theory combinations in the disjoint signatures case. We prove that, for convex theories, cover algorithms can be transferred to theory combinations under the same hypothesis needed to transfer quantifier-free interpolation (i.e., the equality interpolating property, aka strong amalgamation property). The key feature of our algorithm relies on the extensive usage of the Beth definability property for primitive fragments to convert implicitly defined variables into their explicitly defining terms. In the non-convex case, we show by a counterexample that covers may not exist in the combined theories, even in case combined quantifier-free interpolants do exist. However, we exhibit a cover transfer algorithm operating also in the non-convex case for special kinds of theory combinations; these combinations (called ‘tame combinations’) concern multi-sorted theories arising in many model-checking applications (in particular, the ones oriented to verification of data-aware processes).},
  archive      = {J_JAR},
  author       = {Calvanese, Diego and Ghilardi, Silvio and Gianola, Alessandro and Montali, Marco and Rivkin, Andrey},
  doi          = {10.1007/s10817-022-09627-1},
  journal      = {Journal of Automated Reasoning},
  number       = {3},
  pages        = {409-435},
  shortjournal = {J. Auto. Reasoning},
  title        = {Combination of uniform interpolants via beth definability},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Using model theory to find decidable and tractable
description logics with concrete domains. <em>JAR</em>, <em>66</em>(3),
357–407. (<a href="https://doi.org/10.1007/s10817-022-09626-2">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Concrete domains have been introduced in the area of Description Logic to enable reference to concrete objects (such as numbers) and predefined predicates on these objects (such as numerical comparisons) when defining concepts. Unfortunately, in the presence of general concept inclusions (GCIs), which are supported by all modern DL systems, adding concrete domains may easily lead to undecidability. To regain decidability of the DL $$\mathcal {ALC}$$ in the presence of GCIs, quite strong restrictions, in sum called $$\omega $$ -admissibility, were imposed on the concrete domain. On the one hand, we generalize the notion of $$\omega $$ -admissibility from concrete domains with only binary predicates to concrete domains with predicates of arbitrary arity. On the other hand, we relate $$\omega $$ -admissibility to well-known notions from model theory. In particular, we show that finitely bounded homogeneous structures yield $$\omega $$ -admissible concrete domains. This allows us to show $$\omega $$ -admissibility of concrete domains using existing results from model theory. When integrating concrete domains into lightweight DLs of the $$\mathcal {EL}$$ family, achieving decidability is not enough. One wants reasoning in the resulting DL to be tractable. This can be achieved by using so-called p-admissible concrete domains and restricting the interaction between the DL and the concrete domain. We investigate p-admissibility from an algebraic point of view. Again, this yields strong algebraic tools for demonstrating p-admissibility. In particular, we obtain an expressive numerical p-admissible concrete domain based on the rational numbers. Although $$\omega $$ -admissibility and p-admissibility are orthogonal conditions that are almost exclusive, our algebraic characterizations of these two properties allow us to locate an infinite class of p-admissible concrete domains whose integration into $$\mathcal {ALC}$$ yields decidable DLs.},
  archive      = {J_JAR},
  author       = {Baader, Franz and Rydval, Jakub},
  doi          = {10.1007/s10817-022-09626-2},
  journal      = {Journal of Automated Reasoning},
  number       = {3},
  pages        = {357-407},
  shortjournal = {J. Auto. Reasoning},
  title        = {Using model theory to find decidable and tractable description logics with concrete domains},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Polite combination of algebraic datatypes. <em>JAR</em>,
<em>66</em>(3), 331–355. (<a
href="https://doi.org/10.1007/s10817-022-09625-3">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Algebraic datatypes, and among them lists and trees, have attracted a lot of interest in automated reasoning and Satisfiability Modulo Theories (SMT). Since its latest stable version, the SMT-LIB standard defines a theory of algebraic datatypes, which is currently supported by several mainstream SMT solvers. In this paper, we study this particular theory of datatypes and prove that it is strongly polite, showing how it can be combined with other arbitrary disjoint theories using polite combination. The combination method uses a new, simple, and natural notion of additivity that enables deducing strong politeness from (weak) politeness.},
  archive      = {J_JAR},
  author       = {Sheng, Ying and Zohar, Yoni and Ringeissen, Christophe and Lange, Jane and Fontaine, Pascal and Barrett, Clark},
  doi          = {10.1007/s10817-022-09625-3},
  journal      = {Journal of Automated Reasoning},
  number       = {3},
  pages        = {331-355},
  shortjournal = {J. Auto. Reasoning},
  title        = {Polite combination of algebraic datatypes},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Deciding the word problem for ground and strongly shallow
identities w.r.t. Extensional symbols. <em>JAR</em>, <em>66</em>(3),
301–329. (<a href="https://doi.org/10.1007/s10817-022-09624-4">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The word problem for a finite set of ground identities is known to be decidable in polynomial time using congruence closure, and this is also the case if some of the function symbols are assumed to be commutative or defined by certain shallow identities, called strongly shallow. We show that decidability in P is preserved if we add the assumption that certain function symbols f are extensional in the sense that $$f(s_1,\ldots ,s_n) \mathrel {\approx }f(t_1,\ldots ,t_n)$$ implies $$s_1 \mathrel {\approx }t_1,\ldots ,s_n \mathrel {\approx }t_n$$ . In addition, we investigate a variant of extensionality that is more appropriate for commutative function symbols, but which raises the complexity of the word problem to coNP.},
  archive      = {J_JAR},
  author       = {Baader, Franz and Kapur, Deepak},
  doi          = {10.1007/s10817-022-09624-4},
  journal      = {Journal of Automated Reasoning},
  number       = {3},
  pages        = {301-329},
  shortjournal = {J. Auto. Reasoning},
  title        = {Deciding the word problem for ground and strongly shallow identities w.r.t. extensional symbols},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). The resolution of keller’s conjecture. <em>JAR</em>,
<em>66</em>(3), 277–300. (<a
href="https://doi.org/10.1007/s10817-022-09623-5">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider three graphs, $$G_{7,3}$$ , $$G_{7,4}$$ , and $$G_{7,6}$$ , related to Keller’s conjecture in dimension 7. The conjecture is false for this dimension if and only if at least one of the graphs contains a clique of size $$2^7 = 128$$ . We present an automated method to solve this conjecture by encoding the existence of such a clique as a propositional formula. We apply satisfiability solving combined with symmetry-breaking techniques to determine that no such clique exists. This result implies that every unit cube tiling of $$\mathbb {R}^7$$ contains a facesharing pair of cubes. Since a faceshare-free unit cube tiling of $$\mathbb {R}^8$$ exists (which we also verify), this completely resolves Keller’s conjecture.},
  archive      = {J_JAR},
  author       = {Brakensiek, Joshua and Heule, Marijn and Mackey, John and Narváez, David},
  doi          = {10.1007/s10817-022-09623-5},
  journal      = {Journal of Automated Reasoning},
  number       = {3},
  pages        = {277-300},
  shortjournal = {J. Auto. Reasoning},
  title        = {The resolution of keller’s conjecture},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Special issue of selected extended papers of IJCAR 2020.
<em>JAR</em>, <em>66</em>(3), 275–276. (<a
href="https://doi.org/10.1007/s10817-022-09622-6">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_JAR},
  author       = {Peltier, Nicolas and Sofronie-Stokkermans, Viorica},
  doi          = {10.1007/s10817-022-09622-6},
  journal      = {Journal of Automated Reasoning},
  number       = {3},
  pages        = {275-276},
  shortjournal = {J. Auto. Reasoning},
  title        = {Special issue of selected extended papers of IJCAR 2020},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Analyzing read-once cutting plane proofs in horn systems.
<em>JAR</em>, <em>66</em>(2), 239–274. (<a
href="https://doi.org/10.1007/s10817-022-09618-2">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we investigate variants of cutting plane proof systems for a class of integer programs called Horn constraint systems (HCS). Briefly, a system of linear inequalities $$\mathbf{A \cdot x \ge b}$$ is called a Horn constraint system, if each entry in $$\mathbf{A}$$ belongs to the set $${0,1,-1}$$ and furthermore there is at most one positive entry per row. Our focus is on deriving refutations, i.e., proofs of unsatisfiability of such programs in variants of the cutting plane proof system. Horn systems generalize Horn formulas, i.e., CNF formulas with at most one positive literal per clause. A Horn system which results from rewriting a Horn clausal formula is called a Horn clausal constraint system (HClCS). The cutting plane calculus (CP) is a well-known calculus for deciding the unsatisfiability of propositional CNF formulas and integer programs. Usually, CP consists of the addition rule (ADD) and the division rule (DIV). We show that the cutting plane calculus with the addition rule only (CP-ADD) does not require constraints of the form $$0 \le x_i \le 1$$ . We also investigate the existence of read-once refutations in Horn clausal constraint systems in the cutting plane proof system. We show that read-once refutations are incomplete. We show that the problem of finding a read-once refutation using only the ADD rule of an HCS is NP-hard even when the right-hand sides of the HCS belong to the set $${0,1}$$ . Additionally, we show that the problem of finding a read-once refutation using only the ADD rule of an HClCS is NP-hard. We then show that these problems remain hard when we can use both the ADD and DIV rules. We then show that the problem of finding a shortest read-once refutation of an HCS whose right-hand sides belong to the set $${0,1}$$ is NPO BP-complete when the refutation can use only the ADD rule or the refutation can use both the ADD and DIV rules. Finally, we provide a parameterized exponential time algorithm for finding a read-once refutation of a system of Horn constraints using only the ADD rule.},
  archive      = {J_JAR},
  author       = {Wojciechowski, Piotr and Subramani, K. and Chandrasekaran, R.},
  doi          = {10.1007/s10817-022-09618-2},
  journal      = {Journal of Automated Reasoning},
  number       = {2},
  pages        = {239-274},
  shortjournal = {J. Auto. Reasoning},
  title        = {Analyzing read-once cutting plane proofs in horn systems},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). A bi-directional extensible interface between lean and
mathematica. <em>JAR</em>, <em>66</em>(2), 215–238. (<a
href="https://doi.org/10.1007/s10817-021-09611-1">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We implement a user-extensible ad hoc connection between the Lean proof assistant and the computer algebra system Mathematica. By reflecting the syntax of each system in the other and providing a flexible interface for extending translation, our connection allows for the exchange of arbitrary information between the two systems. We show how to make use of the Lean metaprogramming framework to verify certain Mathematica computations, so that the rigor of the proof assistant is not compromised. We also use Mathematica as an untrusted oracle to guide proof search in the proof assistant and interact with a Mathematica notebook from within a Lean session. In the other direction, we import and process Lean declarations from within Mathematica. The proof assistant library serves as a database of mathematical knowledge that the CAS can display and explore.},
  archive      = {J_JAR},
  author       = {Lewis, Robert Y. and Wu, Minchao},
  doi          = {10.1007/s10817-021-09611-1},
  journal      = {Journal of Automated Reasoning},
  number       = {2},
  pages        = {215-238},
  shortjournal = {J. Auto. Reasoning},
  title        = {A bi-directional extensible interface between lean and mathematica},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). A coq formalization of lebesgue integration of nonnegative
functions. <em>JAR</em>, <em>66</em>(2), 175–213. (<a
href="https://doi.org/10.1007/s10817-021-09612-0">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Integration, just as much as differentiation, is a fundamental calculus tool that is widely used in many scientific domains. Formalizing the mathematical concept of integration and the associated results in a formal proof assistant helps in providing the highest confidence on the correctness of numerical programs involving the use of integration, directly or indirectly. By its capability to extend the (Riemann) integral to a wide class of irregular functions, and to functions defined on more general spaces than the real line, the Lebesgue integral is perfectly suited for use in mathematical fields such as probability theory, numerical mathematics, and real analysis. In this article, we present the Coq formalization of $$\sigma $$ -algebras, measures, simple functions, and integration of nonnegative measurable functions, up to the full formal proofs of the Beppo Levi (monotone convergence) theorem and Fatou’s lemma. More than a plain formalization of the known literature, we present several design choices made to balance the harmony between mathematical readability and usability of Coq theorems. These results are a first milestone toward the formalization of $$L^p$$ spaces such as Banach spaces.},
  archive      = {J_JAR},
  author       = {Boldo, Sylvie and Clément, François and Faissole, Florian and Martin, Vincent and Mayero, Micaela},
  doi          = {10.1007/s10817-021-09612-0},
  journal      = {Journal of Automated Reasoning},
  number       = {2},
  pages        = {175-213},
  shortjournal = {J. Auto. Reasoning},
  title        = {A coq formalization of lebesgue integration of nonnegative functions},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Correction to: Differential dynamic logic for hybrid
systems. <em>JAR</em>, <em>66</em>(1), 173. (<a
href="https://doi.org/10.1007/s10817-021-09608-w">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_JAR},
  author       = {Platzer, André},
  doi          = {10.1007/s10817-021-09608-w},
  journal      = {Journal of Automated Reasoning},
  number       = {1},
  pages        = {173},
  shortjournal = {J. Auto. Reasoning},
  title        = {Correction to: Differential dynamic logic for hybrid systems},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Integrating owicki–gries for c11-style memory models into
isabelle/HOL. <em>JAR</em>, <em>66</em>(1), 141–171. (<a
href="https://doi.org/10.1007/s10817-021-09610-2">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Weak memory presents a new challenge for program verification and has resulted in the development of a variety of specialised logics. For C11-style memory models, our previous work has shown that it is possible to extend Hoare logic and Owicki–Gries reasoning to verify correctness of weak memory programs. The technique introduces a set of high-level assertions over C11 states together with a set of basic Hoare-style axioms over atomic weak memory statements (e.g. reads/writes), but retains all other standard proof obligations for compound statements. This paper takes this line of work further by introducing the first deductive verification environment in Isabelle/HOL for C11-like weak memory programs. This verification environment is built on the Nipkow and Nieto’s encoding of Owicki–Gries in the Isabelle theorem prover. We exemplify our techniques over several litmus tests from the literature and two non-trivial examples: Peterson’s algorithm and a read–copy–update algorithm adapted for C11. For the examples we consider, the proof outlines can be automatically discharged using the existing Isabelle tactics developed by Nipkow and Nieto. The benefit here is that programs can be written using a familiar pseudocode syntax with assertions embedded directly into the program.},
  archive      = {J_JAR},
  author       = {Dalvandi, Sadegh and Dongol, Brijesh and Doherty, Simon and Wehrheim, Heike},
  doi          = {10.1007/s10817-021-09610-2},
  journal      = {Journal of Automated Reasoning},
  number       = {1},
  pages        = {141-171},
  shortjournal = {J. Auto. Reasoning},
  title        = {Integrating Owicki–Gries for c11-style memory models into Isabelle/HOL},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Predicate transformer semantics for hybrid systems.
<em>JAR</em>, <em>66</em>(1), 93–139. (<a
href="https://doi.org/10.1007/s10817-021-09607-x">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present a semantic framework for the deductive verification of hybrid systems with Isabelle/HOL. It supports reasoning about the temporal evolutions of hybrid programs in the style of differential dynamic logic modelled by flows or invariant sets for vector fields. We introduce the semantic foundations of this framework and summarise their Isabelle formalisation as well as the resulting verification components. A series of simple examples shows our approach at work.},
  archive      = {J_JAR},
  author       = {Huerta y Munive, Jonathan Julián and Struth, Georg},
  doi          = {10.1007/s10817-021-09607-x},
  journal      = {Journal of Automated Reasoning},
  number       = {1},
  pages        = {93-139},
  shortjournal = {J. Auto. Reasoning},
  title        = {Predicate transformer semantics for hybrid systems},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Conflict-driven satisfiability for theory combination:
Lemmas, modules, and proofs. <em>JAR</em>, <em>66</em>(1), 43–91. (<a
href="https://doi.org/10.1007/s10817-021-09606-y">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Search-based satisfiability procedures try to build a model of the input formula by simultaneously proposing candidate models and deriving new formulae implied by the input. Conflict-driven procedures perform non-trivial inferences only when resolving conflicts between formulæ and assignments representing the candidate model. CDSAT (Conflict-Driven SATisfiability) is a method for conflict-driven reasoning in unions of theories. It combines inference systems for individual theories as theory modules within a solver for the union of the theories. This article augments CDSAT with a more general lemma learning capability and with proof generation. Furthermore, theory modules for several theories of practical interest are shown to fulfill the requirements for completeness and termination of CDSAT. Proof generation is accomplished by a proof-carrying version of the CDSAT transition system that produces proof objects in memory accommodating multiple proof formats. Alternatively, one can apply to CDSAT the LCF approach to proofs from interactive theorem proving, by defining a kernel of reasoning primitives that guarantees the correctness by construction of CDSAT proofs.},
  archive      = {J_JAR},
  author       = {Bonacina, Maria Paola and Graham-Lengrand, Stéphane and Shankar, Natarajan},
  doi          = {10.1007/s10817-021-09606-y},
  journal      = {Journal of Automated Reasoning},
  number       = {1},
  pages        = {43-91},
  shortjournal = {J. Auto. Reasoning},
  title        = {Conflict-driven satisfiability for theory combination: Lemmas, modules, and proofs},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Proof complexity of modal resolution. <em>JAR</em>,
<em>66</em>(1), 1–41. (<a
href="https://doi.org/10.1007/s10817-021-09609-9">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We investigate the proof complexity of modal resolution systems developed by Nalon and Dixon (J Algorithms 62(3–4):117–134, 2007) and Nalon et al. (in: Automated reasoning with analytic Tableaux and related methods—24th international conference, (TABLEAUX’15), pp 185–200, 2015), which form the basis of modal theorem proving (Nalon et al., in: Proceedings of the twenty-sixth international joint conference on artificial intelligence (IJCAI’17), pp 4919–4923, 2017). We complement these calculi by a new tighter variant and show that proofs can be efficiently translated between all these variants, meaning that the calculi are equivalent from a proof complexity perspective. We then develop the first lower bound technique for modal resolution using Prover–Delayer games, which can be used to establish “genuine” modal lower bounds for size of dag-like modal resolution proofs. We illustrate the technique by devising a new modal pigeonhole principle, which we demonstrate to require exponential-size proofs in modal resolution. Finally, we compare modal resolution to the modal Frege systems of Hrubeš (Ann Pure Appl Log 157(2–3):194–205, 2009) and obtain a “genuinely” modal separation.},
  archive      = {J_JAR},
  author       = {Sigley, Sarah and Beyersdorff, Olaf},
  doi          = {10.1007/s10817-021-09609-9},
  journal      = {Journal of Automated Reasoning},
  number       = {1},
  pages        = {1-41},
  shortjournal = {J. Auto. Reasoning},
  title        = {Proof complexity of modal resolution},
  volume       = {66},
  year         = {2022},
}
</textarea>
</details></li>
</ul>

</body>
</html>
