<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>IANDC_complex_beauty</title>
  <style>
    html {font-size: 22px;}
    body {margin: 0 auto; max-width: 76em;}
    #copyID {font-size: 18px;}
  </style>
  <script>
    function copy(element) {
      if (element.type == "button"){
      element.type="text";
      }
      element.style.color="black";
      element.style.backgroundColor="#C7EDCC";
      element.select();
      element.setSelectionRange(0, 99999);
      navigator.clipboard.writeText(element.value);
      window.getSelection().removeAllRanges();
      element.type="button";
    }
  </script>
</head>
<body>

<h2 id="iandc---158">IANDC - 158</h2>
<ul>
<li><details>
<summary>
(2022). Learning residual alternating automata. <em>IANDC</em>,
<em>289</em>, 104981. (<a
href="https://doi.org/10.1016/j.ic.2022.104981">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Residuality plays an essential role for learning finite automata . While residual deterministic and nondeterministic automata have been understood quite well, fundamental questions concerning alternating automata (AFA) remain open. Recently, Angluin, Eisenstat, and Fisman (2015) have initiated a systematic study of residual AFAs and proposed an algorithm called AL⋆ – an extension of the popular L⋆ algorithm – to learn AFAs. Based on computer experiments they conjectured that AL⋆ produces residual AFAs, but have not been able to give a proof. In this paper we disprove this conjecture by constructing a counterexample . As our main positive result we design an efficient learning algorithm, named AL⋆⋆ , and give a proof that it outputs residual AFAs only. In addition, we investigate the succinctness of these different finite automata (FA) types in more detail.},
  archive      = {J_IANDC},
  author       = {Sebastian Berndt and Maciej Liśkiewicz and Matthias Lutter and Rüdiger Reischuk},
  doi          = {10.1016/j.ic.2022.104981},
  journal      = {Information and Computation},
  pages        = {104981},
  shortjournal = {Inf. Comput.},
  title        = {Learning residual alternating automata},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Special issue: Selected papers of the 11th international
symposium on games, automata, logics, and formal verification (GandALF
2020). <em>IANDC</em>, <em>289</em>, 104980. (<a
href="https://doi.org/10.1016/j.ic.2022.104980">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_IANDC},
  author       = {Jean-François Raskin and Davide Bresolin},
  doi          = {10.1016/j.ic.2022.104980},
  journal      = {Information and Computation},
  pages        = {104980},
  shortjournal = {Inf. Comput.},
  title        = {Special issue: Selected papers of the 11th international symposium on games, automata, logics, and formal verification (GandALF 2020)},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Special issue: Formal verification of cyber-physical
systems. <em>IANDC</em>, <em>289</em>, 104979. (<a
href="https://doi.org/10.1016/j.ic.2022.104979">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_IANDC},
  author       = {Luca Geretti ( Guest Editor ) and Alessandro Abate ( Guest Editor ) and Pierluigi Nuzzo ( Guest Editor ) and Tiziano Villa ( Guest Editor )},
  doi          = {10.1016/j.ic.2022.104979},
  journal      = {Information and Computation},
  pages        = {104979},
  shortjournal = {Inf. Comput.},
  title        = {Special issue: Formal verification of cyber-physical systems},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Model checking hyperproperties for markov decision
processes. <em>IANDC</em>, <em>289</em>, 104978. (<a
href="https://doi.org/10.1016/j.ic.2022.104978">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the problem of formalizing and checking probabilistic hyperproperties for Markov decision processes (MDPs). We introduce the temporal logic HyperPCTL that allows explicit and simultaneous quantification over schedulers as well as probabilistic computation trees. We show that the logic can express important quantitative requirements in security and privacy such as probabilistic noninterference, differential privacy , timing side-channel countermeasures, and probabilistic conformance testing. We show that HyperPCTL model checking over MDPs is in general undecidable, but restricting the domain of scheduler quantification to memoryless non-probabilistic schedulers turns the model checking problem decidable. Subsequently, we propose an SMT-based encoding for model checking this language. Finally, we demonstrate the applicability of our method by providing experimental results for verification, and we show how it can be used to solve even certain synthesis problems .},
  archive      = {J_IANDC},
  author       = {Oyendrila Dobe and Erika Ábrahám and Ezio Bartocci and Borzoo Bonakdarpour},
  doi          = {10.1016/j.ic.2022.104978},
  journal      = {Information and Computation},
  pages        = {104978},
  shortjournal = {Inf. Comput.},
  title        = {Model checking hyperproperties for markov decision processes},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). LTL falsification in infinite-state systems. <em>IANDC</em>,
<em>289</em>, 104977. (<a
href="https://doi.org/10.1016/j.ic.2022.104977">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In finite-state systems, if an LTL property is false, there is always a counterexample path (i.e. a witness) for it which is ultimately periodic (i.e. in a lasso-shaped form). When dealing with infinite-state systems, this is no longer the case. In this work, we address this issue by proposing an automatic approach that presents witnesses in an indirect way. The approach is based on two key insights. First, we leverage the notion of well-founded funnel , where a ranking function ensures that the states in the source set are guaranteed to inevitably reach the destination set. We show that, under suitable conditions, a sequence of funnels ensures the existence of a fair path. Second, we adopt a compositional approach to partition the original system into projections and to prove that they result in a non-empty under-approximation of the original system that only contains fair paths. Then, we propose an algorithm that, working in an abstract space induced by a set of predicates, identifies candidate funnels, proves their well-foundedness, and searches for a sequencing order. We experimentally evaluate the approach on examples taken from software, timed and hybrid systems, showing its wide applicability and expressiveness, with an implementation that outperforms various competitor tools.},
  archive      = {J_IANDC},
  author       = {Alessandro Cimatti and Alberto Griggio and Enrico Magnago},
  doi          = {10.1016/j.ic.2022.104977},
  journal      = {Information and Computation},
  pages        = {104977},
  shortjournal = {Inf. Comput.},
  title        = {LTL falsification in infinite-state systems},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). A pumping lemma for regular closure of prefix-free
languages. <em>IANDC</em>, <em>289</em>, 104976. (<a
href="https://doi.org/10.1016/j.ic.2022.104976">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Let Σ be an infinite set of distinct symbols. Let ⁎ P F L ⊆ P o w e r ( Σ ⁎ ) PFL⊆Power(Σ⁎) be the set of all prefix-free languages. For ⁎ N ⊆ P o w e r ( Σ ⁎ ) N⊆Power(Σ⁎) , let Γ R E G ( N ) ΓREG(N) be the regular closure of N N , i.e., let Γ R E G ( N ) ΓREG(N) be the smallest set such that N ⊆ Γ R E G ( N ) N⊆ΓREG(N) and L 1 ∪ L 2 L1∪L2 , L 1 L 2 L1L2 , ⁎ L 1 ⁎ L1⁎ ∈ Γ R E G ( N ) ∈ΓREG(N) for any L 1 , L 2 ∈ Γ R E G ( N ) L1,L2∈ΓREG(N) . In this paper, we provide a pumping lemma for Γ R E G ( P F L ) ΓREG(PFL) . This lemma enables us to prove that some languages do not belong to Γ R E G ( P F L ) ΓREG(PFL) . It is notable that we immediately obtain a pumping lemma for Γ R E G ( D C F L ) ΓREG(DCFL) as a corollary, due to the known fact that Γ R E G ( D C F L ) = Γ R E G ( D C F L ∩ P F L ) ΓREG(DCFL)=ΓREG(DCFL∩PFL) , where we define D C F L DCFL as D C F L : = ∪ Σ 0 D C F L ( Σ 0 ) DCFL:=∪Σ0DCFL(Σ0) with the union taken over all non-empty finite set Σ 0 ⊆ Σ Σ0⊆Σ , and D C F L ( Σ 0 ) DCFL(Σ0) is the family of all ⁎ L ⊆ Σ 0 ⁎ L⊆Σ0⁎ such that L is accepted by a deterministic pushdown automaton over Σ 0 Σ0 by final state.},
  archive      = {J_IANDC},
  author       = {Toshihiro Koga},
  doi          = {10.1016/j.ic.2022.104976},
  journal      = {Information and Computation},
  pages        = {104976},
  shortjournal = {Inf. Comput.},
  title        = {A pumping lemma for regular closure of prefix-free languages},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Deterministic algorithms for the hidden subgroup problem.
<em>IANDC</em>, <em>289</em>, 104975. (<a
href="https://doi.org/10.1016/j.ic.2022.104975">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The hidden subgroup problem ( HSP HSP ) plays a crucial role in the field of quantum computing , since several celebrated quantum algorithms including Shor&#39;s algorithm have a uniform description in the framework of HSP HSP . The problem is as follows: for a finite group G and a finite set X , given a function f : G → X f:G→X and the promise that for any g 1 , g 2 ∈ G , f ( g 1 ) = f ( g 2 ) g1,g2∈G,f(g1)=f(g2) iff g 1 H = g 2 H g1H=g2H for a subgroup H ≤ G H≤G , the goal of the decision version is to determine whether H is trivial, and the goal of the search version is to find H . Nayak (2021) asked whether there exist deterministic algorithms with O ( | G | | H | ) O(|G||H|) query complexity for HSP HSP . We answer this problem for Abelian groups , which also extends the main results of Ye et al. (2021), since here the algorithms do not rely on any prior knowledge of H .},
  archive      = {J_IANDC},
  author       = {Zekun Ye and Lvzhou Li},
  doi          = {10.1016/j.ic.2022.104975},
  journal      = {Information and Computation},
  pages        = {104975},
  shortjournal = {Inf. Comput.},
  title        = {Deterministic algorithms for the hidden subgroup problem},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Encoding inductive invariants as barrier certificates:
Synthesis via difference-of-convex programming. <em>IANDC</em>,
<em>289</em>, 104965. (<a
href="https://doi.org/10.1016/j.ic.2022.104965">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present the invariant barrier-certificate condition that witnesses unbounded-time safety of differential dynamical systems . The proposed condition is the weakest possible one to attain inductive invariance. We show that discharging the invariant barrier-certificate condition —thereby synthesizing invariant barrier certificates— can be encoded as solving an optimization problem subject to bilinear matrix inequalities (BMIs). We further propose a synthesis algorithm based on difference-of-convex programming, which approaches a local optimum of the BMI problem via solving a series of convex optimization problems . This algorithm is incorporated in a branch-and-bound framework that searches for the global optimum in a divide-and-conquer fashion. We present a weak completeness result of our method, namely, a barrier certificate is guaranteed to be found (under some mild assumptions) whenever there exists an inductive invariant (in the form of a given template) that suffices to certify safety. Experimental results on benchmarks demonstrate the effectiveness and efficiency of our approach.},
  archive      = {J_IANDC},
  author       = {Qiuye Wang and Mingshuai Chen and Bai Xue and Naijun Zhan and Joost-Pieter Katoen},
  doi          = {10.1016/j.ic.2022.104965},
  journal      = {Information and Computation},
  pages        = {104965},
  shortjournal = {Inf. Comput.},
  title        = {Encoding inductive invariants as barrier certificates: Synthesis via difference-of-convex programming},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). A robust class of linear recurrence sequences.
<em>IANDC</em>, <em>289</em>, 104964. (<a
href="https://doi.org/10.1016/j.ic.2022.104964">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce a subclass of linear recurrence sequences which we call poly-rational sequences because they are denoted by rational expressions closed under sum and product. We show that this class is robust by giving several characterisations: polynomially ambiguous weighted automata , copyless cost-register automata , rational formal series, and linear recurrence sequences whose eigenvalues are roots of rational numbers.},
  archive      = {J_IANDC},
  author       = {Corentin Barloy and Nathanaël Fijalkow and Nathan Lhote and Filip Mazowiecki},
  doi          = {10.1016/j.ic.2022.104964},
  journal      = {Information and Computation},
  pages        = {104964},
  shortjournal = {Inf. Comput.},
  title        = {A robust class of linear recurrence sequences},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Local higher-order fixpoint iteration. <em>IANDC</em>,
<em>289</em>, 104963. (<a
href="https://doi.org/10.1016/j.ic.2022.104963">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Local fixpoint iteration describes a technique that restricts fixpoint iteration in function spaces to needed arguments only. It has been studied well for first-order functions in abstract interpretation and also in model checking. Here we consider the problem for least and greatest fixpoints of arbitrary type order . We define an abstract algebra of simply-typed higher-order functions with fixpoints in order to express fixpoint evaluation problems as they occur routinely in various applications, including program verification . We present an algorithm that realises local fixpoint iteration for such higher-order fixpoints, prove its correctness and study its optimisation potential in the context of several applications. We also examine a particular fragment of this higher-order fixpoint algebra which allows us to pre-compute needed arguments, as this may help to speed up the fixpoint iteration process .},
  archive      = {J_IANDC},
  author       = {Florian Bruse and Jörg Kreiker and Martin Lange and Marco Sälzer},
  doi          = {10.1016/j.ic.2022.104963},
  journal      = {Information and Computation},
  pages        = {104963},
  shortjournal = {Inf. Comput.},
  title        = {Local higher-order fixpoint iteration},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Distributed localization of wireless sensor network using
communication wheel. <em>IANDC</em>, <em>289</em>, 104962. (<a
href="https://doi.org/10.1016/j.ic.2022.104962">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the network localization problem , i.e., the problem of determining node positions of a wireless sensor network modeled as a unit disk graph. In an arbitrarily deployed network, positions of all nodes of the network may not be uniquely determined. Computational complexity results suggest that even if the network corresponds to a unique solution , a polynomial-time algorithm is unlikely to exist. So we are interested in algorithms that efficiently localize the network partially. A widely used technique that can efficiently localize a uniquely localizable portion of the network is trilateration : starting from three anchors (nodes with known positions), nodes having at least three localized neighbors are sequentially localized. However, the performance of trilateration can substantially differ for different choices of the initial three anchors. In this paper, we propose a distributed localization scheme with a theoretical characterization of nodes that are guaranteed to be localized. In particular, our proposed distributed algorithm starts localization from a strongly interior node and provided that the subgraph induced by the strongly interior nodes is connected, it localizes all nodes of the network except some boundary nodes and isolated weakly interior nodes .},
  archive      = {J_IANDC},
  author       = {Kaustav Bose and Manash Kumar Kundu and Ranendu Adhikary and Buddhadeb Sau},
  doi          = {10.1016/j.ic.2022.104962},
  journal      = {Information and Computation},
  pages        = {104962},
  shortjournal = {Inf. Comput.},
  title        = {Distributed localization of wireless sensor network using communication wheel},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Combination of roots and boolean operations: An application
to state complexity. <em>IANDC</em>, <em>289</em>, 104961. (<a
href="https://doi.org/10.1016/j.ic.2022.104961">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Operations on regular languages that commute with any inverse alphabetic morphism are called 1-uniform transformations. In a previous work we have shown that these operations are encoded by operations on automata , called modifiers, that can be described in terms of functions acting on monoids of transformations. We study the special case where these functions are morphisms and show that the encoded operations are compositions of roots and boolean operations. We first show that there is a bijection between these operations and subsets of eventually periodic sequences of boolean values. We then deduce a tight bound for the state complexity of these operations.},
  archive      = {J_IANDC},
  author       = {Pascal Caron and Edwin Hamel-de le Court and Jean-Gabriel Luque},
  doi          = {10.1016/j.ic.2022.104961},
  journal      = {Information and Computation},
  pages        = {104961},
  shortjournal = {Inf. Comput.},
  title        = {Combination of roots and boolean operations: An application to state complexity},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Efficient and competitive broadcast in multi-channel radio
networks. <em>IANDC</em>, <em>289</em>, 104960. (<a
href="https://doi.org/10.1016/j.ic.2022.104960">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Consider a single-hop, multi-channel, synchronous radio network in which a source node needs to disseminate a message to all other n − 1 n−1 nodes. An adversary called Eve, which captures environmental noise and potentially malicious interference, aims to disrupt this process via jamming. Assume sending, listening, or jamming on one channel for one time slot costs one unit of energy. The question is, if Eve spends T units of energy on jamming, can we devise broadcast algorithms in which each node&#39;s cost is o ( T ) o(T) ? Previous results show such resource competitive algorithms do exist in the single-channel setting: for large T values, each node can receive the message within O ( T ) O(T) time slots while spending only O ˜ ( T / n ) O˜(T/n) energy. In this work, we devise new broadcast algorithms and show that the existence of multiple channels allows faster message dissemination while preserving resource competitiveness. Specifically, if C channels are available, for large T values, our algorithms guarantee each node&#39;s runtime is O ( T / C ) O(T/C) , and each node&#39;s energy cost is O ˜ ( T / n ) O˜(T/n) . Moreover, our algorithms require minimal prior knowledge and allow Eve to be adaptive. Our technical contributions lie in using “epidemic broadcast” in algorithm design to achieve time efficiency and resource competitiveness, and employing coupling techniques in the analysis to handle the adaptivity of the adversary. We also complement algorithmic results with lower bounds, proving both the time complexity and the energy complexity of our algorithms are optimal or near-optimal. In particular, to obtain the lower bound on resource competitiveness, we first prove a new lower bound showing any multi-channel 1-to-1 communication algorithm succeeding with constant probability incurs expected cost of at least Ω ( T ) Ω(T) ; then, via simulation and reduction arguments, we show for the broadcast problem, some node incurs a cost of at least Ω ( T / n ) Ω(T/n) , even in the multi-channel setting.},
  archive      = {J_IANDC},
  author       = {Haimin Chen and Chaodong Zheng},
  doi          = {10.1016/j.ic.2022.104960},
  journal      = {Information and Computation},
  pages        = {104960},
  shortjournal = {Inf. Comput.},
  title        = {Efficient and competitive broadcast in multi-channel radio networks},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Distance labeling schemes for k4-free bridged graphs.
<em>IANDC</em>, <em>289</em>, 104959. (<a
href="https://doi.org/10.1016/j.ic.2022.104959">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {k -Approximate distance labeling schemes are schemes that label the vertices of a graph with short labels in such a way that the k -approximation of the distance between any two vertices u and v can be determined efficiently by merely inspecting the labels of u and v , without using any other information. One of the important problems is finding natural classes of graphs admitting exact or approximate distance labeling schemes with labels of polylogarithmic size. In this paper, we describe a 4-approximate distance labeling scheme for the class of K 4 K4 -free bridged graphs. This scheme uses labels of poly-logarithmic length O ( log ⁡ n 3 ) O(log⁡n3) allowing a constant decoding time. Given the labels of two vertices u and v , the decoding function returns a value between the exact distance d G ( u , v ) dG(u,v) and its quadruple 4 d G ( u , v ) 4dG(u,v) .},
  archive      = {J_IANDC},
  author       = {Victor Chepoi and Arnaud Labourel and Sébastien Ratel},
  doi          = {10.1016/j.ic.2022.104959},
  journal      = {Information and Computation},
  pages        = {104959},
  shortjournal = {Inf. Comput.},
  title        = {Distance labeling schemes for k4-free bridged graphs},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Bounded complete domains and their logical form.
<em>IANDC</em>, <em>289</em>, 104958. (<a
href="https://doi.org/10.1016/j.ic.2022.104958">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We establish a framework of approximable disjunctive sequent calculus , which is sound and complete with respect to approximable FD-algebras. We show that the category of approximable FD-algebras with approximable mappings is equivalent to that of bounded complete domains with Scott continuous functions. This extends Abramsky&#39;s logical representation of Scott domains as domain prelocales to a continuous setting. We also consider some domain constructions applied to approximable FD-algebras and show how to construct the approximable FD-algebras we need for defining the semantics of programming languages . According to a substructure relation, we define a pointed ω -chain complete class of approximable FD-algebras, on which the domain constructions are made continuous and then the initial solutions to recursive domain equations are transformed into the fixed-points of such continuous functions.},
  archive      = {J_IANDC},
  author       = {Longchun Wang and Qingguo Li},
  doi          = {10.1016/j.ic.2022.104958},
  journal      = {Information and Computation},
  pages        = {104958},
  shortjournal = {Inf. Comput.},
  title        = {Bounded complete domains and their logical form},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Survey on mining signal temporal logic specifications.
<em>IANDC</em>, <em>289</em>, 104957. (<a
href="https://doi.org/10.1016/j.ic.2022.104957">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Formal specifications play an essential role in the life-cycle of modern systems, both at the time of their design and during their operation. Despite their importance, formal specifications are only partially (if at all) available. Specification mining is the process of learning likely system properties from the observation of its behavior and its interaction with the environment. Signal temporal logic (STL) is a popular formalism for expressing properties of cyber-physical systems (CPS). In the last decade, the introduction of first methods for mining STL specifications from time series generated by CPS led to a new vivid area of research. This survey paper overviews methods for mining STL specifications from CPS behaviors, sketches different approaches found in the literature and presents them in an intuitive and didactic manner. It aims at presenting the most influential techniques and covers most important aspects of specification mining: template-based vs. template-free, model-based vs. model-free, passive vs. active, and supervised vs. unsupervised learning .},
  archive      = {J_IANDC},
  author       = {Ezio Bartocci and Cristinel Mateis and Eleonora Nesterini and Dejan Nickovic},
  doi          = {10.1016/j.ic.2022.104957},
  journal      = {Information and Computation},
  pages        = {104957},
  shortjournal = {Inf. Comput.},
  title        = {Survey on mining signal temporal logic specifications},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Special issue of SSS 2020. <em>IANDC</em>, <em>289</em>,
104955. (<a href="https://doi.org/10.1016/j.ic.2022.104955">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_IANDC},
  author       = {Stéphane Devismes ( Guest Editor ) and Neeraj Mittal (Guest Editor)},
  doi          = {10.1016/j.ic.2022.104955},
  journal      = {Information and Computation},
  pages        = {104955},
  shortjournal = {Inf. Comput.},
  title        = {Special issue of SSS 2020},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Beyond PCSP(1-in-3,NAE). <em>IANDC</em>, <em>289</em>,
104954. (<a href="https://doi.org/10.1016/j.ic.2022.104954">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {1-in-3-SAT and Not-All-Equal-3-SAT are classic examples of Boolean symmetric (non-promise) constraint satisfaction problems (CSPs). While both problems are NP-hard, Brakensiek and Guruswami showed [SICOMP&#39;21] that given a satisfiable instance of 1-in-3-SAT one can find a solution to the corresponding instance of (weaker) Not-All-Equal-3-SAT. In other words, the promise CSP template ( 1 -in- 3 , NAE ) (1-in-3,NAE) is tractable. Unlike previously established dichotomy results for fragments of promise CSPs (PCSPs), we focus on non-symmetric PCSPs. In particular, we study PCSP templates obtained from the Boolean template ( t -in- k , NAE ) (t-in-k,NAE) by either adding tuples to t -in- k t-in-k or removing tuples from NAE . For the former, we classify all templates as either tractable or not solvable by one of the strongest known algorithm for PCSPs, the combined basic LP and affine IP relaxation of Brakensiek, Guruswami, Wrochna, and Živný [SICOMP&#39;20]. For the latter, we classify all templates as either tractable or NP-hard.},
  archive      = {J_IANDC},
  author       = {Alex Brandts and Stanislav Živný},
  doi          = {10.1016/j.ic.2022.104954},
  journal      = {Information and Computation},
  pages        = {104954},
  shortjournal = {Inf. Comput.},
  title        = {Beyond PCSP(1-in-3,NAE)},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Intensional kleene and rice theorems for abstract program
semantics. <em>IANDC</em>, <em>289</em>, 104953. (<a
href="https://doi.org/10.1016/j.ic.2022.104953">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Classical results in computability theory , notably Rice&#39;s theorem, focus on the extensional content of programs, namely, on the partial recursive functions that programs compute. Later work investigated intensional generalisations of such results that take into account the way in which functions are computed, thus affected by the specific programs computing them. In this paper, we single out a novel class of program semantics based on abstract domains of program properties that are able to capture nonextensional aspects of program computations, such as their asymptotic complexity or logical invariants , and allow us to generalise some foundational computability results such as Rice&#39;s Theorem and Kleene&#39;s Second Recursion Theorem to these semantics. In particular, it turns out that for this class of abstract program semantics, any nontrivial abstract property is undecidable and every decidable over-approximation necessarily includes an infinite set of false positives which covers all the values of the semantic abstract domain.},
  archive      = {J_IANDC},
  author       = {Paolo Baldan and Francesco Ranzato and Linpeng Zhang},
  doi          = {10.1016/j.ic.2022.104953},
  journal      = {Information and Computation},
  pages        = {104953},
  shortjournal = {Inf. Comput.},
  title        = {Intensional kleene and rice theorems for abstract program semantics},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Trading information complexity for error II: The case of a
large error and the external information complexity. <em>IANDC</em>,
<em>289</em>, 104952. (<a
href="https://doi.org/10.1016/j.ic.2022.104952">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Two problems are studied. (1) How much external or internal information cost is required to compute a Boolean-valued function with an error at most 1 / 2 − ξ 1/2−ξ for small ξ &gt; 0 ξ&amp;gt;0 ? A lower bound Ω ( ξ 2 ) Ω(ξ2) and an upper bound O ( ξ ) O(ξ) are established. (2) How much external information cost can be saved to compute a function with a small error ϵ &gt; 0 ϵ&amp;gt;0 comparing to the case when no error is allowed? A lower bound Ω ( ϵ ) Ω(ϵ) and an upper bound O ( h ( ϵ ) ) O(h(ϵ)) are established, the lower bound can be improved to Ω ( h ( ϵ ) ) Ω(h(ϵ)) for product distributions. Except the O ( h ( ϵ ) ) O(h(ϵ)) upper bound, the other three bounds are tight. For distribution μ that is equally distributed on ( 0 , 0 ) (0,0) and ( 1 , 1 ) (1,1) , it is shown that IC μ ext ( XOR , ϵ ) = 1 − 2 ϵ ICμext(XOR,ϵ)=1−2ϵ holds for every 0 ≤ ϵ ≤ 1 / 2 0≤ϵ≤1/2 . This equality seems to be the first example of exact information complexity when ϵ &gt; 0 ϵ&amp;gt;0 .},
  archive      = {J_IANDC},
  author       = {Yaqiao Li},
  doi          = {10.1016/j.ic.2022.104952},
  journal      = {Information and Computation},
  pages        = {104952},
  shortjournal = {Inf. Comput.},
  title        = {Trading information complexity for error II: The case of a large error and the external information complexity},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Linear-time parameterized algorithms with limited local
resources. <em>IANDC</em>, <em>289</em>, 104951. (<a
href="https://doi.org/10.1016/j.ic.2022.104951">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We propose a new computational model for the study of massive data processing. Our model measures the complexity of reading the input data in terms of their very large size N and analyzes the computational cost in terms of a parameter k that characterizes the computational power provided by limited local computing resources. We develop new algorithmic techniques for solving well-known computational problems on the model. In particular, randomized algorithms of running time O ( N + g 1 ( k ) ) O(N+g1(k)) and space O ( k 2 ) O(k2) , with very high probability , are developed for the famous graph matching problem on unweighted and weighted graphs . More specifically, our algorithm for unweighted graphs finds a k -matching (i.e., a matching of k edges) in a general unweighted graph in time O ( N + k 2.5 ) O(N+k2.5) , and our algorithm for weighted graphs finds a maximum weighted k -matching in a general weighted graph in time O ( N + k 3 log ⁡ k ) O(N+k3log⁡k) .},
  archive      = {J_IANDC},
  author       = {Jianer Chen and Ying Guo and Qin Huang},
  doi          = {10.1016/j.ic.2022.104951},
  journal      = {Information and Computation},
  pages        = {104951},
  shortjournal = {Inf. Comput.},
  title        = {Linear-time parameterized algorithms with limited local resources},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Exploring sparse graphs with advice. <em>IANDC</em>,
<em>289</em>, 104950. (<a
href="https://doi.org/10.1016/j.ic.2022.104950">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Graph exploration is a theoretical model of the crucial task of moving an agent through an unknown environment . Here, an algorithm has to guide an explorer through a network with n vertices and m edges, visiting every vertex at least once. We consider the fixed-graph scenario by Kalyanasundaram and Pruhs (ICALP, 1993), where the explorer sees all vertices reachable in one step, their unique names and their distance from the current position. The algorithm only learns the structure of the graph during computation. Therefore, we are interested in the amount of crucial a-priori information (the advice complexity ) needed to solve the problem optimally. We look at graph exploration on directed graphs and focus on cyclic solutions. It is known that O ( n log ⁡ n ) O(nlog⁡n) bits of advice are necessary and sufficient to compute an optimal solution for general graphs. We present algorithms with O ( m ) O(m) advice, thus improving the bound for sparse graphs .},
  archive      = {J_IANDC},
  author       = {Hans-Joachim Böckenhauer and Janosch Fuchs and Walter Unger},
  doi          = {10.1016/j.ic.2022.104950},
  journal      = {Information and Computation},
  pages        = {104950},
  shortjournal = {Inf. Comput.},
  title        = {Exploring sparse graphs with advice},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Almost uniform deployment of mobile agents in dynamic rings.
<em>IANDC</em>, <em>289</em>, 104949. (<a
href="https://doi.org/10.1016/j.ic.2022.104949">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we consider the almost uniform deployment problem of mobile agents in dynamic rings, which requires all agents other than one agent to spread uniformly in the ring. In this paper, we consider this problem in 1-interval connected rings, that is, one of the links may be missing at each time step. Focusing on global knowledge given to agents, we clarify the problem solvability and the algorithm performance. First, we consider agents with knowledge of the number n of nodes. Then, we show that the problem can be solved with O ( k log ⁡ n ) memory space per agent, O ( n log ⁡ k ) rounds, and a total number of O ( k n ) moves, where k is the number of agents. Next, we consider agents with knowledge of k . Then, we show that the problem can be solved with O ( k log ⁡ n ) memory space per agent, O ( n 2 ) rounds, and a total number of O ( n 2 ) moves.},
  archive      = {J_IANDC},
  author       = {Masahiro Shibata and Yuichi Sudo and Junya Nakamura and Yonghwan Kim},
  doi          = {10.1016/j.ic.2022.104949},
  journal      = {Information and Computation},
  pages        = {104949},
  shortjournal = {Inf. Comput.},
  title        = {Almost uniform deployment of mobile agents in dynamic rings},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Polymorphic lambda calculus with context-free session types.
<em>IANDC</em>, <em>289</em>, 104948. (<a
href="https://doi.org/10.1016/j.ic.2022.104948">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Session types provide a typing discipline for structured communication on bidirectional channels. Context-free session types overcome the restriction to tail recursive protocols characteristic of conventional session types. This extension enables the serialization and deserialization of tree structures in a fully type-safe manner. We present the theory underlying the language FreeST 2, which features context-free session types in an extension of System F with linear types and a kinding system to distinguish message types, session types, and channel types. The system presents metatheoretical challenges which we address: contractivity in the presence of polymorphism, a non-trivial equational theory on types, and decidability of type equivalence. We also establish standard results on typing preservation, progress, and a characterization of erroneous processes.},
  archive      = {J_IANDC},
  author       = {Bernardo Almeida and Andreia Mordido and Peter Thiemann and Vasco T. Vasconcelos},
  doi          = {10.1016/j.ic.2022.104948},
  journal      = {Information and Computation},
  pages        = {104948},
  shortjournal = {Inf. Comput.},
  title        = {Polymorphic lambda calculus with context-free session types},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Hierarchical identification of nonlinear hybrid systems in a
bayesian framework. <em>IANDC</em>, <em>289</em>, 104947. (<a
href="https://doi.org/10.1016/j.ic.2022.104947">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper presents a hierarchical framework for the identification of nonlinear hybrid systems in the form of Switched Nonlinear AutoRegressive models with eXogenous variables (SNARX). The identification is done via three levels of inference, using Bayes&#39; rule. In the first level, model parameters are computed via a Maximum a Posteriori (MAP) estimator. The posterior distribution therein involved depends on hyper-parameters that are tuned in the second level of inference. Such terms determine model complexity, and the Bayesian framework is key in returning values that trade off complexity with accuracy by automatically embodying the Occam&#39;s razor principle. Lastly, the third level compares different model structures by means of a quality measure that encompasses data fitness, model complexity, and data classification . The proposed framework is compared with existing relevant methods and is tested on different numerical models, showing promising performance.},
  archive      = {J_IANDC},
  author       = {Ahmad Madary and Hamid Reza Momeni and Alessandro Abate and Kim G. Larsen},
  doi          = {10.1016/j.ic.2022.104947},
  journal      = {Information and Computation},
  pages        = {104947},
  shortjournal = {Inf. Comput.},
  title        = {Hierarchical identification of nonlinear hybrid systems in a bayesian framework},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Unambiguous injective morphisms in free groups.
<em>IANDC</em>, <em>289</em>, 104946. (<a
href="https://doi.org/10.1016/j.ic.2022.104946">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A morphism g is ambiguous with respect to a word u if there exists a second morphism h ≠ g h≠g such that g ( u ) = h ( u ) g(u)=h(u) . Otherwise g is unambiguous with respect to u . Thus unambiguous morphisms are those for which the structure of the morphism is preserved in the image. Ambiguity has so far been studied for morphisms of free monoids, where several characterisations exist for the set of words u permitting an (injective) unambiguous morphism. In the present paper, we consider ambiguity of morphisms of free groups, and consider possible analogies to the existing characterisations in the free monoid . While a direct generalisation results in a trivial situation where all morphisms are ambiguous, we discuss some natural and well-motivated reformulations, and provide a characterisation of words in a free group that permit a morphism which is “as unambiguous as possible”.},
  archive      = {J_IANDC},
  author       = {Joel D. Day and Daniel Reidenbach},
  doi          = {10.1016/j.ic.2022.104946},
  journal      = {Information and Computation},
  pages        = {104946},
  shortjournal = {Inf. Comput.},
  title        = {Unambiguous injective morphisms in free groups},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Recent developments in theory and tool support for hybrid
systems verification with HyPro. <em>IANDC</em>, <em>289</em>, 104945.
(<a href="https://doi.org/10.1016/j.ic.2022.104945">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Over the last decades, the development of algorithms and tools for the safety verification of hybrid systems has been content of intensive research. Numerous novel ideas have been presented and implemented in different tools. Whereas the majority of these tools offer fixed implementations, only few general libraries have been provided for the development of new verification tools. HyPro is such an example, providing a C++ programming library for the implementation of certain types of reachability analysis algorithms for linear hybrid systems. These algorithms, based on flowpipe construction, need geometric or symbolic representation for state sets of hybrid systems. HyPro offers datatypes for different representations, conversions between them, and efficient algorithms based on these datatypes. Since its release in 2017, HyPro &#39;s functionalities have been extended by several implementations. In this paper we give a general introduction to flowpipe-construction-based methods and report on HyPro &#39;s functional advances as well as on applications of the library.},
  archive      = {J_IANDC},
  author       = {Stefan Schupp and Erika Ábrahám and Tristan Ebert},
  doi          = {10.1016/j.ic.2022.104945},
  journal      = {Information and Computation},
  pages        = {104945},
  shortjournal = {Inf. Comput.},
  title        = {Recent developments in theory and tool support for hybrid systems verification with HyPro},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Parameterized complexity of stable roommates with ties and
incomplete lists through the lens of graph parameters. <em>IANDC</em>,
<em>289</em>, 104943. (<a
href="https://doi.org/10.1016/j.ic.2022.104943">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We continue and extend previous work on the parameterized complexity analysis of the NP-hard Stable Roommates with Ties and Incomplete Lists problem, thereby strengthening earlier results both on the side of parameterized hardness as well as on the side of fixed-parameter tractability. Other than for its famous sister problem Stable Marriage which focuses on a bipartite scenario, Stable Roommates with Incomplete Lists allows for arbitrary acceptability graphs whose edges specify the possible matchings of each two agents (agents are represented by graph vertices). Herein, incomplete lists and ties reflect the fact that in realistic application scenarios the agents cannot bring all other agents into a linear order. Among our main contributions is to show that it is W[1]-hard to compute a maximum-cardinality stable matching for acceptability graphs of bounded treedepth, bounded tree-cut width, and bounded disjoint paths modulator number (these are each time the respective parameters). Moreover, we obtain that ‘only’ asking for perfect stable matchings or the mere existence of a stable matching is fixed-parameter tractable with respect to tree-cut width but not with respect to treedepth. On the positive side, we also provide fixed-parameter tractability results for the parameter feedback edge set number.},
  archive      = {J_IANDC},
  author       = {Robert Bredereck and Klaus Heeger and Dušan Knop and Rolf Niedermeier},
  doi          = {10.1016/j.ic.2022.104943},
  journal      = {Information and Computation},
  pages        = {104943},
  shortjournal = {Inf. Comput.},
  title        = {Parameterized complexity of stable roommates with ties and incomplete lists through the lens of graph parameters},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). On enumerating algorithms of novel multiple leaf-distance
granular regular α-subtrees of trees. <em>IANDC</em>, <em>289</em>,
104942. (<a href="https://doi.org/10.1016/j.ic.2022.104942">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Subtrees and BC-subtrees (subtrees in which the distance between any two leaves is even) are important concepts in the study of complex graphical structures. In this article, we propose a novel generalization called the leaf-distance granular regular α -tree (abbreviated as LDR α -tree for short). This is a tree in which the distance between any two leaves is divisible by α ( α is a positive integer). A LDR α -subtree is simply a subtree that is also a LDR α -tree. We present basic properties and generating functions related to the LDR α -subtrees enumeration. Based on those theoretical results we provide efficient algorithms for enumerating various LDR α -subtrees of trees. Our algorithms can serve as multi-distance granularity sifters of a graph to screen all the α -subtree uniformly, and thus provide novel insights into exploring new structural properties from the perspective of multiple leaf-distance granularity .},
  archive      = {J_IANDC},
  author       = {Yu Yang and Hongbo Liu and Hua Wang and Xiao-Dong Zhang and C.L. Philip Chen},
  doi          = {10.1016/j.ic.2022.104942},
  journal      = {Information and Computation},
  pages        = {104942},
  shortjournal = {Inf. Comput.},
  title        = {On enumerating algorithms of novel multiple leaf-distance granular regular α-subtrees of trees},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Parameter synthesis of polynomial dynamical systems.
<em>IANDC</em>, <em>289</em>, 104941. (<a
href="https://doi.org/10.1016/j.ic.2022.104941">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Parametric dynamical systems emerge as a formalism for modeling natural and engineered systems ranging from biology, epidemiology, and medicine to cyber-physics. Parameter tuning is a complex task usually performed exploiting heavy simulations having high computational complexity and not ensuring the correctness of the synthesized systems. We consider the problem of parameter synthesis for discrete-time polynomial systems. We propose a formal method based on Bernstein coefficients that allows refining the set of parameters according to a temporal specification defined as a Signal Temporal Logic formula. The synthesized system is correct with respect to the specification and we demonstrate the scalability of the approach by implementing it in the C++ library Sapo , also available within a stand-alone application and as a web application. Finally, we illustrate the tool usage and the interface through a simple yet realistic epidemiological model and consider an intriguing application enhancing accuracy of the verification of neural networks .},
  archive      = {J_IANDC},
  author       = {Alberto Casagrande and Thao Dang and Luca Dorigo and Tommaso Dreossi and Carla Piazza and Eleonora Pippia},
  doi          = {10.1016/j.ic.2022.104941},
  journal      = {Information and Computation},
  pages        = {104941},
  shortjournal = {Inf. Comput.},
  title        = {Parameter synthesis of polynomial dynamical systems},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Exploiting social influence to control elections based on
positional scoring rules. <em>IANDC</em>, <em>289</em>, 104940. (<a
href="https://doi.org/10.1016/j.ic.2022.104940">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Herein, we present Linear Threshold Ranking (LTR), an extension of the Linear Threshold Model (Kempe et al., KDD 2003). LTR models the spread of a message supporting a target candidate in a social network and how social influence affects the preferences of the voters who receive it, in elections based on positional scoring rules . The problem of election control through social influence requires finding a bounded subset of nodes to be the initial spreaders of this message to maximize the Margin of Victory of a target candidate against the most voted opponent. We prove the problem is NP -hard in LTR. By showing the equivalence of LTR with alternative stochastic processes and then exploiting submodularity, we provide a 1 3 ( 1 − 1 e ) 13(1−1e) approximation algorithm . We achieve similar results also in the destructive variation of LTR, where the message undermines a target candidate, negatively influencing the voters&#39; preference on that candidate.},
  archive      = {J_IANDC},
  author       = {Federico Corò and Emilio Cruciani and Gianlorenzo D&#39;Angelo and Stefano Ponziani},
  doi          = {10.1016/j.ic.2022.104940},
  journal      = {Information and Computation},
  pages        = {104940},
  shortjournal = {Inf. Comput.},
  title        = {Exploiting social influence to control elections based on positional scoring rules},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Abstract processes in the absence of conflicts in general
place/transition systems. <em>IANDC</em>, <em>289</em>, 104939. (<a
href="https://doi.org/10.1016/j.ic.2022.104939">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Goltz and Reisig generalised Petri&#39;s concept of processes of one-safe Petri nets to general nets where places carry multiple tokens. BD-processes are equivalence classes of Goltz-Reisig processes connected through the swapping transformation of Best and Devillers; they can be considered as an alternative representation of runs of nets. Here we present an order respecting bijection between the BD-processes and the FS-processes of a countable net, the latter being defined—in an analogous way—as equivalence classes of firing sequences. Using this, we show that a countable net without binary conflicts has a (unique) largest BD-process.},
  archive      = {J_IANDC},
  author       = {Rob van Glabbeek and Ursula Goltz and Jens-Wolfhard Schicke-Uffmann},
  doi          = {10.1016/j.ic.2022.104939},
  journal      = {Information and Computation},
  pages        = {104939},
  shortjournal = {Inf. Comput.},
  title        = {Abstract processes in the absence of conflicts in general place/transition systems},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Converting nondeterministic two-way automata into small
deterministic linear-time machines. <em>IANDC</em>, <em>289</em>,
104938. (<a href="https://doi.org/10.1016/j.ic.2022.104938">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In 1978 Sakoda and Sipser raised the question of the cost, in terms of size of representations, of the transformation of two-way and one-way nondeterministic automata into equivalent two-way deterministic automata . Despite all the attempts, the question has been answered only for particular cases, while it remains open in general, the best upper bound currently known being exponential. We present a new approach in which unrestricted nondeterministic automata are simulated by deterministic models extending two-way deterministic automata , paying only a polynomial increase of size. Indeed, we study the costs of the conversions of nondeterministic automata into some variants of one-tape deterministic Turing machines working in linear time; namely Hennie machines, weight-reducing Turing machines , and weight-reducing Hennie machines. All these variants are known to share the same computational power: they characterize the class of regular languages.},
  archive      = {J_IANDC},
  author       = {Bruno Guillon and Giovanni Pighizzini and Luca Prigioniero and Daniel Průša},
  doi          = {10.1016/j.ic.2022.104938},
  journal      = {Information and Computation},
  pages        = {104938},
  shortjournal = {Inf. Comput.},
  title        = {Converting nondeterministic two-way automata into small deterministic linear-time machines},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Decomposing reach set computations with low-dimensional sets
and high-dimensional matrices (extended version). <em>IANDC</em>,
<em>289</em>, 104937. (<a
href="https://doi.org/10.1016/j.ic.2022.104937">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Approximating the set of reachable states of a dynamical system is an algorithmic way to rigorously reason about its safety. Despite progress on efficient algorithms for affine dynamical systems, available algorithms still lack scalability to ensure their wide adoption in practice. While modern linear algebra packages are efficient for matrices with tens of thousands of dimensions, set-based image computations are limited to a few hundred. We propose to decompose reach-set computations such that set operations are performed in low dimensions, while matrix operations are performed in the full dimension. Our method is applicable in both dense- and discrete-time settings. For a set of standard benchmarks, we show a speed-up of up to two orders of magnitude compared to the respective state-of-the-art tools, with only modest loss in accuracy. For the dense-time case, we show an experiment with more than 10,000 variables, roughly two orders of magnitude higher than possible before.},
  archive      = {J_IANDC},
  author       = {Sergiy Bogomolov and Marcelo Forets and Goran Frehse and Andreas Podelski and Christian Schilling},
  doi          = {10.1016/j.ic.2022.104937},
  journal      = {Information and Computation},
  pages        = {104937},
  shortjournal = {Inf. Comput.},
  title        = {Decomposing reach set computations with low-dimensional sets and high-dimensional matrices (extended version)},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). On boolean threshold functions with minimum specification
number. <em>IANDC</em>, <em>289</em>, 104926. (<a
href="https://doi.org/10.1016/j.ic.2022.104926">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A set S of Boolean points is a specifying set for a threshold function f if the only threshold function consistent with f on S is f itself. The minimal cardinality of a specifying set for f is the specification number of f and it is never smaller than n + 1 n+1 for a function with n relevant variables. In the present paper, we develop an inductive approach to describing the set of Boolean threshold functions with minimum specification number by means of operations that allow us to extend functions of n variables in this set to functions of n + 1 n+1 variables.},
  archive      = {J_IANDC},
  author       = {Vadim Lozin and Viktor Zamaraev and Elena Zamaraeva and Nikolai Yu. Zolotykh},
  doi          = {10.1016/j.ic.2022.104926},
  journal      = {Information and Computation},
  pages        = {104926},
  shortjournal = {Inf. Comput.},
  title        = {On boolean threshold functions with minimum specification number},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Noisy beeping networks. <em>IANDC</em>, <em>289</em>,
104925. (<a href="https://doi.org/10.1016/j.ic.2022.104925">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Beeping networks consist of exceedingly simple computational devices whose communication is based on beeps and silence. In this work, we introduce noisy beeping networks, where the observed communication is noisy with some fixed probability of error. We show how to transform any algorithm over a noiseless beeping network into a noise-resilient version while incurring a multiplicative overhead of essentially O ( log ⁡ n ) O(log⁡n) in its round complexity, with high probability . Our coding is optimal for some (short) tasks, such as the node-coloring of cliques . Interestingly, in the case of coloring, our technique achieves the same complexity as the standard beeping model while being noise resilient. We further show how to simulate a large family of algorithms designed for distributed networks in the CONGEST( B ) model over a noisy beeping network, with a multiplicative overhead of O ( B ⋅ Δ ⋅ min ⁡ ( n , Δ 2 ) ) O(B⋅Δ⋅min⁡(n,Δ2)) in the round complexity, where Δ is the maximum degree of the network.},
  archive      = {J_IANDC},
  author       = {Yagel Ashkenazi and Ran Gelles and Amir Leshem},
  doi          = {10.1016/j.ic.2022.104925},
  journal      = {Information and Computation},
  pages        = {104925},
  shortjournal = {Inf. Comput.},
  title        = {Noisy beeping networks},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Order-preserving pattern matching indeterminate strings.
<em>IANDC</em>, <em>289</em>, 104924. (<a
href="https://doi.org/10.1016/j.ic.2022.104924">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Given a pattern p of size m and a text t , the problem of order-preserving pattern matching (OPPM) is to find all substrings of t that satisfy one of the orderings defined by p . This problem has applications on time series analysis . However given its strict nature this model is unable to deal with indetermination, thus limiting its application to noisy time series. In this paper we introduce indeterminate characters to alleviate this limitation. We then propose two polynomial time algorithms. If the indetermination is limited to p confirming one occurrence can be computed in O ( r m lg ⁡ r ) O(rmlg⁡r) time, where r is a bound on the number of uncertain characters per position. If the indetermination alternates, but does not occur at the same position in t and p , we present an algorithm that requires O ( r m ( m + log ⁡ r ) ) O(rm(m+log⁡r)) time. We also show that the general problem is NP-hard and provide a polynomial size boolean formula .},
  archive      = {J_IANDC},
  author       = {Luís M.S. Russo and Diogo Costa and Rui Henriques and Hideo Bannai and Alexandre P. Francisco},
  doi          = {10.1016/j.ic.2022.104924},
  journal      = {Information and Computation},
  pages        = {104924},
  shortjournal = {Inf. Comput.},
  title        = {Order-preserving pattern matching indeterminate strings},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Satisfiability checking for mission-time LTL (MLTL).
<em>IANDC</em>, <em>289</em>, 104923. (<a
href="https://doi.org/10.1016/j.ic.2022.104923">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Mission-time Linear Temporal Logic ( LTL ), abbreviated as MLTL , is a bounded variant of Metric Temporal Logic ( MTL ) over naturals designed to generically specify requirements for mission-based system operation common to aircraft, spacecraft, vehicles, and robots. Despite the utility of MLTL as a specification logic, major gaps remain in analyzing MLTL , e.g., for specification debugging or model checking, centering on the absence of any complete MLTL satisfiability checker. In this paper, we explore both the theoretical and algorithmic problems of MLTL satisfiability checking. We prove that the MLTL satisfiability checking problem is NEXPTIME-complete and that satisfiability checking MLTL 0 , the variant of MLTL where all intervals start at 0, is PSPACE-complete. To explore the best algorithmic solution for MLTL satisifiability checking, we reduce this problem to LTL satisfiability checking, LTL f ( LTL over finite traces) satisfiability checking, and model checking respectively, thus conducting translations for MLTL -to- LTL , MLTL -to- LTL f , and MLTL -to- SMV . Moreover, we propose a new SMT -based solution for MLTL satisfiability checking and create a translation for MLTL -to- SMT . Our extensive experimental evaluation shows that while the MLTL -to- SMV translation with NuXmv model checker performs best on the benchmarks whose interval ranges are small (than 100), the MLTL -to- SMT translation with the Z3 SMT solver offers the most scalable performance.},
  archive      = {J_IANDC},
  author       = {Jianwen Li and Moshe Y. Vardi and Kristin Y. Rozier},
  doi          = {10.1016/j.ic.2022.104923},
  journal      = {Information and Computation},
  pages        = {104923},
  shortjournal = {Inf. Comput.},
  title        = {Satisfiability checking for mission-time LTL (MLTL)},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Comparison of algorithms for simple stochastic games.
<em>IANDC</em>, <em>289</em>, 104885. (<a
href="https://doi.org/10.1016/j.ic.2022.104885">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Simple stochastic games are turn-based 2½-player zero-sum graph games with a reachability objective. The problem is to compute the winning probabilities as well as the optimal strategies of both players. In this paper, we compare the three known classes of algorithms – value iteration, strategy iteration and quadratic programming – both theoretically and practically. Further, we suggest several improvements for all algorithms, including the first approach based on quadratic programming that avoids transforming the stochastic game to a stopping one. Our extensive experiments show that these improvements can lead to significant speed-ups. We implemented all algorithms in PRISM-games 3.0, thereby providing the first implementation of quadratic programming for solving simple stochastic games.},
  archive      = {J_IANDC},
  author       = {Jan Křetínský and Emanuel Ramneantu and Alexander Slivinskiy and Maximilian Weininger},
  doi          = {10.1016/j.ic.2022.104885},
  journal      = {Information and Computation},
  pages        = {104885},
  shortjournal = {Inf. Comput.},
  title        = {Comparison of algorithms for simple stochastic games},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Bounded game-theoretic semantics for modal mu-calculus.
<em>IANDC</em>, <em>289</em>, 104882. (<a
href="https://doi.org/10.1016/j.ic.2022.104882">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce a new game-theoretic semantics (GTS) for the modal mu-calculus. Our so-called bounded GTS replaces parity games with alternative evaluation games where only finite paths arise; infinite paths are not needed even when the considered transition system is infinite. The novel games offer alternative approaches to various constructions in the framework of the mu-calculus. While our main focus is introducing the new GTS, we also consider some applications to demonstrate its uses. For example, we consider a natural model transformation procedure that reduces model checking games to checking a single, fixed formula in the constructed models. We also use the GTS to identify new alternative variants of the mu-calculus, including close variants of the logic with PTime model checking; variants with iteration limited to finite ordinals; and other systems where the semantic or syntactic specification of the mu-calculus has been modified in a natural way suggested by the GTS.},
  archive      = {J_IANDC},
  author       = {Lauri Hella and Antti Kuusisto and Raine Rönnholm},
  doi          = {10.1016/j.ic.2022.104882},
  journal      = {Information and Computation},
  pages        = {104882},
  shortjournal = {Inf. Comput.},
  title        = {Bounded game-theoretic semantics for modal mu-calculus},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Decisiveness of stochastic systems and its application to
hybrid models. <em>IANDC</em>, <em>289</em>, 104861. (<a
href="https://doi.org/10.1016/j.ic.2021.104861">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In 2007, Abdulla et al. introduced the concept of decisiveness, an interesting tool for lifting good properties of finite Markov chains to denumerable ones. Later, this concept was extended to more general stochastic transition systems (STSs), allowing the design of various verification algorithms for large classes of (infinite) STSs. We further improve the understanding and utility of decisiveness in two ways. First, we provide a general criterion for proving the decisiveness of general STSs. This criterion, which is very natural but whose proof is rather technical, (strictly) generalizes all known criteria from the literature. Second, we focus on stochastic hybrid systems (SHSs), a stochastic extension of hybrid systems. We establish the decisiveness of a large class of SHSs and, under a few classical hypotheses from mathematical logic , we show how to decide reachability problems in this class, even though they are undecidable for general SHSs. This provides a decidable stochastic extension of o-minimal hybrid systems.},
  archive      = {J_IANDC},
  author       = {Patricia Bouyer and Thomas Brihaye and Mickael Randour and Cédric Rivière and Pierre Vandenhove},
  doi          = {10.1016/j.ic.2021.104861},
  journal      = {Information and Computation},
  pages        = {104861},
  shortjournal = {Inf. Comput.},
  title        = {Decisiveness of stochastic systems and its application to hybrid models},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Synthesis in presence of dynamic links. <em>IANDC</em>,
<em>289</em>, 104856. (<a
href="https://doi.org/10.1016/j.ic.2021.104856">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider the problem of distributed synthesis: Given a distributed architecture and a specification, can we generate a distributed algorithm that satisfies the specification? While previous work focused on static architectures and fixed message sizes, we assume that the communication network changes dynamically and that processes piggy-pack previously received messages onto current messages. Specifically, we address two processes communicating in rounds over a dynamic link. Given a network model, i.e., a set of link directions, an adversary picks, in each round, an arbitrary link from the network model. We show that the synthesis problem is decidable for a network model if and only if it does not contain the &#39;empty&#39; link. For a more general setting allowing for sequences of links, the synthesis problem is decidable if and only if the number of consecutive empty links in all possible sequences is uniformly bounded from above.},
  archive      = {J_IANDC},
  author       = {Béatrice Bérard and Benedikt Bollig and Patricia Bouyer and Matthias Függer and Nathalie Sznajder},
  doi          = {10.1016/j.ic.2021.104856},
  journal      = {Information and Computation},
  pages        = {104856},
  shortjournal = {Inf. Comput.},
  title        = {Synthesis in presence of dynamic links},
  volume       = {289},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022c). Special issue: Selected papers of the 14th international
conference on language and automata theory and applications, LATA 2020.
<em>IANDC</em>, <em>288</em>, 104912. (<a
href="https://doi.org/10.1016/j.ic.2022.104912">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_IANDC},
  author       = {Carlos Martín-Vide and Bianca Truthe},
  doi          = {10.1016/j.ic.2022.104912},
  journal      = {Information and Computation},
  pages        = {104912},
  shortjournal = {Inf. Comput.},
  title        = {Special issue: Selected papers of the 14th international conference on language and automata theory and applications, LATA 2020},
  volume       = {288},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Context-sensitive fusion grammars and fusion grammars with
forbidden context are universal. <em>IANDC</em>, <em>288</em>, 104889.
(<a href="https://doi.org/10.1016/j.ic.2022.104889">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Context-sensitive fusion grammars and fusion grammars with forbidden context are special cases of context-dependent fusion grammars where instead of finite sets of positive and negative context conditions in the first case a rule has only a single positive context condition and in the second case a rule has only a finite set of negative context conditions. In this paper, we show that several decision problems can be formulated quite intuitively by these grammars. In particular, we show that the Boolean satisfiability problem as well as the Post correspondence problem can be transformed into a context-sensitive fusion grammar and that the graph coloring problem can be transformed into a fusion grammar with forbidden context such that the generated languages give solutions for the problems. Furthermore, we prove that both grammar types can generate all recursively enumerable string languages (up to representation of strings as graphs) and are universal in this respect.},
  archive      = {J_IANDC},
  author       = {Aaron Lye},
  doi          = {10.1016/j.ic.2022.104889},
  journal      = {Information and Computation},
  pages        = {104889},
  shortjournal = {Inf. Comput.},
  title        = {Context-sensitive fusion grammars and fusion grammars with forbidden context are universal},
  volume       = {288},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Advice hierarchies among finite automata. <em>IANDC</em>,
<em>288</em>, 104878. (<a
href="https://doi.org/10.1016/j.ic.2022.104878">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We examine the effects of supplying increasing amounts of trusted advice to a finite automaton . Previous work has shown that allowing such automata with a single advice tape to make a single pass over their input renders them unable to recognize the palindromes language, whereas both two-way machines reading advice from a single tape and one-way machines with multiple advice tapes can recognize all languages with exponentially bounded amounts of advice. We study several architectural variants and demonstrate the existence of language hierarchies based on increased advice length, runtime (measured in terms of the number of allowed left-to-right passes on the input), and number of advice tapes. We also prove some lower bounds for recognizing certain concrete languages.},
  archive      = {J_IANDC},
  author       = {Ahmet Bilal Uçan and A.C. Cem Say},
  doi          = {10.1016/j.ic.2022.104878},
  journal      = {Information and Computation},
  pages        = {104878},
  shortjournal = {Inf. Comput.},
  title        = {Advice hierarchies among finite automata},
  volume       = {288},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). On the weisfeiler-leman dimension of fractional packing.
<em>IANDC</em>, <em>288</em>, 104803. (<a
href="https://doi.org/10.1016/j.ic.2021.104803">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The k -dimensional Weisfeiler-Leman procedure ( k - WL k-WL ), which colors k -tuples of vertices in rounds based on the neighborhood structure in the graph, has proven to be immensely fruitful in the algorithmic study of Graph Isomorphism. More generally, it is of fundamental importance in understanding and exploiting symmetries in graphs in various settings. Two graphs are k - WL k-WL -equivalent if the k -dimensional Weisfeiler-Leman procedure produces the same final coloring on both graphs. 1 - WL 1-WL -equivalence is known as fractional isomorphism of graphs, and the k - WL k-WL -equivalence relation becomes finer as k increases. We investigate to what extent standard graph parameters are preserved by k - WL k-WL -equivalence, focusing on fractional graph packing numbers. The integral packing numbers are typically NP-hard to compute, and we discuss applicability of k - WL k-WL -invariance for estimating the integrality gap of the LP relaxation provided by their fractional counterparts.},
  archive      = {J_IANDC},
  author       = {V. Arvind and Frank Fuhlbrück and Johannes Köbler and Oleg Verbitsky},
  doi          = {10.1016/j.ic.2021.104803},
  journal      = {Information and Computation},
  pages        = {104803},
  shortjournal = {Inf. Comput.},
  title        = {On the weisfeiler-leman dimension of fractional packing},
  volume       = {288},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Cayley polynomial–time computable groups. <em>IANDC</em>,
<em>288</em>, 104768. (<a
href="https://doi.org/10.1016/j.ic.2021.104768">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We propose a new generalization of Cayley automatic groups, varying the time complexity of computing multiplication, and language complexity of the normal form representatives. We first consider groups which have normal form language in the class C C and multiplication by generators computable in linear time on a certain restricted Turing machine model (position–faithful one–tape). We show that many of the algorithmic properties of automatic groups are preserved, prove various closure properties, and show that the class is quite large. We then generalize to groups which have normal form language in the class C C and multiplication by generators computable in polynomial time on a (standard) Turing machine . Of particular interest is when C = REG C=REG (the class of regular languages). We prove that REG REG –Cayley polynomial–time computable groups include all finitely generated nilpotent groups, the wreath product Z 2 ≀ Z 2 Z2≀Z2 , and Thompson&#39;s group F .},
  archive      = {J_IANDC},
  author       = {Dmitry Berdinsky and Murray Elder and Prohrak Kruengthomya},
  doi          = {10.1016/j.ic.2021.104768},
  journal      = {Information and Computation},
  pages        = {104768},
  shortjournal = {Inf. Comput.},
  title        = {Cayley polynomial–time computable groups},
  volume       = {288},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). On the complexity of approximately matching a string to a
directed graph. <em>IANDC</em>, <em>288</em>, 104748. (<a
href="https://doi.org/10.1016/j.ic.2021.104748">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The problem of matching a query string to a directed graph , whose vertices are labeled by strings, has application in different fields. In this paper we present results on the complexity of the approximate matching problem , where edit operations are symbol substitutions and are allowed only to the graph labels or both to the graph labels and the query string. We show that deciding if there exists a path in a graph that represents a query string with edit operations to vertex labels is an NP-complete problem and it is fixed-parameter tractable when parameterized by the length of the input string. We show that the variants of approximate string matching we consider are not fixed-parameter tractable, when the parameter is (1) the length of the query string and (2) the number of edit operations. Moreover, we provide inapproximability results for these variants of the of approximate string matching problem .},
  archive      = {J_IANDC},
  author       = {Riccardo Dondi and Giancarlo Mauri and Italo Zoppis},
  doi          = {10.1016/j.ic.2021.104748},
  journal      = {Information and Computation},
  pages        = {104748},
  shortjournal = {Inf. Comput.},
  title        = {On the complexity of approximately matching a string to a directed graph},
  volume       = {288},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Variable-length codes independent or closed with respect to
edit relations. <em>IANDC</em>, <em>288</em>, 104747. (<a
href="https://doi.org/10.1016/j.ic.2021.104747">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We investigate inference of variable-length codes in other domains of computer science, such as noisy information transmission or information retrieval-storage: in such topics, traditionally mostly constant-length codewords act. The study is relied upon the two concepts of independent and closed sets: given an alphabet A and a binary relation ⁎ ⁎ τ ⊆ A ⁎ × A ⁎ τ⊆A⁎×A⁎ , a set ⁎ X ⊆ A ⁎ X⊆A⁎ is τ - independent if τ ( X ) ∩ X = ∅ τ(X)∩X=∅ ; X is τ - closed if τ ( X ) ⊆ X τ(X)⊆X . We focus to those word relations whose images are computed by applying some peculiar combinations of deletion, insertion, or substitution. In particular, characterizations of variable-length codes that are maximal in the families of τ -independent or τ -closed codes are provided.},
  archive      = {J_IANDC},
  author       = {Jean Néraud},
  doi          = {10.1016/j.ic.2021.104747},
  journal      = {Information and Computation},
  pages        = {104747},
  shortjournal = {Inf. Comput.},
  title        = {Variable-length codes independent or closed with respect to edit relations},
  volume       = {288},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Constant-space, constant-randomness verifiers with
arbitrarily small error. <em>IANDC</em>, <em>288</em>, 104744. (<a
href="https://doi.org/10.1016/j.ic.2021.104744">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the capabilities of probabilistic finite-state machines that act as verifiers for certificates of language membership for input strings, in the regime where the verifiers are restricted to toss some fixed nonzero number of coins regardless of the input size. Say and Yakaryılmaz showed that the class of languages that could be verified by these machines within an error bound strictly less than 1 2 12 is precisely NL, but their construction yields verifiers with error bounds that are very close to 1 2 12 for most languages in that class when the definition of “error” is strengthened to include looping forever without giving a response. We characterize a subset of NL for which verification with arbitrarily low error is possible by these extremely weak machines. It turns out that, for any ε &gt; 0 ε&amp;gt;0 , one can construct a constant-coin, constant-space verifier operating within error ε for every language that is recognizable by a linear-time multi-head nondeterministic finite automaton ( 2nfa ( k )). We discuss why it is difficult to generalize this method to all of NL, and give a reasonably tight way to relate the power of linear-time 2nfa ( k )&#39;s to simultaneous time-space complexity classes defined in terms of Turing machines .},
  archive      = {J_IANDC},
  author       = {M. Utkan Gezer and A.C. Cem Say},
  doi          = {10.1016/j.ic.2021.104744},
  journal      = {Information and Computation},
  pages        = {104744},
  shortjournal = {Inf. Comput.},
  title        = {Constant-space, constant-randomness verifiers with arbitrarily small error},
  volume       = {288},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Complexity of automatic sequences. <em>IANDC</em>,
<em>288</em>, 104710. (<a
href="https://doi.org/10.1016/j.ic.2021.104710">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Automatic sequences can be defined by DFAs with output (DFAO) in two natural ways. We propose to consider the minimal size of a corresponding DFAO as the complexity measure of the automatic sequence, for both variants. This paper compares these complexity measures and investigates their properties, such as the relationships with kernel and morphic sequences. There exist automatic sequences for which the one complexity is exponentially greater than the other one, in both directions. For both complexity measures we investigate the effect of taking basic operations on sequences, like removing or adding an initial element, combining sequences, or taking arithmetic subsequences, and observe that these operations may increase the complexity at most polynomially. For periodic sequences we give sharp bounds for both complexity measures.},
  archive      = {J_IANDC},
  author       = {Hans Zantema and Wieb Bosma},
  doi          = {10.1016/j.ic.2021.104710},
  journal      = {Information and Computation},
  pages        = {104710},
  shortjournal = {Inf. Comput.},
  title        = {Complexity of automatic sequences},
  volume       = {288},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Geometrically closed positive varieties of languages.
<em>IANDC</em>, <em>288</em>, 104709. (<a
href="https://doi.org/10.1016/j.ic.2021.104709">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A recently introduced operation of geometrical closure on formal languages is investigated from the viewpoint of algebraic language theory. Positive varieties V V containing exclusively languages with regular geometrical closure are fully characterised by inclusion of V V in W W , a known positive variety arising in the study of the commutative closure. It is proved that the geometrical closure of a language from the intersection of W W with the variety of all star-free languages SF SF always falls into R L T RLT , which is introduced as a subvariety of R R , the variety of languages recognised by R -trivial monoids. All classes between R L T RLT and W ∩ SF W∩SF are thus geometrically closed: for instance, the level 3/2 of the Straubing-Thérien hierarchy, the DA -recognisable languages, or the variety R R . It is also shown that W ∩ SF W∩SF is the largest geometrically closed positive variety of star-free languages, while there is no largest geometrically closed positive variety of regular languages.},
  archive      = {J_IANDC},
  author       = {Ondřej Klíma and Peter Kostolányi},
  doi          = {10.1016/j.ic.2021.104709},
  journal      = {Information and Computation},
  pages        = {104709},
  shortjournal = {Inf. Comput.},
  title        = {Geometrically closed positive varieties of languages},
  volume       = {288},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Distributional formal semantics. <em>IANDC</em>,
<em>287</em>, 104763. (<a
href="https://doi.org/10.1016/j.ic.2021.104763">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Natural language semantics has recently sought to combine the complementary strengths of formal and distributional approaches to meaning. However, given the fundamentally different ‘representational currency’ underlying these approaches—models of the world versus linguistic co-occurrence—their unification has proven extremely difficult. Here, we define Distributional Formal Semantics , which integrates distributionality into a formal semantic system on the level of formal models . This approach offers probabilistic, distributed meaning representations that are inherently compositional, and that naturally capture fundamental semantic notions such as quantification and entailment . Furthermore, we show how the probabilistic nature of these representations allows for probabilistic inference , and how the information-theoretic notion of “information” (measured in Entropy and Surprisal) naturally follows from it. Finally, we illustrate how meaning representations can be derived incrementally from linguistic input using a recurrent neural network model, and how the resultant incremental semantic construction procedure intuitively captures key semantic phenomena, including negation, presupposition, and anaphoricity.},
  archive      = {J_IANDC},
  author       = {Noortje J. Venhuizen and Petra Hendriks and Matthew W. Crocker and Harm Brouwer},
  doi          = {10.1016/j.ic.2021.104763},
  journal      = {Information and Computation},
  pages        = {104763},
  shortjournal = {Inf. Comput.},
  title        = {Distributional formal semantics},
  volume       = {287},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Lifting proofs from countable to uncountable mathematics.
<em>IANDC</em>, <em>287</em>, 104762. (<a
href="https://doi.org/10.1016/j.ic.2021.104762">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Turing&#39;s famous ‘machine’ framework provides an intuitively clear conception of ‘computing with real numbers’. A recursive counterexample to a theorem shows that the theorem does not hold when restricted to computable objects. These counterexamples are often crucial in establishing reversals in the Reverse Mathematics program. All the previous is essentially limited to a language that can only express countable mathematics directly. The aim of this paper is to show that reversals and recursive counterexamples, countable in nature as they might be, directly yield new and interesting results about uncountable mathematics with little-to-no modification . We shall treat the following topics/theorems: the monotone convergence theorem/Specker sequences, compact and closed sets in metric spaces, the Rado selection lemma, the ordering and algebraic closures of fields, and ideals of rings. The higher-order generalisation of sequence is of course provided by nets (aka Moore-Smith sequences ).},
  archive      = {J_IANDC},
  author       = {Sam Sanders},
  doi          = {10.1016/j.ic.2021.104762},
  journal      = {Information and Computation},
  pages        = {104762},
  shortjournal = {Inf. Comput.},
  title        = {Lifting proofs from countable to uncountable mathematics},
  volume       = {287},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). A universal algorithm for krull’s theorem. <em>IANDC</em>,
<em>287</em>, 104761. (<a
href="https://doi.org/10.1016/j.ic.2021.104761">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We give a computational interpretation to an abstract formulation of Krull&#39;s theorem, by analysing its classical proof based on Zorn&#39;s lemma . Our approach is inspired by proof theory, and uses a form of update recursion to replace the existence of maximal ideals . Our main result allows us to derive, in a uniform way, algorithms which compute witnesses for existential theorems in countable abstract algebra . We give a number of concrete examples of this phenomenon, including the prime ideal theorem and Krull&#39;s theorem on valuation rings .},
  archive      = {J_IANDC},
  author       = {Thomas Powell and Peter Schuster and Franziskus Wiesnet},
  doi          = {10.1016/j.ic.2021.104761},
  journal      = {Information and Computation},
  pages        = {104761},
  shortjournal = {Inf. Comput.},
  title        = {A universal algorithm for krull&#39;s theorem},
  volume       = {287},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Language models for some extensions of the lambek calculus.
<em>IANDC</em>, <em>287</em>, 104760. (<a
href="https://doi.org/10.1016/j.ic.2021.104760">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We investigate language interpretations of two extensions of the Lambek calculus: with additive conjunction and disjunction and with additive conjunction and the unit constant. For extensions with additive connectives, we show that conjunction and disjunction behave differently. Adding both of them leads to incompleteness due to the distributivity law. We show that with conjunction only no issues with distributivity arise. In contrast, there exists a corollary of the distributivity law in the language with disjunction only which is not derivable in the non-distributive system. Moreover, this difference keeps valid for systems with permutation and/or weakening structural rules, that is, intuitionistic linear and affine logics and affine multiplicative-additive Lambek calculus. For the extension of the Lambek calculus with the unit constant, we present a calculus which reflects natural algebraic properties of the empty word. We do not claim completeness for this calculus, but we prove undecidability for the whole range of systems extending this minimal calculus and sound w.r.t. language models . As a corollary, we show that in the language with the unit there exists a sequent that is true if all variables are interpreted by regular language, but not true in language models in general.},
  archive      = {J_IANDC},
  author       = {Max Kanovich and Stepan Kuznetsov and Andre Scedrov},
  doi          = {10.1016/j.ic.2021.104760},
  journal      = {Information and Computation},
  pages        = {104760},
  shortjournal = {Inf. Comput.},
  title        = {Language models for some extensions of the lambek calculus},
  volume       = {287},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Complexity thresholds in inclusion logic. <em>IANDC</em>,
<em>287</em>, 104759. (<a
href="https://doi.org/10.1016/j.ic.2021.104759">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Inclusion logic differs from many other logics of dependence and independence in that it can only describe polynomial-time properties. In this article we examine more closely connections between syntactic fragments of inclusion logic and different complexity classes. Our focus is on two computational problems: maximal subteam membership and the model checking problem for a fixed inclusion logic formula. We show that very simple quantifier-free formulae with one or two inclusion atoms generate instances of these problems that are complete for (non-deterministic) logarithmic space and polynomial time . We also present a safety game for the maximal subteam membership problem and use it to investigate this problem over teams in which one variable is a key. Furthermore, we relate our findings to consistent query answering over inclusion dependencies, and present a fragment of inclusion logic that captures non-deterministic logarithmic space in ordered models.},
  archive      = {J_IANDC},
  author       = {Miika Hannula and Lauri Hella},
  doi          = {10.1016/j.ic.2021.104759},
  journal      = {Information and Computation},
  pages        = {104759},
  shortjournal = {Inf. Comput.},
  title        = {Complexity thresholds in inclusion logic},
  volume       = {287},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Deducibility and independence in beklemishev’s autonomous
provability calculus. <em>IANDC</em>, <em>287</em>, 104758. (<a
href="https://doi.org/10.1016/j.ic.2021.104758">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Beklemishev introduced an ordinal notation system for the Feferman-Schütte ordinal Γ 0 Γ0 based on the autonomous expansion of provability algebras. In this paper we present the logic BC BC (for Bracket Calculus ). The language of BC BC extends said ordinal notation system to a strictly positive modal language . Thus, unlike other provability logics, BC BC is based on a self-contained signature that gives rise to an ordinal notation system instead of modalities indexed by some ordinal given a priori. The presented logic is proven to be equivalent to RC Γ 0 RCΓ0 , that is, to the strictly positive fragment of GLP Γ 0 GLPΓ0 . We then define a combinatorial statement based on BC BC and show it to be independent of the theory ATR 0 ATR0 of Arithmetical Transfinite Recursion , a theory of second order arithmetic far more powerful than Peano Arithmetic.},
  archive      = {J_IANDC},
  author       = {David Fernández-Duque and Eduardo Hermo-Reyes},
  doi          = {10.1016/j.ic.2021.104758},
  journal      = {Information and Computation},
  pages        = {104758},
  shortjournal = {Inf. Comput.},
  title        = {Deducibility and independence in beklemishev&#39;s autonomous provability calculus},
  volume       = {287},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Hennessy-milner properties via topological compactness.
<em>IANDC</em>, <em>287</em>, 104757. (<a
href="https://doi.org/10.1016/j.ic.2021.104757">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We give Hennessy-Milner classes for intuitionistic, dual-intuitionistic and bi-intuitionistic logic interpreted in intuitionistic Kripke models, and generalise these results to modal (dual- and bi-)intuitionistic logics. Our main technical tools are image-compact and pre-image-compact relations that provide a semantical description of modal saturation properties.},
  archive      = {J_IANDC},
  author       = {Jim de Groot and Dirk Pattinson},
  doi          = {10.1016/j.ic.2021.104757},
  journal      = {Information and Computation},
  pages        = {104757},
  shortjournal = {Inf. Comput.},
  title        = {Hennessy-milner properties via topological compactness},
  volume       = {287},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Non-normal modal logics and conditional logics: Semantic
analysis and proof theory. <em>IANDC</em>, <em>287</em>, 104756. (<a
href="https://doi.org/10.1016/j.ic.2021.104756">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce proper display calculi for basic monotonic modal logic, the conditional logic CK and a number of their axiomatic extensions. These calculi are sound, complete, conservative, and enjoy cut elimination and subformula property . Our proposal applies the multi-type methodology in the design of proper display calculi, starting from a semantic analysis which motivates syntactic translations from single-type non-normal modal logics to multi-type normal poly-modal logics.},
  archive      = {J_IANDC},
  author       = {Jinsheng Chen and Giuseppe Greco and Alessandra Palmigiano and Apostolos Tzimoulis},
  doi          = {10.1016/j.ic.2021.104756},
  journal      = {Information and Computation},
  pages        = {104756},
  shortjournal = {Inf. Comput.},
  title        = {Non-normal modal logics and conditional logics: Semantic analysis and proof theory},
  volume       = {287},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). One-variable fragments of intermediate logics over linear
frames. <em>IANDC</em>, <em>287</em>, 104755. (<a
href="https://doi.org/10.1016/j.ic.2021.104755">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A correspondence is established between one-variable fragments of (first-order) intermediate logics defined over a fixed countable linear frame and Gödel modal logics defined over many-valued equivalence relations with values in a closed subset of the real unit interval. It is also shown that each of these logics can be interpreted in the one-variable fragment of the corresponding constant domain intermediate logic, which is equivalent to a Gödel modal logic defined over (crisp) equivalence relations. Although the latter modal logics in general lack the finite model property with respect to their frame semantics, an alternative semantics is defined that has this property and used to establish co-NP-completeness results for the one-variable fragments of the corresponding intermediate logics both with and without constant domains.},
  archive      = {J_IANDC},
  author       = {Xavier Caicedo and George Metcalfe and Ricardo Rodríguez and Olim Tuyt},
  doi          = {10.1016/j.ic.2021.104755},
  journal      = {Information and Computation},
  pages        = {104755},
  shortjournal = {Inf. Comput.},
  title        = {One-variable fragments of intermediate logics over linear frames},
  volume       = {287},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Exorcising the phantom zone. <em>IANDC</em>, <em>287</em>,
104754. (<a href="https://doi.org/10.1016/j.ic.2021.104754">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper we introduce a language of first-order hybrid logic in which function symbols are interpreted by partial functions and prove a number of completeness results. Syntactically, our language builds on the basic propositional hybrid language, has a primitive unary predicate symbol DEN DEN which tests whether a term denotes or not, and permits satisfaction operators to rigidify predicate and function symbols. Semantically, our system is actualist, allows terms to be undefined, and has no truth-value gaps. But should we follow Fitting and Mendelsohn and rule out domain elements not belonging to any world, or should we tolerate them? Here we explore both options. As we shall see, while the choice makes no difference when it comes to validity, it has consequences for richer logics.},
  archive      = {J_IANDC},
  author       = {Patrick Blackburn and Manuel Martins and María Manzano and Antonia Huertas},
  doi          = {10.1016/j.ic.2021.104754},
  journal      = {Information and Computation},
  pages        = {104754},
  shortjournal = {Inf. Comput.},
  title        = {Exorcising the phantom zone},
  volume       = {287},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Towards a proof theory for quantifier macros.
<em>IANDC</em>, <em>287</em>, 104753. (<a
href="https://doi.org/10.1016/j.ic.2021.104753">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper focuses on globally sound but possibly locally unsound analytic sequent calculi for quantifier macros defined by sequences of quantifiers. It is demonstrated that no locally sound analytic representation based on the usual eigenvariable condition exists. In consequence, representations by globally sound but possibly locally unsound analytic sequent calculi are used. Cut-elimination is shown by translating proofs into LK LK and retranslating cut-free proofs into the desired format. Finally, criteria are given for sequents to be proved without reference to the extended eigenvariable conditions.},
  archive      = {J_IANDC},
  author       = {Matthias Baaz and Anela Lolic},
  doi          = {10.1016/j.ic.2021.104753},
  journal      = {Information and Computation},
  pages        = {104753},
  shortjournal = {Inf. Comput.},
  title        = {Towards a proof theory for quantifier macros},
  volume       = {287},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). 26th workshop on logic, language, information and
computation – WoLLIC 2019. <em>IANDC</em>, <em>287</em>, 104752. (<a
href="https://doi.org/10.1016/j.ic.2021.104752">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_IANDC},
  author       = {Ruy J.G.B. de Queiroz},
  doi          = {10.1016/j.ic.2021.104752},
  journal      = {Information and Computation},
  pages        = {104752},
  shortjournal = {Inf. Comput.},
  title        = {26th workshop on logic, language, information and computation – WoLLIC 2019},
  volume       = {287},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022b). Nonuniform families of polynomial-size quantum finite
automata and quantum logarithmic-space computation with polynomial-size
advice. <em>IANDC</em>, <em>286</em>, 104783. (<a
href="https://doi.org/10.1016/j.ic.2021.104783">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The state complexity of a finite(-state) automaton intuitively measures the size of the description of the automaton . Sakoda and Sipser [STOC 1972, pp. 275–286] were concerned with nonuniform families of finite automata and they discussed the behaviors of the nonuniform complexity classes defined by such families of finite automata having polynomial-size state complexity. In a similar fashion, we introduce state complexity classes using nonuniform families of quantum finite automata empowered by the flexible use of garbage tapes. We first present general inclusion and separation relationships among state complexity classes of nonuniform families of various one-way finite automata, including deterministic, nondeterministic, probabilistic, and quantum finite automata having polynomially many inner states. For two-way quantum finite automata equipped with flexible garbage tapes, we show a close relationship between the state complexity of the nonuniform family of such polynomial-size quantum finite automata and the parameterized complexity class induced by logarithmic-space quantum computation assisted by polynomial-size advice. We further establish a direct connection between space-bounded quantum computation with quantum advice and quantum finite automata whose transitions are dictated by superpositions of transition tables.},
  archive      = {J_IANDC},
  author       = {Tomoyuki Yamakami},
  doi          = {10.1016/j.ic.2021.104783},
  journal      = {Information and Computation},
  pages        = {104783},
  shortjournal = {Inf. Comput.},
  title        = {Nonuniform families of polynomial-size quantum finite automata and quantum logarithmic-space computation with polynomial-size advice},
  volume       = {286},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). The caucal hierarchy: Interpretations in the (w)MSO+u logic.
<em>IANDC</em>, <em>286</em>, 104782. (<a
href="https://doi.org/10.1016/j.ic.2021.104782">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Caucal hierarchy contains graphs that can be obtained from finite directed graphs by alternately applying the unfolding operation and inverse rational mappings. The goal of this work is to check whether the hierarchy is closed under interpretations in logics extending the monadic second-order logic by the unbounding quantifier, U U (saying that a subformula holds for arbitrarily large finite sets). We prove that by applying interpretations described in the MSO+ U fin Ufin logic (hence also in its fragment WMSO+ U U ) to graphs of the Caucal hierarchy we can only obtain graphs on the same level of the hierarchy. Conversely, interpretations described in the more powerful MSO+ U U logic can give us graphs with an undecidable MSO theory, hence outside of the Caucal hierarchy.},
  archive      = {J_IANDC},
  author       = {Paweł Parys},
  doi          = {10.1016/j.ic.2021.104782},
  journal      = {Information and Computation},
  pages        = {104782},
  shortjournal = {Inf. Comput.},
  title        = {The caucal hierarchy: Interpretations in the (W)MSO+U logic},
  volume       = {286},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Enumeration of two dimensional palindromes. <em>IANDC</em>,
<em>286</em>, 104781. (<a
href="https://doi.org/10.1016/j.ic.2021.104781">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We investigate the maximum number of distinct palindromic sub-words in a two-dimensional finite word. We give tight bounds for the maximum number of distinct palindromic sub-words in two-row periodic/aperiodic words. Using this, we give upper bounds for the number of distinct palindromic sub-words for 2D words of larger sizes. Lastly, we propose a better bound for any finite 2D word.},
  archive      = {J_IANDC},
  author       = {Kalpana Mahalingam and Palak Pandoh},
  doi          = {10.1016/j.ic.2021.104781},
  journal      = {Information and Computation},
  pages        = {104781},
  shortjournal = {Inf. Comput.},
  title        = {Enumeration of two dimensional palindromes},
  volume       = {286},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Transformation of variants of petri nets into
context-dependent fusion grammars. <em>IANDC</em>, <em>286</em>, 104780.
(<a href="https://doi.org/10.1016/j.ic.2021.104780">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Fusion grammars are a novel approach to the generation of hypergraph languages. Context-dependent fusion grammars extend them in such a way that the application of fusion rules can be restricted by positive and negative context conditions. In this paper, we show that several variants of Petri nets can be transformed into these grammars such that the reachable markings are in one-to-one correspondence to the members of the generated language. As this includes place/transition systems with inhibitor arcs, we get as a corollary that context-dependent fusion grammars can generate all recursively enumerable languages .},
  archive      = {J_IANDC},
  author       = {Hans-Jörg Kreowski and Sabine Kuske and Aaron Lye},
  doi          = {10.1016/j.ic.2021.104780},
  journal      = {Information and Computation},
  pages        = {104780},
  shortjournal = {Inf. Comput.},
  title        = {Transformation of variants of petri nets into context-dependent fusion grammars},
  volume       = {286},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Efficient representation and counting of antipower factors
in words. <em>IANDC</em>, <em>286</em>, 104779. (<a
href="https://doi.org/10.1016/j.ic.2021.104779">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A k -antipower (for k ≥ 2 k≥2 ) is a concatenation of k distinct words of the same length. Fici et al. (ICALP 2016) initiated the study of antipowers occurring as fragments of a word, whereas Badkobeh et al. (Inf. Process. Lett., 2018) presented first algorithms computing such fragments. We address two open problems originating from the latter work and propose efficient algorithms for counting and reporting fragments being k -antipowers. For a length- n word, our algorithms cost O ( n k log ⁡ k ) O(nklog⁡k) and O ( n k log ⁡ k + C ) O(nklog⁡k+C) time, respectively, where C is the number of reported fragments. We also show that the number of different k -antipower factors of a length- n word can be computed in O ( n k 4 log ⁡ k log ⁡ n ) O(nk4log⁡klog⁡n) time. Finally, we present an improved data structure that checks whether a given fragment is a k -antipower for a given integer k ≥ 2 k≥2 . Our main algorithmic tools are runs and maximal gapped repeats.},
  archive      = {J_IANDC},
  author       = {Tomasz Kociumaka and Jakub Radoszewski and Wojciech Rytter and Juliusz Straszyński and Tomasz Waleń and Wiktor Zuba},
  doi          = {10.1016/j.ic.2021.104779},
  journal      = {Information and Computation},
  pages        = {104779},
  shortjournal = {Inf. Comput.},
  title        = {Efficient representation and counting of antipower factors in words},
  volume       = {286},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). On linear languages recognized by deterministic biautomata.
<em>IANDC</em>, <em>286</em>, 104778. (<a
href="https://doi.org/10.1016/j.ic.2021.104778">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce the notion of a deterministic biautomaton, a device that reads inputs from both ends, and admits at most one computation on every input word. We show that deterministic biautomata recognize a class of languages which is properly included in the class of linear languages, and which is incomparable to the class of languages recognized by deterministic one-turn pushdown automata . We propose three restrictions of the basic model of deterministic biautomata to characterize the classes of languages generated by DL, linear LL(1), and NH-DL grammars. This results in a chain of four subclasses of linear languages in which all inclusions are strict. For these subclasses and basic operations, we show whether or not a particular class is closed under a considered operation. We prove that it is undecidable whether a linear language belongs to any of these four classes and answer some other decidability questions.},
  archive      = {J_IANDC},
  author       = {Galina Jirásková and Ondřej Klíma},
  doi          = {10.1016/j.ic.2021.104778},
  journal      = {Information and Computation},
  pages        = {104778},
  shortjournal = {Inf. Comput.},
  title        = {On linear languages recognized by deterministic biautomata},
  volume       = {286},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). The complexity of regex crosswords. <em>IANDC</em>,
<em>286</em>, 104777. (<a
href="https://doi.org/10.1016/j.ic.2021.104777">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In a typical regex crossword puzzle , one is given two non-empty lists 〈 R 1 , … , R m 〉 〈R1,…,Rm〉 and 〈 C 1 , … , C n 〉 〈C1,…,Cn〉 of regular expressions (regexes) over some alphabet, and the challenge is to fill in an m × n m×n grid of characters such that the string formed by the i th ith row is in L ( R i ) L(Ri) and the string formed by the j th jth column is in L ( C j ) L(Cj) , for all 1 ≤ i ≤ m 1≤i≤m and 1 ≤ j ≤ n 1≤j≤n . We consider a restriction of this puzzle where all the R i Ri are equal to one another and similarly the C j Cj . We consider a 2-player version of this puzzle, showing it to be PSPACE -complete. Using a reduction from 3SAT 3SAT , we also give a new, simple proof of the known result that the existence problem of a solution for the restricted (1-player) puzzle is NP -complete. We also prove NP -completeness where all the row and column regular expressions are equal to each other.},
  archive      = {J_IANDC},
  author       = {Stephen Fenner and Daniel Padé and Thomas Thierauf},
  doi          = {10.1016/j.ic.2021.104777},
  journal      = {Information and Computation},
  pages        = {104777},
  shortjournal = {Inf. Comput.},
  title        = {The complexity of regex crosswords},
  volume       = {286},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Regular matching and inclusion on compressed tree patterns
with constrained context variables. <em>IANDC</em>, <em>286</em>,
104776. (<a href="https://doi.org/10.1016/j.ic.2021.104776">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the complexity of regular matching and inclusion for compressed tree patterns with context variables subject to regular constraints. Context variables with regular constraints permit to properly generalize on unranked tree patterns with hedge variables. Regular inclusion on unranked tree patterns is relevant to certain query answering on Xml streams with references. We show that regular matching and inclusion with regular constraints can be reduced in polynomial time to the corresponding problem without regular constraints.},
  archive      = {J_IANDC},
  author       = {Iovka Boneva and Joachim Niehren and Momar Sakho},
  doi          = {10.1016/j.ic.2021.104776},
  journal      = {Information and Computation},
  pages        = {104776},
  shortjournal = {Inf. Comput.},
  title        = {Regular matching and inclusion on compressed tree patterns with constrained context variables},
  volume       = {286},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022b). Special issue: Selected papers of the 13th international
conference on language and automata theory and applications, LATA 2019.
<em>IANDC</em>, <em>286</em>, 104775. (<a
href="https://doi.org/10.1016/j.ic.2021.104775">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_IANDC},
  author       = {Carlos Martín-Vide and Bianca Truthe},
  doi          = {10.1016/j.ic.2021.104775},
  journal      = {Information and Computation},
  pages        = {104775},
  shortjournal = {Inf. Comput.},
  title        = {Special issue: Selected papers of the 13th international conference on language and automata theory and applications, LATA 2019},
  volume       = {286},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Selected papers from CSCML 2020, the 4th international
symposium on cyber security cryptology and machine learning.
<em>IANDC</em>, <em>285</em>, 104927. (<a
href="https://doi.org/10.1016/j.ic.2022.104927">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_IANDC},
  author       = {Vladimir Kolesnikov ( Editor, CSCML 2020 selected paper )},
  doi          = {10.1016/j.ic.2022.104927},
  journal      = {Information and Computation},
  pages        = {104927},
  shortjournal = {Inf. Comput.},
  title        = {Selected papers from CSCML 2020, the 4th international symposium on cyber security cryptology and machine learning},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Isomorphism testing of read-once functions and polynomials.
<em>IANDC</em>, <em>285</em>, 104921. (<a
href="https://doi.org/10.1016/j.ic.2022.104921">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we study the isomorphism testing problem of formulas in the Boolean and arithmetic settings. We show that isomorphism testing of read-once formulas is complete for log-space. In contrast, we observe that the problem becomes polynomial-time equivalent to the graph isomorphism problem when the input formulas can be represented as OR of two or more read-once formulas. We address the polynomial isomorphism problem, a special case of polynomial equivalence problem which in turn is important from a cryptographic perspective [Patarin EUROCRYPT &#39;96, and Kayal SODA &#39;11]. As our main result, we propose a deterministic polynomial time canonization scheme for polynomials computed by read-once arithmetic formulas. In contrast, we show that when the arithmetic formula is allowed to read a variable twice, this problem is at least as hard as the graph isomorphism problem.},
  archive      = {J_IANDC},
  author       = {Raghavendra Rao B.V. and Jayalal Sarma M.N.},
  doi          = {10.1016/j.ic.2022.104921},
  journal      = {Information and Computation},
  pages        = {104921},
  shortjournal = {Inf. Comput.},
  title        = {Isomorphism testing of read-once functions and polynomials},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Beyond the worst-case analysis of random priority: Smoothed
and average-case approximation ratios in mechanism design.
<em>IANDC</em>, <em>285</em>, 104920. (<a
href="https://doi.org/10.1016/j.ic.2022.104920">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A mechanism for the random assignment problem takes agents&#39; private preferences over items as input and outputs an allocation. One of the mainstream mechanisms, Random Priority , is asymptotically the best mechanism for welfare maximization. However, its approximation ratio is Θ ( n ) Θ(n) , which implies that there is a large discrepancy between its performance and the optimal social welfare. We evaluate the performance of Random Priority beyond the worst-case analysis in the hope of addressing the inconsistency between the widespread use of the mechanism in practice and the undesired theoretical performance guarantee. We show that with small random noise applied to the worst-case inputs, Random Priority has a constant smoothed approximation ratio . When agents&#39; preference values are independent random variables , Random Priority is nearly optimal evaluated by the average-case approximation ratio. En route to these results, we develop analytics tools to show the insights that the efficiency loss is small on most instances. To our limited knowledge, this is the first work that introduces smoothed analysis to algorithmic mechanism design problems. These results may pave the way for further studies for approximate mechanism design problems beyond the worst-case analysis.},
  archive      = {J_IANDC},
  author       = {Xiaotie Deng and Yansong Gao and Jie Zhang},
  doi          = {10.1016/j.ic.2022.104920},
  journal      = {Information and Computation},
  pages        = {104920},
  shortjournal = {Inf. Comput.},
  title        = {Beyond the worst-case analysis of random priority: Smoothed and average-case approximation ratios in mechanism design},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Think globally, act locally: On the optimal seeding for
nonsubmodular influence maximization. <em>IANDC</em>, <em>285</em>,
104919. (<a href="https://doi.org/10.1016/j.ic.2022.104919">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In the influence maximization problem, one chooses a fixed number of initial seeds in a social network to maximize the spread of their influence. We study this problem with the r -complex contagion model, where each uninfected vertex in the network becomes infected if it has at least r infected neighbors. We focus on a random graph model called the stochastic hierarchical blockmodel . When the graph is not exceptionally sparse, under certain mild assumptions, we prove the optimal seeding strategy puts all the seeds in a single community. This matches the intuition that, in a nonsubmodular cascade model, placing seeds near each other creates synergy. However, it sharply contrasts with the intuition for submodular cascade models (e.g., the independent cascade model) in which nearby seeds tend to erode each others&#39; effects. We use this observation to design a polynomial-time dynamic programming algorithm for a slightly more general setting.},
  archive      = {J_IANDC},
  author       = {Grant Schoenebeck and Biaoshuai Tao and Fang-Yi Yu},
  doi          = {10.1016/j.ic.2022.104919},
  journal      = {Information and Computation},
  pages        = {104919},
  shortjournal = {Inf. Comput.},
  title        = {Think globally, act locally: On the optimal seeding for nonsubmodular influence maximization},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Topological mixing notions on turing machine dynamical
systems. <em>IANDC</em>, <em>285</em>, 104915. (<a
href="https://doi.org/10.1016/j.ic.2022.104915">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Over the past few decades, Turing machines have been studied as dynamical systems , with the focus being on their behavior rather than their results. Noteworthy results concerning topological and dynamical properties, such as the existence and undecidability of topological transitivity in TMH and topological minimality in TMT, were established. Both properties are related to reaching finite windows from some or any possible configuration. Nonetheless, both properties exhibit no restriction over the time a machine takes to reach these finite windows. In this article, we focus on the mixing notions: weak mixing, total transitivity and topological mixing . These properties are related to a time window or gap where finite configurations must reach one another. In this article, we analyze the SMART machine to prove that its TMT dynamical model is topologically weak mixing (and therefore totally transitive) and that all mixing notions are undecidable.},
  archive      = {J_IANDC},
  author       = {Rodrigo Torres-Avilés},
  doi          = {10.1016/j.ic.2022.104915},
  journal      = {Information and Computation},
  pages        = {104915},
  shortjournal = {Inf. Comput.},
  title        = {Topological mixing notions on turing machine dynamical systems},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Posets with interfaces as a model for concurrency.
<em>IANDC</em>, <em>285</em>, 104914. (<a
href="https://doi.org/10.1016/j.ic.2022.104914">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce posets with interfaces (iposets) and generalise their standard serial composition to a new gluing composition. In the partial order semantics of concurrency, interfaces and gluing allow modelling events that extend in time and across components. Alternatively, taking a decompositional view, interfaces allow cutting through events, while serial composition may only cut through edges of a poset. We show that iposets under gluing composition form a category, which generalises the monoid of posets under serial composition up to isomorphism. They form a 2-category when a subsumption order and a lax tensor in the form of a non-commutative parallel composition are added, which generalises the interchange monoids used for modelling series-parallel posets. We also study the gluing-parallel hierarchy of iposets, which generalises the standard series-parallel one. The class of gluing-parallel iposets contains that of series-parallel posets and the class of interval orders , which are well studied in concurrency theory, too. We also show that it is strictly contained in the class of all iposets by identifying several forbidden substructures.},
  archive      = {J_IANDC},
  author       = {Uli Fahrenberg and Christian Johansen and Georg Struth and Krzysztof Ziemiański},
  doi          = {10.1016/j.ic.2022.104914},
  journal      = {Information and Computation},
  pages        = {104914},
  shortjournal = {Inf. Comput.},
  title        = {Posets with interfaces as a model for concurrency},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). An auxiliary logic on trees: On the tower-hardness of logics
featuring reachability and submodel reasoning. <em>IANDC</em>,
<em>285</em>, 104911. (<a
href="https://doi.org/10.1016/j.ic.2022.104911">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We describe a set of simple features that are sufficient in order to make the satisfiability problem of logics interpreted on trees Tower -hard. We exhibit these features through an Auxiliary Logic on Trees ( ALT ), a modal logic that essentially deals with reachability of a fixed node inside a forest and features modalities from sabotage modal logic to reason on submodels. After showing that ALT admits a Tower -complete satisfiability problem, we prove that this logic is captured by four other logics that were independently found to be Tower -complete: two-variables separation logic, quantified computation tree logic, modal logic of heaps and modal separation logic. As a by-product of establishing these connections, we discover strict fragments of these logics that are still non-elementary.},
  archive      = {J_IANDC},
  author       = {Alessio Mansutti},
  doi          = {10.1016/j.ic.2022.104911},
  journal      = {Information and Computation},
  pages        = {104911},
  shortjournal = {Inf. Comput.},
  title        = {An auxiliary logic on trees: On the tower-hardness of logics featuring reachability and submodel reasoning},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Information leakage due to operative errors in card-based
protocols. <em>IANDC</em>, <em>285</em>, 104910. (<a
href="https://doi.org/10.1016/j.ic.2022.104910">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Card-based protocols provide secure multi-party computation using a deck of physical cards via a series of operations, such as shuffling and turning over cards, that are executed by humans. Although almost all existing protocols have been designed to be perfectly secure, operative errors by humans can lead to information leakage . In this paper, we propose a technique for analyzing information leakage due to operative errors in card-based protocols. In particular, we introduce a concept, which we call a “probability trace,” and by enhancing the KWH diagram proposed by Koch, Walzer, and Härtel, we propose a diagrammatic representation for displaying the amount of information leaked. By applying our diagram to a card-based protocol with an operative error, we can precisely reveal the leakage of players&#39; inputs from the protocol output. In addition, we discuss how to detect human errors when people execute the existing six-card AND protocol.},
  archive      = {J_IANDC},
  author       = {Takaaki Mizuki and Yuichi Komano},
  doi          = {10.1016/j.ic.2022.104910},
  journal      = {Information and Computation},
  pages        = {104910},
  shortjournal = {Inf. Comput.},
  title        = {Information leakage due to operative errors in card-based protocols},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Geometric bounds for convergence rates of averaging
algorithms. <em>IANDC</em>, <em>285</em>, 104909. (<a
href="https://doi.org/10.1016/j.ic.2022.104909">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We develop a generic method for bounding the convergence rate of an averaging algorithm running in a multiagent system with a time-varying network, where the associated stochastic matrices have a time-independent Perron vector. The resulting bounds depend on geometric parameters of the dynamic communication graph such as the weighted diameter or the bottleneck measure. As corollaries, we show that the convergence rate of the Metropolis algorithm in a system of n agents is less than 1 − 1 / 4 n 2 1−1/4n2 if the communication graph is permanently connected and bidirectional. We prove a similar upper bound for the EqualNeighbor algorithm under the additional assumptions that the number of neighbors of each agent is constant and the communication graph is not too irregular. In general, our bounds offer improved convergence rates for several averaging algorithms and specific families of communication graphs.},
  archive      = {J_IANDC},
  author       = {Bernadette Charron-Bost},
  doi          = {10.1016/j.ic.2022.104909},
  journal      = {Information and Computation},
  pages        = {104909},
  shortjournal = {Inf. Comput.},
  title        = {Geometric bounds for convergence rates of averaging algorithms},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Rule synchronization for monodirectional tissue-like p
systems with channel states. <em>IANDC</em>, <em>285</em>, 104895. (<a
href="https://doi.org/10.1016/j.ic.2022.104895">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Monodirectional tissue-like P systems with channel states is a kind of computation model in the area of membrane computing, which evolves by the transfer of objects in one direction for two given regions. In this article, we consider monodirectional tissue-like P systems with channel states , wherein rules are used sequentially for each channel and in a maximally parallel manner for the system by incorporating rule synchronization. We prove that the designed monodirectional tissue-like P systems are universal when using two cells, three states, and rules with a maximal length of 1, or using two cells, two states, and rules with a maximal length of 2, or using any number of cells, two states, and rules with a maximal length of 1. The results show that rule synchronization is an effective strategy to enhance the computational power of monodirectional tissue-like P systems with channel states.},
  archive      = {J_IANDC},
  author       = {Yanyan Li and Bosheng Song and Xiangxiang Zeng},
  doi          = {10.1016/j.ic.2022.104895},
  journal      = {Information and Computation},
  pages        = {104895},
  shortjournal = {Inf. Comput.},
  title        = {Rule synchronization for monodirectional tissue-like p systems with channel states},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Fast mixing via polymers for random graphs with unbounded
degree. <em>IANDC</em>, <em>285</em>, 104894. (<a
href="https://doi.org/10.1016/j.ic.2022.104894">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The polymer model framework is a classical tool from statistical mechanics that has recently been used to obtain approximation algorithms for spin systems on classes of bounded-degree graphs; examples include the ferromagnetic Potts model on expanders and on the grid. One of the key ingredients in the analysis of polymer models is controlling the growth rate of the number of polymers, which has been typically achieved so far by invoking the bounded-degree assumption. Nevertheless, this assumption is often restrictive and obstructs the applicability of the method to more general graphs. For example, sparse random graphs typically have bounded average degree and good expansion properties, but they include vertices with unbounded degree, and therefore are excluded from the current polymer-model framework. We develop a less restrictive framework for polymer models that relaxes the standard bounded-degree assumption, by reworking the relevant polymer models from the edge perspective. The edge perspective allows us to bound the growth rate of the number of polymers in terms of the total degree of polymers, which in turn can be related more easily to the expansion properties of the underlying graph. To apply our methods, we consider random graphs with unbounded degrees from a fixed degree sequence (with minimum degree at least 3) and obtain approximation algorithms for the ferromagnetic Potts model, which is a standard benchmark for polymer models. Our techniques also extend to more general spin systems.},
  archive      = {J_IANDC},
  author       = {Andreas Galanis and Leslie Ann Goldberg and James Stewart},
  doi          = {10.1016/j.ic.2022.104894},
  journal      = {Information and Computation},
  pages        = {104894},
  shortjournal = {Inf. Comput.},
  title        = {Fast mixing via polymers for random graphs with unbounded degree},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Fairness and communication-based semantics for session-typed
languages. <em>IANDC</em>, <em>285</em>, 104892. (<a
href="https://doi.org/10.1016/j.ic.2022.104892">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Polarized SILL is a programming language that combines functional programming with session-typed message-passing concurrency. It features general recursion; code and channel transmission; and synchronous and asynchronous communication . To reason about Polarized SILL programs, we develop the first program equivalence framework based on observable communications. We give meaning to Polarized SILL programs using an observed communication semantics (OCS). Our OCS is the first to support general recursion and code transmission. We then develop a communication-based testing equivalences framework and show that one of the equivalences captured by our framework coincides with barbed congruence, the canonical notion of process equivalence. Polarized SILL&#39;s operational semantics is specified using a multiset rewriting system . We introduce fairness for multiset rewriting systems to ensure that our OCS is well-defined in the presence of non-terminating processes, and use fairness properties to simplify reasoning about processes. This work lays the foundation for observational reasoning for session-typed languages with general recursion.},
  archive      = {J_IANDC},
  author       = {Ryan Kavanagh},
  doi          = {10.1016/j.ic.2022.104892},
  journal      = {Information and Computation},
  pages        = {104892},
  shortjournal = {Inf. Comput.},
  title        = {Fairness and communication-based semantics for session-typed languages},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Optimizing reachability sets in temporal graphs by delaying.
<em>IANDC</em>, <em>285</em>, 104890. (<a
href="https://doi.org/10.1016/j.ic.2022.104890">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A temporal graph is a dynamic graph where every edge is assigned a set of integer time labels that indicate at which discrete time step the edge is available. In this paper, we study how changes of the time labels, corresponding to delays on the availability of the edges, affect the reachability sets from given sources. We introduce control mechanisms for reachability sets that are based on two natural operations of delaying. The first operation, termed merging, is global and batches together consecutive time labels into a single time label in the whole network simultaneously. The second, imposes independent delays on the time labels of every edge of the graph. We provide a thorough investigation of the computational complexity of different objectives related to reachability sets when these operations are used.},
  archive      = {J_IANDC},
  author       = {Argyrios Deligkas and Igor Potapov},
  doi          = {10.1016/j.ic.2022.104890},
  journal      = {Information and Computation},
  pages        = {104890},
  shortjournal = {Inf. Comput.},
  title        = {Optimizing reachability sets in temporal graphs by delaying},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Characterising spectra of equivalences for event structures,
logically. <em>IANDC</em>, <em>285</em>, 104887. (<a
href="https://doi.org/10.1016/j.ic.2022.104887">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present a logical characterisation of the equivalences in the spectrum for labelled Prime Event Structures (PESs) and use it for also studying how such spectrum changes when restricting to subclasses of event structures. We first show that a minor modification of the logic characterising hereditary history preserving bisimilarity induces PES isomorphism as logical equivalence. Then, we distill fragments of the logic that characterise all the equivalences in the aforementioned spectrum. In particular, we single out logics for interleaving/step/pomset trace equivalences and weak (pomset) history preserving bisimilarity, which were missing. Finally, we apply our logical characterisation to investigate how the spectrum simplifies when we restrict to subclasses of event structures: Coherence Spaces, where causality is absent, and Elementary Event Structures, where instead conflicts are not allowed. Inclusions between behavioural equivalences are proved by providing encodings between the corresponding sublogics, whereas the non-inclusion between equivalences is witnessed by using distinguishing formulae, i.e., by providing structures which are identified by an equivalence and distinguished by a formula in the logics of the other equivalence.},
  archive      = {J_IANDC},
  author       = {Paolo Baldan and Daniele Gorla and Tommaso Padoan and Ivano Salvo},
  doi          = {10.1016/j.ic.2022.104887},
  journal      = {Information and Computation},
  pages        = {104887},
  shortjournal = {Inf. Comput.},
  title        = {Characterising spectra of equivalences for event structures, logically},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Value iteration for simple stochastic games: Stopping
criterion and learning algorithm. <em>IANDC</em>, <em>285</em>, 104886.
(<a href="https://doi.org/10.1016/j.ic.2022.104886">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The classical problem of reachability in simple stochastic games is typically solved by value iteration (VI), which produces a sequence of under-approximations of the value of the game, but is only guaranteed to converge in the limit. We provide an additional converging sequence of over-approximations, based on an analysis of the game graph. Together, these two sequences entail the first error bound and hence the first stopping criterion for VI on simple stochastic games, indicating when the algorithm can be stopped for a given precision. Consequently, VI becomes an anytime algorithm returning the approximation of the value and the current error bound. We further use this error bound to provide a learning-based asynchronous VI algorithm; it uses simulations and thus often avoids exploring the whole game graph, but still yields the same guarantees. Finally, we experimentally show that the overhead for computing the additional sequence of over-approximations often is negligible.},
  archive      = {J_IANDC},
  author       = {Julia Eisentraut and Edon Kelmendi and Jan Křetínský and Maximilian Weininger},
  doi          = {10.1016/j.ic.2022.104886},
  journal      = {Information and Computation},
  pages        = {104886},
  shortjournal = {Inf. Comput.},
  title        = {Value iteration for simple stochastic games: Stopping criterion and learning algorithm},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Linear construction of a left lyndon tree. <em>IANDC</em>,
<em>285</em>, 104884. (<a
href="https://doi.org/10.1016/j.ic.2022.104884">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We extend the left-to-right Lyndon factorisation of a word to the left Lyndon tree construction of a Lyndon word. It yields an algorithm to sort the prefixes of a Lyndon word according to the infinite ordering defined by Dolce et al. (2019). A straightforward variant computes the left Lyndon forest of a word. All algorithms run in linear time on a general alphabet, that is, in the letter-comparison model.},
  archive      = {J_IANDC},
  author       = {Golnaz Badkobeh and Maxime Crochemore},
  doi          = {10.1016/j.ic.2022.104884},
  journal      = {Information and Computation},
  pages        = {104884},
  shortjournal = {Inf. Comput.},
  title        = {Linear construction of a left lyndon tree},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Automatic winning shifts. <em>IANDC</em>, <em>285</em>,
104883. (<a href="https://doi.org/10.1016/j.ic.2022.104883">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {To each one-dimensional subshift X , we may associate a winning shift W(X) which arises from a combinatorial game played on the language of X . Previously it has been studied what properties of X does W(X) inherit. For example, X and W(X) have the same factor complexity and if X is a sofic subshift, then W(X) is also sofic. In this paper, we develop a notion of automaticity for W(X) , that is, we propose what it means that a vector representation of W(X) is accepted by a finite automaton . Let S be an abstract numeration system such that addition with respect to S is a rational relation. Let X be a subshift generated by an S -automatic word. We prove that as long as there is a bound on the number of nonzero symbols in configurations of W(X) (which follows from X having sublinear factor complexity), then W(X) is accepted by a finite automaton , which can be effectively constructed from the description of X . We provide an explicit automaton when X is generated by certain automatic words such as the Thue-Morse word.},
  archive      = {J_IANDC},
  author       = {Jarkko Peltomäki and Ville Salo},
  doi          = {10.1016/j.ic.2022.104883},
  journal      = {Information and Computation},
  pages        = {104883},
  shortjournal = {Inf. Comput.},
  title        = {Automatic winning shifts},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Towards self-stabilizing blockchain, reconstructing totally
erased blockchain. <em>IANDC</em>, <em>285</em>, 104881. (<a
href="https://doi.org/10.1016/j.ic.2022.104881">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Blockchains are commonly used for crypto-currency systems, where they publicly store transactions. In a permissioned blockchain, only a few participants (nodes) can push new transactions to the chain. The known boundary on the number of faulty participants – up to f for 3 f + 1 participants – may be surpassed, causing the underlying consensus algorithm (BFT) to fail. When a malicious adversary compromises or corrupts enough nodes it may lead to the complete corruption of the ledger and even to the destruction of ledger copies the nodes hold. We suggest a reconstruction solution for the blockchain in the event of such an attack. We present a technique using verifiable secret sharing (VSS), making our solution immediate, requires no trust between the different blockchain parties, and provides each user an independent reconstruction. Our solution enables the exposure of an end-user&#39;s private key in case of dishonest reconstruction, thus, removing the incentive of such an act.},
  archive      = {J_IANDC},
  author       = {Shlomi Dolev and Matan Liber},
  doi          = {10.1016/j.ic.2022.104881},
  journal      = {Information and Computation},
  pages        = {104881},
  shortjournal = {Inf. Comput.},
  title        = {Towards self-stabilizing blockchain, reconstructing totally erased blockchain},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Preface to special issue for DCC 2020. <em>IANDC</em>,
<em>285</em>, 104880. (<a
href="https://doi.org/10.1016/j.ic.2022.104880">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_IANDC},
  author       = {Travis Gagie},
  doi          = {10.1016/j.ic.2022.104880},
  journal      = {Information and Computation},
  pages        = {104880},
  shortjournal = {Inf. Comput.},
  title        = {Preface to special issue for DCC 2020},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Nearest neighbor representations of boolean functions.
<em>IANDC</em>, <em>285</em>, 104879. (<a
href="https://doi.org/10.1016/j.ic.2022.104879">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A nearest neighbor representation of a Boolean function is a set of positive and negative prototypes in R n Rn such that the function has value 1 on an input iff the closest prototype is positive. For k -nearest neighbor representation the majority classification of the k closest prototypes is considered. The nearest neighbor complexity of a Boolean function is the minimal number of prototypes needed to represent the function. We give several bounds for this measure. Separations are given between the cases when prototypes can be real or are required to be Boolean. The complexity of parity is determined exactly. An exponential lower bound is given for mod 2 inner product, and a linear lower bound is given for its k -nearest neighbor complexity. The results are proven using connections to other models such as polynomial threshold functions over { 1 , 2 } {1,2} . We also discuss some of the many open problems arising.},
  archive      = {J_IANDC},
  author       = {Péter Hajnal and Zhihao Liu and György Turán},
  doi          = {10.1016/j.ic.2022.104879},
  journal      = {Information and Computation},
  pages        = {104879},
  shortjournal = {Inf. Comput.},
  title        = {Nearest neighbor representations of boolean functions},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). A discrete and continuous study of the max-chain-formation
problem. <em>IANDC</em>, <em>285</em>, 104877. (<a
href="https://doi.org/10.1016/j.ic.2022.104877">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce and study the Max-Chain-Formation problem, where n robots are ordered along a winding chain and must form a connected, straight line of maximal length connecting its two endpoints. We propose and analyze strategies in a discrete and a continuous time model . In the discrete case, we give a complete analysis if the positions of all robots are initially collinear , showing that the worst-case time to reach an ε -approximation is upper bounded by O ( n 2 ⋅ log ⁡ ( n / ε ) ) O(n2⋅log⁡(n/ε)) and lower bounded by Ω ( n 2 ⋅ log ⁡ ( 1 / ε ) ) Ω(n2⋅log⁡(1/ε)) . In the non-collinear case, we identify a family of instances whose runtime is unbounded. The picture in the continuous case is different: we propose a strategy with an optimal runtime of Θ ( n ) Θ(n) . Avoiding an unbounded runtime similar to the discrete case relies crucially on a counter-intuitive aspect: slowing down the endpoints while all other robots move at full speed.},
  archive      = {J_IANDC},
  author       = {Jannik Castenow and Peter Kling and Till Knollmann and Friedhelm Meyer auf der Heide},
  doi          = {10.1016/j.ic.2022.104877},
  journal      = {Information and Computation},
  pages        = {104877},
  shortjournal = {Inf. Comput.},
  title        = {A discrete and continuous study of the max-chain-formation problem},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). On continued fraction randomness and normality.
<em>IANDC</em>, <em>285</em>, 104876. (<a
href="https://doi.org/10.1016/j.ic.2022.104876">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Recently, Scheerer [22] and Vandehey [24] showed that normality for continued fraction expansions and base- b expansions are incomparable notions. This shows that at some level, randomness for continued fractions and binary expansion are different statistical concepts. In contrast, we show that the continued fraction expansion of a real is computably random if and only if its binary expansion is computably random. To quantify the degree to which a continued fraction fails to be effectively random, we define the effective Hausdorff dimension of individual continued fractions, explicitly constructing continued fractions with dimension 0 and 1.},
  archive      = {J_IANDC},
  author       = {Satyadev Nandakumar and Prateek Vishnoi},
  doi          = {10.1016/j.ic.2022.104876},
  journal      = {Information and Computation},
  pages        = {104876},
  shortjournal = {Inf. Comput.},
  title        = {On continued fraction randomness and normality},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Incentive ratio: A game theoretical analysis of market
equilibria. <em>IANDC</em>, <em>285</em>, 104875. (<a
href="https://doi.org/10.1016/j.ic.2022.104875">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In a Fisher market, the market maker sells m products to n potential agents. The agents submit their utility functions and money endowments to the market maker, who, upon receiving submitted information, derives market equilibrium prices and allocations of the products. Agents are self-interested entities who wish to maximize their utility, and they may misreport their private information for this purpose. The incentive ratio characterizes the extent to which strategic plays can increase an agent&#39;s utility. While agents do benefit by misreporting their private information, we show that the ratio of improvement by a unilateral strategic play is no more than two in markets with gross substitute utilities for the agents. Moreover, it can be pinned down to e 1 / e ≈ 1.445 e1/e≈1.445 in Cobb-Douglas markets. For the Leontief markets in which products are complementary, we show that the incentive ratio is at most two as well.},
  archive      = {J_IANDC},
  author       = {Ning Chen and Xiaotie Deng and Bo Tang and Hongyang Zhang and Jie Zhang},
  doi          = {10.1016/j.ic.2022.104875},
  journal      = {Information and Computation},
  pages        = {104875},
  shortjournal = {Inf. Comput.},
  title        = {Incentive ratio: A game theoretical analysis of market equilibria},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). On quotients of formal power series. <em>IANDC</em>,
<em>285</em>, 104874. (<a
href="https://doi.org/10.1016/j.ic.2022.104874">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Quotient is a basic operation of formal languages, which plays a key role in the construction of minimal deterministic finite automata (DFA) and the universal automata . In this paper, we extend this operation to formal power series and systemically investigate its implications in the study of weighted automata . In particular, we define two quotient operations for formal power series which are called (left or right) quotients and (left or right) residuals respectively. Algebraic properties of the quotient operation and closure properties (w.r.t. regular and context-free series) under quotients and residuals are also investigated for formal power series. Using these operations, we define for each formal power series A two weighted automata that accept A . The first is the minimal deterministic weighted automaton of A , and the second is the universal weighted automaton of A . An effective algebraic method to construct the universal automaton is also presented.},
  archive      = {J_IANDC},
  author       = {Yongming Li and Qian Wang and Sanjiang Li},
  doi          = {10.1016/j.ic.2022.104874},
  journal      = {Information and Computation},
  pages        = {104874},
  shortjournal = {Inf. Comput.},
  title        = {On quotients of formal power series},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022a). Greibach normal form for ω-algebraic systems and weighted
simple ω-pushdown automata. <em>IANDC</em>, <em>285</em>, 104871. (<a
href="https://doi.org/10.1016/j.ic.2022.104871">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In weighted automata theory , many classical results on formal languages have been extended into a quantitative setting. Here, we investigate weighted context-free languages of infinite words, a generalization of ω -context-free languages (as introduced by Cohen and Gold in 1977) and an extension of weighted context-free languages of finite words (that were already investigated by Chomsky and Schützenberger in 1963). As in the theory of formal grammars, these weighted context-free languages, or ω -algebraic series, can be represented as solutions of mixed ω -algebraic systems of equations and by weighted ω -pushdown automata . In our first main result, we show that (mixed) ω -algebraic systems can be transformed into Greibach normal form . We use the Greibach normal form in our second main result to prove that simple ω-reset pushdown automata recognize all ω -algebraic series. Simple ω -reset automata do not use ϵ -transitions and can change the stack only by at most one symbol. These results generalize fundamental properties of context-free languages to weighted context-free languages.},
  archive      = {J_IANDC},
  author       = {Manfred Droste and Sven Dziadek and Werner Kuich},
  doi          = {10.1016/j.ic.2022.104871},
  journal      = {Information and Computation},
  pages        = {104871},
  shortjournal = {Inf. Comput.},
  title        = {Greibach normal form for ω-algebraic systems and weighted simple ω-pushdown automata},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). On the decidability of the valuedness problem for two-way
finite transducers. <em>IANDC</em>, <em>285</em>, 104870. (<a
href="https://doi.org/10.1016/j.ic.2022.104870">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A transducer is infinite-valued if the maximal number of different outputs for an input string is not bounded by any constant. For one-way finite transducers, sufficient and necessary conditions exist in terms of the structure of a transducer to characterize whether the transducer is infinite-valued or not, yielding the decidability result of the finite-valuedness problem. As crossing sequences in two-way automata often play similar roles as states in their one-way counterparts, we consider analogous criteria in the setting of crossing sequences to characterize the infinite-valuedness of two-way finite transducers. The characterization leads to a decidability proof for the valuedness problem of two-way finite transducers.},
  archive      = {J_IANDC},
  author       = {Di-De Yen and Hsu-Chun Yen},
  doi          = {10.1016/j.ic.2022.104870},
  journal      = {Information and Computation},
  pages        = {104870},
  shortjournal = {Inf. Comput.},
  title        = {On the decidability of the valuedness problem for two-way finite transducers},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Store-collect in the presence of continuous churn with
application to snapshots and lattice agreement. <em>IANDC</em>,
<em>285</em>, 104869. (<a
href="https://doi.org/10.1016/j.ic.2022.104869">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present an algorithm for implementing a store-collect object in an asynchronous crash-prone message-passing dynamic system, where nodes continually enter and leave. The algorithm is very simple and efficient, requiring just one round trip for a store operation and two for a collect. We then show the versatility of the store-collect object for implementing churn-tolerant versions of useful data structures , while shielding the user from the complications of the underlying churn. In particular, we present elegant and efficient implementations of atomic snapshot and generalized lattice agreement objects that use store-collect.},
  archive      = {J_IANDC},
  author       = {Hagit Attiya and Sweta Kumari and Archit Somani and Jennifer L. Welch},
  doi          = {10.1016/j.ic.2022.104869},
  journal      = {Information and Computation},
  pages        = {104869},
  shortjournal = {Inf. Comput.},
  title        = {Store-collect in the presence of continuous churn with application to snapshots and lattice agreement},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Compact representation of graphs with bounded bandwidth or
treedepth. <em>IANDC</em>, <em>285</em>, 104867. (<a
href="https://doi.org/10.1016/j.ic.2022.104867">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the problem of compact representation of graphs that have small bandwidth as well as graphs that have small treedepth . We present navigation oracles that support degree and adjacency queries in constant time and neighborhood queries in constant time per neighbor. For graphs of size n and bandwidth k , our oracle takes ( k + ⌈ log ⁡ 2 k ⌉ ) n + o ( k n ) (k+⌈log⁡2k⌉)n+o(kn) bits. We also show that ( k − 5 k − 4 ) n − O ( k 2 ) (k−5k−4)n−O(k2) bits are required to encode such graphs. For graphs of size n and treedepth k , we present an oracle that takes ( k + ⌈ log ⁡ k ⌉ + 2 ) n + o ( k n ) (k+⌈log⁡k⌉+2)n+o(kn) bits and complement it with lower bounds that show our oracle is compact for specific ranges of k . Our navigation oracles for both treedepth and treedepth parameters can be augmented, with additional n + o ( n ) n+o(n) bits, to support connectivity queries in constant time.},
  archive      = {J_IANDC},
  author       = {Shahin Kamali},
  doi          = {10.1016/j.ic.2022.104867},
  journal      = {Information and Computation},
  pages        = {104867},
  shortjournal = {Inf. Comput.},
  title        = {Compact representation of graphs with bounded bandwidth or treedepth},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). A new framework for deniable secure key exchange.
<em>IANDC</em>, <em>285</em>, 104866. (<a
href="https://doi.org/10.1016/j.ic.2022.104866">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A deniable secure key exchange protocol allows two parties to agree on a common secret while achieving two seemingly contradictory functionalities: authentication and deniability. The former requires each party to confirm the identity of the other while the latter requires any attacker (e.g., participant or eavesdropper) be unable to prove to a third party an honest party&#39;s participation. Designing an efficient secure key exchange with deniability is a challenging problem. In this paper, we first formalize the deniability model by requiring information theoretic deniability with an eavesdropping attack . The information theoretic deniability has the advantage that it can hold forever without any computational assumption. An eavesdropping attack (Di Raimondo et al., CCS&#39;06) allows an attacker to apply eavesdropped transcripts into an active attack session. This gives an attacker more power to make the victim undeniable as he does not know the randomness of the transcript. We then propose an efficient, provably deniable secure framework of key exchange. Our deniability holds non-adaptively in the eavesdropping model. However, if we consider a model without an eavesdropping attack (which is practical in many scenarios), then our framework is proven adaptively deniable. This is important since no previous key exchange protocols can satisfy our adaptive and information theoretical deniability. We give a concrete realization for our framework that is more efficient than SKEME (Krawczyk, NDSS&#39;96).},
  archive      = {J_IANDC},
  author       = {Shaoquan Jiang and Yeow Meng Chee and San Ling and Huaxiong Wang and Chaoping Xing},
  doi          = {10.1016/j.ic.2022.104866},
  journal      = {Information and Computation},
  pages        = {104866},
  shortjournal = {Inf. Comput.},
  title        = {A new framework for deniable secure key exchange},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Specification and optimal reactive synthesis of run-time
enforcement shields. <em>IANDC</em>, <em>285</em>, 104865. (<a
href="https://doi.org/10.1016/j.ic.2022.104865">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A run time enforcement shield is a controller which corrects the output O of a system with sporadic errors (SSE) so as to guarantee the invariance of a critical requirement. Moreover, the shield output O ′ O′ must deviate from the SSE output O “as little as possible” to maintain the quality. We give a method for logical specification of shields using logic QDDC . The specification consists of a correctness requirement REQ , a mandatory hard deviation constraint HDC , and a soft deviation constraint SDC whose satisfaction must be optimized in an H -optimal fashion. We show how a tool DCSynth implementing soft requirement guided synthesis is used for the automatic synthesis of shields from such specifications. Next, we give logical formulation of various notions of shields including Bloem&#39;s k -Stabilizing shield, Wu&#39;s Burst-error shield, as well as new EK -shield and Windowed- EK -shield. We experimentally compare the performance of the shields synthesized under these notions.},
  archive      = {J_IANDC},
  author       = {Paritosh K. Pandya and Amol Wakankar},
  doi          = {10.1016/j.ic.2022.104865},
  journal      = {Information and Computation},
  pages        = {104865},
  shortjournal = {Inf. Comput.},
  title        = {Specification and optimal reactive synthesis of run-time enforcement shields},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Higher order monotonicity and submodularity of influence in
social networks: From local to global. <em>IANDC</em>, <em>285</em>,
104864. (<a href="https://doi.org/10.1016/j.ic.2022.104864">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Kempe, Kleinberg and Tardos (KKT) proposed the following conjecture about the general threshold model in social networks: local monotonicity and submodularity implies global monotonicity and submodularity. That is, if the threshold function of every node is monotone and submodular, then the spread function is monotone and submodular. The correctness of this conjecture has been proved by Mossel and Roch. In this paper, we first provide the concept AD- k (Alternating Difference- k ) as a generalization of monotonicity and submodularity. Specifically, a set function f is called AD- k if all the ℓ -th order differences of f on all inputs have sign ( − 1 ) ℓ + 1 (−1)ℓ+1 for every ℓ ≤ k ℓ≤k . We propose a refined version of KKT&#39;s conjecture: in the general threshold model, local AD- k implies global AD- k . We prove the correctness of our conjecture when the social graph is a DAG. Furthermore, we affirm our conjecture on general social graphs when k = ∞ k=∞ .},
  archive      = {J_IANDC},
  author       = {Wei Chen and Qiang Li and Xiaohan Shan and Xiaoming Sun and Jialin Zhang},
  doi          = {10.1016/j.ic.2022.104864},
  journal      = {Information and Computation},
  pages        = {104864},
  shortjournal = {Inf. Comput.},
  title        = {Higher order monotonicity and submodularity of influence in social networks: From local to global},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Counting (watson-crick) palindromes in watson-crick
conjugates. <em>IANDC</em>, <em>285</em>, 104863. (<a
href="https://doi.org/10.1016/j.ic.2021.104863">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A DNA string is a Watson-Crick (WK-)palindrome when the complement of its reverse is equal to itself. The Watson-Crick mapping θ is an involution that is also an antimorphism. In this paper, we study a generalization of conjugates of a word that incorporate the notion of WK-involution θ called θ -conjugates or WK-conjugates. We consider some general properties of the set C θ ( w ) Cθ(w) , i.e., the set of θ -conjugates of a word w . We characterize words with the same set of θ -conjugates and also provide words where the set of conjugates of a word is equal to the set of θ -conjugates of the word. We study the distribution of palindromes and Watson-Crick palindromes, also known as θ -palindromes, among both the set of conjugates and θ -conjugates of a word w . We also find the structure of words that have at least one (WK-)palindrome in C θ ( w ) Cθ(w) .},
  archive      = {J_IANDC},
  author       = {Kalpana Mahalingam and Anuran Maity and Palak Pandoh},
  doi          = {10.1016/j.ic.2021.104863},
  journal      = {Information and Computation},
  pages        = {104863},
  shortjournal = {Inf. Comput.},
  title        = {Counting (Watson-crick) palindromes in watson-crick conjugates},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). A practical succinct dynamic graph representation.
<em>IANDC</em>, <em>285</em>, 104862. (<a
href="https://doi.org/10.1016/j.ic.2021.104862">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We address the problem of representing dynamic graphs using k 2 k2 -trees. The k 2 k2 -tree data structure is one of the succinct data structures proposed for representing static graphs, and binary relations in general. It relies on compact representations of bit vectors. Hence, by relying on compact representations of dynamic bit vectors, we can also represent dynamic graphs. However, this approach suffers of a well known bottleneck in compressed dynamic indexing. In this paper we present a k 2 k2 -tree based implementation which follows instead the ideas by Munro et al. (PODS 2015) to circumvent this bottleneck. We present two dynamic graph k 2 k2 -tree implementations, one as a standalone implementation and another as a C++ library. The library includes efficient edge and neighbourhood iterators, as well as some illustrative algorithms. Our experimental results show that these implementations are competitive in practice.},
  archive      = {J_IANDC},
  author       = {Miguel E. Coimbra and Joana Hrotkó and Alexandre P. Francisco and Luís M.S. Russo and Guillermo de Bernardo and Susana Ladra and Gonzalo Navarro},
  doi          = {10.1016/j.ic.2021.104862},
  journal      = {Information and Computation},
  pages        = {104862},
  shortjournal = {Inf. Comput.},
  title        = {A practical succinct dynamic graph representation},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Automatic pre- and postconditions for partial differential
equations. <em>IANDC</em>, <em>285</em>, 104860. (<a
href="https://doi.org/10.1016/j.ic.2021.104860">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Based on an automata-theoretic and algebraic framework, we study equational reasoning for Initial Value Problems ( ivp s) of polynomial Partial Differential Equations ( pde s). We first characterize the solutions of a pde system Σ in terms of the final morphism from a coalgebra induced by Σ to the coalgebra of formal power series ( fps ). fps solutions conservatively extend the classical analytic ones. To express ivp s in their general form, we then introduce stratified systems, where the specification of a function can be decomposed into distinct subsystems of pde s. We lift the existence and uniqueness result of fps solutions to stratified systems. We then give a relatively complete algorithm to compute weakest preconditions and strongest postconditions for such systems. To some extent, this result reduces equational reasoning on pde initial value problems to algebraic reasoning. We illustrate some experiments conducted with a proof-of-concept implementation of the method.},
  archive      = {J_IANDC},
  author       = {Michele Boreale},
  doi          = {10.1016/j.ic.2021.104860},
  journal      = {Information and Computation},
  pages        = {104860},
  shortjournal = {Inf. Comput.},
  title        = {Automatic pre- and postconditions for partial differential equations},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). LZRR: LZ77 parsing with right reference. <em>IANDC</em>,
<em>285</em>, 104859. (<a
href="https://doi.org/10.1016/j.ic.2021.104859">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Lossless data compression has been widely studied in computer science. One of the most widely used lossless data compressions is Lempel-Ziv (LZ) 77 parsing , which achieves a high compression ratio. Bidirectional (a.k.a. macro ) parsing is a lossless data compression technique that computes a sequence of phrases copied from another substring ( target phrase ) on either the left or the right position in an input string. Navarro et al. recently showed that a large gap may exist between the size of the smallest bidirectional parse of a given string and that of LZ77 parsing. In addition, finding the smallest bidirectional parse of a given text is NP-complete. Several variants of bidirectional parsing algorithm have been proposed thus far, but no prior work for bidirectional parsing algorithm has achieved compression that is at least as good as LZ77 parsing for any string. In this paper, we present the first practical bidirectional parsing algorithm named LZ77 parsing with right reference (LZRR) , in which the number of LZRR phrases is theoretically guaranteed to be not larger than the number of LZ77 phrases. Experimental results using benchmark strings show that the number of LZRR phrases is approximately six percent smaller than that of LZ77 phrases.},
  archive      = {J_IANDC},
  author       = {Takaaki Nishimoto and Yasuo Tabei},
  doi          = {10.1016/j.ic.2021.104859},
  journal      = {Information and Computation},
  pages        = {104859},
  shortjournal = {Inf. Comput.},
  title        = {LZRR: LZ77 parsing with right reference},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Physical zero-knowledge proof and NP-completeness proof of
suguru puzzle. <em>IANDC</em>, <em>285</em>, 104858. (<a
href="https://doi.org/10.1016/j.ic.2021.104858">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Suguru is a paper and pencil puzzle invented by Naoki Inaba. The goal of the game is to fill a grid with numbers between 1 and 5 while respecting three simple constraints. We first prove the NP-completeness of Suguru puzzle. For this we design gadgets to encode the PLANAR-CIRCUIT-SAT in a Suguru grid. We then design a physical Zero-Knowledge Proof (ZKP) protocol for Suguru. This ZKP protocol allows a prover to prove that he knows a solution of a Suguru grid to a verifier without leaking any information on the solution. To construct such a physical ZKP protocol, we only rely on a few physical cards and adapted encoding. For a Suguru grid with n cells, we only use 5 n + 5 5n+5 cards. Moreover, we prove the three classical security properties of a ZKP: completeness, extractability, and zero-knowledge.},
  archive      = {J_IANDC},
  author       = {Léo Robert and Daiki Miyahara and Pascal Lafourcade and Luc Libralesso and Takaaki Mizuki},
  doi          = {10.1016/j.ic.2021.104858},
  journal      = {Information and Computation},
  pages        = {104858},
  shortjournal = {Inf. Comput.},
  title        = {Physical zero-knowledge proof and NP-completeness proof of suguru puzzle},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Randomness and uniform distribution modulo one.
<em>IANDC</em>, <em>285</em>, 104857. (<a
href="https://doi.org/10.1016/j.ic.2021.104857">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We elaborate the notions of Martin-Löf and Schnorr randomness for real numbers in terms of uniform distribution of sequences. We give a necessary condition for a real number to be Schnorr random expressed in terms of classical uniform distribution of sequences. This extends the result proved by Avigad for sequences of linear functions with integer coefficients to the wider classical class of Koksma sequences of functions. And, by requiring equidistribution with respect to every computably enumerable open set (respectively, computably enumerable open set with computable measure) in the unit interval, we give a sufficient condition for Martin-Löf (respectively Schnorr) randomness.},
  archive      = {J_IANDC},
  author       = {Verónica Becher and Serge Grigorieff},
  doi          = {10.1016/j.ic.2021.104857},
  journal      = {Information and Computation},
  pages        = {104857},
  shortjournal = {Inf. Comput.},
  title        = {Randomness and uniform distribution modulo one},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). A combinatorial characterization of self-stabilizing
population protocols. <em>IANDC</em>, <em>285</em>, 104829. (<a
href="https://doi.org/10.1016/j.ic.2021.104829">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We characterize self-stabilizing functions in population protocols for complete interaction graphs. In particular, we investigate self-stabilization in systems of N finite state agents in which a malicious scheduler selects an arbitrary sequence of pairwise interactions under a global fairness condition. We show a necessary and sufficient condition for self-stabilization. Specifically we show that functions without certain set-theoretic conditions are impossible to compute in a self-stabilizing manner. Our main contribution is in the converse, where we construct a self-stabilizing protocol for all other functions that meet this characterization. Our positive construction uses Dickson&#39;s Lemma to develop the notion of the root set, a concept that turns out to fundamentally characterize self-stabilization in this model. We believe it may lend to characterizing self-stabilization in more general models as well.},
  archive      = {J_IANDC},
  author       = {Shaan Mathur and Rafail Ostrovsky},
  doi          = {10.1016/j.ic.2021.104829},
  journal      = {Information and Computation},
  pages        = {104829},
  shortjournal = {Inf. Comput.},
  title        = {A combinatorial characterization of self-stabilizing population protocols},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). The CBH characterisation theorem beyond algebraic quantum
theory. <em>IANDC</em>, <em>285</em>, 104828. (<a
href="https://doi.org/10.1016/j.ic.2021.104828">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The CBH theorem characterises quantum theory within a C*-algebraic framework. Namely, mathematical properties of C*-algebras modelling quantum systems are equivalent to constraints that are information-theoretic in nature: (1) noncommutativity of subalgebras is equivalent to impossibility of signalling; (2) noncommutativity of the whole algebra is equivalent to impossibility of broadcasting; (3) the existence of entangled states is implied by the impossibility of secure bit commitment (with the converse conjectured). However, the C*-algebraic framework has drawn criticism as it already contains much of the mathematical structure of quantum theory such as complex linearity. We address this issue by a generalising C*-algebras categorically. In this framework, equivalence (1) holds, equivalence (2) becomes a strict implication, and implication (3) fails in general. Thus we identify exactly what work is being done by the complex-linear structure of C*-algebras. In doing so, we uncover a richer hierarchy of notions of ‘classicality’ and ‘quantumness’ of information than visible in the concrete case.},
  archive      = {J_IANDC},
  author       = {Chris Heunen and Aleks Kissinger},
  doi          = {10.1016/j.ic.2021.104828},
  journal      = {Information and Computation},
  pages        = {104828},
  shortjournal = {Inf. Comput.},
  title        = {The CBH characterisation theorem beyond algebraic quantum theory},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). The refinement calculus of reactive systems. <em>IANDC</em>,
<em>285</em>, 104819. (<a
href="https://doi.org/10.1016/j.ic.2021.104819">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Refinement Calculus of Reactive Systems (RCRS) is a compositional formal framework for modeling and reasoning about reactive systems. RCRS provides a language which can describe atomic components as symbolic transition systems or QLTL formulas, and composite components formed using three primitive composition operators: serial, parallel, and feedback. The semantics of the language is given in terms of monotonic property transformers, an extension of monotonic predicate transformers to reactive systems. RCRS can specify both safety and liveness properties . It can also model input-output systems which are both non-deterministic and non-input-receptive (i.e., which may reject some inputs at some points in time), and can thus be seen as a behavioral type system. RCRS provides a set of techniques for symbolic computer-aided reasoning, including compositional static analysis and verification. RCRS comes with a publicly available implementation which includes a complete formalization of the RCRS theory in the Isabelle proof assistant.},
  archive      = {J_IANDC},
  author       = {Viorel Preoteasa and Iulia Dragomir and Stavros Tripakis},
  doi          = {10.1016/j.ic.2021.104819},
  journal      = {Information and Computation},
  pages        = {104819},
  shortjournal = {Inf. Comput.},
  title        = {The refinement calculus of reactive systems},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Optimal in-place suffix sorting. <em>IANDC</em>,
<em>285</em>, 104818. (<a
href="https://doi.org/10.1016/j.ic.2021.104818">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The suffix array is a fundamental data structure for many applications that involve string searching and data compression . We obtain the first in-place suffix array construction algorithms that are optimal both in time and space for (read-only) integer alphabets. We make the following contributions:},
  archive      = {J_IANDC},
  author       = {Zhize Li and Jian Li and Hongwei Huo},
  doi          = {10.1016/j.ic.2021.104818},
  journal      = {Information and Computation},
  pages        = {104818},
  shortjournal = {Inf. Comput.},
  title        = {Optimal in-place suffix sorting},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Distributed computability: Relating k-immediate snapshot and
x-set agreement. <em>IANDC</em>, <em>285</em>, 104815. (<a
href="https://doi.org/10.1016/j.ic.2021.104815">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper introduces a generalization of the immediate snapshot object denoted k-immediate snapshot, requiring that the snapshot returned contains at least ( n − k ) (n−k) pairs. The case k = n − 1 k=n−1 corresponds to the original immediate snapshot object, which requires that the snapshot returned contains at least one pair 〈process id, value〉 pair, that corresponds to the process id that invoked the operation). The paper first shows that k -immediate snapshot is impossible to implement in an asynchronous read/write system, even if k = n − 2 k=n−2 and t = 1 t=1 . Then, the paper considers x -set agreement, another object stronger than the classical read/write t -crash read/write model (when x ≤ t x≤t ), and studies the relation with the k -immediate snapshot object, establishing strong relations linking these two fundamental distributed computing abstractions. The paper shows conditions under which x -set agreement can be solved in read/write systems enriched with k -immediate snapshot objects. It also shwos when k -immediate snapshot and consensus are equivalent.},
  archive      = {J_IANDC},
  author       = {Carole Delporte and Hugues Fauconnier and Sergio Rajsbaum and Michel Raynal},
  doi          = {10.1016/j.ic.2021.104815},
  journal      = {Information and Computation},
  pages        = {104815},
  shortjournal = {Inf. Comput.},
  title        = {Distributed computability: Relating k-immediate snapshot and x-set agreement},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Robust, expressive, and quantitative linear temporal logics:
Pick any two for free. <em>IANDC</em>, <em>285</em>, 104810. (<a
href="https://doi.org/10.1016/j.ic.2021.104810">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Linear Temporal Logic (LTL) is the standard specification language for reactive systems and is successfully applied in industrial settings. However, many shortcomings of LTL have been identified, including limited expressiveness, the lack of quantitative features, and the inability to express robustness. While there is work on overcoming these shortcomings, each of these is typically addressed in isolation, which is insufficient for any application in which all shortcomings manifest themselves simultaneously. Here, we tackle this issue by introducing logics that address more than one shortcoming. To this end, we combine Linear Dynamic Logic, Prompt-LTL, and robust LTL, each addressing one aspect, to new logics. The resulting logics have the same desirable algorithmic properties as plain LTL for all combinations of two aspects. In particular, the highly efficient algorithmic backends developed for LTL are also applicable to these new logics. Finally, we discuss how to address all three aspects simultaneously.},
  archive      = {J_IANDC},
  author       = {Daniel Neider and Alexander Weinert and Martin Zimmermann},
  doi          = {10.1016/j.ic.2021.104810},
  journal      = {Information and Computation},
  pages        = {104810},
  shortjournal = {Inf. Comput.},
  title        = {Robust, expressive, and quantitative linear temporal logics: Pick any two for free},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Reachability games with relaxed energy constraints.
<em>IANDC</em>, <em>285</em>, 104806. (<a
href="https://doi.org/10.1016/j.ic.2021.104806">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study games with reachability objectives under energy constraints. We first prove that under strict energy constraints (either only lower-bound constraint or interval constraint), those games are LOGSPACE LOGSPACE -equivalent to energy games with the same energy constraints but without reachability objective (i.e., for infinite runs). We then consider two relaxations of the upper-bound constraints (while keeping the lower-bound constraint strict): in the first one, called weak upper bound , the upper bound is absorbing , i.e., when the upper bound is reached, the extra energy is not stored; in the second one, we allow for temporary violations of the upper bound, imposing limits on the number or on the amount of violations. We prove that when considering weak upper bound, reachability objectives require memory, but can still be solved in polynomial-time for one-player arenas; we prove that they are in co co NP NP in the two-player setting. Allowing for bounded violations makes the problem PSPACE PSPACE -complete for one-player arenas and EXPTIME EXPTIME -complete for two players. We then address the problem of existence of bounds for a given arena. We show that with reachability objectives, existence can be a simpler problem than the game itself, and conversely that with infinite games, existence can be harder.},
  archive      = {J_IANDC},
  author       = {Loïc Hélouët and Nicolas Markey and Ritam Raha},
  doi          = {10.1016/j.ic.2021.104806},
  journal      = {Information and Computation},
  pages        = {104806},
  shortjournal = {Inf. Comput.},
  title        = {Reachability games with relaxed energy constraints},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Edge minimization in de bruijn graphs. <em>IANDC</em>,
<em>285</em>, 104795. (<a
href="https://doi.org/10.1016/j.ic.2021.104795">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper introduces the de Bruijn graph edge minimization problem , which is related to the compression of de Bruijn graphs: find the order- k de Bruijn graph with minimum edge count among all orders. We describe an efficient algorithm that solves this problem. Since the edge minimization problem is connected to the BWT compression technique called “tunneling”, the paper also describes a way to minimize the length of a tunneled BWT in such a way that useful properties for sequence analysis are preserved. Thus, it provides significant progress towards a solution to the open problem of finding optimal disjoint blocks that minimize space, as stated in Alanko et al. (DCC 2019).},
  archive      = {J_IANDC},
  author       = {Uwe Baier and Thomas Büchler and Enno Ohlebusch and Pascal Weber},
  doi          = {10.1016/j.ic.2021.104795},
  journal      = {Information and Computation},
  pages        = {104795},
  shortjournal = {Inf. Comput.},
  title        = {Edge minimization in de bruijn graphs},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). C-trie++: A dynamic trie tailored for fast prefix searches.
<em>IANDC</em>, <em>285</em>, 104794. (<a
href="https://doi.org/10.1016/j.ic.2021.104794">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Given a dynamic set K of k strings of total length n whose characters are drawn from an alphabet of size σ , a keyword dictionary is a data structure built on K that provides lookup, prefix search, and update operations on K . Under the assumption that α = w / lg ⁡ σ characters fit into a single machine word of w bits, we propose a keyword dictionary that represents K in either n lg ⁡ σ + Θ ( k lg ⁡ n ) or | T | lg ⁡ σ + Θ ( k w ) bits of space, where | T | is the number of nodes of a trie representing K . It supports all operations in O ( m / α + lg ⁡ α ) expected time on an input string of length m in the word RAM model. An evaluation of our implementation highlights the practical usefulness of the proposed data structure, especially for prefix searches — one of the most essential keyword dictionary operations.},
  archive      = {J_IANDC},
  author       = {Kazuya Tsuruta and Dominik Köppl and Shunsuke Kanda and Yuto Nakashima and Shunsuke Inenaga and Hideo Bannai and Masayuki Takeda},
  doi          = {10.1016/j.ic.2021.104794},
  journal      = {Information and Computation},
  pages        = {104794},
  shortjournal = {Inf. Comput.},
  title        = {C-trie++: A dynamic trie tailored for fast prefix searches},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Faster repetition-aware compressed suffix trees based on
block trees. <em>IANDC</em>, <em>285</em>, 104749. (<a
href="https://doi.org/10.1016/j.ic.2021.104749">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The suffix tree is a fundamental data structure in stringology, but its space usage, though linear, is an important problem in applications like Bioinformatics. We design and implement a new compressed suffix tree (CST) targeted to highly repetitive texts, such as large genomic collections of the same species. Our first contribution is to enhance the Block Tree, a data structure that captures the repetitiveness of its input sequence, to represent the topology of trees with large repeated subtrees. Our so-called Block-Tree Compressed Topology (BT-CT) data structure augments the Block Tree nodes with data that speeds up tree navigation . Our Block-Tree CST (BT-CST), in turn, uses the BT-CT to compress the topology of the suffix tree, and also replaces the sampling of the suffix array and its inverse with grammar- and/or Block-Tree-based representations of those arrays. Our experimental results show that BT-CTs reach navigation speeds comparable to compact tree representations that are insensitive to repetitiveness, while using 2–10 times less space on the topologies of the suffix trees of repetitive collections. Our BT-CST is slightly larger than previous repetition-aware suffix trees based on grammar-compressed topologies, but outperforms them in time, often by orders of magnitude.},
  archive      = {J_IANDC},
  author       = {Manuel Cáceres and Gonzalo Navarro},
  doi          = {10.1016/j.ic.2021.104749},
  journal      = {Information and Computation},
  pages        = {104749},
  shortjournal = {Inf. Comput.},
  title        = {Faster repetition-aware compressed suffix trees based on block trees},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Ring exploration with myopic luminous robots.
<em>IANDC</em>, <em>285</em>, 104702. (<a
href="https://doi.org/10.1016/j.ic.2021.104702">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We investigate exploration algorithms for autonomous mobile robots evolving in uniform ring-shaped networks. Unlike previous works, we consider myopia (each robot can only observe its neighboring nodes) and luminosity (each robot can use only two colors for its light) properties for the robots. As a main contribution, we prove that (i) in the FSYNC model, two (resp. three) myopic robots are necessary and sufficient to achieve perpetual (resp. terminating) exploration, and (ii) in the SSYNC and ASYNC models, three (resp. four) myopic robots are necessary and sufficient to achieve perpetual (resp. terminating) exploration. We also show that, in all execution models, our perpetual exploration algorithm is universal. That is, the algorithm solves perpetual exploration from any solvable initial configuration with two (resp. three) myopic robots and two colors in the FSYNC model (resp. the SSYNC and ASYNC models). On the other hand, we provide impossibility results for universal terminating exploration.},
  archive      = {J_IANDC},
  author       = {Fukuhito Ooshita and Sébastien Tixeuil},
  doi          = {10.1016/j.ic.2021.104702},
  journal      = {Information and Computation},
  pages        = {104702},
  shortjournal = {Inf. Comput.},
  title        = {Ring exploration with myopic luminous robots},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Clairvoyant state machine replication. <em>IANDC</em>,
<em>285</em>, 104701. (<a
href="https://doi.org/10.1016/j.ic.2021.104701">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider the state machine replication problem in semi-synchronous systems subject to Byzantine server failures. We propose a new solution to the problem in the form of a protocol for the generalized consensus problem. The protocol solves the consensus problem in a setting in which information about conflicts between transactions is available (such information can be in the form of transaction read and write sets). Unlike most prior proposals (for generalized or classical consensus), which use a leader to order transactions, this protocol is leaderless, and relies on non-skipping timestamps for transaction ordering. Being leaderless, the protocol does not need to pause for leader elections. The use of non-skipping timestamps permits servers to commit transactions as soon as they know that no conflicting transaction can be ordered earlier. For n servers of which f may be faulty, this protocol requires n &gt; 4 f n&amp;gt;4f .},
  archive      = {J_IANDC},
  author       = {Rida Bazzi and Maurice Herlihy},
  doi          = {10.1016/j.ic.2021.104701},
  journal      = {Information and Computation},
  pages        = {104701},
  shortjournal = {Inf. Comput.},
  title        = {Clairvoyant state machine replication},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Load balanced distributed directories. <em>IANDC</em>,
<em>285</em>, 104700. (<a
href="https://doi.org/10.1016/j.ic.2021.104700">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present LB-Spiral , a novel distributed directory protocol for shared objects, suitable for large-scale distributed shared memory systems . Each shared object has an owner node that can modify its value. The ownership may change by moving the object from one node to another in response to move requests. The value of an object can be read by other nodes with lookup requests. The distinctive feature of LB-Spiral is that it balances the processing load on nodes in addition to minimizing the communication cost in general network topologies . In contrast, the existing distributed directory protocols for general network topologies only minimize the communication cost. In particular, LB-Spiral achieves poly-log approximation for both load and communication cost in general networks with respect to the problem parameters. Simulation results show that the established theoretical results translate well in practice.},
  archive      = {J_IANDC},
  author       = {Shishir Rai and Gokarna Sharma and Costas Busch and Maurice Herlihy},
  doi          = {10.1016/j.ic.2021.104700},
  journal      = {Information and Computation},
  pages        = {104700},
  shortjournal = {Inf. Comput.},
  title        = {Load balanced distributed directories},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). On fast pattern formation by autonomous robots.
<em>IANDC</em>, <em>285</em>, 104699. (<a
href="https://doi.org/10.1016/j.ic.2021.104699">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider the fundamental problem of arranging a set of n autonomous robots (points) on a real plane according to an arbitrary given pattern. Each robot operates in a, largely oblivious, look-compute-move step. We measure the time complexity of our algorithms in “epochs,” which denotes the minimum time interval in which every robot performs at least one look-compute-move step. We present a framework for the pattern formation problem in which leader election is key. Where n robots can elect a leader in T LE ( n ) TLE(n) epochs, we show that pattern formation can be solved in O ( T LE ( n ) ) O(TLE(n)) epochs on the semi-synchronous model using robots that either are transparent (that is, the classical oblivious robots model where complete visibility is guaranteed at all times) or have lights with a constant number of colors (that is, the robots with lights model where robots are not transparent but the colors of the lights are persistent between steps). We also prove that, for some cases, the O ( T LE ( n ) ) O(TLE(n)) epochs are optimal on the semi-synchronous model. Our results on the semi-synchronous model indicate that transparency and lights compensate for each other in the pattern formation problem. The proposed method runs in O ( T L E ( n ) + log ⁡ n ) O(TLE(n)+log⁡n) epochs on the asynchronous model of robots with lights. This translates to an algorithm on the asynchronous model that runs in O ( log ⁡ n ) O(log⁡n) randomized epochs with high probability . Our algorithms do not assume agreement on direction or orientation of the robots such as global coordinate system, chirality, or one-axis agreement. Robot motions are rigid in the sense that when a robot moves it reaches its destination point at the completion of that move. The proposed algorithms are randomized and guarantee the claimed time bounds with high probability . The randomization is used only for leader election. Finally, we provide lower bounds regarding optimality of our results as well as impossibility of designing an asynchronous algorithm in the classical model.},
  archive      = {J_IANDC},
  author       = {Ramachandran Vaidyanathan and Gokarna Sharma and Jerry Trahan},
  doi          = {10.1016/j.ic.2021.104699},
  journal      = {Information and Computation},
  pages        = {104699},
  shortjournal = {Inf. Comput.},
  title        = {On fast pattern formation by autonomous robots},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Simple and fast approximate counting and leader election in
populations. <em>IANDC</em>, <em>285</em>, 104698. (<a
href="https://doi.org/10.1016/j.ic.2021.104698">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study leader election and population size counting for population protocols: networks of finite-state anonymous agents that interact randomly. We provide simple protocols for approximate counting of the size of the population and for leader election. We show a protocol for leader election that terminates in O ( log 2 ⁡ n log ⁡ m ) O(log2⁡nlog⁡m) parallel time, where m is a parameter that belongs to Ω ( log ⁡ n ) Ω(log⁡n) and O ( n ) O(n) , using O ( max ⁡ { log ⁡ m , log ⁡ log ⁡ n } ) O(max⁡{log⁡m,log⁡log⁡n}) bits. By adjusting m between log ⁡ n log⁡n and n , we obtain a leader election protocol whose time and space can be smoothly traded off between O ( log 2 ⁡ n log ⁡ log ⁡ n ) O(log2⁡nlog⁡log⁡n) to O ( log ⁡ n ) O(log⁡n) time and O ( log ⁡ log ⁡ n ) O(log⁡log⁡n) to O ( log ⁡ n ) O(log⁡n) bits. We also give a protocol which provides a constant factor approximation of log ⁡ n log⁡n of the population size n , or an upper bound n e ne which is at most n a na for some constant a &gt; 1 a&amp;gt;1 . This protocol assumes the existence of a unique leader and stabilizes in Θ ( log ⁡ n ) Θ(log⁡n) parallel time.},
  archive      = {J_IANDC},
  author       = {Othon Michail and Paul G. Spirakis and Michail Theofilatos},
  doi          = {10.1016/j.ic.2021.104698},
  journal      = {Information and Computation},
  pages        = {104698},
  shortjournal = {Inf. Comput.},
  title        = {Simple and fast approximate counting and leader election in populations},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). A self-stabilizing hashed patricia trie. <em>IANDC</em>,
<em>285</em>, 104697. (<a
href="https://doi.org/10.1016/j.ic.2021.104697">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {While many research in distributed computing has covered solutions for self-stabilizing computing and topologies, there is far less work on self-stabilization for distributed data structures . However, when peers in peer-to-peer networks crash, a distributed data structure may not remain intact. We present a self-stabilizing protocol for a distributed data structure called the Hashed Patricia Trie (Kniesburges and Scheideler WALCOM&#39;11) that enables efficient prefix search on a set of keys. The data structure has many applications while offering low overhead and efficient operations when embedded on top of a Distributed Hash Table . Especially, longest prefix matching for x can be done in O ( log ⁡ | x | ) O(log⁡|x|) hash table read accesses. We show how to maintain the structure in a self-stabilizing way, while assuring a low overhead in a legal state and an asymptotically optimal memory demand of Θ ( d ) Θ(d) bits, where d is the number of bits needed for storing all keys.},
  archive      = {J_IANDC},
  author       = {Till Knollmann and Christian Scheideler},
  doi          = {10.1016/j.ic.2021.104697},
  journal      = {Information and Computation},
  pages        = {104697},
  shortjournal = {Inf. Comput.},
  title        = {A self-stabilizing hashed patricia trie},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). An efficient approach to achieve compositionality using
optimized multi-version object based transactional systems.
<em>IANDC</em>, <em>285</em>, 104696. (<a
href="https://doi.org/10.1016/j.ic.2021.104696">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In the modern era of multi-core systems, the main aim is to utilize the cores properly. This utilization can be done by concurrent programming . But developing a flawless and well-organized concurrent program is difficult. Software Transactional Memory Systems (STMs) are a convenient programming interface which assist the programmer to access the shared memory concurrently without worrying about consistency issues. Many STMs available in the literature execute read/write primitive operations on memory buffers. We represent them as Read-Write STMs or RWSTMs. Whereas, there exists some STMs which work on higher level operations. We refer these STMs as Object Based STMs or OSTMs. The literature of databases and RWSTMs say that maintaining multiple versions ensures greater concurrency. So, this paper proposes the notion of Optimized Multi-version Object Based STMs or OPT-MVOSTMs which encapsulates the idea of multiple versions in OSTMs to harness the greater concurrency efficiently.},
  archive      = {J_IANDC},
  author       = {Chirag Juyal and Sandeep Kulkarni and Sweta Kumari and Sathya Peri and Archit Somani},
  doi          = {10.1016/j.ic.2021.104696},
  journal      = {Information and Computation},
  pages        = {104696},
  shortjournal = {Inf. Comput.},
  title        = {An efficient approach to achieve compositionality using optimized multi-version object based transactional systems},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Search by a metamorphic robotic system in a finite 2D square
grid. <em>IANDC</em>, <em>285</em>, 104695. (<a
href="https://doi.org/10.1016/j.ic.2021.104695">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider search in an unknown finite 2D square grid by a metamorphic robotic system consisting of anonymous memory-less modules. Each module autonomously moves while executing a common distributed algorithm and the modules collectively form a robotic system by keeping connectivity. The number of shapes of the metamorphic robotic system grows as the number of modules increases, and a shape of the system serves as its memory and shows its functionality. We present the minimum number of modules for search in a finite 2D square grid. We demonstrate that if the modules agree on the directions, i.e., they are equipped with the global compass, three modules are necessary and sufficient for search from an arbitrary initial shape, otherwise five modules are necessary and sufficient for search from limited initial shapes assuming that all modules share a common handedness.},
  archive      = {J_IANDC},
  author       = {Keisuke Doi and Yukiko Yamauchi and Shuji Kijima and Masafumi Yamashita},
  doi          = {10.1016/j.ic.2021.104695},
  journal      = {Information and Computation},
  pages        = {104695},
  shortjournal = {Inf. Comput.},
  title        = {Search by a metamorphic robotic system in a finite 2D square grid},
  volume       = {285},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022a). How does adiabatic quantum computation fit into quantum
automata theory? <em>IANDC</em>, <em>284</em>, 104694. (<a
href="https://doi.org/10.1016/j.ic.2021.104694">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Quantum computation has emerged as a powerful computational medium of our time, having demonstrated the remarkable efficiency in factoring a positive integer and searching databases faster than any currently known classical computing algorithm. Adiabatic evolution of quantum systems has been studied as a potential means that physically realizes quantum computation. Up to now, all the research on adiabatic quantum systems has dealt with polynomial time-bounded computation and little attention has been paid to, for instance, adiabatic quantum systems consuming only constant memory space. Such quantum systems can be modeled in a form similar to quantum finite automata . This exposition dares to ask a bold question of how to make adiabatic quantum computation fit into the rapidly progressing framework of quantum automata theory . As our answer to this eminent but profound question, we first lay out a fundamental platform to carry out adiabatic evolutionary quantum systems (AEQSs) with limited computational resources (in size, energy, spectral gap, etc.) and then demonstrate how to construct such AEQSs by operating suitable families of quantum finite automata . We further explore fundamental structural properties of decision problems (as well as promise problems) solved quickly by the appropriately constructed AEQSs.},
  archive      = {J_IANDC},
  author       = {Tomoyuki Yamakami},
  doi          = {10.1016/j.ic.2021.104694},
  journal      = {Information and Computation},
  pages        = {104694},
  shortjournal = {Inf. Comput.},
  title        = {How does adiabatic quantum computation fit into quantum automata theory?},
  volume       = {284},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). State complexity of GF(2)-operations on unary languages.
<em>IANDC</em>, <em>284</em>, 104693. (<a
href="https://doi.org/10.1016/j.ic.2021.104693">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The paper investigates the state complexity of two operations on regular languages, known as GF(2)-concatenation and GF(2)-inverse (Bakinova et al., “Formal languages over GF(2)”, LATA 2018), in the case of a one-symbol alphabet. The GF(2)-concatenation is a variant of the classical concatenation obtained by replacing Boolean logic in its definition with the GF(2) field; it is proved that GF(2)-concatenation of two unary languages recognized by an m -state and an n -state DFA is recognized by a DFA with 2 m n 2mn states, and this number of states is necessary in the worst case, as long as m and n are relatively prime . This operation is known to have an inverse, and the state complexity of the GF(2)-inverse operation over a unary alphabet is proved to be exactly 2 n − 1 + 1 2n−1+1 , with the proof based on primitive polynomials over GF(2). For a generalization of the GF(2)-inverse, called the GF(2)-star, the state complexity in the unary case is exactly 2 n 2n .},
  archive      = {J_IANDC},
  author       = {Alexander Okhotin and Elizaveta Sazhneva},
  doi          = {10.1016/j.ic.2021.104693},
  journal      = {Information and Computation},
  pages        = {104693},
  shortjournal = {Inf. Comput.},
  title        = {State complexity of GF(2)-operations on unary languages},
  volume       = {284},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Operational union-complexity. <em>IANDC</em>, <em>284</em>,
104692. (<a href="https://doi.org/10.1016/j.ic.2021.104692">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Union-free languages are described by regular expressions using only concatenation and Kleene-star. Every regular language can be given as a union of finitely many union-free languages. By the minimal number of union-free languages needed in such union-free decompositions of a regular language, its union-complexity is defined. In this paper, the union-complexity of the languages obtained by various operations is studied, e.g., having two languages with union-complexities n and m , respectively, what could be the union-complexity of their union/concatenation/shuffle. Particularly, it is shown that the Kleene-star of any regular language has union-complexity 1. In some cases, e.g., at union and concatenation, the resulting language has a bounded union-complexity. In some other cases, e.g., at complement, the resulted language can have arbitrarily large union-complexity. At ( k -th) power of a language, the case of the unary alphabet and the general case (alphabet with at least two symbols) have different upper bounds. While, in case of shuffle, there is an unbounded growth in the general case, while for languages over the unary alphabet the growth is bounded. Tight upper bounds are shown for all of the above mentioned cases (whenever the growth is bounded). At intersection we also show an unbounded growth in the general case, especially, over a binary alphabet .},
  archive      = {J_IANDC},
  author       = {Benedek Nagy},
  doi          = {10.1016/j.ic.2021.104692},
  journal      = {Information and Computation},
  pages        = {104692},
  shortjournal = {Inf. Comput.},
  title        = {Operational union-complexity},
  volume       = {284},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Descriptional complexity of iterated uniform finite-state
transducers. <em>IANDC</em>, <em>284</em>, 104691. (<a
href="https://doi.org/10.1016/j.ic.2021.104691">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce the deterministic computational model of an iterated uniform finite-state transducer ( iufst ). An iufst performs the same length-preserving transduction on several left-to-right sweeps. The first sweep acts on the input string, any other sweep processes the output of the previous one. The iufst accepts by halting in an accepting state at the end of a sweep. First, we study constant sweep bounded iufst s. We prove their computational power coincides with the class of regular languages. We show their descriptional power vs. deterministic finite automata , and the state cost of implementing language operations. We prove the NL -completeness of typical decision problems. Next, we analyze non-constant sweep bounded iufst s. We show they can accept non-regular languages provided an at least logarithmic amount of sweeps is allowed. We exhibit a proper non-regular language hierarchy depending on sweep complexity. The non-semidecidability of typical decision problems is also addressed.},
  archive      = {J_IANDC},
  author       = {Martin Kutrib and Andreas Malcher and Carlo Mereghetti and Beatrice Palano},
  doi          = {10.1016/j.ic.2021.104691},
  journal      = {Information and Computation},
  pages        = {104691},
  shortjournal = {Inf. Comput.},
  title        = {Descriptional complexity of iterated uniform finite-state transducers},
  volume       = {284},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Structural properties of NFAs and growth rates of
nondeterminism measures. <em>IANDC</em>, <em>284</em>, 104690. (<a
href="https://doi.org/10.1016/j.ic.2021.104690">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Tree width (respectively, string path width) measures the number of partial (respectively, complete) computations of a nondeterministic finite automaton (NFA) on a given input. We characterize polynomial and exponential growth rates of tree width and string path width by structural properties of NFAs. Polynomial growth rates, roughly speaking, require that there exist computations going through a bounded number of cycles where the strings of characters labeling the cycles satisfy certain requirements. As the main result we show that the degrees of the polynomials bounding the tree width and string path width of an NFA differ from each other by at most one. More generally, an NFA is said to have cycle height K K if any computation can visit at most K K distinct cycles. We give a polynomial time algorithm to decide whether an NFA has finite cycle height and, in the positive case, to compute its optimal cycle height.},
  archive      = {J_IANDC},
  author       = {Chris Keeler and Kai Salomaa},
  doi          = {10.1016/j.ic.2021.104690},
  journal      = {Information and Computation},
  pages        = {104690},
  shortjournal = {Inf. Comput.},
  title        = {Structural properties of NFAs and growth rates of nondeterminism measures},
  volume       = {284},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Maximal state complexity and generalized de bruijn words.
<em>IANDC</em>, <em>284</em>, 104689. (<a
href="https://doi.org/10.1016/j.ic.2021.104689">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We compute the exact maximum state complexity for the language consisting of m words of length N , and characterize languages achieving the maximum. We also consider a special case, namely languages C ( w ) C(w) consisting of the conjugates of a single word w . The words for which the maximum state complexity of C ( w ) C(w) is achieved turn out to be a natural generalization of de Bruijn words. We show that generalized de Bruijn words exist for each length and consider the number of them.},
  archive      = {J_IANDC},
  author       = {Daniel Gabric and Štěpán Holub and Jeffrey Shallit},
  doi          = {10.1016/j.ic.2021.104689},
  journal      = {Information and Computation},
  pages        = {104689},
  shortjournal = {Inf. Comput.},
  title        = {Maximal state complexity and generalized de bruijn words},
  volume       = {284},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). On the computational completeness of matrix simple
semi-conditional grammars. <em>IANDC</em>, <em>284</em>, 104688. (<a
href="https://doi.org/10.1016/j.ic.2021.104688">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In matrix grammars, context-free rules have to be applied in a certain order. In simple semi-conditional (SSC) grammars, the derivations are controlled either by a permitting string or by a forbidden string associated to each rule. In SSC grammars, the maximum length i of permitting strings and the maximum length j of forbidden strings, the numbers of conditional rules and of nonterminals serve as measures of descriptional complexity and the pair ( i , j ) (i,j) is called the degree of such SSC grammars. Matrix grammars with appearance checking with three nonterminals are computationally complete; however, the matrix length is unbounded. Matrix SSC grammars (MSSC) put matrix grammar control on SSC rules. In this paper, we show that MSSC grammars with degrees ( 2 , 1 ) (2,1) , ( 2 , 0 ) (2,0) and ( 3 , 0 ) (3,0) are computationally complete, restricting several other descriptional complexity measures. With our constructions, we even bound the matrix length for MSSC grammars.},
  archive      = {J_IANDC},
  author       = {Henning Fernau and Lakshmanan Kuppusamy and Indhumathi Raman},
  doi          = {10.1016/j.ic.2021.104688},
  journal      = {Information and Computation},
  pages        = {104688},
  shortjournal = {Inf. Comput.},
  title        = {On the computational completeness of matrix simple semi-conditional grammars},
  volume       = {284},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Nondeterministic right one-way jumping finite automata.
<em>IANDC</em>, <em>284</em>, 104687. (<a
href="https://doi.org/10.1016/j.ic.2021.104687">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Right-one way jumping finite automata are deterministic devices that process their input in a discontinuous fashion. We generalise these devices to nondeterministic machines. More precisely we study the impact on the computational power of these machines when allowing multiple initial states and/or a nondeterministic transition function including spontaneous or λ -transitions. We show inclusion relations and incomparability results of the induced language families. Since for right-one way jumping devices the use of spontaneous transitions is subject to different natural interpretations, we also study this subject in detail, showing that most interpretations are equivalent to each other and lead to the same language families. Finally we also study inclusion and incomparability results to classical language families and to the families of languages accepted by finite automata with translucent letters.},
  archive      = {J_IANDC},
  author       = {Simon Beier and Markus Holzer},
  doi          = {10.1016/j.ic.2021.104687},
  journal      = {Information and Computation},
  pages        = {104687},
  shortjournal = {Inf. Comput.},
  title        = {Nondeterministic right one-way jumping finite automata},
  volume       = {284},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Descriptional complexity of formal systems (DCFS 2019).
<em>IANDC</em>, <em>284</em>, 104686. (<a
href="https://doi.org/10.1016/j.ic.2021.104686">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_IANDC},
  author       = {Galina Jirásková ( Special Issue Editor ) and Stavros Konstantinidis (Special Issue Editor)},
  doi          = {10.1016/j.ic.2021.104686},
  journal      = {Information and Computation},
  pages        = {104686},
  shortjournal = {Inf. Comput.},
  title        = {Descriptional complexity of formal systems (DCFS 2019)},
  volume       = {284},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). A periodicity lemma for partial words. <em>IANDC</em>,
<em>283</em>, 104677. (<a
href="https://doi.org/10.1016/j.ic.2020.104677">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We investigate the function L(h,p,q) , called here the length function , such that L(h,p,q) is the minimum length which guarantees that a natural extension of the periodicity lemma is valid for partial words with h holes and (so-called strong) periods p,q . In a series of papers, the formulae for the length function, in terms of p and q , were provided for each fixed h≤7 . We demystify the generic structure of such formulae and give a complete characterization of the length function for any parameter h expressed in terms of a piecewise-linear function with O(h) pieces. We also show how to evaluate the length function in O(log⁡p+log⁡q) time, which is an improvement upon the best previously known O(p+q) -time algorithm.},
  archive      = {J_IANDC},
  author       = {Tomasz Kociumaka and Jakub Radoszewski and Wojciech Rytter and Tomasz Waleń},
  doi          = {10.1016/j.ic.2020.104677},
  journal      = {Information and Computation},
  pages        = {104677},
  shortjournal = {Inf. Comput.},
  title        = {A periodicity lemma for partial words},
  volume       = {283},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Learners based on transducers. <em>IANDC</em>, <em>283</em>,
104676. (<a href="https://doi.org/10.1016/j.ic.2020.104676">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The learners considered here process data in cycles and maintain as a long term memory a string which provides all internal data the learner can use in the next cycle. Updating of these strings is usually done by either recursive or automatic learners. The present work looks at transduced learners, which sit in-between. The results include that transduced learners can learn all learnable automatic families with memory exponential in the size of the longest input seen so far. Furthermore, there is a hierarchy based on the memory-allowance: if n is the size of the largest datum seen so far, then for all k ≥ 1 k≥1 , memory n k + 1 nk+1 allows one to learn more automatic families than memory n k nk . Further results shed light on when it can be imposed that transduced learners be consistent, conservative or iterative. The main result of this kind is that all learnable automatic families have a consistent and conservative transduced learner.},
  archive      = {J_IANDC},
  author       = {Sanjay Jain and Shao Ning Kuek and Eric Martin and Frank Stephan},
  doi          = {10.1016/j.ic.2020.104676},
  journal      = {Information and Computation},
  pages        = {104676},
  shortjournal = {Inf. Comput.},
  title        = {Learners based on transducers},
  volume       = {283},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Default logic and bounded treewidth. <em>IANDC</em>,
<em>283</em>, 104675. (<a
href="https://doi.org/10.1016/j.ic.2020.104675">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we study Reiter&#39;s propositional default logic when the treewidth of a certain graph representation (semi-primal graph) of the input theory is bounded. We establish a dynamic programming algorithm on tree decompositions that decides whether a theory has a consistent stable extension ( Cons ). Our algorithm can even be used to enumerate all generating defaults ( EnumSD ) that lead to stable extensions. We show that our algorithm decides Cons in linear time in the input theory and triple exponential time in the treewidth Further, our algorithm solves EnumSD with a pre-computation step that is linear in the input theory and triple exponential in the treewidth followed by a linear delay to output solutions. Finally, we take the exponential time hypothesis (ETH) into consideration and establish lower bounds of bounded treewidth algorithms for Cons .},
  archive      = {J_IANDC},
  author       = {Johannes K. Fichte and Markus Hecher and Irina Schindler},
  doi          = {10.1016/j.ic.2020.104675},
  journal      = {Information and Computation},
  pages        = {104675},
  shortjournal = {Inf. Comput.},
  title        = {Default logic and bounded treewidth},
  volume       = {283},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Pomset bisimulation and unfolding for reset petri nets.
<em>IANDC</em>, <em>283</em>, 104674. (<a
href="https://doi.org/10.1016/j.ic.2020.104674">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Reset Petri nets are a particular class of Petri nets where transition firings can remove all tokens from a place without checking if this place actually holds tokens or not. In this paper we look at partial order semantics of reset Petri nets. In particular, we propose a pomset bisimulation for comparing their concurrent behaviours. Building on this pomset bisimulation we then propose a generalization of the standard finite complete prefixes of unfolding for this class of Petri nets.},
  archive      = {J_IANDC},
  author       = {Thomas Chatain and Maurice Comlan and David Delfieu and Loïg Jezequel and Olivier-Henri Roux},
  doi          = {10.1016/j.ic.2020.104674},
  journal      = {Information and Computation},
  pages        = {104674},
  shortjournal = {Inf. Comput.},
  title        = {Pomset bisimulation and unfolding for reset petri nets},
  volume       = {283},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Context-free timed formalisms: Robust automata and linear
temporal logics. <em>IANDC</em>, <em>283</em>, 104673. (<a
href="https://doi.org/10.1016/j.ic.2020.104673">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The paper focuses on automata and linear temporal logics for real-time pushdown reactive systems bridging tractable formalisms specialized for expressing separately dense-time real-time properties and context-free properties though preserving tractability. As for automata , we introduce Event-Clock Nested Automata ( ECNA ), a formalism that combines Event Clock Automata ( ECA ) and Visibly Pushdown Automata ( VPA ). ECNA enjoy the same closure and decidability properties of ECA and VPA expressively extending any previous attempt of combining ECA and VPA . As for temporal logics, we introduce two formalisms for specifying quantitative timing context-free requirements: Event-Clock Nested Temporal Logic ( EC_NTL ) and Nested Metric Temporal Logic ( NMTL ). EC_NTL is an extension of both the logic CaRet and Event-Clock Temporal Logic having Exptime -complete satisfiability of EC_NTL and visibly model-checking of Visibly Pushdown Timed Systems ( VPTS ) against EC_NTL . NMTL is a context-free extension of standard Metric Temporal Logic ( MTL ) which is in general undecidable having, though, a fragment expressively equivalent to EC_NTL with Exptime -complete satisfiability and visibly model-checking of VPTS problems.},
  archive      = {J_IANDC},
  author       = {Laura Bozzelli and Aniello Murano and Adriano Peron},
  doi          = {10.1016/j.ic.2020.104673},
  journal      = {Information and Computation},
  pages        = {104673},
  shortjournal = {Inf. Comput.},
  title        = {Context-free timed formalisms: Robust automata and linear temporal logics},
  volume       = {283},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Formal languages over GF(2). <em>IANDC</em>, <em>283</em>,
104672. (<a href="https://doi.org/10.1016/j.ic.2020.104672">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Variants of the union and concatenation operations on formal languages are investigated, in which Boolean logic in the definitions (that is, conjunction and disjunction) is replaced with the operations in the two-element field GF(2) (conjunction and exclusive OR). Union is thus replaced with symmetric difference , whereas concatenation gives rise to a new GF(2)-concatenation operation, which is notable for being invertible. All operations preserve regularity, and for a pair of languages recognized by an m -state and an n -state DFA , their GF(2)-concatenation is recognized by a DFA with m ⋅ 2 n m⋅2n states, and this number of states is in the worst case necessary. Similarly, the state complexity of GF(2)-inverse is 2 n + 1 2n+1 . Next, a new class of formal grammars based on GF(2)-operations is defined, and it is shown to have the same computational complexity as ordinary grammars with union and concatenation: in particular, simple parsing in time O ( n 3 ) O(n3) , fast parsing in the time of matrix multiplication , and parsing in NC 2 .},
  archive      = {J_IANDC},
  author       = {Ekaterina Bakinova and Artem Basharin and Igor Batmanov and Konstantin Lyubort and Alexander Okhotin and Elizaveta Sazhneva},
  doi          = {10.1016/j.ic.2020.104672},
  journal      = {Information and Computation},
  pages        = {104672},
  shortjournal = {Inf. Comput.},
  title        = {Formal languages over GF(2)},
  volume       = {283},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022a). Special issue: Selected papers of the 12th international
conference on language and automata theory and applications, LATA 2018.
<em>IANDC</em>, <em>283</em>, 104671. (<a
href="https://doi.org/10.1016/j.ic.2020.104671">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_IANDC},
  author       = {Carlos Martín-Vide and Bianca Truthe},
  doi          = {10.1016/j.ic.2020.104671},
  journal      = {Information and Computation},
  pages        = {104671},
  shortjournal = {Inf. Comput.},
  title        = {Special issue: Selected papers of the 12th international conference on language and automata theory and applications, LATA 2018},
  volume       = {283},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022b). Logic for ω-pushdown automata. <em>IANDC</em>,
<em>282</em>, 104659. (<a
href="https://doi.org/10.1016/j.ic.2020.104659">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Context-free languages of infinite words have recently found increasing interest. Here, we will present a second-order logic with the same expressive power as Büchi or Muller pushdown automata for infinite words. This extends fundamental logical characterizations of Büchi, Elgot, Trakhtenbrot for regular languages of finite and infinite words and a more recent logical characterization of Lautemann, Schwentick and Thérien for context-free languages of finite words to ω -context-free languages. For our argument, we will investigate Greibach normal forms of ω -context-free grammars as well as a new type of Büchi pushdown automata which can alter their stack by at most one element and without ϵ -transitions. We show that they suffice to accept all ω -context-free languages. This enables us to use similar results recently developed for infinite nested words.},
  archive      = {J_IANDC},
  author       = {Manfred Droste and Sven Dziadek and Werner Kuich},
  doi          = {10.1016/j.ic.2020.104659},
  journal      = {Information and Computation},
  pages        = {104659},
  shortjournal = {Inf. Comput.},
  title        = {Logic for ω-pushdown automata},
  volume       = {282},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Weighted operator precedence languages. <em>IANDC</em>,
<em>282</em>, 104658. (<a
href="https://doi.org/10.1016/j.ic.2020.104658">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In the last years renewed investigation of operator precedence languages (OPL) led to discover important properties thereof: OPL are closed with respect to all major operations, are characterized, besides by the original grammar family, in terms of an automata family (OPA) and an MSO logic ; furthermore they significantly generalize the well-known visibly pushdown languages (VPL). A different area of research investigates quantitative evaluations of formal languages by adding weights to strings. In this paper, we lay the foundation to marry these two research fields. We introduce weighted operator precedence automata and show how they are both strict extensions of OPA and weighted visibly pushdown automata. We prove a Nivat-like result which shows that quantitative OPL can be described by unweighted OPA and very particular weighted OPA. In a Büchi-like theorem, we show that weighted OPA are expressively equivalent to a weighted MSO-logic for OPL.},
  archive      = {J_IANDC},
  author       = {Manfred Droste and Stefan Dück and Dino Mandrioli and Matteo Pradella},
  doi          = {10.1016/j.ic.2020.104658},
  journal      = {Information and Computation},
  pages        = {104658},
  shortjournal = {Inf. Comput.},
  title        = {Weighted operator precedence languages},
  volume       = {282},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Principal abstract families of weighted tree languages.
<em>IANDC</em>, <em>282</em>, 104657. (<a
href="https://doi.org/10.1016/j.ic.2020.104657">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce semiring-weighted regular tree grammars with storage where the semiring is complete. We show that the class of weighted tree languages generated by them is a principal abstract family of weighted tree languages provided that the semiring is commutative, the rank of symbols occurring in trees is bounded by a global parameter, and that the storage is finitely encoded and contains a reset instruction. Moreover, we prove the same statement for the iterated pushdown (instead of finitely encoded storage containing a reset instruction).},
  archive      = {J_IANDC},
  author       = {Zoltán Fülöp and Heiko Vogler},
  doi          = {10.1016/j.ic.2020.104657},
  journal      = {Information and Computation},
  pages        = {104657},
  shortjournal = {Inf. Comput.},
  title        = {Principal abstract families of weighted tree languages},
  volume       = {282},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Costs and rewards in priced timed automata. <em>IANDC</em>,
<em>282</em>, 104656. (<a
href="https://doi.org/10.1016/j.ic.2020.104656">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider Pareto analysis of multi-priced timed automata (MPTA) having multiple observers recording costs (to be minimised) and rewards (to be maximised) along a computation. We study the Pareto Domination Problem, which asks whether it is possible to reach a target location such that the accumulated costs and rewards Pareto dominate a given vector. We show that this problem is undecidable in general, but decidable for MPTA with at most three observers. We show the problem to be PSPACE-complete for MPTA recording only costs or only rewards. We also consider an approximate Pareto Domination that is decidable in exponential time with no restrictions on types and number of observers. We develop connections between MPTA and Diophantine equations . Undecidability of the Pareto Domination Problem is shown by reduction from Hilbert&#39;s 10th Problem, while decidability for three observers entails translation to a decidable fragment of arithmetic involving quadratic forms .},
  archive      = {J_IANDC},
  author       = {Martin Fränzle and Mahsa Shirmohammadi and Mani Swaminathan and James Worrell},
  doi          = {10.1016/j.ic.2020.104656},
  journal      = {Information and Computation},
  pages        = {104656},
  shortjournal = {Inf. Comput.},
  title        = {Costs and rewards in priced timed automata},
  volume       = {282},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Regular transducer expressions for regular transformations.
<em>IANDC</em>, <em>282</em>, 104655. (<a
href="https://doi.org/10.1016/j.ic.2020.104655">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Functional MSO transductions, deterministic two-way transducers, as well as streaming string transducers are all equivalent models for regular functions. In this paper, we show that every regular function, either on finite words or on infinite words, captured by a deterministic two-way transducer, can be described with a regular transducer expression ( RTE ). For infinite words, the two-way transducer uses Muller acceptance and ω -regular look-ahead. RTE s are constructed from constant functions using the combinators if-then-else (deterministic choice), Hadamard product, and unambiguous versions of the Cauchy product, the 2-chained Kleene-iteration and the 2-chained omega-iteration. Our proof works for transformations of both finite and infinite words, extending the result on finite words of Alur et al. in LICS&#39;14. The construction of an RTE associated with a deterministic two-way transducer is guided by a regular expression which is “good” wrt. its transition monoid . “Good” expressions are unambiguous, ensuring the functionality of the output computed. Moreover, in “good” expressions, iterations (Kleene-plus or omega) are restricted to subexpressions corresponding to idempotent elements of the transition monoid . “Good” expressions can be obtained with an unambiguous version of Imre Simon&#39;s famous forest factorization theorem . To handle infinite words, we introduce the notion of transition monoids for deterministic two-way Muller transducers with look-ahead, where the look-ahead is captured by some backward deterministic Büchi automaton . This paper is an extended version of [15] presented at LICS&#39;18.},
  archive      = {J_IANDC},
  author       = {Vrunda Dave and Paul Gastin and Shankara Narayanan Krishna},
  doi          = {10.1016/j.ic.2020.104655},
  journal      = {Information and Computation},
  pages        = {104655},
  shortjournal = {Inf. Comput.},
  title        = {Regular transducer expressions for regular transformations},
  volume       = {282},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Approximate minimization of weighted tree automata.
<em>IANDC</em>, <em>282</em>, 104654. (<a
href="https://doi.org/10.1016/j.ic.2020.104654">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper studies the following approximate minimization problem: given a minimal weighted tree automaton A with n states recognizing a weighted tree language f , can we construct a smaller automaton A ˆ Aˆ with n ˆ nˆ&amp;lt;n states recognizing a language f ˆ fˆ that is a good approximation of f ? The corresponding problem for weighted automata on strings was recently studied by Balle et al. [16] , [15] , where the authors introduced a new canonical form for weighted automata called singular value automata inspired by spectral methods , and showed that truncating such canonical form yields a solution for the problem satisfying a certain approximation criteria. In this paper we take a similar approach and show that in the tree case one can obtain an analogous canonical form that we call singular value tree automata , and use it to study the approximate minimization problem for weighted tree automata. We first establish the existence of this canonical form for weighted tree automata and then provide bounds on the quality of the resulting approximation method based on truncation. We also study the problem of computing the canonical form given a minimal weighted tree automaton and show that in the tree case this task is considerably more complicated than in the string case. In particular, computing the canonical form reduces to solving a system of polynomial equations . By further reducing this problem to the computation of generalized partition functions for weighted tree automata, we propose and analyze two methods for computing the canonical form based on iterative methods: fixed point iteration and Newton&#39;s method . Our analysis of Newton&#39;s method unveils a connection between iterative methods and sequences of sets of trees satisfying a certain technical condition that might be of independent interest.},
  archive      = {J_IANDC},
  author       = {Borja Balle and Guillaume Rabusseau},
  doi          = {10.1016/j.ic.2020.104654},
  journal      = {Information and Computation},
  pages        = {104654},
  shortjournal = {Inf. Comput.},
  title        = {Approximate minimization of weighted tree automata},
  volume       = {282},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Dynamics of reputation in mobile agents systems and weighted
timed automata. <em>IANDC</em>, <em>282</em>, 104653. (<a
href="https://doi.org/10.1016/j.ic.2020.104653">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The reputation of a process is based on its past and present behaviour; it evolves in time depending on several factors including the actions performed, the reputation of its interacting processes and locations where the process resides. We design a calculus of mobile agents in distributed systems able to handle the dynamics of reputation which changes over time depending on specified factors. The main idea is to provide a formal understanding of how reputation is formed from complex interactions in agent systems based on timed migration and communication, and how we can verify automatically the properties involving reputation. After presenting the operational semantics of our calculus and some results, the mobile agents described easily in this calculus are translated into networks of weighted timed automata having a bisimilar behaviour. Based on this translation, we use an existing software platform to analyze reputation-based properties of mobile agents in distributed systems.},
  archive      = {J_IANDC},
  author       = {Bogdan Aman and Gabriel Ciobanu},
  doi          = {10.1016/j.ic.2020.104653},
  journal      = {Information and Computation},
  pages        = {104653},
  shortjournal = {Inf. Comput.},
  title        = {Dynamics of reputation in mobile agents systems and weighted timed automata},
  volume       = {282},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Weighted automata computation of edit distances with
consolidations and fragmentations. <em>IANDC</em>, <em>282</em>, 104652.
(<a href="https://doi.org/10.1016/j.ic.2020.104652">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study edit distances between strings, based on weighted operations such as character substitutions, insertions, deletions, and consolidations and fragmentations . The two latter operations transform a sequence of characters into one character and vice-versa. They correspond to the compression and expansion in Dynamic Time-Warping algorithms for speech recognition and are used for the formal analysis of written music. We show that such edit distances are not computable in general, and propose weighted automata constructions to compute restricted cases of edit distances, taking into account both consolidations and deletions, or both fragmentations and insertions. Assuming that the operation ruleset has a constant size, these constructions are polynomial into the lengths of the involved strings. We finally show that the optimal weight of sequences made of consolidations chained with fragmentations, in that order, is computable for arbitrary rulesets, and not computable for some rulesets when reversing the order of fragmentations and consolidations.},
  archive      = {J_IANDC},
  author       = {Mathieu Giraud and Florent Jacquemard},
  doi          = {10.1016/j.ic.2020.104652},
  journal      = {Information and Computation},
  pages        = {104652},
  shortjournal = {Inf. Comput.},
  title        = {Weighted automata computation of edit distances with consolidations and fragmentations},
  volume       = {282},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). What’s decidable about weighted automata? <em>IANDC</em>,
<em>282</em>, 104651. (<a
href="https://doi.org/10.1016/j.ic.2020.104651">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Weighted automata map input words to values, and have numerous applications in computer science. A result by Krob from the 90s implies that the universality problem is decidable for weighted automata over the tropical semiring with weights in N ∪ { ∞ } N∪{∞} and is undecidable when the weights are in Z ∪ { ∞ } Z∪{∞} . We continue the study of the borders of decidability in weighted automata over the tropical semiring. We give a complete picture of the decidability and complexity of various decision problems for them, including non-emptiness, universality, equality, and containment. For the undecidability results, we provide direct proofs, which stay in the terrain of state machines. This enables us to tighten the results and apply them to a very simple class of automata. In addition, we provide a toolbox of algorithms and techniques for weighted automata, on top of which we establish the complexity bounds.},
  archive      = {J_IANDC},
  author       = {Shaull Almagor and Udi Boker and Orna Kupferman},
  doi          = {10.1016/j.ic.2020.104651},
  journal      = {Information and Computation},
  pages        = {104651},
  shortjournal = {Inf. Comput.},
  title        = {What&#39;s decidable about weighted automata?},
  volume       = {282},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Preservation of normality by transducers. <em>IANDC</em>,
<em>282</em>, 104650. (<a
href="https://doi.org/10.1016/j.ic.2020.104650">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider input deterministic finite state transducers with infinite inputs and infinite outputs, and we consider the property of Borel normality on infinite words. When these transducers are given by a strongly connected set of states, and when the input is a Borel normal sequence, the output is an infinite word such that every word has a frequency given by a weighted automaton over the rationals. We prove that there is an algorithm that decides in cubic time whether an input deterministic transducer preserves normality.},
  archive      = {J_IANDC},
  author       = {Olivier Carton and Elisa Orduna},
  doi          = {10.1016/j.ic.2020.104650},
  journal      = {Information and Computation},
  pages        = {104650},
  shortjournal = {Inf. Comput.},
  title        = {Preservation of normality by transducers},
  volume       = {282},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Bisimulation metrics and norms for real-weighted automata.
<em>IANDC</em>, <em>282</em>, 104649. (<a
href="https://doi.org/10.1016/j.ic.2020.104649">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We develop a new bisimulation (pseudo)metric for weighted finite automata (WFA) that generalizes Boreale&#39;s linear bisimulation relation. Our metrics are induced by seminorms on the state space of WFA. Our development is based on spectral properties of sets of linear operators . In particular, the joint spectral radius of the transition matrices of WFA plays a central role. We also study continuity properties of the bisimulation pseudometric , establish an undecidability result for computing the metric, and give a preliminary account of applications to spectral learning of weighted automata .},
  archive      = {J_IANDC},
  author       = {Borja Balle and Pascale Gourdeau and Prakash Panangaden},
  doi          = {10.1016/j.ic.2020.104649},
  journal      = {Information and Computation},
  pages        = {104649},
  shortjournal = {Inf. Comput.},
  title        = {Bisimulation metrics and norms for real-weighted automata},
  volume       = {282},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Probabilistic automata of bounded ambiguity. <em>IANDC</em>,
<em>282</em>, 104648. (<a
href="https://doi.org/10.1016/j.ic.2020.104648">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Probabilistic automata are an extension of nondeterministic finite automata in which transitions are annotated with probabilities . Despite its simplicity, this model is very expressive and many algorithmic questions are undecidable. In this work we focus on the emptiness problem (and its variant the value problem), which asks whether a given probabilistic automaton accepts some word with probability greater than a given threshold. We consider finitely ambiguous probabilistic automata . Our main contributions are to construct efficient algorithms for analysing finitely ambiguous probabilistic automata through a reduction to a multi-objective optimisation problem called the stochastic path problem. We obtain a polynomial time algorithm for approximating the value of probabilistic automata of fixed ambiguity and a quasi-polynomial time algorithm for the emptiness problem for 2-ambiguous probabilistic automata. We complement these positive results by an inapproximability result stating that the value of finitely ambiguous probabilistic automata cannot be approximated unless P = NP P=NP .},
  archive      = {J_IANDC},
  author       = {Nathanaël Fijalkow and Cristian Riveros and James Worrell},
  doi          = {10.1016/j.ic.2020.104648},
  journal      = {Information and Computation},
  pages        = {104648},
  shortjournal = {Inf. Comput.},
  title        = {Probabilistic automata of bounded ambiguity},
  volume       = {282},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Weighted propositional configuration logics: A specification
language for architectures with quantitative features. <em>IANDC</em>,
<em>282</em>, 104647. (<a
href="https://doi.org/10.1016/j.ic.2020.104647">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce and investigate a weighted propositional configuration logic over commutative semirings. Our logic is intended to serve as a specification language for software architectures with quantitative features. We prove an efficient construction of full normal forms and decidability of equivalence of formulas in this logic. We illustrate the motivation of this work by describing well-known architectures equipped with quantitative characteristics using formulas in our logic.},
  archive      = {J_IANDC},
  author       = {Paulina Paraponiari and George Rahonis},
  doi          = {10.1016/j.ic.2020.104647},
  journal      = {Information and Computation},
  pages        = {104647},
  shortjournal = {Inf. Comput.},
  title        = {Weighted propositional configuration logics: A specification language for architectures with quantitative features},
  volume       = {282},
  year         = {2022},
}
</textarea>
</details></li>
<li><details>
<summary>
(2022). Preface. <em>IANDC</em>, <em>282</em>, 104646. (<a
href="https://doi.org/10.1016/j.ic.2020.104646">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_IANDC},
  author       = {Manfred Droste and Andreas Maletti and Heiko Vogler},
  doi          = {10.1016/j.ic.2020.104646},
  journal      = {Information and Computation},
  pages        = {104646},
  shortjournal = {Inf. Comput.},
  title        = {Preface},
  volume       = {282},
  year         = {2022},
}
</textarea>
</details></li>
</ul>

</body>
</html>
