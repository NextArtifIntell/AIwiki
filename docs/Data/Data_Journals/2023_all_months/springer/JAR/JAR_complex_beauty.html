<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>JAR_complex_beauty</title>
  <style>
    html {font-size: 22px;}
    body {margin: 0 auto; max-width: 76em;}
    #copyID {font-size: 18px;}
  </style>
  <script>
    function copy(element) {
      if (element.type == "button"){
      element.type="text";
      }
      element.style.color="black";
      element.style.backgroundColor="#C7EDCC";
      element.select();
      element.setSelectionRange(0, 99999);
      navigator.clipboard.writeText(element.value);
      window.getSelection().removeAllRanges();
      element.type="button";
    }
  </script>
</head>
<body>

<h2 id="jar---40">JAR - 40</h2>
<ul>
<li><details>
<summary>
(2023). Formal verification of termination criteria for first-order
recursive functions. <em>JAR</em>, <em>67</em>(4), 1–30. (<a
href="https://doi.org/10.1007/s10817-023-09669-z">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper presents a formalization of several termination criteria for first-order recursive functions. The formalization, which is developed in the Prototype Verification System (PVS), includes the specification and proof of equivalence of semantic termination, Turing termination, size change principle, calling context graphs, and matrix-weighted graphs. These termination criteria are defined on a computational model that consists of a basic functional language called PVS0, which is an embedding of recursive first-order functions. Through this embedding, the native mechanism for checking termination of recursive functions in PVS could be soundly extended with semi-automatic termination criteria such as calling contexts graphs.},
  archive      = {J_JAR},
  author       = {Muñoz, Cesar A. and Ayala-Rincón, Mauricio and Moscato, Mariano M. and Dutle, Aaron M. and Narkawicz, Anthony J. and Almeida, Ariane Alves and da Silva, Andréia B. Avelar and Ramos, Thiago M. Ferreira},
  doi          = {10.1007/s10817-023-09669-z},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {1-30},
  shortjournal = {J. Auto. Reasoning},
  title        = {Formal verification of termination criteria for first-order recursive functions},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Enabling floating-point arithmetic in the coq proof
assistant. <em>JAR</em>, <em>67</em>(4), 1–30. (<a
href="https://doi.org/10.1007/s10817-023-09679-x">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Floating-point arithmetic is a well-known and extremely efficient way of performing approximate computations over the real numbers. Although it requires some careful considerations, floating-point numbers are nowadays routinely used to prove mathematical theorems. Numerical computations have been applied in the context of formal proofs too, as illustrated by the CoqInterval library. But these computations do not benefit from the powerful floating-point units available in modern processors, since they are emulated inside the logic of the formal system. This paper experiments with the use of hardware floating-point numbers for numerically intensive proofs verified by the Coq proof assistant. This gives rise to various questions regarding the formalization, the implementation, the usability, and the level of trust. This approach has been applied to the CoqInterval and ValidSDP libraries, which demonstrates a speedup of at least one order of magnitude.},
  archive      = {J_JAR},
  author       = {Martin-Dorel, Érik and Melquiond, Guillaume and Roux, Pierre},
  doi          = {10.1007/s10817-023-09679-x},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {1-30},
  shortjournal = {J. Auto. Reasoning},
  title        = {Enabling floating-point arithmetic in the coq proof assistant},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Finitary type theories with and without contexts.
<em>JAR</em>, <em>67</em>(4), 1–87. (<a
href="https://doi.org/10.1007/s10817-023-09678-y">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We give a definition of finitary type theories that subsumes many examples of dependent type theories, such as variants of Martin–Löf type theory, simple type theories, first-order and higher-order logics, and homotopy type theory. We prove several general meta-theorems about finitary type theories: weakening, admissibility of substitution and instantiation of metavariables, derivability of presuppositions, uniqueness of typing, and inversion principles. We then give a second formulation of finitary type theories in which there are no explicit contexts. Instead, free variables are explicitly annotated with their types. We provide translations between finitary type theories with and without contexts, thereby showing that they have the same expressive power. The context-free type theory is implemented in the nucleus of the Andromeda 2 proof assistant.},
  archive      = {J_JAR},
  author       = {Haselwarter, Philipp G. and Bauer, Andrej},
  doi          = {10.1007/s10817-023-09678-y},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {1-87},
  shortjournal = {J. Auto. Reasoning},
  title        = {Finitary type theories with and without contexts},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Lower bounds for QCDCL via formula gauge. <em>JAR</em>,
<em>67</em>(4), 1–25. (<a
href="https://doi.org/10.1007/s10817-023-09683-1">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {QCDCL is one of the main algorithmic paradigms for solving quantified Boolean formulas (QBF). We design a new technique to show lower bounds for the running time in QCDCL algorithms. For this we model QCDCL by concisely defined proof systems and identify a new width measure for formulas, which we call gauge. We show that for a large class of QBFs, large (e.g. linear) gauge implies exponential lower bounds for QCDCL proof size. We illustrate our technique by computing the gauge for a number of sample QBFs, thereby providing new exponential lower bounds for QCDCL. Our technique is the first bespoke lower bound technique for QCDCL.},
  archive      = {J_JAR},
  author       = {Böhm, Benjamin and Beyersdorff, Olaf},
  doi          = {10.1007/s10817-023-09683-1},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {1-25},
  shortjournal = {J. Auto. Reasoning},
  title        = {Lower bounds for QCDCL via formula gauge},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Combining stable infiniteness and (strong) politeness.
<em>JAR</em>, <em>67</em>(4), 1–22. (<a
href="https://doi.org/10.1007/s10817-023-09684-0">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Polite theory combination is a method for obtaining a solver for a combination of two (or more) theories using the solvers of each individual theory as black boxes. Unlike the earlier Nelson–Oppen method, which is usable only when both theories are stably infinite, only one of the theories needs to be strongly polite in order to use the polite combination method. In its original presentation, politeness was required from one of the theories rather than strong politeness, which was later proven to be insufficient. The first contribution of this paper is a proof that indeed these two notions are different, obtained by presenting a polite theory that is not strongly polite. We also study several variants of this question. The cost of the generality afforded by the polite combination method, compared to the Nelson–Oppen method, is a larger space of arrangements to consider, involving variables that are not necessarily shared between the purified parts of the input formula. The second contribution of this paper is a hybrid method (building on both polite and Nelson–Oppen combination), which aims to reduce the number of considered variables when a theory is stably infinite with respect to some of its sorts but not all of them. The time required to reason about arrangements is exponential in the worst case, so reducing the number of variables considered has the potential to improve performance significantly. We show preliminary evidence for this by demonstrating significant speed-up on a smart contract verification benchmark.},
  archive      = {J_JAR},
  author       = {Sheng, Ying and Zohar, Yoni and Ringeissen, Christophe and Reynolds, Andrew and Barrett, Clark and Tinelli, Cesare},
  doi          = {10.1007/s10817-023-09684-0},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {1-22},
  shortjournal = {J. Auto. Reasoning},
  title        = {Combining stable infiniteness and (Strong) politeness},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Bisequent calculus for four-valued quasi-relevant logics:
Cut elimination and interpolation. <em>JAR</em>, <em>67</em>(4), 1–19.
(<a href="https://doi.org/10.1007/s10817-023-09685-z">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present a uniform syntactical characterisation of the class of quasi-relevant logics which are four-valued extensions of the basic relevant logic B of Meyer and Routley. All these logics are obtained by the addition of suitable quasi-relevant implications to the four-valued logic of First Degree Entailment FDE. So far they were characterised axiomatically and semantically in several ways but did not obtain a special proof-theoretic treatment. To this aim a generalised form of sequent calculus called bisequent calculus (BSC) is applied. In BSC rules operate on the ordered pairs of ordinary sequents. It may be treated as the weakest kind of system in the rich family of generalised sequent calculi operating on items which are some collections of ordinary sequents, like hypersequents or nested sequents. It is shown that all logics under consideration have cut-free characterisation in BSC which satisfies the subformula property and yields decidability. It is also shown that the interpolation theorem holds for these logics if their language is enriched with additional negation.},
  archive      = {J_JAR},
  author       = {Indrzejczak, Andrzej},
  doi          = {10.1007/s10817-023-09685-z},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {1-19},
  shortjournal = {J. Auto. Reasoning},
  title        = {Bisequent calculus for four-valued quasi-relevant logics: Cut elimination and interpolation},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Saturation-based boolean conjunctive query answering and
rewriting for the guarded quantification fragments. <em>JAR</em>,
<em>67</em>(4), 1–68. (<a
href="https://doi.org/10.1007/s10817-023-09687-x">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Query answering is an important problem in AI, database and knowledge representation. In this paper, we develop saturation-based Boolean conjunctive query answering and rewriting procedures for the guarded, the loosely guarded and the clique-guarded fragments. Our query answering procedure improves existing resolution-based decision procedures for the guarded and the loosely guarded fragments and this procedure solves Boolean conjunctive query answering problems for the guarded, the loosely guarded and the clique-guarded fragments. Based on this query answering procedure, we also introduce a novel saturation-based query rewriting procedure for these guarded fragments. Unlike mainstream query answering and rewriting methods, our procedures derive a compact and reusable saturation, namely a closure of formulas, to handle the challenge of querying for distributed datasets. This paper lays the theoretical foundations for the first automated deduction decision procedures for Boolean conjunctive query answering and the first saturation-based Boolean conjunctive query rewriting in the guarded, the loosely guarded and the clique-guarded fragments.},
  archive      = {J_JAR},
  author       = {Zheng, Sen and Schmidt, Renate A.},
  doi          = {10.1007/s10817-023-09687-x},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {1-68},
  shortjournal = {J. Auto. Reasoning},
  title        = {Saturation-based boolean conjunctive query answering and rewriting for the guarded quantification fragments},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Self-evident automated geometric theorem proving based on
complex number identity. <em>JAR</em>, <em>67</em>(4), 1–18. (<a
href="https://doi.org/10.1007/s10817-023-09688-w">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {How to automatically generate short and easy-to-understand proofs for geometric theorems has long been an issue of concern in mathematics education. A novel automated geometric theorem proving method based on complex number identities is proposed in this paper, which acts as a bridge between geometry and algebra. According to the proposed method, the geometric relations in the given proposition are first transformed into a complex number expression, then the complex number identity is generated by the elimination method; finally, the closure property under all four operations of real numbers is employed to prove the proposition. A test on more than 300 geometric problems shows that the proposed method is highly effective, and the corresponding proofs are short, with obvious geometric meaning.},
  archive      = {J_JAR},
  author       = {Peng, Xicheng and Zhang, Jingzhong and Chen, Mao and Liu, Sannyuya},
  doi          = {10.1007/s10817-023-09688-w},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {1-18},
  shortjournal = {J. Auto. Reasoning},
  title        = {Self-evident automated geometric theorem proving based on complex number identity},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). POSIX lexing with derivatives of regular expressions.
<em>JAR</em>, <em>67</em>(3), 1–24. (<a
href="https://doi.org/10.1007/s10817-023-09667-1">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Brzozowski introduced the notion of derivatives for regular expressions. They can be used for a very simple regular expression matching algorithm. Sulzmann and Lu cleverly extended this algorithm in order to deal with POSIX matching, which is the underlying disambiguation strategy for regular expressions needed in lexers. Their algorithm generates POSIX values which encode the information of how a regular expression matches a string—that is, which part of the string is matched by which part of the regular expression. In this paper we give our inductive definition of what a POSIX value is and show that Sulzmann and Lu’s algorithm always generates such a value. We also show that our inductive definition of a POSIX value is equivalent to an alternative definition by Okui and Suzuki which identifies POSIX values as least elements according to an ordering of values.},
  archive      = {J_JAR},
  author       = {Urban, Christian},
  doi          = {10.1007/s10817-023-09667-1},
  journal      = {Journal of Automated Reasoning},
  number       = {3},
  pages        = {1-24},
  shortjournal = {J. Auto. Reasoning},
  title        = {POSIX lexing with derivatives of regular expressions},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). A resolution proof system for dependency stochastic boolean
satisfiability. <em>JAR</em>, <em>67</em>(3), 1–27. (<a
href="https://doi.org/10.1007/s10817-023-09670-6">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Dependency stochastic Boolean satisfiability (DSSAT), which generalizes stochastic Boolean satisfiability (SSAT) and dependency quantified Boolean formula (DQBF), is a new logical formalism that allows compact encoding of NEXPTIME decision problems under uncertainty. Despite potentially broad applications, a decision procedure for DSSAT remains lacking. In this work, we present the first sound and complete resolution calculus for DSSAT. The resolution system deduces the maximum satisfying probability of a DSSAT formula and provides a witnessing certificate. We also show that when the special case of SSAT formulas is considered, the DSSAT resolution calculus p-simulates a known SSAT resolution scheme. Our result may pave a theoretical foundation for further development and certification of DSSAT solvers.},
  archive      = {J_JAR},
  author       = {Luo, Yun-Rong and Cheng, Che and Jiang, Jie-Hong R.},
  doi          = {10.1007/s10817-023-09670-6},
  journal      = {Journal of Automated Reasoning},
  number       = {3},
  pages        = {1-27},
  shortjournal = {J. Auto. Reasoning},
  title        = {A resolution proof system for dependency stochastic boolean satisfiability},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Measure construction by extension in dependent type theory
with application to integration. <em>JAR</em>, <em>67</em>(3), 1–27. (<a
href="https://doi.org/10.1007/s10817-023-09671-5">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We report on an original formalization of measure and integration theory in the Coq proof assistant. We build the Lebesgue measure following a standard construction that had not yet been formalized in proof assistants based on dependent type theory: by extension of a measure over a semiring of sets. We achieve this formalization by leveraging on existing techniques from the Mathematical Components project. We explain how we extend Mathematical Components’ iterated operators and mathematical structures for analysis to provide support for infinite sums and extended real numbers. We introduce new mathematical structures for measure theory and incidentally provide an illustrative, concrete application of Hierarchy-Builder, a generic tool for the formalization of hierarchies of mathematical structures. This formalization of measure theory provides the basis for a new formalization of the Lebesgue integration compatible with the Mathematical Components project.},
  archive      = {J_JAR},
  author       = {Affeldt, Reynald and Cohen, Cyril},
  doi          = {10.1007/s10817-023-09671-5},
  journal      = {Journal of Automated Reasoning},
  number       = {3},
  pages        = {1-27},
  shortjournal = {J. Auto. Reasoning},
  title        = {Measure construction by extension in dependent type theory with application to integration},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Rensets and renaming-based recursion for syntax with
bindings extended version. <em>JAR</em>, <em>67</em>(3), 1–27. (<a
href="https://doi.org/10.1007/s10817-023-09672-4">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce renaming-enriched sets (rensets for short), which are algebraic structures axiomatizing fundamental properties of renaming (also known as variable-for-variable substitution) on syntax with bindings. Rensets compare favorably in some respects with the well-known foundation based on nominal sets. In particular, renaming is a more fundamental operator than the nominal swapping operator and enjoys a simpler, equationally expressed relationship with the variable-freshness predicate. Together with some natural axioms matching properties of the syntactic constructors, rensets yield a truly minimalistic characterization of $$\lambda $$ -calculus terms as an abstract datatype—one involving an infinite set of unconditional equations, referring only to the most fundamental term operators: the constructors and renaming. This characterization yields a recursion principle, which (similarly to the case of nominal sets) can be improved by incorporating Barendregt’s variable convention. When interpreting syntax in semantic domains, our renaming-based recursor is easier to deploy than the nominal recursor. Our results have been validated with the proof assistant Isabelle/HOL.},
  archive      = {J_JAR},
  author       = {Popescu, Andrei},
  doi          = {10.1007/s10817-023-09672-4},
  journal      = {Journal of Automated Reasoning},
  number       = {3},
  pages        = {1-27},
  shortjournal = {J. Auto. Reasoning},
  title        = {Rensets and renaming-based recursion for syntax with bindings extended version},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Binary codes that do not preserve primitivity. <em>JAR</em>,
<em>67</em>(3), 1–27. (<a
href="https://doi.org/10.1007/s10817-023-09674-2">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A set of words X is not primitivity-preserving if there is a primitive list of length at least two of elements from X whose concatenation is imprimitive. Here, a word or list is primitive if it is not equal to a concatenation of several copies of a shorter word or list, and imprimitive otherwise. We formalize a full characterization of such two-element sets $${x,y}$$ in the proof assistant Isabelle/HOL. The formalization is based on an existing proof which we analyze and simplify using some innovative ideas. Part of the formalization, interesting on its own, is a description of the ways in which the square xx can appear inside a concatenation of words x and y if $$\left| y \right| \le \left| x \right| $$ . We also provide a formalized parametric solution of the related equation $$x^jy^k = z^\ell $$ .},
  archive      = {J_JAR},
  author       = {Holub, Štěpán and Raška, Martin and Starosta, Štěpán},
  doi          = {10.1007/s10817-023-09674-2},
  journal      = {Journal of Automated Reasoning},
  number       = {3},
  pages        = {1-27},
  shortjournal = {J. Auto. Reasoning},
  title        = {Binary codes that do not preserve primitivity},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). SCL(EQ): SCL for first-order logic with equality.
<em>JAR</em>, <em>67</em>(3), 1–35. (<a
href="https://doi.org/10.1007/s10817-023-09673-3">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We propose a new calculus SCL(EQ) for first-order logic with equality that only learns non-redundant clauses. Following the idea of CDCL (Conflict Driven Clause Learning) and SCL (Clause Learning from Simple Models) a ground literal model assumption is used to guide inferences that are then guaranteed to be non-redundant. Redundancy is defined with respect to a dynamically changing ordering derived from the ground literal model assumption. We prove SCL(EQ) sound and complete and provide examples where our calculus improves on superposition.},
  archive      = {J_JAR},
  author       = {Leidinger, Hendrik and Weidenbach, Christoph},
  doi          = {10.1007/s10817-023-09673-3},
  journal      = {Journal of Automated Reasoning},
  number       = {3},
  pages        = {1-35},
  shortjournal = {J. Auto. Reasoning},
  title        = {SCL(EQ): SCL for first-order logic with equality},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Cyclic hypersequent system for transitive closure logic.
<em>JAR</em>, <em>67</em>(3), 1–40. (<a
href="https://doi.org/10.1007/s10817-023-09675-1">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We propose a cut-free cyclic system for transitive closure logic (TCL) based on a form of hypersequents, suitable for automated reasoning via proof search. We show that previously proposed sequent systems are cut-free incomplete for basic validities from Kleene Algebra (KA) and propositional dynamic logic ( $$\text {PDL}$$ ), over standard translations. On the other hand, our system faithfully simulates known cyclic systems for KA and $$\text {PDL}$$ , thereby inheriting their completeness results. A peculiarity of our system is its richer correctness criterion, exhibiting ‘alternating traces’ and necessitating a more intricate soundness argument than for traditional cyclic proofs.},
  archive      = {J_JAR},
  author       = {Das, Anupam and Girlando, Marianna},
  doi          = {10.1007/s10817-023-09675-1},
  journal      = {Journal of Automated Reasoning},
  number       = {3},
  pages        = {1-40},
  shortjournal = {J. Auto. Reasoning},
  title        = {Cyclic hypersequent system for transitive closure logic},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Mechanising gödel–löb provability logic in HOL light.
<em>JAR</em>, <em>67</em>(3), 1–34. (<a
href="https://doi.org/10.1007/s10817-023-09677-z">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce our implementation in HOL Light of the metatheory for Gödel–Löb provability logic (GL), covering soundness and completeness w.r.t. possible world semantics and featuring a prototype of a theorem prover for GL itself. The strategy we develop here to formalise the modal completeness proof overcomes the technical difficulty due to the non-compactness of GL and is an adaptation—according to the formal language and tools at hand—of the proof given in George Boolos’ 1995 monograph. Our theorem prover for GL relies then on this formalisation, is implemented as a tactic of HOL Light that mimics the proof search in the labelled sequent calculus $$\textsf{G3KGL}$$ , and works as a decision algorithm for the provability logic: if the algorithm positively terminates, the tactic succeeds in producing a HOL Light theorem stating that the input formula is a theorem of GL; if the algorithm negatively terminates, the tactic extracts a model falsifying the input formula. We discuss our code for the formal proof of modal completeness and the design of our proof search algorithm. Furthermore, we propose some examples of the latter’s interactive and automated use.},
  archive      = {J_JAR},
  author       = {Maggesi, Marco and Perini Brogi, Cosimo},
  doi          = {10.1007/s10817-023-09677-z},
  journal      = {Journal of Automated Reasoning},
  number       = {3},
  pages        = {1-34},
  shortjournal = {J. Auto. Reasoning},
  title        = {Mechanising Gödel–Löb provability logic in HOL light},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Reasoning about vectors: Satisfiability modulo a theory of
sequences. <em>JAR</em>, <em>67</em>(3), 1–34. (<a
href="https://doi.org/10.1007/s10817-023-09682-2">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Dynamic arrays, also referred to as vectors, are fundamental data structures used in many programs. Modeling their semantics efficiently is crucial when reasoning about such programs. The theory of arrays is widely supported but is not ideal, because the number of elements is fixed (determined by its index sort) and cannot be adjusted, which is a problem, given that the length of vectors often plays an important role when reasoning about vector programs. In this paper, we propose reasoning about vectors using a theory of sequences. We introduce the theory, propose a basic calculus adapted from one for the theory of strings, and extend it to efficiently handle common vector operations. We prove that our calculus is sound and show how to construct a model when it terminates with a saturated configuration. Finally, we describe an implementation of the calculus in cvc5 and demonstrate its efficacy by evaluating it on verification conditions for smart contracts and benchmarks derived from existing array benchmarks.},
  archive      = {J_JAR},
  author       = {Sheng, Ying and Nötzli, Andres and Reynolds, Andrew and Zohar, Yoni and Dill, David and Grieskamp, Wolfgang and Park, Junkil and Qadeer, Shaz and Barrett, Clark and Tinelli, Cesare},
  doi          = {10.1007/s10817-023-09682-2},
  journal      = {Journal of Automated Reasoning},
  number       = {3},
  pages        = {1-34},
  shortjournal = {J. Auto. Reasoning},
  title        = {Reasoning about vectors: Satisfiability modulo a theory of sequences},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). A proof procedure for separation logic with inductive
definitions and data. <em>JAR</em>, <em>67</em>(3), 1–46. (<a
href="https://doi.org/10.1007/s10817-023-09680-4">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A proof procedure, in the spirit of the sequent calculus, is proposed to check the validity of entailments between Separation Logic formulas combining inductively defined predicates denoting structures of bounded tree width and theory reasoning. The calculus is sound and complete, in the sense that a sequent is valid iff it admits a (possibly infinite) proof tree. We also show that the procedure terminates in the two following cases: (i) When the inductive rules that define the predicates occurring on the left-hand side of the entailment terminate, in which case the proof tree is always finite. (ii) When the theory is empty, in which case every valid sequent admits a rational proof tree, where the total number of pairwise distinct sequents occurring in the proof tree is doubly exponential w.r.t. the size of the end-sequent.},
  archive      = {J_JAR},
  author       = {Echenim, Mnacho and Peltier, Nicolas},
  doi          = {10.1007/s10817-023-09680-4},
  journal      = {Journal of Automated Reasoning},
  number       = {3},
  pages        = {1-46},
  shortjournal = {J. Auto. Reasoning},
  title        = {A proof procedure for separation logic with inductive definitions and data},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Preprocessing of propagation redundant clauses.
<em>JAR</em>, <em>67</em>(3), 1–26. (<a
href="https://doi.org/10.1007/s10817-023-09681-3">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The propagation redundant (PR) proof system generalizes the resolution and resolution asymmetric tautology proof systems used by conflict-driven clause learning (CDCL) solvers. PR allows short proofs of unsatisfiability for some problems that are difficult for CDCL solvers. Previous attempts to automate PR clause learning used hand-crafted heuristics that work well on some highly-structured problems. For example, the solver SaDiCaL incorporates PR clause learning into the CDCL loop, but it cannot compete with modern CDCL solvers due to its fragile heuristics. We present PReLearn, a preprocessing technique that learns short PR clauses. Adding these clauses to a formula reduces the search space that the solver must explore. By performing PR clause learning as a preprocessing stage, PR clauses can be found efficiently without sacrificing the robustness of modern CDCL solvers. On a large portion of SAT competition benchmarks we found that preprocessing with PReLearn improves solver performance. In addition, there were several satisfiable and unsatisfiable formulas that could only be solved after preprocessing with PReLearn. PReLearn supports proof logging, giving a high level of confidence in the results. Lastly, we tested the robustness of PReLearn by applying other forms of preprocessing as well as by randomly permuting variable names in the formula before running PReLearn, and we found PReLearn performed similarly with and without the changes to the formula.},
  archive      = {J_JAR},
  author       = {Reeves, Joseph E. and Heule, Marijn J. H. and Bryant, Randal E.},
  doi          = {10.1007/s10817-023-09681-3},
  journal      = {Journal of Automated Reasoning},
  number       = {3},
  pages        = {1-26},
  shortjournal = {J. Auto. Reasoning},
  title        = {Preprocessing of propagation redundant clauses},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). An automated approach to the collatz conjecture.
<em>JAR</em>, <em>67</em>(2), 1–44. (<a
href="https://doi.org/10.1007/s10817-022-09658-8">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We explore the Collatz conjecture and its variants through the lens of termination of string rewriting. We construct a rewriting system that simulates the iterated application of the Collatz function on strings corresponding to mixed binary–ternary representations of positive integers. We prove that the termination of this rewriting system is equivalent to the Collatz conjecture. We also prove that a previously studied rewriting system that simulates the Collatz function using unary representations does not admit termination proofs via natural matrix interpretations, even when used in conjunction with dependency pairs. To show the feasibility of our approach in proving mathematically interesting statements, we implement a minimal termination prover that uses natural/arctic matrix interpretations and we find automated proofs of nontrivial weakenings of the Collatz conjecture. Although we do not succeed in proving the Collatz conjecture, we believe that the ideas here represent an interesting new approach.},
  archive      = {J_JAR},
  author       = {Yolcu, Emre and Aaronson, Scott and Heule, Marijn J. H.},
  doi          = {10.1007/s10817-022-09658-8},
  journal      = {Journal of Automated Reasoning},
  number       = {2},
  pages        = {1-44},
  shortjournal = {J. Auto. Reasoning},
  title        = {An automated approach to the collatz conjecture},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Unifying splitting. <em>JAR</em>, <em>67</em>(2), 1–44. (<a
href="https://doi.org/10.1007/s10817-023-09660-8">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {AVATAR is an elegant and effective way to split clauses in a saturation prover using a SAT solver. But is it refutationally complete? And how does it relate to other splitting architectures? To answer these questions, we present a unifying framework that extends a saturation calculus (e.g., superposition) with splitting and that embeds the result in a prover guided by a SAT solver. The framework also allows us to study locking, a subsumption-like mechanism based on the current propositional model. Various architectures are instances of the framework, including AVATAR, labeled splitting, and SMT with quantifiers.},
  archive      = {J_JAR},
  author       = {Ebner, Gabriel and Blanchette, Jasmin and Tourret, Sophie},
  doi          = {10.1007/s10817-023-09660-8},
  journal      = {Journal of Automated Reasoning},
  number       = {2},
  pages        = {1-44},
  shortjournal = {J. Auto. Reasoning},
  title        = {Unifying splitting},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). First-order theory of rewriting for linear
variable-separated rewrite systems: Automation, formalization,
certification. <em>JAR</em>, <em>67</em>(2), 1–76. (<a
href="https://doi.org/10.1007/s10817-023-09661-7">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The first-order theory of rewriting is decidable for linear variable-separated rewrite systems. We present a new decision procedure which is the basis of FORT, a decision and synthesis tool for properties expressible in the theory. The decision procedure is based on tree automata techniques and verified in Isabelle. Several extensions make the theory more expressive and FORT more versatile. We present a certificate language that enables the output of FORT to be certified by the certifier FORTify generated from the formalization, and we provide extensive experiments.},
  archive      = {J_JAR},
  author       = {Middeldorp, Aart and Lochmann, Alexander and Mitterwallner, Fabian},
  doi          = {10.1007/s10817-023-09661-7},
  journal      = {Journal of Automated Reasoning},
  number       = {2},
  pages        = {1-76},
  shortjournal = {J. Auto. Reasoning},
  title        = {First-order theory of rewriting for linear variable-separated rewrite systems: Automation, formalization, certification},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Combining higher-order logic with set theory formalizations.
<em>JAR</em>, <em>67</em>(2), 1–23. (<a
href="https://doi.org/10.1007/s10817-023-09663-5">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Isabelle Higher-order Tarski–Grothendieck object logic includes in its foundations both higher-order logic and set theory, which allows importing the libraries of Isabelle/HOL and Isabelle/Mizar. The two libraries, however, define all the basic concepts independently, which means that the results in the two are disconnected. In this paper, we align significant parts of these two libraries, by defining isomorphisms between their concepts, including the real numbers and algebraic structures. The isomorphisms allow us to transport theorems between the foundations and use the results from the libraries simultaneously.},
  archive      = {J_JAR},
  author       = {Kaliszyk, Cezary and Pąk, Karol},
  doi          = {10.1007/s10817-023-09663-5},
  journal      = {Journal of Automated Reasoning},
  number       = {2},
  pages        = {1-23},
  shortjournal = {J. Auto. Reasoning},
  title        = {Combining higher-order logic with set theory formalizations},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Synthesising programs with non-trivial constants.
<em>JAR</em>, <em>67</em>(2), 1–25. (<a
href="https://doi.org/10.1007/s10817-023-09664-4">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Program synthesis is the mechanised construction of software. One of the main difficulties is the efficient exploration of the very large solution space, and tools often require a user-provided syntactic restriction of the search space. While useful in general, such syntactic restrictions provide little help for the generation of programs that contain non-trivial constants, unless the user is able to provide the constants in advance. This is a fundamentally difficult task for state-of-the-art synthesisers. We propose a new approach to the synthesis of programs with non-trivial constants that combines the strengths of a counterexample-guided inductive synthesiser with those of a theory solver, exploring the solution space more efficiently without relying on user guidance. We call this approach CEGIS( $$\mathcal {T}$$ ), where $$\mathcal {T}$$ is a first-order theory. We present two exemplars, one based on Fourier-Motzkin (FM) variable elimination and one based on first-order satisfiability. We demonstrate the practical value of CEGIS( $$\mathcal {T}$$ ) by automatically synthesising programs for a set of intricate benchmarks. Additionally, we present a case study where we integrate CEGIS( $$\mathcal {T}$$ ) within the mature synthesiser CVC4 and show that CEGIS( $$\mathcal {T}$$ ) improves CVC4’s results.},
  archive      = {J_JAR},
  author       = {Abate, Alessandro and Barbosa, Haniel and Barrett, Clark and David, Cristina and Kesseli, Pascal and Kroening, Daniel and Polgreen, Elizabeth and Reynolds, Andrew and Tinelli, Cesare},
  doi          = {10.1007/s10817-023-09664-4},
  journal      = {Journal of Automated Reasoning},
  number       = {2},
  pages        = {1-25},
  shortjournal = {J. Auto. Reasoning},
  title        = {Synthesising programs with non-trivial constants},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). A formal theory of choreographic programming. <em>JAR</em>,
<em>67</em>(2), 1–34. (<a
href="https://doi.org/10.1007/s10817-023-09665-3">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Choreographic programming is a paradigm for writing coordination plans for distributed systems from a global point of view, from which correct-by-construction decentralised implementations can be generated automatically. Theory of choreographies typically includes a number of complex results that are proved by structural induction. The high number of cases and the subtle details in some of these proofs has led to important errors being found in published works. In this work, we formalise the theory of a choreographic programming language in Coq. Our development includes the basic properties of this language, a proof of its Turing completeness, a compilation procedure to a process language, and an operational characterisation of the correctness of this procedure. Our formalisation experience illustrates the benefits of using a theorem prover: we get both an additional degree of confidence from the mechanised proof, and a significant simplification of the underlying theory. Our results offer a foundation for the future formal development of choreographic languages.},
  archive      = {J_JAR},
  author       = {Cruz-Filipe, Luís and Montesi, Fabrizio and Peressotti, Marco},
  doi          = {10.1007/s10817-023-09665-3},
  journal      = {Journal of Automated Reasoning},
  number       = {2},
  pages        = {1-34},
  shortjournal = {J. Auto. Reasoning},
  title        = {A formal theory of choreographic programming},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). An automatically verified prototype of the android
permissions system. <em>JAR</em>, <em>67</em>(2), 1–24. (<a
href="https://doi.org/10.1007/s10817-023-09666-2">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In a previous work we presented formal specifications of idealized formulations of the permission model of Android in the Coq proof assistant. This formal development is about 23 KLOC of Coq code, including proofs. In this work the Coq model is encoded in $${log}$$ (‘setlog’)—a satisfiability solver and a constraint logic programming language— which is then used to automatically discharge most of the proofs performed in Coq. We show how the Coq model is encoded in $${log}$$ and how automated proofs are performed. The resulting $${log}$$ model is an automatically verified executable prototype of the Android permissions system. Detailed data on the empirical evaluation resulting after executing all the proofs in $${log}$$ is provided. The integration of Coq and $${log}$$ as to provide a framework featuring automated proof and prototype generation is discussed.},
  archive      = {J_JAR},
  author       = {Cristiá, Maximiliano and De Luca, Guido and Luna, Carlos},
  doi          = {10.1007/s10817-023-09666-2},
  journal      = {Journal of Automated Reasoning},
  number       = {2},
  pages        = {1-24},
  shortjournal = {J. Auto. Reasoning},
  title        = {An automatically verified prototype of the android permissions system},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Engel’s theorem in mathlib. <em>JAR</em>, <em>67</em>(2),
1–10. (<a href="https://doi.org/10.1007/s10817-023-09668-0">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We discuss the theory of Lie algebras in Lean’s Mathlib library. Using nilpotency as the theme, we outline a computer formalisation of Engel’s theorem and an application to root space theory. We emphasise that all arguments work with coefficients in any commutative ring.},
  archive      = {J_JAR},
  author       = {Nash, Oliver},
  doi          = {10.1007/s10817-023-09668-0},
  journal      = {Journal of Automated Reasoning},
  number       = {2},
  pages        = {1-10},
  shortjournal = {J. Auto. Reasoning},
  title        = {Engel’s theorem in mathlib},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Synthetic undecidability and incompleteness of first-order
axiom systems in coq. <em>JAR</em>, <em>67</em>(1), 1–31. (<a
href="https://doi.org/10.1007/s10817-022-09647-x">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We mechanise the undecidability of various first-order axiom systems in Coq, employing the synthetic approach to computability underlying the growing Coq Library of Undecidability Proofs. Concretely, we cover both semantic and deductive entailment in fragments of Peano arithmetic (PA) as well as ZF and related finitary set theories, with their undecidability established by many-one reductions from solvability of Diophantine equations, i.e. Hilbert’s tenth problem (H10), and the Post correspondence problem (PCP), respectively. In the synthetic setting based on the computability of all functions definable in a constructive foundation, such as Coq’s type theory, it suffices to define these reductions as meta-level functions with no need for further encoding in a formalised model of computation. The concrete cases of PA and the considered set theories are supplemented by a general synthetic theory of undecidable axiomatisations, focusing on well-known connections to consistency and incompleteness. Specifically, our reductions rely on the existence of standard models, necessitating additional assumptions in the case of full ZF, and all axiomatic extensions still justified by such standard models are shown incomplete. As a by-product of the undecidability of set theories formulated using only membership and no equality symbol, we obtain the undecidability of first-order logic with a single binary relation.},
  archive      = {J_JAR},
  author       = {Kirst, Dominik and Hermes, Marc},
  doi          = {10.1007/s10817-022-09647-x},
  journal      = {Journal of Automated Reasoning},
  number       = {1},
  pages        = {1-31},
  shortjournal = {J. Auto. Reasoning},
  title        = {Synthetic undecidability and incompleteness of first-order axiom systems in coq},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). A solver for arrays with concatenation. <em>JAR</em>,
<em>67</em>(1), 1–31. (<a
href="https://doi.org/10.1007/s10817-022-09654-y">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The theory of arrays has been widely investigated. But concatenation, an operator that consistently appears in specifications of functional-correctness verification tools (e.g., Dafny, VeriFast, VST), is not included in most variants of the theory. Arrays with concatenation need better solvers with theoretical guarantees. We formalize a theory of arrays with concatenation, and define the array property fragment with concatenation. Although the array property fragment without concatenation is decidable, the fragment with concatenation is undecidable in general (e.g., when the base theory for array elements is linear integer arithmetic). But we characterize a “tangle-free” fragment; we present an algorithm that classifies verification goals in the array property fragment with concatenation as tangle-free or entangled, and that decides validity of tangle-free goals. We implement the algorithm in Coq and apply it to functional-correctness verification of C programs. The result shows our algorithm is reasonably efficient and reduces a significant amount of human effort in verification tasks. We also give an algorithm for using this array theory solver as a theory solver in SMT solvers.},
  archive      = {J_JAR},
  author       = {Wang, Qinshi and Appel, Andrew W.},
  doi          = {10.1007/s10817-022-09654-y},
  journal      = {Journal of Automated Reasoning},
  number       = {1},
  pages        = {1-31},
  shortjournal = {J. Auto. Reasoning},
  title        = {A solver for arrays with concatenation},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). A formalization and proof checker for isabelle’s metalogic.
<em>JAR</em>, <em>67</em>(1), 1–21. (<a
href="https://doi.org/10.1007/s10817-022-09648-w">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Isabelle is a generic theorem prover with a fragment of higher-order logic as a metalogic for defining object logics. Isabelle also provides proof terms. We formalize this metalogic and the language of proof terms in Isabelle/HOL, define an executable (but inefficient) proof term checker and prove its correctness w.r.t. the metalogic. We integrate the proof checker with Isabelle and run it on a range of logics and theories to check the correctness of all the proofs in those theories.},
  archive      = {J_JAR},
  author       = {Roßkopf, Simon and Nipkow, Tobias},
  doi          = {10.1007/s10817-022-09648-w},
  journal      = {Journal of Automated Reasoning},
  number       = {1},
  pages        = {1-21},
  shortjournal = {J. Auto. Reasoning},
  title        = {A formalization and proof checker for isabelle’s metalogic},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Formalising szemerédi’s regularity lemma and roth’s theorem
on arithmetic progressions in isabelle/HOL. <em>JAR</em>,
<em>67</em>(1), 1–21. (<a
href="https://doi.org/10.1007/s10817-022-09650-2">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We have formalised Szemerédi’s Regularity Lemma and Roth’s Theorem on Arithmetic Progressions, two major results in extremal graph theory and additive combinatorics, using the proof assistant Isabelle/HOL. For the latter formalisation, we used the former to first show the Triangle Counting Lemma and the Triangle Removal Lemma: themselves important technical results. Here, in addition to showcasing the main formalised statements and definitions, we focus on sensitive points in the proofs, describing how we overcame the difficulties that we encountered.},
  archive      = {J_JAR},
  author       = {Edmonds, Chelsea and Koutsoukou-Argyraki, Angeliki and Paulson, Lawrence C.},
  doi          = {10.1007/s10817-022-09650-2},
  journal      = {Journal of Automated Reasoning},
  number       = {1},
  pages        = {1-21},
  shortjournal = {J. Auto. Reasoning},
  title        = {Formalising szemerédi’s regularity lemma and roth’s theorem on arithmetic progressions in Isabelle/HOL},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Measuring the readability of geometric proofs: The area
method case. <em>JAR</em>, <em>67</em>(1), 1–21. (<a
href="https://doi.org/10.1007/s10817-022-09652-0">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Using an approach, inspired by our modernisation of Lemoine’s Geometrography, this paper proposes a new readability criterion for formal proofs produced by automated theorem provers for geometry. We analyse two criteria to measure the readability of a proof: the criterion given by Chou et al. and the one given by Wiedijk. After discussing the limitations of these two criteria, we introduce a novel approach, which provides a new criterion. We conclude discussing some future work.},
  archive      = {J_JAR},
  author       = {Quaresma, Pedro and Graziani, Pierluigi},
  doi          = {10.1007/s10817-022-09652-0},
  journal      = {Journal of Automated Reasoning},
  number       = {1},
  pages        = {1-21},
  shortjournal = {J. Auto. Reasoning},
  title        = {Measuring the readability of geometric proofs: The area method case},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Superposition for higher-order logic. <em>JAR</em>,
<em>67</em>(1), 1–54. (<a
href="https://doi.org/10.1007/s10817-022-09649-9">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We recently designed two calculi as stepping stones towards superposition for full higher-order logic: Boolean-free $$\lambda $$ -superposition and superposition for first-order logic with interpreted Booleans. Stepping on these stones, we finally reach a sound and refutationally complete calculus for higher-order logic with polymorphism, extensionality, Hilbert choice, and Henkin semantics. In addition to the complexity of combining the calculus’s two predecessors, new challenges arise from the interplay between $$\lambda $$ -terms and Booleans. Our implementation in Zipperposition outperforms all other higher-order theorem provers and is on a par with an earlier, pragmatic prototype of Booleans in Zipperposition.},
  archive      = {J_JAR},
  author       = {Bentkamp, Alexander and Blanchette, Jasmin and Tourret, Sophie and Vukmirović, Petar},
  doi          = {10.1007/s10817-022-09649-9},
  journal      = {Journal of Automated Reasoning},
  number       = {1},
  pages        = {1-54},
  shortjournal = {J. Auto. Reasoning},
  title        = {Superposition for higher-order logic},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Correction: Towards formalising schutz’ axioms for minkowski
spacetime in isabelle/HOL. <em>JAR</em>, <em>67</em>(1), 1. (<a
href="https://doi.org/10.1007/s10817-022-09651-1">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_JAR},
  author       = {Schmoetten, Richard and Palmer, Jake E. and Fleuriot, Jacques D.},
  doi          = {10.1007/s10817-022-09651-1},
  journal      = {Journal of Automated Reasoning},
  number       = {1},
  pages        = {1},
  shortjournal = {J. Auto. Reasoning},
  title        = {Correction: Towards formalising schutz’ axioms for minkowski spacetime in Isabelle/HOL},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Linear depth deduction with subformula property for
intuitionistic epistemic logic. <em>JAR</em>, <em>67</em>(1), 1–28. (<a
href="https://doi.org/10.1007/s10817-022-09653-z">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In their seminal paper Artemov and Protopopescu provide Hilbert formal systems, Brower–Heyting–Kolmogorov and Kripke semantics for the logics of intuitionistic belief and knowledge. Subsequently Krupski has proved that the logic of intuitionistic knowledge is PSPACE-complete and Su and Sano have provided calculi enjoying the subformula property. This paper continues the investigations around sequent calculi for Intuitionistic Epistemic Logics by providing sequent calculi that have the subformula property and that are terminating in linear depth. Our calculi allow us to design a procedure that for invalid formulas returns a Kripke model of minimal depth. Finally we also discuss refutational sequent calculi, that is sequent calculi to prove that formulas are invalid.},
  archive      = {J_JAR},
  author       = {Fiorino, Guido},
  doi          = {10.1007/s10817-022-09653-z},
  journal      = {Journal of Automated Reasoning},
  number       = {1},
  pages        = {1-28},
  shortjournal = {J. Auto. Reasoning},
  title        = {Linear depth deduction with subformula property for intuitionistic epistemic logic},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Efficient extensional binary tries. <em>JAR</em>,
<em>67</em>(1), 1–27. (<a
href="https://doi.org/10.1007/s10817-022-09655-x">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Lookup tables (finite maps) are a ubiquitous data structure. In pure functional languages they are best represented using trees instead of hash tables. In pure functional languages within constructive logic, without a primitive integer type, they are well represented using binary tries instead of search trees. In this work, we introduce canonical binary tries, an improved binary-trie data structure that enjoys a natural extensionality property, quite useful in proofs, and supports sparseness more efficiently. We provide full proofs of correctness in Coq. We provide microbenchmark measurements of canonical binary tries versus several other data structures for finite maps, in a variety of application contexts; as well as measurement of canonical versus original tries in two big, real systems. The application context of data structures contained in theorem statements imposes unusual requirements for which canonical tries are particularly well suited.},
  archive      = {J_JAR},
  author       = {Appel, Andrew W. and Leroy, Xavier},
  doi          = {10.1007/s10817-022-09655-x},
  journal      = {Journal of Automated Reasoning},
  number       = {1},
  pages        = {1-27},
  shortjournal = {J. Auto. Reasoning},
  title        = {Efficient extensional binary tries},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Semantically-guided goal-sensitive reasoning: Decision
procedures and the koala prover. <em>JAR</em>, <em>67</em>(1), 1–42. (<a
href="https://doi.org/10.1007/s10817-022-09656-w">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The main topic of this article are SGGS decision procedures for fragments of first-order logic without equality. SGGS (Semantically-Guided Goal-Sensitive reasoning) is an attractive basis for decision procedures, because it generalizes to first-order logic the Conflict-Driven Clause Learning (CDCL) procedure for propositional satisfiability. As SGGS is both refutationally complete and model-complete in the limit, SGGS decision procedures are model-constructing. We investigate the termination of SGGS with both positive and negative results: for example, SGGS decides Datalog and the stratified fragment (including Effectively PRopositional logic) that are relevant to many applications. Then we discover several new decidable fragments, by showing that SGGS decides them. These fragments have the small model property, as the cardinality of their SGGS-generated models can be upper bounded, and for most of them termination tools can be applied to test a set of clauses for membership. We also present the first implementation of SGGS—the Koala theorem prover—and we report on experiments with Koala.},
  archive      = {J_JAR},
  author       = {Bonacina, Maria Paola and Winkler, Sarah},
  doi          = {10.1007/s10817-022-09656-w},
  journal      = {Journal of Automated Reasoning},
  number       = {1},
  pages        = {1-42},
  shortjournal = {J. Auto. Reasoning},
  title        = {Semantically-guided goal-sensitive reasoning: Decision procedures and the koala prover},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Optimal deterministic controller synthesis from steady-state
distributions. <em>JAR</em>, <em>67</em>(1), 1–26. (<a
href="https://doi.org/10.1007/s10817-022-09657-9">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The formal synthesis of control policies is a classic problem that entails the computation of optimal strategies for an agent interacting in some environment such that some formal guarantees of behavior are met. These guarantees are specified as part of the problem description and can be supplied by the end user in the form of various logics (e.g., Linear Temporal Logic and Computation Tree Logic) or imposed via constraints on agent-environment interactions. The latter has received significant attention in recent years within the context of constraints on the asymptotic frequency with which an agent visits states of interest. This is captured by the steady-state distribution of the agent. The formal synthesis of stochastic policies satisfying constraints on this distribution has been studied. However, the derivation of deterministic policies for the same has received little attention. In this paper, we focus on this deterministic steady-state control problem, i.e., the problem of obtaining a deterministic policy for optimal expected-reward behavior in the presence of linear constraints representing the desired steady-state behavior. Two integer linear programs are proposed and validated experimentally to solve this problem in unichain and multichain Markov decision processes. Finally, we prove that this problem is NP-hard even in the restricted setting where deterministic transitions are enforced on the MDP and there are only two actions.},
  archive      = {J_JAR},
  author       = {Velasquez, Alvaro and Alkhouri, Ismail and Subramani, K. and Wojciechowski, Piotr and Atia, George},
  doi          = {10.1007/s10817-022-09657-9},
  journal      = {Journal of Automated Reasoning},
  number       = {1},
  pages        = {1-26},
  shortjournal = {J. Auto. Reasoning},
  title        = {Optimal deterministic controller synthesis from steady-state distributions},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Finding normal binary floating-point factors efficiently.
<em>JAR</em>, <em>67</em>(1), 1–52. (<a
href="https://doi.org/10.1007/s10817-023-09659-1">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Solving the floating-point equation $$x \otimes y = z$$ , where x, y and z belong to floating-point intervals, is a common task in automated reasoning for which no efficient algorithm is known in general. We show that it can be solved by computing a constant number of floating-point factors, and give a fast algorithm for computing successive normal floating-point factors of normal floating-point numbers in radix 2. This leads to an efficient procedure for solving the given equation, running in time of the same order as floating-point multiplication.},
  archive      = {J_JAR},
  author       = {Andrlon, Mak},
  doi          = {10.1007/s10817-023-09659-1},
  journal      = {Journal of Automated Reasoning},
  number       = {1},
  pages        = {1-52},
  shortjournal = {J. Auto. Reasoning},
  title        = {Finding normal binary floating-point factors efficiently},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Computer-aided constructions of commafree codes.
<em>JAR</em>, <em>67</em>(1), 1–10. (<a
href="https://doi.org/10.1007/s10817-023-09662-6">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We determine the maximum size $$W_k(n)$$ of a commafree code with codeword length k and alphabet size n for a few previously unknown values of k and n. With the aid of modern SAT solver tooling we prove that $$W_4(5) = 139$$ , $$W_6(3) = 113$$ , and $$W_{12}(2) = 334$$ and exhibit codes that achieve these bounds.},
  archive      = {J_JAR},
  author       = {Windsor, Aaron A.},
  doi          = {10.1007/s10817-023-09662-6},
  journal      = {Journal of Automated Reasoning},
  number       = {1},
  pages        = {1-10},
  shortjournal = {J. Auto. Reasoning},
  title        = {Computer-aided constructions of commafree codes},
  volume       = {67},
  year         = {2023},
}
</textarea>
</details></li>
</ul>

</body>
</html>
