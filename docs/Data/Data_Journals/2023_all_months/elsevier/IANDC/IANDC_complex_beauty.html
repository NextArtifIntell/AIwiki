<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>IANDC_complex_beauty</title>
  <style>
    html {font-size: 22px;}
    body {margin: 0 auto; max-width: 76em;}
    #copyID {font-size: 18px;}
  </style>
  <script>
    function copy(element) {
      if (element.type == "button"){
      element.type="text";
      }
      element.style.color="black";
      element.style.backgroundColor="#C7EDCC";
      element.select();
      element.setSelectionRange(0, 99999);
      navigator.clipboard.writeText(element.value);
      window.getSelection().removeAllRanges();
      element.type="button";
    }
  </script>
</head>
<body>

<h2 id="iandc---73">IANDC - 73</h2>
<ul>
<li><details>
<summary>
(2023). Special issue: Selected papers of the 15th international
conference on language and automata theory and applications, LATA 2021.
<em>IANDC</em>, <em>295</em>, 105101. (<a
href="https://doi.org/10.1016/j.ic.2023.105101">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_IANDC},
  author       = {Carlos Martín-Vide and Bianca Truthe},
  doi          = {10.1016/j.ic.2023.105101},
  journal      = {Information and Computation},
  pages        = {105101},
  shortjournal = {Inf. Comput.},
  title        = {Special issue: Selected papers of the 15th international conference on language and automata theory and applications, LATA 2021},
  volume       = {295},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Algorithmic aspects of secure domination in unit disk
graphs. <em>IANDC</em>, <em>295</em>, 105090. (<a
href="https://doi.org/10.1016/j.ic.2023.105090">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Given a graph G with vertex set V , a set S ⊆ V S⊆V is a secure dominating set of G if S is a dominating set of G and if for every vertex u ∈ V ∖ S u∈V∖S , there exists a vertex v ∈ S v∈S adjacent to u such that ( S ∪ { u } ) ∖ { v } (S∪{u})∖{v} is a dominating set of G .The minimum secure dominating set (or, for short, MSDS) problem asks to find an MSDS in a given graph. In this paper, we first show that the decision version of the MSDS problem is NP-complete in unit disk graphs, even in grid graphs. Secondly, we give an O ( n + m ) O(n+m) time t -approximation algorithm for the MSDS problem in several geometric intersection graphs which are K 1 , t K1,t -free for some integer t ≥ 3 t≥3 . Finally, we propose a PTAS for the MSDS problem in unit disk graphs.},
  archive      = {J_IANDC},
  author       = {Cai-Xia Wang and Yu Yang and Shou-Jun Xu},
  doi          = {10.1016/j.ic.2023.105090},
  journal      = {Information and Computation},
  pages        = {105090},
  shortjournal = {Inf. Comput.},
  title        = {Algorithmic aspects of secure domination in unit disk graphs},
  volume       = {295},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Temporal logics with language parameters. <em>IANDC</em>,
<em>295</em>, 105087. (<a
href="https://doi.org/10.1016/j.ic.2023.105087">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We develop a generic framework to extend the logics LTL, CTL + and CTL ⁎ by automata-based connectives from formal language classes and analyse this framework with regard to regular languages, visibly pushdown languages, deterministic and non-deterministic context-free languages. More precisely, we consider how the use of different automata classes changes the expressive power of the logics and provide algorithms for the satisfiability and model checking problems induced by the use of different classes of automata . For the model checking problem, we treat not only finite Kripke transition systems, but also visibly pushdown systems and pushdown systems. We provide completeness or undecidability results in all cases and show that the extensions we consider can formulate properties not expressible in classical temporal logics or regular extensions thereof.},
  archive      = {J_IANDC},
  author       = {Jens Oliver Gutsfeld and Markus Müller-Olm and Christian Dielitz},
  doi          = {10.1016/j.ic.2023.105087},
  journal      = {Information and Computation},
  pages        = {105087},
  shortjournal = {Inf. Comput.},
  title        = {Temporal logics with language parameters},
  volume       = {295},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023b). New characterizations of primitive permutation groups with
applications to synchronizing automata. <em>IANDC</em>, <em>295</em>,
105086. (<a href="https://doi.org/10.1016/j.ic.2023.105086">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {For a finite permutation group on n elements we show the following (and variants thereof) equivalences: (1) the permutation group is primitive, (2) in the transformation monoid generated by the group and any rank n − 1 n−1 mapping there exists, for every non-empty subset, an element mapping the whole permutation domain onto this subset, (3) in the transformation monoid generated by the group and any rank n − 1 n−1 mapping there exists, for every two distinct subsets, an element mapping precisely one to a singleton set. We also investigate further properties related to the reachability of subsets. Lastly, we apply our results to automata and show that automata whose transformation monoids contain a primitive permutation group and a mapping that excludes precisely one state from its image are completely reachable and have the property that a minimal automaton for the set of synchronizing words has the maximal possible number of states.},
  archive      = {J_IANDC},
  author       = {Stefan Hoffmann},
  doi          = {10.1016/j.ic.2023.105086},
  journal      = {Information and Computation},
  pages        = {105086},
  shortjournal = {Inf. Comput.},
  title        = {New characterizations of primitive permutation groups with applications to synchronizing automata},
  volume       = {295},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023a). Binary and circular automata having maximal state
complexity for the set of synchronizing words. <em>IANDC</em>,
<em>295</em>, 105076. (<a
href="https://doi.org/10.1016/j.ic.2023.105076">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {An automaton is synchronizing if there exists a word driving it into a definite state regardless of the starting state. For an n -state automaton the set of synchronizing words is a regular language that can be accepted by an automaton having 2 n − n 2n−n states. Here, we study automata over two input letters and circular automata with n states having the property that the minimal automata for their sets of synchronizing words have 2 n − n 2n−n states, i.e., the minimal automata are maximal possible. We give a sufficient condition for this property that links it to completely reachable automata, non-trivial automaton congruences and the notion of uniform minimality . We apply our result to the family K n Kn of automata that was previously only conjectured to have this property.},
  archive      = {J_IANDC},
  author       = {Stefan Hoffmann},
  doi          = {10.1016/j.ic.2023.105076},
  journal      = {Information and Computation},
  pages        = {105076},
  shortjournal = {Inf. Comput.},
  title        = {Binary and circular automata having maximal state complexity for the set of synchronizing words},
  volume       = {295},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Learning mealy machines with one timer. <em>IANDC</em>,
<em>295</em>, 105013. (<a
href="https://doi.org/10.1016/j.ic.2023.105013">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present Mealy machines with a single timer (MM1Ts), a class of sufficiently expressive models to describe the real-time behavior of many realistic applications that we can learn efficiently. We show how we can obtain learning algorithms for MM1Ts via a reduction to the problem of learning Mealy machines. We describe an implementation of an MM1T learner on top of LearnLib and compare its performance with recent algorithms proposed by Aichernig et al. and An et al. on several realistic benchmarks.},
  archive      = {J_IANDC},
  author       = {Frits Vaandrager and Masoud Ebrahimi and Roderick Bloem},
  doi          = {10.1016/j.ic.2023.105013},
  journal      = {Information and Computation},
  pages        = {105013},
  shortjournal = {Inf. Comput.},
  title        = {Learning mealy machines with one timer},
  volume       = {295},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). On the transformation of two-way finite automata to
unambiguous finite automata. <em>IANDC</em>, <em>295</em>, 104956. (<a
href="https://doi.org/10.1016/j.ic.2022.104956">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper estimates the number of states in an unambiguous finite automaton (UFA) that is sufficient and in the worst case necessary to simulate an n -state two-way deterministic finite automaton (2DFA) and an n -state two-way unambiguous finite automaton (2UFA). It is proved that a 2UFA with n states can be transformed to a UFA with fewer than 2 n ⋅ n ! 2n⋅n! states. On the other hand, for every n , there is a language recognized by an n -state 2DFA that requires a UFA with at least Ω ( ( 2 + 1 ) 2 n ⋅ n − 1 ) = Ω ( 5.828 n ) Ω((2+1)2n⋅n−1)=Ω(5.828n) states. The latter result is obtained as a lower bound on the rank of a certain matrix.},
  archive      = {J_IANDC},
  author       = {Semyon Petrov and Alexander Okhotin},
  doi          = {10.1016/j.ic.2022.104956},
  journal      = {Information and Computation},
  pages        = {104956},
  shortjournal = {Inf. Comput.},
  title        = {On the transformation of two-way finite automata to unambiguous finite automata},
  volume       = {295},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Finite-word hyperlanguages. <em>IANDC</em>, <em>295</em>,
104944. (<a href="https://doi.org/10.1016/j.ic.2022.104944">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Formal languages are in the core of models of computation and their behavior. A rich family of models for many classes of languages have been widely studied. Hyperproperties lift conventional trace-based languages from a set of execution traces to a set of sets of executions. Hyperproperties have been shown to be a powerful formalism for expressing and reasoning about information-flow security policies and important properties of cyber-physical systems. Although there is an extensive body of work on formal-language representation of trace properties, we currently lack such a general characterization for hyperproperties. We introduce hyperlanguages over finite words and models for expressing them. Essentially, these models express multiple words by using assignments to quantified word variables . Relying on the standard models for regular languages, we propose regular hyperexpressions and finite-word hyperautomata (NFH) , for modeling the class of regular hyperlanguages . We demonstrate the ability of regular hyperlanguages to express hyperproperties for finite traces. We explore the closure properties and the complexity of the fundamental decision problems such as nonemptiness, universality, membership, and containment for various fragments of NFH.},
  archive      = {J_IANDC},
  author       = {Borzoo Bonakdarpour and Sarai Sheinvald},
  doi          = {10.1016/j.ic.2022.104944},
  journal      = {Information and Computation},
  pages        = {104944},
  shortjournal = {Inf. Comput.},
  title        = {Finite-word hyperlanguages},
  volume       = {295},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Location automata for regular expressions with shuffle and
intersection. <em>IANDC</em>, <em>295</em>, 104917. (<a
href="https://doi.org/10.1016/j.ic.2022.104917">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We define the notion of location for regular expressions with shuffle by extending the notion of position in standard regular expressions. Locations allow for the definition of the sets Follow Follow , First First , and Last Last with their usual semantics. From these, we construct an automaton for regular expressions with shuffle ( A POS APOS ), which generalises the standard position/Glushkov automaton. The sets mentioned above are also the foundation for other constructions, such as the Follow automaton, and automata based on pointed expressions. As a consequence, all these constructions can be generalised to the shuffle operator. We show that the partial derivative automaton is a right-quotient of A POS APOS . We relate A POS APOS with another automaton construction based on positions that has been previously studied ( A ∂ p o s A∂pos ). The prefix automaton is extended to the shuffle operator and shown not to be a quotient of A POS APOS . Locations are also used to define a position automaton for regular expressions with the intersection.},
  archive      = {J_IANDC},
  author       = {Sabine Broda and António Machiavelo and Nelma Moreira and Rogério Reis},
  doi          = {10.1016/j.ic.2022.104917},
  journal      = {Information and Computation},
  pages        = {104917},
  shortjournal = {Inf. Comput.},
  title        = {Location automata for regular expressions with shuffle and intersection},
  volume       = {295},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Eilenberg’s variety theorem without boolean operations.
<em>IANDC</em>, <em>295</em>, 104916. (<a
href="https://doi.org/10.1016/j.ic.2022.104916">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Eilenberg&#39;s variety theorem marked a milestone in the algebraic theory of regular languages by establishing a formal correspondence between properties of regular languages and properties of finite monoids recognizing them. Motivated by classes of languages accepted by quantum finite automata , we introduce basic varieties of regular languages , a weakening of Eilenberg&#39;s original concept that does not require closure under any boolean operations, and prove a variety theorem for them. To do so, we investigate the algebraic recognition of languages by lattice bimodules , generalizing Klíma and Polák&#39;s lattice algebras, and we utilize the duality between algebraic completely distributive lattices and posets .},
  archive      = {J_IANDC},
  author       = {Fabian Birkmann and Stefan Milius and Henning Urbat},
  doi          = {10.1016/j.ic.2022.104916},
  journal      = {Information and Computation},
  pages        = {104916},
  shortjournal = {Inf. Comput.},
  title        = {Eilenberg&#39;s variety theorem without boolean operations},
  volume       = {295},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Learnability and positive equivalence relations.
<em>IANDC</em>, <em>295</em>, 104913. (<a
href="https://doi.org/10.1016/j.ic.2022.104913">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Prior work of Gavryushkin, Khoussainov, Jain and Stephan investigated what algebraic structures can be realised in worlds given by a positive (= recursively enumerable) equivalence relation which partitions the natural numbers into infinitely many equivalence classes. The present work investigates the infinite one-one numbered recursively enumerable (r.e.) families realised by such relations and asks how the choice of the equivalence relation impacts the learnability properties of these classes when studying learnability in the limit from positive examples, also known as learning from text. For all choices of such positive equivalence relations, for each of the following entries, there are one-one numbered r.e. families which satisfy it: (a) they are behaviourally correctly learnable but not vacillatorily learnable; (b) they are explanatorily learnable but not confidently learnable; (c) they are not behaviourally correctly learnable. Furthermore, there is a positive equivalence relation which enforces that (d) every vacillatorily learnable one-one numbered family of languages closed under this equivalence relation is already explanatorily learnable and cannot be confidently learnable. In addition, if there is for a positive equivalence relation a confidently learnable class, then there is also a class which is confidently but not finitely learnable.},
  archive      = {J_IANDC},
  author       = {David Belanger and Ziyuan Gao and Sanjay Jain and Wei Li and Frank Stephan},
  doi          = {10.1016/j.ic.2022.104913},
  journal      = {Information and Computation},
  pages        = {104913},
  shortjournal = {Inf. Comput.},
  title        = {Learnability and positive equivalence relations},
  volume       = {295},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). On hardest languages for one-dimensional cellular automata.
<em>IANDC</em>, <em>295</em>, 104891. (<a
href="https://doi.org/10.1016/j.ic.2022.104891">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The existence of “hardest languages” in the sense of Greibach (“The hardest context-free language”, 1973) is investigated for two families of cellular automata . For one-way real-time cellular automata , also known as trellis automata , it is shown that there is no hardest language under reductions by deterministic finite transducers. For linear-time cellular automata , a hardest language under reductions by homomorphisms is constructed.},
  archive      = {J_IANDC},
  author       = {Mikhail Mrykhin and Alexander Okhotin},
  doi          = {10.1016/j.ic.2022.104891},
  journal      = {Information and Computation},
  pages        = {104891},
  shortjournal = {Inf. Comput.},
  title        = {On hardest languages for one-dimensional cellular automata},
  volume       = {295},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Usefulness of information and decomposability of unary
regular languages. <em>IANDC</em>, <em>295</em>, 104868. (<a
href="https://doi.org/10.1016/j.ic.2022.104868">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We continue the research on usefulness of information examining the effect of supplementary information on the complexity of solving a problem. We use DFAs for a formal setting. Given a problem (a regular language) L p r o b Lprob we measure the complexity of its solution — a DFA A p r o b Aprob accepting L p r o b Lprob — using the state complexity. A supplementary information (advice) L a d v Ladv given by A a d v Aadv is useful if a simpler problem L n e w Lnew given by A n e w Anew exists such that L p r o b = L n e w ∩ L a d v Lprob=Lnew∩Ladv and both L n e w Lnew and L a d v Ladv are simpler than L p r o b Lprob . This is formalized via the notion of decomposability of finite automata and regular languages. We address the problem of deterministic decomposability of unary regular languages. We give a characterization upon deterministic decomposability for the class of unary regular languages and we discuss the problem of deciding whether a given DFA over unary alphabet is decomposable ( UDFA-Decomposability problem).},
  archive      = {J_IANDC},
  author       = {Giovanni Pighizzini and Branislav Rovan and Šimon Sádovský},
  doi          = {10.1016/j.ic.2022.104868},
  journal      = {Information and Computation},
  pages        = {104868},
  shortjournal = {Inf. Comput.},
  title        = {Usefulness of information and decomposability of unary regular languages},
  volume       = {295},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Efficient construction of the BWT for repetitive text using
string compression. <em>IANDC</em>, <em>294</em>, 105088. (<a
href="https://doi.org/10.1016/j.ic.2023.105088">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present a new semi-external algorithm that builds the Burrows–Wheeler transform variant of Bauer et al. (a.k.a., BCR BWT) in linear expected time. Our method uses compression techniques to reduce computational costs when the input is massive and repetitive. Concretely, we build on induced suffix sorting (ISS) and resort to run-length and grammar compression to maintain our intermediate results in compact form. Our compression format not only saves space but also speeds up the required computations. Our experiments show important space and computation time savings when the text is repetitive. In moderate-size collections of real human genome assemblies (14.2 GB - 75.05 GB), our memory peak is, on average, 1.7x smaller than the peak of the state-of-the-art BCR BWT construction algorithm ( ropebwt2 ), while running 5x faster. Our current implementation was also able to compute the BCR BWT of 400 real human genome assemblies (1.2 TB) in 41.21 hours using 118.83 GB of working memory (around 10\% of the input size). Interestingly, the results we report in the 1.2 TB file are dominated by the difficulties of scanning huge files under memory constraints (specifically, I/O operations). This fact indicates we can perform much better with a more careful implementation of our method, thus scaling to even bigger sizes efficiently.},
  archive      = {J_IANDC},
  author       = {Diego Díaz-Domínguez and Gonzalo Navarro},
  doi          = {10.1016/j.ic.2023.105088},
  journal      = {Information and Computation},
  pages        = {105088},
  shortjournal = {Inf. Comput.},
  title        = {Efficient construction of the BWT for repetitive text using string compression},
  volume       = {294},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Further improvements for SAT in terms of formula length.
<em>IANDC</em>, <em>294</em>, 105085. (<a
href="https://doi.org/10.1016/j.ic.2023.105085">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we prove that the general CNF satisfiability problem can be solved in ⁎ O ⁎ ( 1.0638 L ) O⁎(1.0638L) time, where L is the length of the input CNF-formula (i.e., the total number of literals in the formula), which improves the previous result of ⁎ O ⁎ ( 1.0652 L ) O⁎(1.0652L) obtained in 2009. Our algorithm was analyzed by using the measure-and-conquer method. Our improvements are mainly attributed to the following two points: we carefully design branching rules to deal with degree-5 and degree-4 variables to avoid previous bottlenecks; we show that some worst cases will not always happen, and then we can use an amortized technique to get further improvements. In our analyses, we provide some general frameworks for analysis and several lower bounds on the decreasing of the measure to simplify the arguments. These techniques may be used to analyze more algorithms based on the measure-and-conquer method.},
  archive      = {J_IANDC},
  author       = {Junqiang Peng and Mingyu Xiao},
  doi          = {10.1016/j.ic.2023.105085},
  journal      = {Information and Computation},
  pages        = {105085},
  shortjournal = {Inf. Comput.},
  title        = {Further improvements for SAT in terms of formula length},
  volume       = {294},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). The tail-recursive fragment of timed recursive CTL.
<em>IANDC</em>, <em>294</em>, 105084. (<a
href="https://doi.org/10.1016/j.ic.2023.105084">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Timed Recursive CTL (TRCTL) was recently proposed as a merger of two extensions of the well-known branching-time logic CTL: Timed CTL on one hand is interpreted over real-time systems like timed automata , and Recursive CTL (RecCTL) on the other hand obtains high expressiveness through the introduction of a recursion operator. Model checking for the resulting logic is known to be 2-EXPTIME-complete. The aim of this paper is to investigate the possibility to obtain a fragment of lower complexity without losing too much expressive power . It is obtained by a syntactic property called “tail-recursiveness” that restricts the way that recursive formulas can be built. This restriction is known to decrease the complexity of model checking by half an exponential in the untimed setting. We show that this also works in the real-time world: model checking for the tail-recursive fragment of TRCTL is EXPSPACE-complete already in its data complexity, i.e. for a fixed formula. The upper bound is obtained via a model-checking procedure on region graphs combining standard untiming constructions with a tailored algorithm. The lower bound is established by a reduction from a suitable tiling problem.},
  archive      = {J_IANDC},
  author       = {Florian Bruse and Martin Lange},
  doi          = {10.1016/j.ic.2023.105084},
  journal      = {Information and Computation},
  pages        = {105084},
  shortjournal = {Inf. Comput.},
  title        = {The tail-recursive fragment of timed recursive CTL},
  volume       = {294},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Pspace-completeness of the temporal logic of sub-intervals
and suffixes. <em>IANDC</em>, <em>294</em>, 105083. (<a
href="https://doi.org/10.1016/j.ic.2023.105083">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we prove Pspace -completeness of the finite satisfiability and model checking problems for the fragment of Halpern and Shoham interval logic with modality 〈 E 〉 〈E〉 , for the “suffix” relation on pairs of intervals, and modality 〈 D 〉 〈D〉 , for the “sub-interval” relation, under the homogeneity assumption. The result significantly improves the Expspace upper bound recently established for the same fragment, and proves the rather surprising fact that the complexity of the considered problems does not change when we add either the modality for suffixes ( 〈 E 〉 〈E〉 ) or, symmetrically, the modality for prefixes ( 〈 B 〉 〈B〉 ) to the logic of sub-intervals (featuring only 〈 D 〉 〈D〉 ).},
  archive      = {J_IANDC},
  author       = {Laura Bozzelli and Angelo Montanari and Adriano Peron and Pietro Sala},
  doi          = {10.1016/j.ic.2023.105083},
  journal      = {Information and Computation},
  pages        = {105083},
  shortjournal = {Inf. Comput.},
  title        = {Pspace-completeness of the temporal logic of sub-intervals and suffixes},
  volume       = {294},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Building a small and informative phylogenetic supertree.
<em>IANDC</em>, <em>294</em>, 105082. (<a
href="https://doi.org/10.1016/j.ic.2023.105082">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We combine two fundamental optimization problems related to the construction of phylogenetic trees called maximum rooted triplets consistency and minimally resolved supertree into a new problem, which we call q-maximum rooted triplets consistency ( q -MAXRTC). It takes as input a set R R of rooted, binary phylogenetic trees with three leaves each and asks for a phylogenetic tree with exactly q internal nodes that contains the largest possible number of trees from R R . We prove that q -MAXRTC is NP-hard to approximate within a constant, develop polynomial-time approximation algorithms for different values of q , and show experimentally that representing a phylogenetic tree by one having much fewer nodes typically does not destroy too much branching information. To demonstrate the algorithmic advantage of using trees with few internal nodes, we also propose a new algorithm for computing the rooted triplet distance that is faster than the existing algorithms when restricted to such trees.},
  archive      = {J_IANDC},
  author       = {Jesper Jansson and Konstantinos Mampentzidis and Sandhya T.P.},
  doi          = {10.1016/j.ic.2023.105082},
  journal      = {Information and Computation},
  pages        = {105082},
  shortjournal = {Inf. Comput.},
  title        = {Building a small and informative phylogenetic supertree},
  volume       = {294},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Taming strategy logic: Non-recurrent fragments.
<em>IANDC</em>, <em>294</em>, 105081. (<a
href="https://doi.org/10.1016/j.ic.2023.105081">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Strategy Logic ( for short) is one of the prominent languages for reasoning about the strategic abilities of agents in a multi-agent setting. This logic extends with first-order quantifiers over the agent strategies and encompasses other formalisms, such as and . The model-checking problem for and several of its fragments has been extensively studied. On the other hand, the picture is much less clear on the satisfiability front, where the problem is undecidable for the full logic. In this work, we study two fragments of One-Goal , where the nesting of sentences within temporal operators is constrained. We show that the satisfiability problem for these two logics, and for the corresponding fragments of and , is in and , respectively.},
  archive      = {J_IANDC},
  author       = {Massimo Benerecetti and Fabio Mogavero and Adriano Peron},
  doi          = {10.1016/j.ic.2023.105081},
  journal      = {Information and Computation},
  pages        = {105081},
  shortjournal = {Inf. Comput.},
  title        = {Taming strategy logic: Non-recurrent fragments},
  volume       = {294},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023b). On the complexity of decision problems for some classes of
machines and applications. <em>IANDC</em>, <em>294</em>, 105080. (<a
href="https://doi.org/10.1016/j.ic.2023.105080">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the computational complexity of important decision problems — including general membership, fixed-machine membership, emptiness, disjointness , equivalence, containment, universe, and finiteness problems — for various restrictions and combinations of two-way nondeterministic reversal-bounded multicounter machines ( 2 NCM 2NCM ) and two-way pushdown automata . We show that the general membership problem (respectively fixed membership problem) for 2 NCM 2NCM is NP NP -complete (respectively in P P ). We then give applications to some problems in coding theory. We examine generalizations of various types of codes with marginal errors. For example, a language L is k -infix-free if there is no non-empty string y in L that is an infix of more than k strings in L − { y } L−{y} . Our general results imply the complexity of determining whether a given machine accepts a k -infix-free language, for one- and two-way deterministic and nondeterministic finite automata (answering an open question from the literature).},
  archive      = {J_IANDC},
  author       = {Oscar H. Ibarra and Ian McQuillan},
  doi          = {10.1016/j.ic.2023.105080},
  journal      = {Information and Computation},
  pages        = {105080},
  shortjournal = {Inf. Comput.},
  title        = {On the complexity of decision problems for some classes of machines and applications},
  volume       = {294},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Modelling mutual exclusion in a process algebra with
time-outs. <em>IANDC</em>, <em>294</em>, 105079. (<a
href="https://doi.org/10.1016/j.ic.2023.105079">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {I show that in a standard process algebra extended with time-outs one can correctly model mutual exclusion in such a way that starvation-freedom holds without assuming fairness or justness, even when one makes the problem more challenging by assuming memory accesses to be atomic. This can be achieved only when dropping the requirement of speed independence.},
  archive      = {J_IANDC},
  author       = {Rob van Glabbeek},
  doi          = {10.1016/j.ic.2023.105079},
  journal      = {Information and Computation},
  pages        = {105079},
  shortjournal = {Inf. Comput.},
  title        = {Modelling mutual exclusion in a process algebra with time-outs},
  volume       = {294},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Extending the reach of the point-to-set principle.
<em>IANDC</em>, <em>294</em>, 105078. (<a
href="https://doi.org/10.1016/j.ic.2023.105078">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The point-to-set principle of J. Lutz and N. Lutz (2018) has recently enabled the theory of computing to be used to answer open questions about fractal geometry in Euclidean spaces Rn . These are classical questions, meaning that their statements do not involve computation or related aspects of logic. In this paper we extend the reach of the point-to-set principle from Euclidean spaces to arbitrary separable metric spaces X . We first extend two algorithmic dimensions—computability-theoretic versions of classical Hausdorff and packing dimensions that assign dimensions dim⁡(x) and Dim(x) to individual points x∈X —to arbitrary separable metric spaces and to arbitrary gauge families. Our first two main results then extend the point-to-set principle to arbitrary separable metric spaces and to a large class of gauge families. We demonstrate the power of our extended point-to-set principle by using it to prove new theorems about classical fractal dimensions in hyperspaces .},
  archive      = {J_IANDC},
  author       = {Jack H. Lutz and Neil Lutz and Elvira Mayordomo},
  doi          = {10.1016/j.ic.2023.105078},
  journal      = {Information and Computation},
  pages        = {105078},
  shortjournal = {Inf. Comput.},
  title        = {Extending the reach of the point-to-set principle},
  volume       = {294},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Abstract interpretation, hoare logic, and incorrectness
logic for quantum programs. <em>IANDC</em>, <em>294</em>, 105077. (<a
href="https://doi.org/10.1016/j.ic.2023.105077">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Abstract interpretation, Hoare logic, and incorrectness (or reverse Hoare) logic are powerful techniques for static analysis of computer programs. They have all been successfully extended to the quantum setting, but developed largely in parallel. This paper explores the relationship between these techniques in the context of verifying quantum while-programs, where the abstract domain and the set of assertions for quantum states are well-structured. We show that any complete quantum abstract interpretation induces a quantum Hoare logic and a quantum incorrectness logic, both being sound and relatively complete. Moreover, the induced logic systems operate in a forward manner, making them more suitable for certain applications. Conversely, any sound and relatively complete quantum Hoare logic or incorrectness logic induces a complete quantum abstract interpretation. As an application, we show the non-existence of any sound and relatively complete quantum Hoare logic or incorrectness logic if tuples of local subspaces are taken as assertions.},
  archive      = {J_IANDC},
  author       = {Yuan Feng and Sanjiang Li},
  doi          = {10.1016/j.ic.2023.105077},
  journal      = {Information and Computation},
  pages        = {105077},
  shortjournal = {Inf. Comput.},
  title        = {Abstract interpretation, hoare logic, and incorrectness logic for quantum programs},
  volume       = {294},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Combinatory categorial grammars as generators of weighted
forests. <em>IANDC</em>, <em>294</em>, 105075. (<a
href="https://doi.org/10.1016/j.ic.2023.105075">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Combinatory Categorial Grammar (CCG) is an extension of categorial grammar that is well-established in computational linguistics . It is mildly context-sensitive, so it is efficiently parsable and reaches an expressiveness that is suitable for describing natural languages. Weighted CCG (wCCG) are introduced as a natural extension of CCG with weights taken from an arbitrary commutative semiring. Their expressive power is compared to other weighted formalisms with special emphasis on the weighted forests generated by wCCG since the ability to express the underlying syntactic structure of an input sentence is a vital feature of CCG in the area of natural language processing . Building on recent results for the expressivity in the unweighted setting, the corresponding results are derived for the weighted setting for any commutative semiring. More precisely, the weighted forests generatable by wCCG are also generatable by weighted simple monadic context-free tree grammar (wsCFTG). If the rule system is restricted to application rules and composition rules of first degree, then the generatable weighted forests are exactly the regular weighted forests. Finally, when only application rules are allowed, then a proper subset of the regular weighted forests is generatable.},
  archive      = {J_IANDC},
  author       = {Andreas Maletti and Lena Katharina Schiffer},
  doi          = {10.1016/j.ic.2023.105075},
  journal      = {Information and Computation},
  pages        = {105075},
  shortjournal = {Inf. Comput.},
  title        = {Combinatory categorial grammars as generators of weighted forests},
  volume       = {294},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). A new class of string transformations for compressed text
indexing. <em>IANDC</em>, <em>294</em>, 105068. (<a
href="https://doi.org/10.1016/j.ic.2023.105068">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Introduced about thirty years ago in the field of data compression , the Burrows-Wheeler Transform (BWT) is a string transformation that, besides being a booster of the performance of memoryless compressors, plays a fundamental role in the design of efficient self-indexing compressed data structures . Finding other string transformations with the same remarkable properties of BWT has been a challenge for many researchers for a long time. In this paper, we introduce a whole class of new string transformations, called local orderings-based transformations , which have all the “myriad virtues” of BWT. As a further result, we show that such new string transformations can be used for the construction of the recently introduced r -index, which makes them suitable also for highly repetitive collections. In this context, we consider the problem of finding, for a given string, the BWT variant that minimizes the number of runs in the transformed string.},
  archive      = {J_IANDC},
  author       = {Raffaele Giancarlo and Giovanni Manzini and Antonio Restivo and Giovanna Rosone and Marinella Sciortino},
  doi          = {10.1016/j.ic.2023.105068},
  journal      = {Information and Computation},
  pages        = {105068},
  shortjournal = {Inf. Comput.},
  title        = {A new class of string transformations for compressed text indexing},
  volume       = {294},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). A strengthened eCK secure identity based authenticated key
agreement protocol based on the standard CDH assumption. <em>IANDC</em>,
<em>294</em>, 105067. (<a
href="https://doi.org/10.1016/j.ic.2023.105067">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {An Authenticated Key Agreement (AKA) protocol enables two communicating parties to compute a session key with equal partnership, such that each entity is assured of the authenticity of its peer. Identity-based AKA (ID-AKA) protocols facilitate implicit authentication of the participating entities, without certificate verification. However, most of the existing ID-AKA schemes are proven secure based on the strong Gap Diffie-Hellman (GDH) assumption. Currently, there are no known implementation methods to realize the GDH assumption without using bilinear pairings . Further, none of the existing ID-AKA protocols have provable security against practical attacks due to intermediate result leakages. To this end, we propose a purely pairing-free ID-AKA protocol based on the Computational Diffie-Hellman assumption. The protocol offers provable security under the strengthened eCK (seCK) model that captures attacks resulting from intermediate result leakages. Comparative analysis with other ID-AKA protocols suggests that the proposed protocol satisfies stronger security requirements, without the gap assumption.},
  archive      = {J_IANDC},
  author       = {Renu Mary Daniel and Anitha Thomas and Elijah Blessing Rajsingh and Salaja Silas},
  doi          = {10.1016/j.ic.2023.105067},
  journal      = {Information and Computation},
  pages        = {105067},
  shortjournal = {Inf. Comput.},
  title        = {A strengthened eCK secure identity based authenticated key agreement protocol based on the standard CDH assumption},
  volume       = {294},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Swendsen-wang dynamics for the ferromagnetic ising model
with external fields. <em>IANDC</em>, <em>294</em>, 105066. (<a
href="https://doi.org/10.1016/j.ic.2023.105066">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the sampling problem for the ferromagnetic Ising model with consistent external fields, and in particular, Swendsen-Wang dynamics on this model. We introduce a new grand model unifying two closely related models: the subgraph world and the random cluster model. Through this new viewpoint, we show:},
  archive      = {J_IANDC},
  author       = {Weiming Feng and Heng Guo and Jiaheng Wang},
  doi          = {10.1016/j.ic.2023.105066},
  journal      = {Information and Computation},
  pages        = {105066},
  shortjournal = {Inf. Comput.},
  title        = {Swendsen-wang dynamics for the ferromagnetic ising model with external fields},
  volume       = {294},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Achieving sequenced SQL with log-segmented timestamps.
<em>IANDC</em>, <em>294</em>, 105065. (<a
href="https://doi.org/10.1016/j.ic.2023.105065">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In a period-timestamped, relational temporal database , each tuple is timestamped with a period. The timestamp records when the tuple is “alive” in some temporal dimension. Sequenced semantics is a special semantics for evaluating a query in a temporal database . The semantics stipulates that the query must, in effect, be evaluated simultaneously in each time instant using the tuples alive at that instant. Previous research has proposed changes to a database management system&#39;s query evaluation engine to support sequenced semantics. We show how to achieve sequenced semantics without modifying a query evaluation engine. Our technique has two pillars. First we use log-segmented timestamps to record a tuple&#39;s lifetime. A log-segmented timestamp divides the time-line into segments of known length. Any temporal period can be represented by a small number of such segments. Second, by taking advantage of the properties of log-segmented timestamps, we translate a sequenced query to a non-temporal query, using the operations already present in an unmodified, non-temporal query evaluation engine. The paper provides translations for both relational algebra and SQL . We experimentally evaluate the SQL translation. The primary contribution of this paper is how to implement sequenced semantics using log-segmented timestamped tuples in a generic SQL DBMS.},
  archive      = {J_IANDC},
  author       = {Curtis E. Dyreson and M.A. Manazir Ahsan},
  doi          = {10.1016/j.ic.2023.105065},
  journal      = {Information and Computation},
  pages        = {105065},
  shortjournal = {Inf. Comput.},
  title        = {Achieving sequenced SQL with log-segmented timestamps},
  volume       = {294},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Complexity classification of the eight-vertex model.
<em>IANDC</em>, <em>293</em>, 105064. (<a
href="https://doi.org/10.1016/j.ic.2023.105064">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We prove a complexity dichotomy theorem for the eight-vertex model. For every setting of the parameters of the model, we prove that computing the partition function is either solvable in polynomial time or #P-hard. The dichotomy criterion is explicit. For tractability, we find some new classes of problems computable in polynomial time . For #P-hardness, we employ Möbius transformations to prove the success of interpolations.},
  archive      = {J_IANDC},
  author       = {Jin-Yi Cai and Zhiguo Fu},
  doi          = {10.1016/j.ic.2023.105064},
  journal      = {Information and Computation},
  pages        = {105064},
  shortjournal = {Inf. Comput.},
  title        = {Complexity classification of the eight-vertex model},
  volume       = {293},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). A faster algorithm for converting simple temporal networks
with uncertainty into dispatchable form. <em>IANDC</em>, <em>293</em>,
105063. (<a href="https://doi.org/10.1016/j.ic.2023.105063">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A Simple Temporal Network with Uncertainty (STNU) is a data structure for reasoning about time constraints on actions that may have uncertain durations. An STNU is dispatchable if it can be executed in real-time with minimal computation 1) satisfying all constraints no matter how the uncertain durations play out and 2) retaining maximum flexibility. The fastest known algorithm for converting STNUs into dispatchable form runs in O ( n 3 ) O(n3) time, where n is the number of timepoints. This paper presents a faster algorithm that runs in O ( m n + k n 2 + n 2 log ⁡ n ) O(mn+kn2+n2log⁡n) time, where m is the number of edges and k is the number of uncertain durations. This performance is particularly meaningful in fields like Business Process Management, where sparse STNUs can represent temporal processes or plans. For sparse STNUs, our algorithm generates dispatchable forms in time O ( n 2 log ⁡ n ) O(n2log⁡n) , a significant improvement over the O ( n 3 ) O(n3) -time previous fastest algorithm.},
  archive      = {J_IANDC},
  author       = {Luke Hunsberger and Roberto Posenato},
  doi          = {10.1016/j.ic.2023.105063},
  journal      = {Information and Computation},
  pages        = {105063},
  shortjournal = {Inf. Comput.},
  title        = {A faster algorithm for converting simple temporal networks with uncertainty into dispatchable form},
  volume       = {293},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Are bundles good deals for first-order modal logic?
<em>IANDC</em>, <em>293</em>, 105062. (<a
href="https://doi.org/10.1016/j.ic.2023.105062">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Bundled products are often offered as good deals to customers. In first-order modal logic (FOML), when we bundle quantifiers and modalities together (as in ∃ x □ ∃x□ , ◇ ◇ ∀ x ◇∀x , etc.), we get new logical operators whose combinations produce interesting fragments of FOML without any restriction on the arity of predicates, the number of variables, or the modal scope. It is well-known that finding decidable fragments of FOML is hard, so we may ask: do bundled fragments that exploit the distinct expressivity of FOML constitute good deals in balancing the expressivity and complexity? There are a few positive earlier results towards identifying the decidable ones. In this paper, we map the terrain of bundled fragments of FOML in (un)decidability, and in the cases without a definite answer yet, we show that they lack the finite model property . Moreover, whether the class of models considered has constant domains (across states/worlds) or increasing domains presents another layer of complexity. We also present the loosely bundled fragment , which generalizes the bundles and yet retains decidability (over increasing domain models).},
  archive      = {J_IANDC},
  author       = {Mo Liu and Anantha Padmanabha and R. Ramanujam and Yanjing Wang},
  doi          = {10.1016/j.ic.2023.105062},
  journal      = {Information and Computation},
  pages        = {105062},
  shortjournal = {Inf. Comput.},
  title        = {Are bundles good deals for first-order modal logic?},
  volume       = {293},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Asymptotic elimination of partially continuous aggregation
functions in directed graphical models. <em>IANDC</em>, <em>293</em>,
105061. (<a href="https://doi.org/10.1016/j.ic.2023.105061">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {For a finite and relational signature σ and finite domain D we consider the set W D WD of all σ -structures with domain D . On W D WD a probability distribution is determined by a so-called parametrized probabilistic graphical model , a concept studied in statistical relational artificial intelligence . We also consider a many valued logic, denoted PLA , with truth values in the unit interval for expressing queries. PLA uses aggregation functions, for example the arithmetic mean , geometric mean , maximum and minimum, instead of quantifiers. In this setting we prove that every formula of PLA with only admissible aggregation functions is asymptotically equivalent to a formula without aggregation functions, as the domain size tends to infinity. A corollary of this is a probabilistic convergence law for PLA -formulas with only admissible aggregation functions.},
  archive      = {J_IANDC},
  author       = {Vera Koponen and Felix Weitkämper},
  doi          = {10.1016/j.ic.2023.105061},
  journal      = {Information and Computation},
  pages        = {105061},
  shortjournal = {Inf. Comput.},
  title        = {Asymptotic elimination of partially continuous aggregation functions in directed graphical models},
  volume       = {293},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Traceable constant-size multi-authority credentials.
<em>IANDC</em>, <em>293</em>, 105060. (<a
href="https://doi.org/10.1016/j.ic.2023.105060">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Many attribute-based anonymous credential (ABC) schemes have been proposed, enabling users to anonymously prove possession of attributes. Recent papers introduced constant-size credentials issued by a single credential issuer for showing a subset of attributes. However, proving possession of attributes from multiple issuers typically requires independent credentials. Only aggregate signature-based attribute-based credential schemes can overcome this limitation. This paper presents new ABC schemes using aggregate signatures with randomizable tags. The schemes consider malicious credential issuers, adaptive corruptions, and collusions with malicious users. While our constructions only support selective attribute disclosures to remain compact, our approach significantly improves the complexity in time and memory for showing multiple attributes. For the first time, the cost for the prover becomes (almost) independent of the number of attributes and issuers. Whereas anonymous credentials require privacy of the user, we also propose the first schemes allowing traceability by a specific tracing authority.},
  archive      = {J_IANDC},
  author       = {Chloé Hébant and David Pointcheval},
  doi          = {10.1016/j.ic.2023.105060},
  journal      = {Information and Computation},
  pages        = {105060},
  shortjournal = {Inf. Comput.},
  title        = {Traceable constant-size multi-authority credentials},
  volume       = {293},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Multi random projection inner product encryption,
applications to proximity searchable encryption for the iris biometric.
<em>IANDC</em>, <em>293</em>, 105059. (<a
href="https://doi.org/10.1016/j.ic.2023.105059">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Biometric databases collect people&#39;s information and perform proximity search (finding records within bounded distance of the query) with few cryptographic protections . This work studies proximity searchable encryption applied to the iris biometric. Prior work proposed to build proximity search from inner product functional encryption (Kim et al., SCN 2018). This work identifies and closes two gaps in this approach: Finally, we show that our scheme can be instantiated using symmetric pairing groups, which improves search efficiency.},
  archive      = {J_IANDC},
  author       = {Chloe Cachet and Sohaib Ahmad and Luke Demarest and Serena Riback and Ariel Hamlin and Benjamin Fuller},
  doi          = {10.1016/j.ic.2023.105059},
  journal      = {Information and Computation},
  pages        = {105059},
  shortjournal = {Inf. Comput.},
  title        = {Multi random projection inner product encryption, applications to proximity searchable encryption for the iris biometric},
  volume       = {293},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Formal verification for event stream processing: Model
checking of BeepBeep stream processing pipelines. <em>IANDC</em>,
<em>293</em>, 105058. (<a
href="https://doi.org/10.1016/j.ic.2023.105058">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Event stream processing (ESP) is the application of a computation to a set of input sequences of arbitrary data objects, called “events”, in order to produce other sequences of data objects. In recent years, a large number of ESP systems have been developed; however, none of them is easily amenable to a formal verification of properties on their execution. In this paper, we show how stream processing pipelines built with an existing ESP library called BeepBeep 3 can be exported as a Kripke structure for the NuXmv model checker . This makes it possible to formally verify properties on these pipelines, and opens the way to the use of such pipelines directly within a model checker as an extension of its specification language.},
  archive      = {J_IANDC},
  author       = {Alexis Bédard and Sylvain Hallé},
  doi          = {10.1016/j.ic.2023.105058},
  journal      = {Information and Computation},
  pages        = {105058},
  shortjournal = {Inf. Comput.},
  title        = {Formal verification for event stream processing: Model checking of BeepBeep stream processing pipelines},
  volume       = {293},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Can romeo and juliet meet? Or rendezvous games with
adversaries on graphs. <em>IANDC</em>, <em>293</em>, 105049. (<a
href="https://doi.org/10.1016/j.ic.2023.105049">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce the rendezvous game with adversaries. In this game, two players, Facilitator and Divider , play against each other on a graph. Facilitator has two agents and Divider has a team of k agents located in some vertices. They take turns in moving their agents to adjacent vertices (or staying put). Facilitator wins if his agents meet in some vertex. Divider aims to prevent the rendezvous of Facilitator&#39;s agents. We show that deciding whether Facilitator can win is PSPACE PSPACE -hard and, when parameterized by k , co-W [ 2 ] co-W[2] -hard. Moreover, even deciding whether Facilitator can win within τ steps is co-NP co-NP -complete already for τ = 2 τ=2 . On the other hand, for chordal and P 5 P5 -free graphs, we prove that the problem is solvable in polynomial time . Finally, we show that the problem is fixed-parameter tractable parameterized by both the graph&#39;s neighborhood diversity and the number of steps τ .},
  archive      = {J_IANDC},
  author       = {Fedor V. Fomin and Petr A. Golovach and Dimitrios M. Thilikos},
  doi          = {10.1016/j.ic.2023.105049},
  journal      = {Information and Computation},
  pages        = {105049},
  shortjournal = {Inf. Comput.},
  title        = {Can romeo and juliet meet? or rendezvous games with adversaries on graphs},
  volume       = {293},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Reducing the number of disjuncts in DTPs. <em>IANDC</em>,
<em>293</em>, 105048. (<a
href="https://doi.org/10.1016/j.ic.2023.105048">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Disjunctive Temporal Problem (DTP) consists of a finite set of time points and a finite set of constraints, each composed of alternative disjuncts modeling delays and deadlines for possibly different pairs of time points . An instance of DTP is consistent if there exists an assignment of real values to the time points such that all constraints are satisfied. Here we focus on DTPs with at most k ≥ 2 k≥2 disjuncts per constraint. We define a few polynomial-time encoders to reduce the number of disjuncts to at most k ′ k′ , with 2 ≤ k ′ ≤ k 2≤k′≤k , preserving (in)consistency of the original instance. These results generalize previous work in the literature. Anyway, we provide a methodology not related to any specific technology that sticks to DTP.},
  archive      = {J_IANDC},
  author       = {Alice Raffaele and Matteo Zavatteri},
  doi          = {10.1016/j.ic.2023.105048},
  journal      = {Information and Computation},
  pages        = {105048},
  shortjournal = {Inf. Comput.},
  title        = {Reducing the number of disjuncts in DTPs},
  volume       = {293},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). The bang calculus revisited. <em>IANDC</em>, <em>293</em>,
105047. (<a href="https://doi.org/10.1016/j.ic.2023.105047">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Call-by-Push-Value (CBPV) is a programming paradigm subsuming both Call-by-Name (CBN) and Call-by-Value (CBV) semantics. The essence of this paradigm is captured by the Bang Calculus, a term language connecting CBPV and Linear Logic . This paper presents a revisited version of the Bang Calculus, called λ !, enjoying some important properties missing in the original formulation. Indeed, the new calculus integrates permutative conversions to unblock value redexes while preserving confluence. A second contribution is related to non-idempotent types. We provide a quantitative type system for our λ !-calculus, giving upper bounds to the length of the reduction to normal form plus its size. We also explore the properties of this type system with respect to CBN/CBV translations. Last but not least, the quantitative system is refined to a tight one, which transforms the previous upper bound into two independent exact measures for the reduction length and the normal form size respectively.},
  archive      = {J_IANDC},
  author       = {Antonio Bucciarelli and Delia Kesner and Alejandro Ríos and Andrés Viso},
  doi          = {10.1016/j.ic.2023.105047},
  journal      = {Information and Computation},
  pages        = {105047},
  shortjournal = {Inf. Comput.},
  title        = {The bang calculus revisited},
  volume       = {293},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). On tightness of tsaknakis-spirakis descent methods for
approximate nash equilibria. <em>IANDC</em>, <em>293</em>, 105046. (<a
href="https://doi.org/10.1016/j.ic.2023.105046">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This article explores the minimum approximation ratio for Nash equilibrium in bi-matrix games, focusing on the Tsaknakis and Spirakis (TS) methods. The previous SOTA, TS algorithm, achieved an approximation ratio of 0.3393, but efforts to improve the analysis of the TS algorithm have been unsuccessful. This work demonstrates that the bound of 0.3393 is tight for the TS algorithm and presents a theoretical worst-case analysis. A condition for identifying tight instances is provided, along with a generator. While most generated instances are unstable, indicating potential improvements, stable instances exist where perturbations cannot enhance the 0.3393 bound. Other approximate algorithms , such as regret-matching and fictitious play, achieve better ratios on these instances. The generated instances can serve as benchmarks for approximate Nash equilibrium algorithms. The article also mentions progress in the TS algorithm, achieving an approximation ratio of 1/3, which can be further studied using the presented techniques.},
  archive      = {J_IANDC},
  author       = {Zhaohua Chen and Xiaotie Deng and Wenhan Huang and Hanyu Li and Yuhao Li},
  doi          = {10.1016/j.ic.2023.105046},
  journal      = {Information and Computation},
  pages        = {105046},
  shortjournal = {Inf. Comput.},
  title        = {On tightness of tsaknakis-spirakis descent methods for approximate nash equilibria},
  volume       = {293},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Breaking goppa-based McEliece with hints. <em>IANDC</em>,
<em>293</em>, 105045. (<a
href="https://doi.org/10.1016/j.ic.2023.105045">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider the McEliece cryptosystem with a binary Goppa code C ⊂ F 2 n C⊂F2n specified by an irreducible Goppa polynomial g ( x ) ∈ F 2 m [ X ] g(x)∈F2m[X] and Goppa points ( α 1 , … , α n ) ∈ F 2 m n (α1,…,αn)∈F2mn . Since g ( x ) g(x) together with the α i αi &#39;s allow for efficient decoding, these parameters form McEliece secret keys. Such a Goppa code C is an ( n − t m ) (n−tm) -dimensional subspace of F 2 n F2n , and therefore C has co-dimension tm . For typical McEliece instantiations we have t m ≈ n 4 tm≈n4 . We show that given more than tm elements of the Goppa points allows to recover the Goppa polynomial g ( x ) g(x) and the remaining entries in polynomial time . Hence, in case t m ≈ n 4 tm≈n4 , roughly a fourth of a McEliece secret key is sufficient to recover the full key efficiently. Let us give an illustrative numerical example. For ClassicMcEliece with ( n , t , m ) = ( 3488 , 64 , 12 ) (n,t,m)=(3488,64,12) on input 64 ⋅ 12 + 1 = 769 64⋅12+1=769 Goppa points, we recover the remaining 3488 − 769 = 2719 3488−769=2719 Goppa points in F 2 12 F212 and the degree-64 Goppa polynomial g ( x ) ∈ F 2 12 [ x ] g(x)∈F212[x] in 60 secs. Our results also extend to the case of erroneous Goppa points, but in this case our algorithms are no longer polynomial time .},
  archive      = {J_IANDC},
  author       = {Elena Kirshanova and Alexander May},
  doi          = {10.1016/j.ic.2023.105045},
  journal      = {Information and Computation},
  pages        = {105045},
  shortjournal = {Inf. Comput.},
  title        = {Breaking goppa-based McEliece with hints},
  volume       = {293},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Hypernormalisation in an abstract setting. <em>IANDC</em>,
<em>293</em>, 105044. (<a
href="https://doi.org/10.1016/j.ic.2023.105044">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Jacobs&#39; hypernormalisation is a construction on finitely supported discrete probability distributions , obtained by generalising certain patterns occurring in quantitative information theory . In this paper, we generalise Jacobs&#39; notion in turn, by describing a notion of hypernormalisation in the abstract setting of a symmetric monoidal category endowed with a linear exponential monad—a structure arising in the categorical semantics of linear logic . We show that Jacobs&#39; hypernormalisation arises in this fashion from the finitely supported probability measure monad on the category of sets, which can be seen as a linear exponential monad with respect to a non-standard monoidal structure on sets which we term the convex monoidal structure . We give the construction of this monoidal structure in terms of a quantum-algebraic notion known as a tricocycloid . Besides the motivating example, and its generalisations to the continuous context, we give a range of other instances of our abstract hypernormalisation, which swap out the side-effect of probabilistic choice for other important side-effects such as non-deterministic choice, ranked choice, and input from a stream of values.},
  archive      = {J_IANDC},
  author       = {Richard Garner},
  doi          = {10.1016/j.ic.2023.105044},
  journal      = {Information and Computation},
  pages        = {105044},
  shortjournal = {Inf. Comput.},
  title        = {Hypernormalisation in an abstract setting},
  volume       = {293},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). MrNISC from LWE with polynomial modulus. <em>IANDC</em>,
<em>293</em>, 105043. (<a
href="https://doi.org/10.1016/j.ic.2023.105043">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Introduced by Benhamouda and Lin [TCC&#39;20], a multi-party reusable non-interactive secure computation protocol (mrNISC) consists of a commitment phase and an unbounded number of computation phases. In the commitment phase, a number of parties first commit to their input in a single broadcast round. Later in a computation phase, any subset of the parties can compute a function on their joint input by each sending a single broadcast message. Benhamouda and Lin [TCC&#39;20] constructed the first mrNISC for all functions based on standard hardness assumptions in pairing groups. Soon after their work, two concurrent papers by Benhamouda et al. [EUROCRYPT&#39;21] and Ananth et al. [EUROCRYPT&#39;21] constructed mrNISC for all functions based on the hardness of LWE with super-polynomial modulus-to-noise ratio . In this work we build the first mrNISC for all functions based solely on LWE with polynomial modulus-to-noise ratio. We thus place mrNISC in the same category as public-key encryption and leveled fully homomorphic encryption in terms of the required LWE hardness assumption. We achieve our result by carefully introducing a bootstrapping step in the construction of Benhamouda et al.},
  archive      = {J_IANDC},
  author       = {Sina Shiehian},
  doi          = {10.1016/j.ic.2023.105043},
  journal      = {Information and Computation},
  pages        = {105043},
  shortjournal = {Inf. Comput.},
  title        = {MrNISC from LWE with polynomial modulus},
  volume       = {293},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Deterministic quantum search with adjustable parameters:
Implementations and applications. <em>IANDC</em>, <em>292</em>, 105042.
(<a href="https://doi.org/10.1016/j.ic.2023.105042">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Grover&#39;s algorithm provides a quadratic speedup over classical algorithms to search for marked elements in an unstructured database. The original algorithm is probabilistic, and there are several schemes to achieve the deterministic version, by using the generalized Grover&#39;s iteration G ( α , β ) : = S r ( β ) S o ( α ) G(α,β):=Sr(β)So(α) . However, in all the existing schemes the value range of α and β is limited; for instance, in the three early schemes they are determined by the proportion of marked states M / N M/N . In this paper, we break through this limitation by presenting a search framework with adjustable parameters, which allows α or β to be arbitrarily given. The significance of the framework lies not only in the expansion of mathematical form , but also in its application value, as we present two disparate problems which we are able to solve deterministically using the proposed framework, whereas previous schemes are ineffective.},
  archive      = {J_IANDC},
  author       = {Guanzhong Li and Lvzhou Li},
  doi          = {10.1016/j.ic.2023.105042},
  journal      = {Information and Computation},
  pages        = {105042},
  shortjournal = {Inf. Comput.},
  title        = {Deterministic quantum search with adjustable parameters: Implementations and applications},
  volume       = {292},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Bayesian definition of random sequences with respect to
conditional probabilities. <em>IANDC</em>, <em>292</em>, 105041. (<a
href="https://doi.org/10.1016/j.ic.2023.105041">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study Martin-Löf random (ML-random) points on computable probability measures on sample and parameter spaces (Bayes models). We consider variants of conditional randomness defined by ML-randomness on Bayes models and those of conditional blind randomness. We show that variants of conditional blind randomness are ill-defined from the Bayes statistical point of view. We prove that if the sets of random sequences of uniformly computable parametric models are pairwise disjoint then there is a consistent estimator for the model. Finally, we present an algorithmic solution to a classical problem in Bayes statistics , i.e. the posterior distributions converge weakly to almost all parameters if and only if the posterior distributions converge weakly to all ML-random parameters.},
  archive      = {J_IANDC},
  author       = {Hayato Takahashi},
  doi          = {10.1016/j.ic.2023.105041},
  journal      = {Information and Computation},
  pages        = {105041},
  shortjournal = {Inf. Comput.},
  title        = {Bayesian definition of random sequences with respect to conditional probabilities},
  volume       = {292},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Tasks in modular proofs of concurrent algorithms.
<em>IANDC</em>, <em>292</em>, 105040. (<a
href="https://doi.org/10.1016/j.ic.2023.105040">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Proving the correctness of distributed or concurrent algorithms is a complex process. Errors in the reasoning are hard to find, calling for computer-checked proof systems like Coq or TLA + . To use these tools, sequential specifications of base objects are required to build modular proofs by composition. Unfortunately, many concurrent objects lack a sequential specification. This article describes a method to transform any task , a specification of a concurrent one-shot distributed problem, into a sequential specification involving two calls, set set and get get . This enables designers to compose proofs, facilitating modular computer-checked proofs of algorithms built using tasks and sequential objects as building blocks . Moir &amp; Anderson implementation of renaming using splitters , wait-free concurrent objects, is an algorithm designed by composition, but it is not modular. Using our transformation, a modular description of the algorithm is given in TLA + and mechanically verified using the TLA + Proof System. As far as we know, this is the first time this algorithm is mechanically verified.},
  archive      = {J_IANDC},
  author       = {Armando Castañeda and Aurélie Hurault and Philippe Quéinnec and Matthieu Roy},
  doi          = {10.1016/j.ic.2023.105040},
  journal      = {Information and Computation},
  pages        = {105040},
  shortjournal = {Inf. Comput.},
  title        = {Tasks in modular proofs of concurrent algorithms},
  volume       = {292},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Atomic cross-chain swaps with improved space, time and local
time complexities. <em>IANDC</em>, <em>292</em>, 105039. (<a
href="https://doi.org/10.1016/j.ic.2023.105039">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {An effective atomic cross-chain swap protocol is introduced by Herlihy [Herlihy, 2018] as a distributed coordination protocol in order to exchange assets across multiple blockchains among multiple untrusted parties. The atomic cross-chain swap protocol guarantees; (1) if all parties conform to the protocol, then all assets are exchanged among the parties, (2) even if some parties or coalitions of parties deviate from the protocol, no party conforming to the protocol suffers a loss, and (3) no coalition has an incentive to deviate from the protocol. Herlihy [Herlihy, 2018] invented this protocol by using hashed timelock contracts. A cross-chain swap is modeled as a directed graph D = ( V , A ) D=(V,A) . Vertex set V denotes a set of parties and arc set A denotes a set of proposed asset transfers. Let Δ be time enough for a party to publish a contract on any of the blockchains , or to change the state of a contract and for the other party to detect the change. The space complexity of the protocol is O ( | A | 2 ) O(|A|2) . The local time complexity of the protocol is O ( | V | ⋅ | L | ) O(|V|⋅|L|) , where L is a feedback vertex set computed by the protocol. We propose a new atomic cross-chain swap protocol which uses only signature information and improves the space complexity to O ( | A | ⋅ | V | ) O(|A|⋅|V|) and the local time complexity to O ( | V | ) O(|V|) . Moreover, if all parties conform to our protocol, our proposed protocol improves the time complexity from O ( | V | Δ ) O(|V|Δ) to O ( Δ ) O(Δ) .},
  archive      = {J_IANDC},
  author       = {Soichiro Imoto and Yuichi Sudo and Hirotsugu Kakugawa and Toshimitsu Masuzawa},
  doi          = {10.1016/j.ic.2023.105039},
  journal      = {Information and Computation},
  pages        = {105039},
  shortjournal = {Inf. Comput.},
  title        = {Atomic cross-chain swaps with improved space, time and local time complexities},
  volume       = {292},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Self-adjusting grid networks. <em>IANDC</em>, <em>292</em>,
105038. (<a href="https://doi.org/10.1016/j.ic.2023.105038">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Emerging networked systems become increasingly flexible, reconfigurable, and “self-⁎”. This introduces an opportunity to adjust networked systems in a demand-aware manner, leveraging spatial and temporal locality in the workload for online optimizations. However, it also introduces a tradeoff: while more frequent adjustments can improve performance, they also entail higher reconfiguration costs. This paper studies self-adjusting grid networks in which frequently communicating nodes (e.g., virtual machines) are moved topologically closer in an online and demand-aware manner, striking a balance between the benefits and costs of reconfigurations. The paper presents a general Ω ( log ⁡ n ) Ω(log⁡n) lower bound for this problem, even in scenarios where the demand graph is constant once learned. To demonstrate the challenge of adapting a network to pair-wise communication requests, we also design an O ( log ⁡ n ) O(log⁡n) -competitive algorithm for 1-dimensional grids.},
  archive      = {J_IANDC},
  author       = {Chen Avin and Ingo van Duijn and Maciej Pacut and Stefan Schmid},
  doi          = {10.1016/j.ic.2023.105038},
  journal      = {Information and Computation},
  pages        = {105038},
  shortjournal = {Inf. Comput.},
  title        = {Self-adjusting grid networks},
  volume       = {292},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Fault tolerant network constructors. <em>IANDC</em>,
<em>292</em>, 105037. (<a
href="https://doi.org/10.1016/j.ic.2023.105037">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider adversarial crash faults of nodes in the network constructors model [Michail and Spirakis, 2016]. We first show that, without further assumptions, the class of graph languages that can be (stably) constructed under crash faults is non-empty but small. On the positive side, linear waste enables the construction, on a fraction of the nodes, of any graph language that is constructible in the fault-free case and partial constructibility allows us to construct a large class of graph languages. We then extend the original model with a minimal form of fault notifications . Our main result under that model is a fault-tolerant universal constructor . Finally, we show that logarithmic local memories can be exploited for a no-waste fault-tolerant simulation of any network constructor.},
  archive      = {J_IANDC},
  author       = {Othon Michail and Paul G. Spirakis and Michail Theofilatos},
  doi          = {10.1016/j.ic.2023.105037},
  journal      = {Information and Computation},
  pages        = {105037},
  shortjournal = {Inf. Comput.},
  title        = {Fault tolerant network constructors},
  volume       = {292},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Ring exploration of myopic luminous robots with visibility
more than one. <em>IANDC</em>, <em>292</em>, 105036. (<a
href="https://doi.org/10.1016/j.ic.2023.105036">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We investigate ring exploration algorithms for autonomous myopic luminous robots. We consider the constraint that the visible distance is any constant of at least two and the number of colors of light devices is two. As a main contribution, in the fully synchronous, semi-synchronous, and asynchronous models, we prove that 1) two robots are necessary and sufficient to achieve perpetual exploration and 2) three robots are necessary and sufficient to achieve terminating exploration. These results show the power of large visibility for luminous robots because, when the visible distance is one and the number of colors is two, three and four robots are necessary to achieve perpetual and terminating exploration, respectively, in the semi-synchronous and asynchronous models. We also show that the proposed perpetual exploration algorithm is universal. On the other hand, we show that no universal algorithm exists for terminating exploration with three robots.},
  archive      = {J_IANDC},
  author       = {Shota Nagahama and Fukuhito Ooshita and Michiko Inoue},
  doi          = {10.1016/j.ic.2023.105036},
  journal      = {Information and Computation},
  pages        = {105036},
  shortjournal = {Inf. Comput.},
  title        = {Ring exploration of myopic luminous robots with visibility more than one},
  volume       = {292},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Synchronous t-resilient consensus in arbitrary graphs.
<em>IANDC</em>, <em>292</em>, 105035. (<a
href="https://doi.org/10.1016/j.ic.2023.105035">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the number of rounds needed to solve consensus in a synchronous network G where at most t nodes may fail by crashing. This problem has been thoroughly studied when G is a complete graph, but very little is known when G is arbitrary. We define a notion of radius ( G , t ) radius(G,t) , that extends the standard graph theoretical notion of radius, for considering all the ways in which t nodes may crash, and we present an algorithm that solves consensus in radius ( G , t ) radius(G,t) rounds. Then we derive a lower bound showing that, among oblivious algorithms, our algorithm is optimal for a large family of graphs including all vertex-transitive graphs.},
  archive      = {J_IANDC},
  author       = {Armando Castañeda and Pierre Fraigniaud and Ami Paz and Sergio Rajsbaum and Matthieu Roy and Corentin Travers},
  doi          = {10.1016/j.ic.2023.105035},
  journal      = {Information and Computation},
  pages        = {105035},
  shortjournal = {Inf. Comput.},
  title        = {Synchronous t-resilient consensus in arbitrary graphs},
  volume       = {292},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). On divergence-sensitive weak probabilistic bisimilarity.
<em>IANDC</em>, <em>292</em>, 105033. (<a
href="https://doi.org/10.1016/j.ic.2023.105033">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Weak probabilistic bisimilarity is a well-established notion to equate concurrent probabilistic systems that behave observably equivalent. This notion can be pivotal in the model checking of large probabilistic systems, because the considered model can be replaced by an equivalent, but possibly much smaller one prior to model checking. The conventional work has thus far considered weak probabilistic bisimilarity while ignoring the divergent behavior (interpreted as infinite internal computations). However, we argue that divergence can have a remarkable influence on the equivalence of two concurrent probabilistic systems. We thus explore divergence-sensitive refinements of weak probabilistic bisimilarity. We work in the setting of probabilistic automata , and study the consistent feasible verification method for the notion of divergence-sensitivity that discriminates presence and absence of divergence in bisimilar states. We furthermore present a novel polynomial-time algorithm to compute divergence-sensitive bisimilarity. It intertwines partition-refinement and inductive verification steps in a highly non-trivial manner.},
  archive      = {J_IANDC},
  author       = {Kangli He and Hengyang Wu and Yixiang Chen},
  doi          = {10.1016/j.ic.2023.105033},
  journal      = {Information and Computation},
  pages        = {105033},
  shortjournal = {Inf. Comput.},
  title        = {On divergence-sensitive weak probabilistic bisimilarity},
  volume       = {292},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). On the power of finite ambiguity in büchi complementation.
<em>IANDC</em>, <em>292</em>, 105032. (<a
href="https://doi.org/10.1016/j.ic.2023.105032">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this work, we exploit the power of finite ambiguity for the complementation problem of Büchi automata by using reduced run directed acyclic graphs (DAGs) over infinite words, in which each vertex has at most one predecessor; these reduced run DAGs have only a finite number of infinite runs, thus obtaining the finite ambiguity in Büchi complementation. We show how to use this type of reduced run DAGs as a unified tool to optimize both rank-based and slice-based complementation constructions for Büchi automata with a finite degree of ambiguity. As a result, given a Büchi automaton with n states and a finite degree of ambiguity, the number of states in the complementary Büchi automaton constructed by the classical rank-based and slice-based complementation constructions can be improved from 2 O ( n log ⁡ n ) 2O(nlog⁡n) and O ( ( 3 n ) n ) O((3n)n) to O ( 6 n ) ⊆ 2 O ( n ) O(6n)⊆2O(n) and O ( 4 n ) O(4n) , respectively. We further show how to construct such reduced run DAGs for limit deterministic Büchi automata and obtain a specialized complementation algorithm, thus demonstrating the generality of the power of finite ambiguity.},
  archive      = {J_IANDC},
  author       = {Weizhi Feng and Yong Li and Andrea Turrini and Moshe Y. Vardi and Lijun Zhang},
  doi          = {10.1016/j.ic.2023.105032},
  journal      = {Information and Computation},
  pages        = {105032},
  shortjournal = {Inf. Comput.},
  title        = {On the power of finite ambiguity in büchi complementation},
  volume       = {292},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023a). Non-closure under complementation for unambiguous linear
grammars. <em>IANDC</em>, <em>292</em>, 105031. (<a
href="https://doi.org/10.1016/j.ic.2023.105031">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The paper demonstrates the non-closure of the family of unambiguous linear languages (that is, those defined by unambiguous linear context-free grammars) under complementation. To be precise, a particular unambiguous linear grammar is presented, and it is proved that the complement of this language is not defined by any context-free grammar. This also constitutes an alternative proof for the result of Hibbard and Ullian (“The independence of inherent ambiguity from complementedness among context-free languages”, JACM , 1966) on the non-closure of the unambiguous languages under complementation.},
  archive      = {J_IANDC},
  author       = {Olga Martynova and Alexander Okhotin},
  doi          = {10.1016/j.ic.2023.105031},
  journal      = {Information and Computation},
  pages        = {105031},
  shortjournal = {Inf. Comput.},
  title        = {Non-closure under complementation for unambiguous linear grammars},
  volume       = {292},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Weight-reducing turing machines. <em>IANDC</em>,
<em>292</em>, 105030. (<a
href="https://doi.org/10.1016/j.ic.2023.105030">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {It is well known that one-tape Turing machines running in linear time are no more powerful than finite automata ; namely they recognize exactly the class of regular languages. We prove that it is not decidable if a one-tape machine runs in linear time, even if it is deterministic and restricted to use only the portion of the tape that initially contains the input. This motivates the introduction of a constructive variant of one-tape machines, called a weight-reducing machine, and the investigation of its properties. We focus on the deterministic case . In particular, we show that, paying a polynomial size increase only, each weight-reducing machine can be turned into a halting one that runs in linear time. Furthermore each weight-reducing machine can be converted into equivalent nondeterministic and deterministic finite automata by paying an exponential and doubly-exponential increase in size, respectively. These costs cannot be reduced in the worst case.},
  archive      = {J_IANDC},
  author       = {Bruno Guillon and Giovanni Pighizzini and Luca Prigioniero and Daniel Průša},
  doi          = {10.1016/j.ic.2023.105030},
  journal      = {Information and Computation},
  pages        = {105030},
  shortjournal = {Inf. Comput.},
  title        = {Weight-reducing turing machines},
  volume       = {292},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Compact representations of spatial hierarchical structures
with support for topological queries. <em>IANDC</em>, <em>292</em>,
105029. (<a href="https://doi.org/10.1016/j.ic.2023.105029">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Among different spatial data models, the topological model for spatial regions explicitly represents common boundaries. This model pursues the efficiency of topology-related queries and the elimination of data redundancy . This paper proposes several space-efficient data structures to support access to the topological representation of two-dimensional regions that are organized in a multi-granular or hierarchical structure, such as the political and administrative partition of a country. In the context of these hierarchies, we focus on queries that search for inclusion, disjointness , and adjacency between regions. The proposed structures build upon compact planar graph embeddings, which show to have a good trade-off between space and time.},
  archive      = {J_IANDC},
  author       = {José Fuentes-Sepúlveda and Diego Gatica and Gonzalo Navarro and M. Andrea Rodríguez and Diego Seco},
  doi          = {10.1016/j.ic.2023.105029},
  journal      = {Information and Computation},
  pages        = {105029},
  shortjournal = {Inf. Comput.},
  title        = {Compact representations of spatial hierarchical structures with support for topological queries},
  volume       = {292},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Continuous randomness via transformations of 2-random
sequences. <em>IANDC</em>, <em>292</em>, 105028. (<a
href="https://doi.org/10.1016/j.ic.2023.105028">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Reimann and Slaman initiated the study of sequences that are Martin-Löf random with respect to a continuous measure. In the case of sequences that are random with respect to a computable, continuous measure, the picture is understood: such sequences are truth-table equivalent to a Martin-Löf random sequence. However, we may ask: Given a sequence that is random with respect to a continuous measure but not with respect to any computable measure, how close to effective is the measure with respect to which it is continuously random? In this study, we take up this question by examining various transformations of 2-random sequences to establish several results on sequences that are continuously random with respect to a measure that is computable in ∅ ′ ∅′ but not random with respect to a computable measure. In addition, we obtain similar results when transforming 2-randomness under a wider class of effective operators.},
  archive      = {J_IANDC},
  author       = {Christopher P. Porter},
  doi          = {10.1016/j.ic.2023.105028},
  journal      = {Information and Computation},
  pages        = {105028},
  shortjournal = {Inf. Comput.},
  title        = {Continuous randomness via transformations of 2-random sequences},
  volume       = {292},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023a). New characterizations of exponential, elementary, and
non-elementary time-bounded turing machines. <em>IANDC</em>,
<em>292</em>, 105027. (<a
href="https://doi.org/10.1016/j.ic.2023.105027">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Machine models with multiple types of stores are studied. Deterministic two-way pushdown automata augmented by some number of checking stacks are known to accept exactly the class of elementary languages, which is very general but still has a decidable membership problem. First, we define such a machine to be synchronous if, when a checking stack starts to read from its stack, all other checking stacks can no longer write. For such a synchronous machine, the multiple checking stacks are equivalent to machines with 2 synchronous checking stacks which, in turn, are equivalent to exponential time-bounded deterministic Turing machines . Next, we also show that for any (reasonably defined) one-way deterministic machine model M M with a decidable membership problem, the two-way deterministic multi-head variant of M M augmented by any number of checking stacks also has a decidable membership problem. We also examine a model, two-way deterministic pushdown automata augmented with some number of non-erasing stacks, where the machine starts reading from the stacks at most a linear number of times. We show that this model accepts non-elementary languages but still has a decidable membership problem, resolving an open problem from the literature.},
  archive      = {J_IANDC},
  author       = {Oscar H. Ibarra and Ian McQuillan},
  doi          = {10.1016/j.ic.2023.105027},
  journal      = {Information and Computation},
  pages        = {105027},
  shortjournal = {Inf. Comput.},
  title        = {New characterizations of exponential, elementary, and non-elementary time-bounded turing machines},
  volume       = {292},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). To be announced. <em>IANDC</em>, <em>292</em>, 105026. (<a
href="https://doi.org/10.1016/j.ic.2023.105026">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this survey we review dynamic epistemic logics with modalities for quantification over information change. Of such logics we present complete axiomatizations , focussing on axioms involving the interaction between knowledge and such quantifiers, we report on their relative expressivity, on decidability and on the complexity of model checking and satisfiability, and on applications. We focus on open problems and new directions for research.},
  archive      = {J_IANDC},
  author       = {Hans van Ditmarsch},
  doi          = {10.1016/j.ic.2023.105026},
  journal      = {Information and Computation},
  pages        = {105026},
  shortjournal = {Inf. Comput.},
  title        = {To be announced},
  volume       = {292},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Pushdown and lempel-ziv depth. <em>IANDC</em>, <em>292</em>,
105025. (<a href="https://doi.org/10.1016/j.ic.2023.105025">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In previously published work (Jordon and Moser, 2020), notions of finite-state-depth and pushdown-depth were presented. These were based on finite-state transducers and information lossless pushdown compressors. Unfortunately, a complete separation between the two notions was not established. This paper introduces a new formulation of pushdown-depth based on restricting how fast a pushdown compressor&#39;s stack can grow. This allows us to do a full comparison by demonstrating the existence of sequences with high finite-state-depth and low pushdown-depth, and vice-versa. A new notion based on the Lempel-Ziv 78 algorithm is also presented. Its difference from finite-state-depth is shown by a Lempel-Ziv deep sequence that is not finite-state deep, and vice versa. Lempel-Ziv-depth&#39;s difference from pushdown-depth is shown by building sequences that have a pushdown-depth of roughly 1/2 but low Lempel-Ziv depth, and by a sequence with high Lempel-Ziv depth but low pushdown-depth. Properties of all three notions are also studied.},
  archive      = {J_IANDC},
  author       = {Liam Jordon and Philippe Moser},
  doi          = {10.1016/j.ic.2023.105025},
  journal      = {Information and Computation},
  pages        = {105025},
  shortjournal = {Inf. Comput.},
  title        = {Pushdown and lempel-ziv depth},
  volume       = {292},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Software science view on quantum circuit algorithms.
<em>IANDC</em>, <em>292</em>, 105024. (<a
href="https://doi.org/10.1016/j.ic.2023.105024">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We show that, on the abstraction level of quantum circuit diagrams, quantum circuit algorithms belong to the species of interactive sequential algorithms that we studied in earlier work. This observation leads to a natural specification language for quantum circuit algorithms.},
  archive      = {J_IANDC},
  author       = {Yuri Gurevich and Andreas Blass},
  doi          = {10.1016/j.ic.2023.105024},
  journal      = {Information and Computation},
  pages        = {105024},
  shortjournal = {Inf. Comput.},
  title        = {Software science view on quantum circuit algorithms},
  volume       = {292},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Complexity of ck-coloring in hereditary classes of graphs.
<em>IANDC</em>, <em>292</em>, 105015. (<a
href="https://doi.org/10.1016/j.ic.2023.105015">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {For a graph F , a graph G is F-free if it does not contain an induced subgraph isomorphic to F . For two graphs G and H , an H-coloring of G is a mapping f : V ( G ) → V ( H ) f:V(G)→V(H) such that for every edge u v ∈ E ( G ) uv∈E(G) it holds that f ( u ) f ( v ) ∈ E ( H ) f(u)f(v)∈E(H) . We are interested in the complexity of the problem H - Coloring , which asks for the existence of an H -coloring of an input graph G . In particular, we consider H - Coloring of F -free graphs, where F is a fixed graph and H is an odd cycle of length at least 5. This problem is closely related to the well known open problem of determining the complexity of 3- Coloring of P t Pt -free graphs. We show that for every odd k ≥ 5 k≥5 , the C k Ck - Coloring problem, even in the list variant, can be solved in polynomial time in P 9 P9 -free graphs. The algorithm extends to the list version of C k Ck - Coloring , where k ≥ 10 k≥10 is an even number . On the other hand, we prove that if some component of F is not a subgraph of a subdivided claw, then the following problems are NP-complete in F -free graphs:},
  archive      = {J_IANDC},
  author       = {Maria Chudnovsky and Shenwei Huang and Paweł Rzążewski and Sophie Spirkl and Mingxian Zhong},
  doi          = {10.1016/j.ic.2023.105015},
  journal      = {Information and Computation},
  pages        = {105015},
  shortjournal = {Inf. Comput.},
  title        = {Complexity of ck-coloring in hereditary classes of graphs},
  volume       = {292},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Algorithmic coincidence classification of mesh patterns.
<em>IANDC</em>, <em>292</em>, 105014. (<a
href="https://doi.org/10.1016/j.ic.2023.105014">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Permutations have connections to other mathematical objects such as Schubert varieties, sorting networks, and genome rearrangements. Often the connection is described in terms of patterns that are absent from the permutations. There can be ambiguity in this description, in the sense that the same subset of permutations can be defined with two different patterns. This is called coincidence and we focus on the coincidence of mesh patterns, one of the most descriptive version of patterns in permutations. We review and extend previous results on coincidence of mesh patterns. We introduce the notion of a force on a permutation pattern and apply it to the coincidence classification of mesh patterns, completing the classification up to size three. We also show that this concept can be used to enumerate classical permutation classes.},
  archive      = {J_IANDC},
  author       = {Christian Bean and Bjarki Gudmundsson and Tomas Ken Magnusson and Henning Ulfarsson},
  doi          = {10.1016/j.ic.2023.105014},
  journal      = {Information and Computation},
  pages        = {105014},
  shortjournal = {Inf. Comput.},
  title        = {Algorithmic coincidence classification of mesh patterns},
  volume       = {292},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Deterministic size discovery and topology recognition in
radio networks with short labels. <em>IANDC</em>, <em>292</em>, 105010.
(<a href="https://doi.org/10.1016/j.ic.2023.105010">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider size discovery and topology recognition in radio networks without collision detection , modeled by simple undirected connected graphs . The aim of size discovery is that all nodes output the number of nodes in the graph, and in the task of topology recognition, each node has to learn the topology of the graph and its position in it. Nodes are assigned labels which are (not necessarily different) binary strings. Each node uses its own label as input when executing the algorithm. The length of a labeling scheme is the largest length of a label. Our goal is to construct short labeling schemes for size discovery and topology recognition in arbitrary radio networks, and to design efficient deterministic distributed algorithms for each of these tasks, using these short schemes. In both cases, the length of our labeling schemes is asymptotically optimal.},
  archive      = {J_IANDC},
  author       = {Adam Gańczorz and Tomasz Jurdziński and Mateusz Lewko and Andrzej Pelc},
  doi          = {10.1016/j.ic.2023.105010},
  journal      = {Information and Computation},
  pages        = {105010},
  shortjournal = {Inf. Comput.},
  title        = {Deterministic size discovery and topology recognition in radio networks with short labels},
  volume       = {292},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Improving convergence and practicality of slide-type
reductions. <em>IANDC</em>, <em>291</em>, 105012. (<a
href="https://doi.org/10.1016/j.ic.2023.105012">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The best lattice reduction algorithm known in theory for approximating the Shortest Vector Problem (SVP) over lattices is the slide reduction algorithm (STOC &#39;08 &amp; CRYPTO &#39;20). In this paper, we first improve the running time analysis of computing slide-reduced bases based on potential functions. This analysis applies to a generic slide reduction algorithm that includes (natural variants of) slide reduction and block-Rankin reduction (ANTS &#39;14). We then present a rigorous dynamic analysis of generic slide reduction using techniques originally applied to a variant of BKZ (CRYPTO &#39;11). This provides guarantees on the quality of the current lattice basis during execution. This dynamic analysis not only implies sharper convergence for these algorithms to find a short nonzero vector (rather than a fully reduced basis), but also allows to heuristically model/trace the practical behaviour of slide reduction. Interestingly, this dynamic analysis inspires us to introduce a new slide reduction variant with better time/quality trade-offs. This is confirmed by both our experiments and simulation, which also show that our variant is competitive with state-of-the-art reduction algorithms. To the best of our knowledge, this work is the first attempt of improving the practical performance of slide reduction beyond speeding up the SVP oracle.},
  archive      = {J_IANDC},
  author       = {Jianwei Li and Michael Walter},
  doi          = {10.1016/j.ic.2023.105012},
  journal      = {Information and Computation},
  pages        = {105012},
  shortjournal = {Inf. Comput.},
  title        = {Improving convergence and practicality of slide-type reductions},
  volume       = {291},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023b). State complexity of transforming graph-walking automata to
halting, returning and reversible. <em>IANDC</em>, <em>291</em>, 105011.
(<a href="https://doi.org/10.1016/j.ic.2023.105011">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Graph-walking automata (GWA) traverse graphs by moving between the nodes following the edges, using a finite-state control to decide where to go next. It is known that every GWA can be transformed to a GWA that halts on every input, to a GWA returning to the initial node to accept, and to a reversible GWA. This paper establishes lower bounds on the state blow-up of these transformations, as well as improves the known upper bounds. It is shown that, for graphs with k labels of edge end-points, making an n -state GWA return to the initial node in the worst case requires at least 2 ( k − 3 ) n 2(k−3)n and at most 2 k n + n 2kn+n states. Similar asymptotically tight bounds are proved for transformations ensuring other properties: for halting on every input, at least 2 ( k − 3 ) ( n − 1 ) 2(k−3)(n−1) and at most 2 k n + 1 2kn+1 states; for returning and halting, at least 2 ( k − 3 ) ( 2 n − 1 ) 2(k−3)(2n−1) and at most 4 k n + 1 4kn+1 ; for reversible, between 2 ( k − 3 ) ( n − 1 ) − 1 2(k−3)(n−1)−1 and 2 k n + 1 2kn+1 ; for returning and reversible, between 2 ( k − 3 ) ( 2 n − 1 ) − 1 2(k−3)(2n−1)−1 and 4 k n + 1 4kn+1 .},
  archive      = {J_IANDC},
  author       = {Olga Martynova and Alexander Okhotin},
  doi          = {10.1016/j.ic.2023.105011},
  journal      = {Information and Computation},
  pages        = {105011},
  shortjournal = {Inf. Comput.},
  title        = {State complexity of transforming graph-walking automata to halting, returning and reversible},
  volume       = {291},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Removing redundant refusals: Minimal complete test suites
for failure trace semantics. <em>IANDC</em>, <em>291</em>, 105009. (<a
href="https://doi.org/10.1016/j.ic.2023.105009">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We explore the problem of finding a minimal complete test suite for refusal trace (or failure trace) semantics. Our approach is based on generating a minimal complete set of forbidden refusal traces and utilises several interesting insights into the semantics. In particular, we identify a key class of refusals called fundamental refusals which essentially determine the refusal trace semantics, and the associated equivalence relation. We then propose a small but not necessarily minimal test suite, which can be constructed with a simple algorithm. Subsequently, we provide an enumerative method to remove all redundant traces from our complete test suite, which comes in two variants, depending on whether we wish to retain the highly desirable uniform completeness. We also address a related problem from modal logic, namely the construction of a characteristic formula of a given process with respect to refusal trace semantics, using a variant of Hennessy-Milner logic with recursion.},
  archive      = {J_IANDC},
  author       = {Maciej Gazda and Robert M Hierons},
  doi          = {10.1016/j.ic.2023.105009},
  journal      = {Information and Computation},
  pages        = {105009},
  shortjournal = {Inf. Comput.},
  title        = {Removing redundant refusals: Minimal complete test suites for failure trace semantics},
  volume       = {291},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Learning half-spaces on general infinite spaces equipped
with a distance function. <em>IANDC</em>, <em>291</em>, 105008. (<a
href="https://doi.org/10.1016/j.ic.2023.105008">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {For a general infinite distance space X X , with no assumptions about the distance function, which need not satisfy the metric axioms, it is not clear what the VC-dimension of the class H H of half-spaces in X X may be and if there are generalization error bounds for learning H H . We define a combinatorial dimension of X X to be the independence number of the class of balls in X X . We compute it for Euclidean space and for several non-metric distance spaces. Using this dimension, we are able to provide a generalization error bound for learning H H over any infinite distance space X X .},
  archive      = {J_IANDC},
  author       = {Joel Ratsaby},
  doi          = {10.1016/j.ic.2023.105008},
  journal      = {Information and Computation},
  pages        = {105008},
  shortjournal = {Inf. Comput.},
  title        = {Learning half-spaces on general infinite spaces equipped with a distance function},
  volume       = {291},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Sensitivity of string compressors and repetitiveness
measures. <em>IANDC</em>, <em>291</em>, 104999. (<a
href="https://doi.org/10.1016/j.ic.2022.104999">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The sensitivity of a string compression algorithm C asks how much the output size C ( T ) C(T) for an input string T can increase when a single character edit operation is performed on T . This notion enables one to measure the robustness of compression algorithms in terms of errors and/or dynamic changes occurring in the input string. In this paper, we analyze the worst-case multiplicative sensitivity of string compression algorithms, which is defined by max T ∈ Σ n ⁡ { C ( T ′ ) / C ( T ) : ed ( T , T ′ ) = 1 } maxT∈Σn⁡{C(T′)/C(T):ed(T,T′)=1} , where ed ( T , T ′ ) ed(T,T′) denotes the edit distance between T and T ′ T′ . In particular, for the most common versions of the Lempel-Ziv 77 compressors, we prove that the worst-case multiplicative sensitivity is only a small constant (2 or 3, depending on the version of the Lempel-Ziv 77 and the edit operation type), i.e., the size of the Lempel-Ziv 77 factorizations can be larger by only a small constant factor. We strengthen our upper bound results by presenting matching lower bounds on the worst-case sensitivity for all these major versions of the Lempel-Ziv 77 factorizations. We generalize these results to the smallest bidirectional scheme b . In addition, we show that the sensitivity of a grammar-based compressor called GCIS (Grammar Compression by Induced Sorting) is also a small constant. Further, we extend the notion of the worst-case sensitivity to string repetitiveness measures such as the smallest string attractor size γ and the substring complexity δ , and show that the worst-case sensitivity of δ is also a small constant. These results contrast with the previously known related results such that the size z 78 z78 of the Lempel-Ziv 78 factorization can increase by a factor of Ω ( n 1 / 4 ) Ω(n1/4) (shown by Lagarde and Perifel), and the number r of runs in the Burrows-Wheeler transform can increase by a factor of Ω ( log ⁡ n ) Ω(log⁡n) (shown by Giuliani et al.) when a character is prepended to an input string of length n . By applying our sensitivity bounds of δ or the smallest grammar to known results (cf. Navarro&#39;s survey) some non-trivial upper bounds for the sensitivities of important string compressors and repetitiveness measures including γ , r , LZ-End, RePair, LongestMatch, and AVL-grammar, are derived. We also exhibit the worst-case additive sensitivity max T ∈ Σ n ⁡ { C ( T ′ ) − C ( T ) : ed ( T , T ′ ) = 1 } maxT∈Σn⁡{C(T′)−C(T):ed(T,T′)=1} , which allows one to observe more details in the changes of the output sizes.},
  archive      = {J_IANDC},
  author       = {Tooru Akagi and Mitsuru Funakoshi and Shunsuke Inenaga},
  doi          = {10.1016/j.ic.2022.104999},
  journal      = {Information and Computation},
  pages        = {104999},
  shortjournal = {Inf. Comput.},
  title        = {Sensitivity of string compressors and repetitiveness measures},
  volume       = {291},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Causal computational complexity of distributed processes.
<em>IANDC</em>, <em>290</em>, 104998. (<a
href="https://doi.org/10.1016/j.ic.2022.104998">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This article studies the complexity of π -calculus processes with respect to the quantity of transitions caused by an incoming message. First, we propose a typing system for integrating Bellantoni and Cook&#39;s characterisation of polytime computable functions into Deng and Sangiorgi&#39;s typing system for termination. We then define computational complexity of distributed messages based on Degano and Priami&#39;s causal semantics, which identifies the dependency between interleaved transitions. Next, we apply a necessary syntactic flow analysis to typable processes to ensure a computational bound on the number of distributed messages. We prove that our analysis is decidable ; sound in the sense that it guarantees that the total number of messages causally dependent of an input request received from the outside is bounded by a polynomial of the content of this request; and complete , meaning that each polynomial recursive function can be computed by a typable process.},
  archive      = {J_IANDC},
  author       = {Romain Demangeon and Nobuko Yoshida},
  doi          = {10.1016/j.ic.2022.104998},
  journal      = {Information and Computation},
  pages        = {104998},
  shortjournal = {Inf. Comput.},
  title        = {Causal computational complexity of distributed processes},
  volume       = {290},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Effective notions of weak convergence of measures on the
real line. <em>IANDC</em>, <em>290</em>, 104997. (<a
href="https://doi.org/10.1016/j.ic.2022.104997">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We establish a framework for the study of the effective theory of weak convergence of measures. We define two effective notions of weak convergence of measures on R R : one uniform and one non-uniform. We show that these notions are equivalent. By means of this equivalence, we prove an effective version of the Portmanteau Theorem, which consists of multiple equivalent definitions of weak convergence of measures.},
  archive      = {J_IANDC},
  author       = {Timothy H. McNicholl and Diego A. Rojas},
  doi          = {10.1016/j.ic.2022.104997},
  journal      = {Information and Computation},
  pages        = {104997},
  shortjournal = {Inf. Comput.},
  title        = {Effective notions of weak convergence of measures on the real line},
  volume       = {290},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Timed network games. <em>IANDC</em>, <em>290</em>, 104996.
(<a href="https://doi.org/10.1016/j.ic.2022.104996">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Network games are widely used as a model for selfish resource-allocation problems. The classical model abstracts the fact that different users may use a resource at different times and for different duration – factors that play an important role in determining the costs of the users in reality. We consider here timed network games , which add time to network games. Each vertex v in the network is associated with a cost function, mapping the load on v to the price that a player pays for staying in v for one time unit with this load. The network is equipped with clocks , and, as in timed automata , edges are guarded by constraints on the values of the clocks, and their traversal may involve resetting some clocks. We also study the fragment of network games with a single clock that is not reset and thus keeps track only of the global time elapsed.},
  archive      = {J_IANDC},
  author       = {Guy Avni and Shibashis Guha and Orna Kupferman},
  doi          = {10.1016/j.ic.2022.104996},
  journal      = {Information and Computation},
  pages        = {104996},
  shortjournal = {Inf. Comput.},
  title        = {Timed network games},
  volume       = {290},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Randomness below complete theories of arithmetic.
<em>IANDC</em>, <em>290</em>, 104983. (<a
href="https://doi.org/10.1016/j.ic.2022.104983">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We show that reals z which compute complete extensions of arithmetic have the random join property: for each random x x&amp;lt;Tz there exists random y y&amp;lt;Tz such that z ≡ T x ⊕ y z≡Tx⊕y . The same is true for the truth-table and the weak truth-table reducibilities.},
  archive      = {J_IANDC},
  author       = {George Barmpalias and Wei Wang},
  doi          = {10.1016/j.ic.2022.104983},
  journal      = {Information and Computation},
  pages        = {104983},
  shortjournal = {Inf. Comput.},
  title        = {Randomness below complete theories of arithmetic},
  volume       = {290},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Exact bounds for acyclic higher-order recursion schemes.
<em>IANDC</em>, <em>290</em>, 104982. (<a
href="https://doi.org/10.1016/j.ic.2022.104982">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Beckmann [1] derives bounds on the length of reduction chains of classes of simply typed λ -calculus terms which are exact up-to a constant factor in their highest exponent. Afshari et al. [2] obtain similar bounds on acyclic higher-order recursion schemes (HORS) by embedding them in the simply typed λ -calculus and applying Beckmann&#39;s result. In this article, we apply Beckmann&#39;s proof strategy directly to acyclic HORS, proving exactness of the bounds on reduction chain length and obtaining exact bounds on the size of languages generated by acyclic HORS.},
  archive      = {J_IANDC},
  author       = {Bahareh Afshari and Dominik Wehr},
  doi          = {10.1016/j.ic.2022.104982},
  journal      = {Information and Computation},
  pages        = {104982},
  shortjournal = {Inf. Comput.},
  title        = {Exact bounds for acyclic higher-order recursion schemes},
  volume       = {290},
  year         = {2023},
}
</textarea>
</details></li>
</ul>

</body>
</html>
