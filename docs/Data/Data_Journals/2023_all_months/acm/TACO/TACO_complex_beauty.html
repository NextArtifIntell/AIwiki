<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>TACO_complex_beauty</title>
  <style>
    html {font-size: 22px;}
    body {margin: 0 auto; max-width: 76em;}
    #copyID {font-size: 18px;}
  </style>
  <script>
    function copy(element) {
      if (element.type == "button"){
      element.type="text";
      }
      element.style.color="black";
      element.style.backgroundColor="#C7EDCC";
      element.select();
      element.setSelectionRange(0, 99999);
      navigator.clipboard.writeText(element.value);
      window.getSelection().removeAllRanges();
      element.type="button";
    }
  </script>
</head>
<body>

<h2 id="taco---4">TACO - 4</h2>
<ul>
<li><details>
<summary>
(2023). Autovesk: Automatic vectorized code generation from
unstructured static kernels using graph transformations. <em>TACO</em>,
<em>21</em>(1), 4:1–25. (<a
href="https://doi.org/10.1145/3631709">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Leveraging the SIMD capability of modern CPU architectures is mandatory to take full advantage of their increased performance. To exploit this capability, binary executables must be vectorized, either manually by developers or automatically by a tool. For this reason, the compilation research community has developed several strategies for transforming scalar code into a vectorized implementation. However, most existing automatic vectorization techniques in modern compilers are designed for regular codes, leaving irregular applications with non-contiguous data access patterns at a disadvantage. In this article, we present a new tool, Autovesk, that automatically generates vectorized code from scalar code, specifically targeting irregular data access patterns. We describe how our method transforms a graph of scalar instructions into a vectorized one, using different heuristics to reduce the number or cost of instructions. Finally, we demonstrate the effectiveness of our approach on various computational kernels using Intel AVX-512 and ARM SVE. We compare the speedups of Autovesk vectorized code over GCC, Clang LLVM, and Intel automatic vectorization optimizations. We achieve competitive results on linear kernels and up to 11× speedups on irregular kernels.},
  archive      = {J_TACO},
  author       = {Hayfa Tayeb and Ludovic Paillat and Bérenger Bramas},
  doi          = {10.1145/3631709},
  journal      = {ACM Transactions on Architecture and Code Optimization},
  month        = {12},
  number       = {1},
  pages        = {4:1–25},
  shortjournal = {ACM Trans. Archit. Code Optim.},
  title        = {Autovesk: Automatic vectorized code generation from unstructured static kernels using graph transformations},
  volume       = {21},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). JiuJITsu: Removing gadgets with safe register allocation for
JIT code generation. <em>TACO</em>, <em>21</em>(1), 3:1–26. (<a
href="https://doi.org/10.1145/3631526">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Code-reuse attacks have the capability to craft malicious instructions from small code fragments, commonly referred to as “gadgets.” These gadgets are generated by JIT (Just-In-Time) engines as integral components of native instructions, with the flexibility to be embedded in various fields, including Displacement . In this article, we introduce a novel approach for potential gadget insertion, achieved through the manipulation of ModR/M and SIB bytes via JavaScript code. This manipulation influences a JIT engine’s register allocation and code generation algorithms. These newly generated gadgets do not rely on constants and thus evade existing constant blinding schemes. Furthermore, they can be combined with 1-byte constants, a combination that proves to be challenging to defend against using conventional constant blinding techniques. To showcase the feasibility of our approach, we provide proof-of-concept (POC) code for three distinct types of gadgets. Our research underscores the potential for attackers to exploit ModR/M and SIB bytes within JIT-generated native instructions. In response, we propose a practical defense mechanism to mitigate such attacks. We introduce JiuJITsu , a security-enhanced register allocation scheme designed to prevent harmful register assignments during the JIT code generation phase, thereby thwarting the generation of these malicious gadgets. We conduct a comprehensive analysis of JiuJITsu ’s effectiveness in defending against code-reuse attacks. Our findings demonstrate that it incurs a runtime overhead of under 1\% when evaluated using JetStream2 benchmarks and real-world websites.},
  archive      = {J_TACO},
  author       = {Zhang Jiang and Ying Chen and Xiaoli Gong and Jin Zhang and Wenwen Wang and Pen-Chung Yew},
  doi          = {10.1145/3631526},
  journal      = {ACM Transactions on Architecture and Code Optimization},
  month        = {12},
  number       = {1},
  pages        = {3:1–26},
  shortjournal = {ACM Trans. Archit. Code Optim.},
  title        = {JiuJITsu: Removing gadgets with safe register allocation for JIT code generation},
  volume       = {21},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). DAG-order: An order-based dynamic DAG scheduling for
real-time networks-on-chip. <em>TACO</em>, <em>21</em>(1), 2:1–24. (<a
href="https://doi.org/10.1145/3631527">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {With the high-performance requirement of safety-critical real-time tasks, the platforms of many-core processors with high parallelism are widely utilized, where network-on-chip (NoC) is generally employed for inter-core communication due to its scalability and high efficiency. Unfortunately, large uncertainties are suffered on NoCs from both the overly parallel architecture and the distributed scheduling strategy (e.g., wormhole flow control), which complicates the response time upper bounds estimation (i.e., either unsafe or pessimistic). For DAG-based real-time parallel tasks, to solve this problem, we propose DAG-Order, an order-based dynamic DAG scheduling approach, which strictly guarantees NoC real-time services. First, rather than build the new analysis to fit the widely used best-effort wormhole NoC, DAG-Order is built upon a kind of advanced low-latency NoC with SLT ( S ingle-cycle L ong-range T raversal) to avoid the unpredictable parallel transmission on the shared source-destination link of wormhole NoCs. Second, DAG-Order is a non-preemptive dynamic scheduling strategy, which jointly considers communication as well as computation workloads, and fits SLT NoC. With such an order-based dynamic scheduling strategy, the provably bound safety is ensured by enforcing certain order constraints among DAG edges/vertices that eliminate the execution-timing anomaly at runtime. Third, the order constraints are further relaxed for higher average-case runtime performance without compromising bound safety. Finally, an effective heuristic algorithm seeking a proper schedule order is developed to tighten the bounds. Experiments on synthetic and realistic benchmarks demonstrate that DAG-Order performs better than the state-of-the-art related scheduling methods.},
  archive      = {J_TACO},
  author       = {Peng Chen and Hui Chen and Weichen Liu and Linbo Long and Wanli Chang and Nan Guan},
  doi          = {10.1145/3631527},
  journal      = {ACM Transactions on Architecture and Code Optimization},
  month        = {12},
  number       = {1},
  pages        = {2:1–24},
  shortjournal = {ACM Trans. Archit. Code Optim.},
  title        = {DAG-order: An order-based dynamic DAG scheduling for real-time networks-on-chip},
  volume       = {21},
  year         = {2023},
}
</textarea>
</details></li>
<li><details>
<summary>
(2023). Critical data backup with hybrid flash-based consumer
devices. <em>TACO</em>, <em>21</em>(1), 1:1–23. (<a
href="https://doi.org/10.1145/3631529">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Hybrid flash-based storage constructed with high-density and low-cost flash memory has become increasingly popular in consumer devices in the last decade due to its low cost. However, its poor reliability is one of the major concerns. To protect critical data for guaranteeing user experience, some methods are proposed to improve the reliability of consumer devices with non-hybrid flash storage. However, with the widespread use of hybrid storage, these methods will result in severe problems, including significant performance and endurance degradation. This is caused by the fact that the different characteristics of flash memory in hybrid storage are not considered, e.g., performance, endurance, and access granularity. To address these problems, a critical data backup (CDB) design is proposed to ensure critical data reliability at a low cost. The basic idea is to accumulate two copies of critical data in the fast memory first to make full use of its performance and endurance. Then, one copy will be migrated to the slow memory in the stripe to avoid the write amplification caused by different access granularity between them. By respecting the different characteristics of flash memory in hybrid storage, CDB can achieve encouraging performance and endurance improvement compared with the state-of-the-art. Furthermore, to avoid performance and lifetime degradation caused by the backup data occupying too much space of fast memory, CDB Pro is designed. Two advanced schemes are integrated. One is making use of the pseudo-single-level-cell (pSLC) technique to make a part of slow memory become high-performance. By supplying some high-performance space, data will be fully updated before being evicted to slow memory. More invalid data are generated which reduces eviction costs. Another is to categorize data into three types according to their different life cycles. By putting the same type of data in a block, the eviction efficiency is improved. Therefore, both can improve device performance and lifetime based on CDB. Experiments are conducted to prove the efficiency of CDB and CDB Pro. Experimental results show that compared with the state-of-the-arts, CDB can ensure critical data reliability with lower device performance and lifetime loss whereas CDB Pro can diminish the loss further.},
  archive      = {J_TACO},
  author       = {Longfei Luo and Dingcui Yu and Yina Lv and Liang Shi},
  doi          = {10.1145/3631529},
  journal      = {ACM Transactions on Architecture and Code Optimization},
  month        = {12},
  number       = {1},
  pages        = {1:1–23},
  shortjournal = {ACM Trans. Archit. Code Optim.},
  title        = {Critical data backup with hybrid flash-based consumer devices},
  volume       = {21},
  year         = {2023},
}
</textarea>
</details></li>
</ul>

</body>
</html>
