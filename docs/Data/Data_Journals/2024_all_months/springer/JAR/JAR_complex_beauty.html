<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>JAR_complex_beauty</title>
  <style>
    html {font-size: 22px;}
    body {margin: 0 auto; max-width: 76em;}
    #copyID {font-size: 18px;}
  </style>
  <script>
    function copy(element) {
      if (element.type == "button"){
      element.type="text";
      }
      element.style.color="black";
      element.style.backgroundColor="#C7EDCC";
      element.select();
      element.setSelectionRange(0, 99999);
      navigator.clipboard.writeText(element.value);
      window.getSelection().removeAllRanges();
      element.type="button";
    }
  </script>
</head>
<body>

<h2 id="jar---25">JAR - 25</h2>
<ul>
<li><details>
<summary>
(2024). Single-set cubical categories and their formalisation with a
proof assistant. <em>JAR</em>, <em>68</em>(4), 1–32. (<a
href="https://doi.org/10.1007/s10817-024-09710-9">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce a single-set axiomatisation of cubical $$\omega $$ -categories, including connections and inverses. We justify these axioms by establishing a series of equivalences between the category of single-set cubical $$\omega $$ -categories, and their variants with connections and inverses, and the corresponding cubical $$\omega $$ -categories. We also report on the formalisation of cubical $$\omega $$ -categories with the Isabelle/HOL proof assistant, which has been instrumental in developing the single-set axiomatisation.},
  archive      = {J_JAR},
  author       = {Malbos, Philippe and Massacrier, Tanguy and Struth, Georg},
  doi          = {10.1007/s10817-024-09710-9},
  journal      = {Journal of Automated Reasoning},
  month        = {12},
  number       = {4},
  pages        = {1-32},
  shortjournal = {J. Auto. Reasoning},
  title        = {Single-set cubical categories and their formalisation with a proof assistant},
  volume       = {68},
  year         = {2024},
}
</textarea>
</details></li>
<li><details>
<summary>
(2024). IsaVODEs: Interactive verification of cyber-physical systems
at scale. <em>JAR</em>, <em>68</em>(4), 1–50. (<a
href="https://doi.org/10.1007/s10817-024-09709-2">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We formally introduce IsaVODEs (Isabelle verification with Ordinary Differential Equations), an open, compositional and extensible framework for the verification of cyber-physical systems. We extend a previous semantic approach with methods and techniques that increase its expressivity, proof automation, and scalability to the level of state-of-the-art deductive verification tools. Our contributions include a user-friendly specification language, a flexible hybrid store model, including vectors and matrices, and separation-logic-style rules for local reasoning with hybrid stores using a novel form of differentiation called framed Fréchet derivatives. The formalisation of correctness specifications with forward predicate transformers, the certification of flows as unique solutions to systems of ordinary differential equations, and invariant reasoning for such systems also contribute to the scalability and usability of our framework. In combination, these features make our framework flexible and adaptable to several verification workflows. A suite of examples and hybrid systems verification benchmarks validate our framework relative to other state-of-the-art approaches.},
  archive      = {J_JAR},
  author       = {Huerta y Munive, Jonathan Julián and Foster, Simon and Gleirscher, Mario and Struth, Georg and Pardillo Laursen, Christian and Hickman, Thomas},
  doi          = {10.1007/s10817-024-09709-2},
  journal      = {Journal of Automated Reasoning},
  month        = {12},
  number       = {4},
  pages        = {1-50},
  shortjournal = {J. Auto. Reasoning},
  title        = {IsaVODEs: Interactive verification of cyber-physical systems at scale},
  volume       = {68},
  year         = {2024},
}
</textarea>
</details></li>
<li><details>
<summary>
(2024). Windmills of the minds: A hopping algorithm for fermat’s two
squares theorem. <em>JAR</em>, <em>68</em>(4), 1–21. (<a
href="https://doi.org/10.1007/s10817-024-09708-3">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Fermat’s two squares theorem asserts that a prime one more than a multiple of 4 is a sum of two squares. There are many proofs of this gem in number theory, including a remarkable one-sentence proof by Don Zagier based on two involutions on a finite set built from such a prime. Applying the two involutions alternatively leads to an iterative algorithm to find the two squares for the prime. Moreover, a detailed analysis of the computation reveals that it is possible to jump through the iteration nodes, leading to a better hopping algorithm. Here is a formalisation of Zagier’s proof, deriving the involutions using windmill patterns. Theories developed for the formal proof are used to establish the correctness of both algorithms.},
  archive      = {J_JAR},
  author       = {Chan, Hing Lun},
  doi          = {10.1007/s10817-024-09708-3},
  journal      = {Journal of Automated Reasoning},
  month        = {12},
  number       = {4},
  pages        = {1-21},
  shortjournal = {J. Auto. Reasoning},
  title        = {Windmills of the minds: A hopping algorithm for fermat’s two squares theorem},
  volume       = {68},
  year         = {2024},
}
</textarea>
</details></li>
<li><details>
<summary>
(2024). A practical decision procedure for quantifier-free,
decidable languages extended with restricted quantifiers. <em>JAR</em>,
<em>68</em>(4), 1–28. (<a
href="https://doi.org/10.1007/s10817-024-09713-6">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Let $$\mathcal {L}_\mathcal {X}$$ be the language of a first-order, decidable, quantifier-free theory $$\mathcal {X}$$ . Consider the language, $$\mathcal {L}_\mathcal{R}\mathcal{Q}(\mathcal {X})$$ , that extends $$\mathcal {L}_\mathcal {X}$$ with formulas of the form $$\forall x \in A: \phi $$ (restricted universal quantifier, RUQ) and $$\exists x \in A: \phi $$ (restricted existential quantifier, REQ), where A is a finite set and $$\phi $$ is a formula made of $$\mathcal {X}$$ -formulas, RUQ and REQ. That is, $$\mathcal {L}_\mathcal{R}\mathcal{Q}(\mathcal {X})$$ admits nested restricted quantifiers. In this paper we present a decision procedure for some expressive fragments of $$\mathcal {L}_\mathcal{R}\mathcal{Q}(\mathcal {X})$$ and its implementation as part of the $$\{log\}$$ (‘setlog’) tool. The usefulness of the approach is shown by reporting on three real-world case studies.},
  archive      = {J_JAR},
  author       = {Cristiá, Maximiliano and Rossi, Gianfranco},
  doi          = {10.1007/s10817-024-09713-6},
  journal      = {Journal of Automated Reasoning},
  month        = {12},
  number       = {4},
  pages        = {1-28},
  shortjournal = {J. Auto. Reasoning},
  title        = {A practical decision procedure for quantifier-free, decidable languages extended with restricted quantifiers},
  volume       = {68},
  year         = {2024},
}
</textarea>
</details></li>
<li><details>
<summary>
(2024). Investigations into proof structures. <em>JAR</em>,
<em>68</em>(4), 1–70. (<a
href="https://doi.org/10.1007/s10817-024-09711-8">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce and elaborate a novel formalism for the manipulation and analysis of proofs as objects in a global manner. In this first approach the formalism is restricted to first-order problems characterized by condensed detachment. It is applied in an exemplary manner to a coherent and comprehensive formal reconstruction and analysis of historical proofs of a widely-studied problem due to Łukasiewicz. The underlying approach opens the door towards new systematic ways of generating lemmas in the course of proof search to the effects of reducing the search effort and finding shorter proofs. Among the numerous reported experiments along this line, a proof of Łukasiewicz ’s problem was automatically discovered that is much shorter than any proof found before by man or machine.},
  archive      = {J_JAR},
  author       = {Wernhard, Christoph and Bibel, Wolfgang},
  doi          = {10.1007/s10817-024-09711-8},
  journal      = {Journal of Automated Reasoning},
  month        = {12},
  number       = {4},
  pages        = {1-70},
  shortjournal = {J. Auto. Reasoning},
  title        = {Investigations into proof structures},
  volume       = {68},
  year         = {2024},
}
</textarea>
</details></li>
<li><details>
<summary>
(2024). Certified first-order AC-unification and applications.
<em>JAR</em>, <em>68</em>(4), 1–48. (<a
href="https://doi.org/10.1007/s10817-024-09714-5">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {AC-unification, i.e., unification modulo Associativity and Commutativity axioms is a key component in rewrite-based programming languages and theorem provers. We have used the PVS proof assistant to specify Stickel’s pioneering AC-unification algorithm and proved it to be terminating (using an elaborate lexicographic measure based on Fages’ termination proof), sound, and complete. We give a detailed account of the formalisation, including descriptions of the main steps in the proofs of termination, soundness, and completeness; the files that were created along with their hierarchy and size; and a discussion about our design choices, including the consequences of our choice for the grammar of terms. We also discuss applications of the certified AC-unification algorithm, showing how the formalisation could be used as a starting point to formalise more efficient AC-unification algorithms or to test implementations of AC-unification algorithms. This formalisation has been used to obtain a certified nominal AC-matching algorithm. Also, it could serve as a basis to specify a nominal AC-unification algorithm once this open theoretical problem is solved.},
  archive      = {J_JAR},
  author       = {Ayala-Rincón, Mauricio and Fernández, Maribel and Ferreira Silva, Gabriel and Kutsia, Temur and Nantes-Sobrinho, Daniele},
  doi          = {10.1007/s10817-024-09714-5},
  journal      = {Journal of Automated Reasoning},
  month        = {12},
  number       = {4},
  pages        = {1-48},
  shortjournal = {J. Auto. Reasoning},
  title        = {Certified first-order AC-unification and applications},
  volume       = {68},
  year         = {2024},
}
</textarea>
</details></li>
<li><details>
<summary>
(2024). Refinement of parallel algorithms down to LLVM: Applied to
practically efficient parallel sorting. <em>JAR</em>, <em>68</em>(3),
1–28. (<a href="https://doi.org/10.1007/s10817-024-09701-w">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present a stepwise refinement approach to develop verified parallel algorithms, down to efficient LLVM code. The resulting algorithms’ performance is competitive with their counterparts implemented in C++. Our approach is backwards compatible with the Isabelle Refinement Framework, such that existing sequential formalizations can easily be adapted or re-used. As case study, we verify a parallel quicksort algorithm that is competitive to unverified state-of-the-art algorithms.},
  archive      = {J_JAR},
  author       = {Lammich, Peter},
  doi          = {10.1007/s10817-024-09701-w},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-28},
  shortjournal = {J. Auto. Reasoning},
  title        = {Refinement of parallel algorithms down to LLVM: Applied to practically efficient parallel sorting},
  volume       = {68},
  year         = {2024},
}
</textarea>
</details></li>
<li><details>
<summary>
(2024). General clauses for SAT-based proof search in intuitionistic
propositional logic. <em>JAR</em>, <em>68</em>(3), 1–41. (<a
href="https://doi.org/10.1007/s10817-024-09703-8">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In recent years some papers have addressed the problem of the validity in Intuitionistic Propositional Logic (IPL) using the approach proposed by Claessen and Rosén based on reduction to Satisfiability Modulo Theories. This approach depends on an initial preprocessing phase that reduces the input formula in the intuitionistic language to an equivalent sequent in the language of clauses. In this paper we present general clauses, an extension of the clauses used by Claessen and Rosén, that allow us to define a natural relationship between the semantics of the extended clauses and Kripke semantics. We present a decision procedure for general clauses and we show how to encode intuitionistic formulas in the language of general clauses so to decide IPL. The experimental results show that our implementation in general outperforms the state-of-the-art provers for IPL. In principle general clauses can be used as a target language for other non-classical logics with Kripke semantics, so that our decision procedure can be used to decide them.},
  archive      = {J_JAR},
  author       = {Fiorentini, Camillo and Ferrari, Mauro},
  doi          = {10.1007/s10817-024-09703-8},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-41},
  shortjournal = {J. Auto. Reasoning},
  title        = {General clauses for SAT-based proof search in intuitionistic propositional logic},
  volume       = {68},
  year         = {2024},
}
</textarea>
</details></li>
<li><details>
<summary>
(2024). Verifying a sequent calculus prover for first-order logic
with functions in isabelle/HOL. <em>JAR</em>, <em>68</em>(3), 1–30. (<a
href="https://doi.org/10.1007/s10817-024-09697-3">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We describe the design, implementation and verification of an automated theorem prover for first-order logic with functions. The proof search procedure is based on sequent calculus and we formally verify its soundness and completeness in Isabelle/HOL using an existing abstract framework for coinductive proof trees. Our analytic completeness proof covers both open and closed formulas. Since our deterministic prover considers only the subset of terms relevant to proving a given sequent, we do the same when building a countermodel from a failed proof. Finally, we formally connect our prover with the proof system and semantics of the existing SeCaV system. In particular, the prover can generate human-readable SeCaV proofs which are also machine-verifiable proof certificates. The abstract framework we rely on requires us to fix a stream of proof rules in advance, independently of the formula we are trying to prove. We discuss the efficiency implications of this and the difficulties in mitigating them.},
  archive      = {J_JAR},
  author       = {From, Asta Halkjær and Jacobsen, Frederik Krogsdal},
  doi          = {10.1007/s10817-024-09697-3},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-30},
  shortjournal = {J. Auto. Reasoning},
  title        = {Verifying a sequent calculus prover for first-order logic with functions in Isabelle/HOL},
  volume       = {68},
  year         = {2024},
}
</textarea>
</details></li>
<li><details>
<summary>
(2024). Dependency schemes in CDCL-based QBF solving: A
proof-theoretic study. <em>JAR</em>, <em>68</em>(3), 1–24. (<a
href="https://doi.org/10.1007/s10817-024-09707-4">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In Quantified Boolean Formulas QBFs, dependency schemes help to detect spurious or superfluous dependencies that are implied by the variable ordering in the quantifier prefix but are not essential for constructing countermodels. This detection can provably shorten refutations in specific proof systems, and is expected to speed up runs of QBF solvers. The proof system $$\texttt{QCDCL}$$ recently defined by Beyersdorff and Boehm (LMCS 2023) abstracts the reasoning employed by QBF solvers based on conflict-driven clause-learning (CDCL) techniques. We show how to incorporate the use of dependency schemes into this proof system, either in a preprocessing phase, or in the propagations and clause learning, or both. We then show that when the reflexive resolution path dependency scheme $$\texttt{D}^{\texttt{rrs}}$$ is used, a mixed picture emerges: the proof systems that add $$\texttt{D}^{\texttt{rrs}}$$ to $$\texttt{QCDCL}$$ in these three ways are not only incomparable with each other, but are also incomparable with the basic $$\texttt{QCDCL}$$ proof system that does not use $$\texttt{D}^{\texttt{rrs}}$$ at all, as well as with several other resolution-based QBF proof systems. A notable fact is that all our separations are achieved through QBFs with bounded quantifier alternation.},
  archive      = {J_JAR},
  author       = {Choudhury, Abhimanyu and Mahajan, Meena},
  doi          = {10.1007/s10817-024-09707-4},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-24},
  shortjournal = {J. Auto. Reasoning},
  title        = {Dependency schemes in CDCL-based QBF solving: A proof-theoretic study},
  volume       = {68},
  year         = {2024},
}
</textarea>
</details></li>
<li><details>
<summary>
(2024). Verifying the generalization of deep learning to
out-of-distribution domains. <em>JAR</em>, <em>68</em>(3), 1–60. (<a
href="https://doi.org/10.1007/s10817-024-09704-7">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Deep neural networks (DNNs) play a crucial role in the field of machine learning, demonstrating state-of-the-art performance across various application domains. However, despite their success, DNN-based models may occasionally exhibit challenges with generalization, i.e., may fail to handle inputs that were not encountered during training. This limitation is a significant challenge when it comes to deploying deep learning for safety-critical tasks, as well as in real-world settings characterized by substantial variability. We introduce a novel approach for harnessing DNN verification technology to identify DNN-driven decision rules that exhibit robust generalization to previously unencountered input domains. Our method assesses generalization within an input domain by measuring the level of agreement between independently trained deep neural networks for inputs in this domain. We also efficiently realize our approach by using off-the-shelf DNN verification engines, and extensively evaluate it on both supervised and unsupervised DNN benchmarks, including a deep reinforcement learning (DRL) system for Internet congestion control—demonstrating the applicability of our approach for real-world settings. Moreover, our research introduces a fresh objective for formal verification, offering the prospect of mitigating the challenges linked to deploying DNN-driven systems in real-world scenarios.},
  archive      = {J_JAR},
  author       = {Amir, Guy and Maayan, Osher and Zelazny, Tom and Katz, Guy and Schapira, Michael},
  doi          = {10.1007/s10817-024-09704-7},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-60},
  shortjournal = {J. Auto. Reasoning},
  title        = {Verifying the generalization of deep learning to out-of-distribution domains},
  volume       = {68},
  year         = {2024},
}
</textarea>
</details></li>
<li><details>
<summary>
(2024). Verifying programs with logic and extended proof rules: Deep
embedding vs. Shallow embedding. <em>JAR</em>, <em>68</em>(3), 1–59. (<a
href="https://doi.org/10.1007/s10817-024-09706-5">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Many foundational program verification tools have been developed to build machine-checked program correctness proofs, a majority of which are based on Hoare logic. Their program logics, their assertion languages, and their underlying programming languages can be formalized by either a shallow embedding or a deep embedding. Tools like early versions of Verified Software Toolchain (before 2018) choose different shallow embeddings to formalize their program logic. But the pros and cons of these different embeddings were not yet well studied. Therefore, we want to study the impact of the program logic’s embedding on logic’s proof rules in this paper. This paper considers a set of useful extended proof rules, which aided the proof automation in VST, and four different logic embeddings: one deep embedding and three common shallow embeddings. We prove the validity of these extended rules under these embeddings and discuss their main challenges. Furthermore, we propose a method to lift existing shallowly embedded logics to deeply embedded ones to greatly simplify proofs of extended rules in VST. We implemented our theory in VST by lifting the originally shallowly embedded VST to our deeply embedded VST and establishing these extended rules.},
  archive      = {J_JAR},
  author       = {Wang, Zhongye and Cao, Qinxiang and Tao, Yichen},
  doi          = {10.1007/s10817-024-09706-5},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-59},
  shortjournal = {J. Auto. Reasoning},
  title        = {Verifying programs with logic and extended proof rules: Deep embedding vs. shallow embedding},
  volume       = {68},
  year         = {2024},
}
</textarea>
</details></li>
<li><details>
<summary>
(2024). Towards a scalable proof engine: A performant prototype
rewriting primitive for coq. <em>JAR</em>, <em>68</em>(3), 1–32. (<a
href="https://doi.org/10.1007/s10817-024-09705-6">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We address the challenges of scaling verification efforts to match the increasing complexity and size of systems. We propose a research agenda aimed at building a performant proof engine by studying the asymptotic performance of proof engines and redesigning their building blocks. As a case study, we explore equational rewriting and introduce a novel prototype proof engine building block for rewriting in Coq, utilizing proof by reflection for enhanced performance. Our prototype implementation can significantly improve the development of verified compilers, as demonstrated in a case study with the Fiat Cryptography toolchain. The resulting extracted command-line compiler is about 1000 $$\times $$ faster while featuring simpler compiler-specific proofs. This work lays some foundation for scaling verification efforts and contributes to the broader goal of developing a proof engine with good asymptotic performance, ultimately aimed at enabling the verification of larger and more complex systems.},
  archive      = {J_JAR},
  author       = {Gross, Jason and Erbsen, Andres and Philipoom, Jade and Agrawal, Rajashree and Chlipala, Adam},
  doi          = {10.1007/s10817-024-09705-6},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-32},
  shortjournal = {J. Auto. Reasoning},
  title        = {Towards a scalable proof engine: A performant prototype rewriting primitive for coq},
  volume       = {68},
  year         = {2024},
}
</textarea>
</details></li>
<li><details>
<summary>
(2024). Sequent calculi for choice logics. <em>JAR</em>,
<em>68</em>(2), 1–27. (<a
href="https://doi.org/10.1007/s10817-024-09695-5">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Choice logics constitute a family of propositional logics and are used for the representation of preferences, with especially qualitative choice logic (QCL) being an established formalism with numerous applications in artificial intelligence. While computational properties and applications of choice logics have been studied in the literature, only few results are known about the proof-theoretic aspects of their use. We propose a sound and complete sequent calculus for preferred model entailment in QCL, where a formula F is entailed by a QCL-theory T if F is true in all preferred models of T. The calculus is based on labeled sequent and refutation calculi, and can be easily adapted for different purposes. For instance, using the calculus as a cornerstone, calculi for other choice logics such as conjunctive choice logic (CCL) and lexicographic choice logic (LCL) can be obtained in a straightforward way.},
  archive      = {J_JAR},
  author       = {Bernreiter, Michael and Lolic, Anela and Maly, Jan and Woltran, Stefan},
  doi          = {10.1007/s10817-024-09695-5},
  journal      = {Journal of Automated Reasoning},
  month        = {6},
  number       = {2},
  pages        = {1-27},
  shortjournal = {J. Auto. Reasoning},
  title        = {Sequent calculi for choice logics},
  volume       = {68},
  year         = {2024},
}
</textarea>
</details></li>
<li><details>
<summary>
(2024). Formalized functional analysis with semilinear maps.
<em>JAR</em>, <em>68</em>(2), 1–26. (<a
href="https://doi.org/10.1007/s10817-024-09696-4">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Semilinear maps are a generalization of linear maps between vector spaces where we allow the scalar action to be twisted by a ring homomorphism such as complex conjugation. In particular, this generalization unifies the concepts of linear and conjugate-linear maps. We implement this generalization in Lean’s mathlib library, along with a number of important results in functional analysis which previously were impossible to formalize properly. Specifically, we prove the Fréchet–Riesz representation theorem and the spectral theorem for compact self-adjoint operators generically over real and complex Hilbert spaces, additionally developing the Fourier theory needed to state and prove Parseval’s identity. We also show that semilinear maps have applications beyond functional analysis by formalizing the one-dimensional case of a theorem of Dieudonné and Manin that classifies the isocrystals over an algebraically closed field with positive characteristic.},
  archive      = {J_JAR},
  author       = {Dupuis, Frédéric and Lewis, Robert Y. and Macbeth, Heather},
  doi          = {10.1007/s10817-024-09696-4},
  journal      = {Journal of Automated Reasoning},
  month        = {6},
  number       = {2},
  pages        = {1-26},
  shortjournal = {J. Auto. Reasoning},
  title        = {Formalized functional analysis with semilinear maps},
  volume       = {68},
  year         = {2024},
}
</textarea>
</details></li>
<li><details>
<summary>
(2024). SAT meets tableaux for linear temporal logic satisfiability.
<em>JAR</em>, <em>68</em>(2), 1–32. (<a
href="https://doi.org/10.1007/s10817-023-09691-1">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Linear temporal logic ( $$\textsf{LTL}\,$$ ) and its variant interpreted on finite traces ( $$\textsf{LTL}_{\textsf{f}\,}$$ ) are among the most popular specification languages in the fields of formal verification, artificial intelligence, and others. In this paper, we focus on the satisfiability problem for $$\textsf{LTL}\,$$ and $$\textsf{LTL}_{\textsf{f}\,}$$ formulas, for which many techniques have been devised during the last decades. Among these are tableau systems, of which the most recent is Reynolds’ tree-shaped tableau. We provide a SAT-based algorithm for $$\textsf{LTL}\,$$ and $$\textsf{LTL}_{\textsf{f}\,}$$ satisfiability checking based on Reynolds’ tableau, proving its correctness and discussing experimental results obtained through its implementation in the BLACK satisfiability checker.},
  archive      = {J_JAR},
  author       = {Geatti, Luca and Gigante, Nicola and Montanari, Angelo and Venturato, Gabriele},
  doi          = {10.1007/s10817-023-09691-1},
  journal      = {Journal of Automated Reasoning},
  month        = {6},
  number       = {2},
  pages        = {1-32},
  shortjournal = {J. Auto. Reasoning},
  title        = {SAT meets tableaux for linear temporal logic satisfiability},
  volume       = {68},
  year         = {2024},
}
</textarea>
</details></li>
<li><details>
<summary>
(2024). Linear resources in isabelle/HOL. <em>JAR</em>,
<em>68</em>(2), 1–49. (<a
href="https://doi.org/10.1007/s10817-024-09698-2">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present a formal framework for process composition based on actions that are specified by their input and output resources. The correctness of these compositions is verified by translating them into deductions in intuitionistic linear logic. As part of the verification we derive simple conditions on the compositions which ensure well-formedness of the corresponding deduction when satisfied. We mechanise the whole framework, including a deep embedding of ILL, in the proof assistant Isabelle/HOL. Beyond the increased confidence in our proofs, this allows us to automatically generate executable code for our verified definitions. We demonstrate our approach by formalising part of the simulation game Factorio and modelling a manufacturing process in it. Our framework guarantees that this model is free of bottlenecks.},
  archive      = {J_JAR},
  author       = {Smola, Filip and Fleuriot, Jacques D.},
  doi          = {10.1007/s10817-024-09698-2},
  journal      = {Journal of Automated Reasoning},
  month        = {6},
  number       = {2},
  pages        = {1-49},
  shortjournal = {J. Auto. Reasoning},
  title        = {Linear resources in Isabelle/HOL},
  volume       = {68},
  year         = {2024},
}
</textarea>
</details></li>
<li><details>
<summary>
(2024). Schematic program proofs with abstract execution.
<em>JAR</em>, <em>68</em>(2), 1–57. (<a
href="https://doi.org/10.1007/s10817-023-09692-0">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We propose Abstract Execution, a static verification framework based on symbolic execution and dynamic frames for proving properties of schematic programs. Since a schematic program may potentially represent infinitely many concrete programs, Abstract Execution can analyze infinitely many programs at once. Trading off expressiveness and automation, the framework allows proving many interesting (universal, behavioral) properties fully automatically. Its main application are correctness proofs of program transformations represented as pairs of schematic programs. We implemented Abstract Execution in a deductive verification framework and designed a graphical workbench supporting the modeling process. Abstract Execution has been applied to correct code refactoring, analysis of the cost impact of transformation rules, and parallelization of sequential code. Using our framework, we found and reported several bugs in the refactoring engines of the Java IDEs IntelliJ IDEA and Eclipse, which were acknowledged and fixed.},
  archive      = {J_JAR},
  author       = {Steinhöfel, Dominic and Hähnle, Reiner},
  doi          = {10.1007/s10817-023-09692-0},
  journal      = {Journal of Automated Reasoning},
  month        = {6},
  number       = {2},
  pages        = {1-57},
  shortjournal = {J. Auto. Reasoning},
  title        = {Schematic program proofs with abstract execution},
  volume       = {68},
  year         = {2024},
}
</textarea>
</details></li>
<li><details>
<summary>
(2024). Automated generation of geometry proof problems based on
point geometry identity. <em>JAR</em>, <em>68</em>(2), 1–17. (<a
href="https://doi.org/10.1007/s10817-024-09699-1">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The automated generation of geometry proof problems represents a burgeoning research domain in the realm of artificial intelligence, with significant practical implications for mathematics education. In this study, we present a method for automatically generating fresh geometry proof questions by adapting existing ones. The core of the approach is a novel representation model for geometry proof problems, which we term “point geometry identity&quot;. According to this model, the premises and conclusion to be proven in a geometry proof problem, as well as their relationships, can be expressed as an expression. Subsequently, by applying equivalent deformation principles of algebraic expressions, we can modify the premises and conclusions of existing problems to generate new ones. Experimental analysis and expert evaluations indicate that our approach can efficiently generate a substantial number of diverse problems suitable for mathematics education within a short span of time. Moreover, under the same input conditions, our method can generate novel problems that existing techniques cannot.},
  archive      = {J_JAR},
  author       = {Li, Lei and Yang, Zongkai and Chen, Mao and Peng, Xicheng and Sun, Jianwen and Yan, Zhonghua and Liu, Sannyuya},
  doi          = {10.1007/s10817-024-09699-1},
  journal      = {Journal of Automated Reasoning},
  month        = {6},
  number       = {2},
  pages        = {1-17},
  shortjournal = {J. Auto. Reasoning},
  title        = {Automated generation of geometry proof problems based on point geometry identity},
  volume       = {68},
  year         = {2024},
}
</textarea>
</details></li>
<li><details>
<summary>
(2024). Gale-shapley verified. <em>JAR</em>, <em>68</em>(2), 1–17.
(<a href="https://doi.org/10.1007/s10817-024-09700-x">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper presents a detailed verification of the Gale-Shapley algorithm for stable matching (or marriage). The verification proceeds by stepwise transformation of programs and proofs. The initial steps are on the level of imperative programs, ending in a linear time algorithm. An executable functional program is obtained in a last step. The emphasis is on the stepwise development of the algorithm and the required invariants.},
  archive      = {J_JAR},
  author       = {Nipkow, Tobias},
  doi          = {10.1007/s10817-024-09700-x},
  journal      = {Journal of Automated Reasoning},
  month        = {6},
  number       = {2},
  pages        = {1-17},
  shortjournal = {J. Auto. Reasoning},
  title        = {Gale-shapley verified},
  volume       = {68},
  year         = {2024},
}
</textarea>
</details></li>
<li><details>
<summary>
(2024). A matroid-based automatic prover and coq proof generator for
projective incidence geometry. <em>JAR</em>, <em>68</em>(1), 1–29. (<a
href="https://doi.org/10.1007/s10817-023-09690-2">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present an automatic theorem prover for projective incidence geometry. This prover does not consider coordinates. Instead, it follows a combinatorial approach based on the concept of rank. This allows to deal only with sets of points and to capture relations between objects of the projective space (equality, collinearity, coplanarity, etc.) in a homogenous way. Taking advantage of the computational aspect of this approach, we automatically compute by saturation the ranks of all sets of the powerset of the points of the geometric configuration we consider. Upon completion of the saturation phase, our prover then retraces the proof process and generates the corresponding Coq code. This code is then formally checked by the Coq proof assistant, thus ensuring that the proof is actually correct. We use the prover to verify some well-known, non-trivial theorems in projective space geometry, among them: Desargues’ theorem and Dandelin–Gallucci’s theorem.},
  archive      = {J_JAR},
  author       = {Braun, David and Magaud, Nicolas and Schreck, Pascal},
  doi          = {10.1007/s10817-023-09690-2},
  journal      = {Journal of Automated Reasoning},
  month        = {3},
  number       = {1},
  pages        = {1-29},
  shortjournal = {J. Auto. Reasoning},
  title        = {A matroid-based automatic prover and coq proof generator for projective incidence geometry},
  volume       = {68},
  year         = {2024},
}
</textarea>
</details></li>
<li><details>
<summary>
(2024). Should decisions in QCDCL follow prefix order? <em>JAR</em>,
<em>68</em>(1), 1–31. (<a
href="https://doi.org/10.1007/s10817-024-09694-6">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Quantified conflict-driven clause learning (QCDCL) is one of the main solving approaches for quantified Boolean formulas (QBF). One of the differences between QCDCL and propositional CDCL is that QCDCL typically follows the prefix order of the QBF for making decisions. We investigate an alternative model for QCDCL solving where decisions can be made in arbitrary order. The resulting system $$\textsf{QCDCL}^\textsf {{A\tiny {\MakeUppercase {ny}}}}$$ is still sound and terminating, but does not necessarily allow to always learn asserting clauses or cubes. To address this potential drawback, we additionally introduce two subsystems that guarantee to always learn asserting clauses ( $$\textsf{QCDCL}^\textsf {{U\tiny {\MakeUppercase {ni}}-A\tiny {\MakeUppercase {ny}}}}$$ ) and asserting cubes ( $$\textsf{QCDCL}^\textsf {{E\tiny {\MakeUppercase {xi}}-A\tiny {\MakeUppercase {ny}}}}$$ ), respectively. We model all four approaches by formal proof systems and show that $$\textsf{QCDCL}^\textsf {{U\tiny {\MakeUppercase {ni}}-A\tiny {\MakeUppercase {ny}}}}$$ is exponentially better than $$\mathsf{{QCDCL}} $$ on false formulas, whereas $$\textsf{QCDCL}^\textsf {{E\tiny {\MakeUppercase {xi}}-A\tiny {\MakeUppercase {ny}}}}$$ is exponentially better than $$\mathsf{{QCDCL}} $$ on true QBFs. Technically, this involves constructing specific QBF families and showing lower and upper bounds in the respective proof systems. We complement our theoretical study with some initial experiments that confirm our theoretical findings.},
  archive      = {J_JAR},
  author       = {Böhm, Benjamin and Peitl, Tomáš and Beyersdorff, Olaf},
  doi          = {10.1007/s10817-024-09694-6},
  journal      = {Journal of Automated Reasoning},
  month        = {3},
  number       = {1},
  pages        = {1-31},
  shortjournal = {J. Auto. Reasoning},
  title        = {Should decisions in QCDCL follow prefix order?},
  volume       = {68},
  year         = {2024},
}
</textarea>
</details></li>
<li><details>
<summary>
(2024). A formalization of the CHSH inequality and tsirelson’s
upper-bound in isabelle/HOL. <em>JAR</em>, <em>68</em>(1), 1–26. (<a
href="https://doi.org/10.1007/s10817-023-09689-9">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present a formalization of several fundamental notions and results from Quantum Information theory in the proof assistant Isabelle/HOL, including density matrices and projective measurements, along with the proof that the local hidden-variable hypothesis advocated by Einstein to model quantum mechanics cannot hold. The proof of the latter result is based on the so-called CHSH inequality, and it is the violation of this inequality that was experimentally evidenced by Aspect, who earned the Nobel Prize in 2022 for his work. We also formalize various results related to the violation of the CHSH inequality, such as Tsirelson’s bound, which quantifies the amount to which this inequality can be violated in a quantum setting.},
  archive      = {J_JAR},
  author       = {Echenim, Mnacho and Mhalla, Mehdi},
  doi          = {10.1007/s10817-023-09689-9},
  journal      = {Journal of Automated Reasoning},
  month        = {3},
  number       = {1},
  pages        = {1-26},
  shortjournal = {J. Auto. Reasoning},
  title        = {A formalization of the CHSH inequality and tsirelson’s upper-bound in Isabelle/HOL},
  volume       = {68},
  year         = {2024},
}
</textarea>
</details></li>
<li><details>
<summary>
(2024). Formally-verified round-off error analysis of runge–kutta
methods. <em>JAR</em>, <em>68</em>(1), 1–33. (<a
href="https://doi.org/10.1007/s10817-023-09686-y">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Numerical errors are insidious, difficult to predict and inherent in different levels of critical systems design. Indeed, numerical algorithms generally constitute approximations of an ideal mathematical model, which itself constitutes an approximation of a physical reality which has undergone multiple measurement errors. To this are added rounding errors due to computer arithmetic implementations, often neglected even if they can significantly distort the results obtained. This applies to Runge–Kutta methods used for the numerical integration of ordinary differential equations, that are ubiquitous to model fundamental laws of physics, chemistry, biology or economy. We provide a Coq formalization of the rounding error analysis of Runge–Kutta methods applied to linear systems and implemented in floating-point arithmetic. We propose a generic methodology to build a bound on the error accumulated over the iterations, taking gradual underflow into account. We then instantiate this methodology for two classic Runge–Kutta methods, namely Euler and RK2. The formalization of the results include the definition of matrix norms, the proof of rounding error bounds of matrix operations and the formalization of the generic results and their applications on examples. In order to support the proposed approach, we provide numerical experiments on examples coming from nuclear physics applications.},
  archive      = {J_JAR},
  author       = {Faissole, Florian},
  doi          = {10.1007/s10817-023-09686-y},
  journal      = {Journal of Automated Reasoning},
  month        = {3},
  number       = {1},
  pages        = {1-33},
  shortjournal = {J. Auto. Reasoning},
  title        = {Formally-verified round-off error analysis of Runge–Kutta methods},
  volume       = {68},
  year         = {2024},
}
</textarea>
</details></li>
<li><details>
<summary>
(2024). Non-termination in term rewriting and logic programming.
<em>JAR</em>, <em>68</em>(1), 1–24. (<a
href="https://doi.org/10.1007/s10817-023-09693-z">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we define two particular forms of non-termination, namely loops and binary chains, in an abstract framework that encompasses term rewriting and logic programming. The definition of loops relies on the notion of compatibility of binary relations. We also present a syntactic criterion for the detection of a special case of binary chains. Moreover, we describe our implementation NTI and compare its results at the Termination Competition 2023 with those of leading analyzers.},
  archive      = {J_JAR},
  author       = {Payet, Étienne},
  doi          = {10.1007/s10817-023-09693-z},
  journal      = {Journal of Automated Reasoning},
  month        = {3},
  number       = {1},
  pages        = {1-24},
  shortjournal = {J. Auto. Reasoning},
  title        = {Non-termination in term rewriting and logic programming},
  volume       = {68},
  year         = {2024},
}
</textarea>
</details></li>
</ul>

</body>
</html>
