<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>IJFCS_complex_beauty</title>
  <style>
    html {font-size: 22px;}
    body {margin: 0 auto; max-width: 76em;}
    #copyID {font-size: 18px;}
  </style>
  <script>
    function copy(element) {
      if (element.type == "button"){
      element.type="text";
      }
      element.style.color="black";
      element.style.backgroundColor="#C7EDCC";
      element.select();
      element.setSelectionRange(0, 99999);
      navigator.clipboard.writeText(element.value);
      window.getSelection().removeAllRanges();
      element.type="button";
    }
  </script>
</head>
<body>

<h2 id="ijfcs---51">IJFCS - 51</h2>
<ul>
<li><details>
<summary>
(2021). A pseudo-random generator whose output is a normal sequence.
<em>IJFCS</em>, <em>32</em>(8), 981‚Äì989. (<a
href="https://doi.org/10.1142/S0129054121500325">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Pseudo-random number generators (PRNGs) are widely used in computer simulation, cryptography, and many other fields. In this paper, we describe a PRNG class, which, firstly, has been successfully tested using the most powerful modern test batteries, and secondly, is proved to consist of generators that generate normal sequences. The latter property means that, for any generated sequence x 1 x 2 ‚Ä¶ and any binary word w , we have},
  archive      = {J_IJFCS},
  author       = {Boris Ryabko},
  doi          = {10.1142/S0129054121500325},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {8},
  pages        = {981-989},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {A pseudo-random generator whose output is a normal sequence},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). NP-hardness and approximation algorithms for iterative
pricing on social networks with externalities. <em>IJFCS</em>,
<em>32</em>(8), 957‚Äì979. (<a
href="https://doi.org/10.1142/S0129054121500313">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study how a monopolist seller should price an indivisible product iteratively to the consumers who are connected by a known link-weighted directed social network. For two consumers u and v , there is an arc directed from u to v if and only if v is a fashion leader of u . Assuming complete information about the network, the seller offers consumers a sequence of prices over time and the goal is to obtain the maximum revenue. We assume that the consumers buy the product as soon as the seller posts a price not greater than their valuations of the product. The product‚Äôs value for a consumer is determined by three factors: a fixed consumer specified intrinsic value and a variable positive (resp. negative) externality that is exerted from the consumer‚Äôs out(resp. in)-neighbours. The setting of positive externality is that the influence of fashion leaders on a consumer is the total weight of links from herself to her fashion leaders who have owned the product, and more fashion leaders of a consumer owning the product will increase the influence (external value) on the consumer. And the setting of negative externalities is that the product‚Äôs value of showing off for a consumer is the total weight of links from her followers who do not own the product to herself, and more followers of a consumer owning the product will decrease this external value for the consumer. We confirm that finding an optimal iterative pricing is NP-hard even for acyclic networks with maximum total degree 3 and with all intrinsic values zero. We design a greedy algorithm which achieves ( n ‚àí 1 ) -approximation for networks with all intrinsic values zero and show that the approximation ratio n ‚àí 1 is tight. Complementary to the hardness result, we design a ( 1 . 8 + ùúñ ) -approximation algorithm for Barab√°si‚ÄìAlbert networks.},
  archive      = {J_IJFCS},
  author       = {Chenli Shen and Wensong Lin},
  doi          = {10.1142/S0129054121500313},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {8},
  pages        = {957-979},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {NP-hardness and approximation algorithms for iterative pricing on social networks with externalities},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Unpaired many-to-many disjoint path cover of balanced
hypercubest. <em>IJFCS</em>, <em>32</em>(8), 943‚Äì956. (<a
href="https://doi.org/10.1142/S0129054121500301">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A many-to-many k -disjoint path cover ( k -DPC) of a graph G is a set of k vertex-disjoint paths joining k distinct pairs of source and sink in which each vertex of G is contained exactly once in a path. The balanced hypercube B H n , a variant of the hypercube, was introduced as a desired interconnection network topology. Let S = { s 1 , s 2 , ‚Ä¶ , s 2 n ‚àí 2 } and T = { t 1 , t 2 , ‚Ä¶ , t 2 n ‚àí 2 } be any two sets of vertices in different partite sets of B H n ( n ‚â• 2 ). Cheng et al. in [ Appl. Math. Comput. 242 (2014) 127‚Äì142] proved that there exists paired many-to-many 2-disjoint path cover of B H n when | S | = | T | = 2 . In this paper, we prove that there exists unpaired many-to-many ( 2 n ‚àí 2 ) -disjoint path cover of B H n ( n ‚â• 2 ) from S to T , which has improved some known results. The upper bound 2 n ‚àí 2 is best possible in terms of the number of disjoint paths in unpaired many-to-many k -DPC of B H n .},
  archive      = {J_IJFCS},
  author       = {Huazhong L√º and Tingzeng Wu},
  doi          = {10.1142/S0129054121500301},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {8},
  pages        = {943-956},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Unpaired many-to-many disjoint path cover of balanced hypercubest},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Extremal results on vertex and link residual closeness.
<em>IJFCS</em>, <em>32</em>(8), 921‚Äì941. (<a
href="https://doi.org/10.1142/S0129054121500295">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Robustness of the network topology is a key aspect in the design of computer networks. Vertex (Link, respectively) residual closeness is a new graph-theoretic concept defined as a measure of network robustness due to the failure of individual vertices (links, respectively). In this paper, we identify the trees and unicyclic graphs with the first a few smallest vertex residual closeness, and determine the graphs that minimize or maximize the vertex (link, respectively) residual closeness over some classes of graphs.},
  archive      = {J_IJFCS},
  author       = {Bo Zhou and Zhenan Li and Haiyan Guo},
  doi          = {10.1142/S0129054121500295},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {8},
  pages        = {921-941},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Extremal results on vertex and link residual closeness},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Two effective properties of œâ-rational functions.
<em>IJFCS</em>, <em>32</em>(7), 901‚Äì920. (<a
href="https://doi.org/10.1142/S0129054121500283">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We prove two new effective properties of rational functions over infinite words which are realized by finite state B√ºchi transducers. Firstly, for each such function F : Œ£ œâ ‚Üí Œì œâ , one can construct a deterministic B√ºchi automaton ùíú accepting a dense Œ† 2 0 -subset of Œ£ œâ such that the restriction of F to L ( ùíú ) is continuous. Secondly, we give a new proof of the decidability of the first Baire class for synchronous œâ -rational functions from which we get an extension of this result involving the notion of Wadge classes of regular œâ -languages.},
  archive      = {J_IJFCS},
  author       = {Olivier Finkel},
  doi          = {10.1142/S0129054121500283},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {7},
  pages        = {901-920},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Two effective properties of œâ-rational functions},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Alternate lucas cubes. <em>IJFCS</em>, <em>32</em>(7),
871‚Äì899. (<a href="https://doi.org/10.1142/S0129054121500271">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce alternate Lucas cubes, a new family of graphs designed as an alternative for the well known Lucas cubes. These interconnection networks are subgraphs of Fibonacci cubes and have a useful fundamental decomposition similar to the one for Fibonacci cubes. The vertices of alternate Lucas cubes are constructed from binary strings that are encodings of Lucas representation of integers. As well as ordinary hypercubes, Fibonacci cubes and Lucas cubes, alternate Lucas cubes have several interesting structural and enumerative properties. In this paper we study some of these properties. Specifically, we give the fundamental decomposition giving the recursive structure, determine the number of edges, number of vertices by weight, the distribution of the degrees; as well as the properties of induced hypercubes, q -cube polynomials and maximal hypercube polynomials. We also obtain the irregularity polynomials of this family of graphs, determine the conditions for Hamiltonicity, and calculate metric properties such as the radius, diameter, and the center.},
  archive      = {J_IJFCS},
  author       = {√ñmer Eƒüecioƒülu and Elif Saygƒ± and Z√ºlf√ºkar Saygƒ±},
  doi          = {10.1142/S0129054121500271},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {7},
  pages        = {871-899},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Alternate lucas cubes},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the construction of multiply constant-weight codes.
<em>IJFCS</em>, <em>32</em>(7), 861‚Äì870. (<a
href="https://doi.org/10.1142/S012905412150026X">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Multiply constant-weight codes (MCWCs) were introduced recently to improve the reliability of certain physically unclonable function response. In this paper, two methods of constructing MCWCs are presented following the concatenation methodology. In other words, MCWCs are constructed by concatenating approximate outer codes and inner codes. Besides, several classes of optimal MCWCs are derived from these methods. In the first method, the outer codes are q -ary codes and the inner codes are constant-weight codes over G F ( 2 ) . Furthermore, if the outer code achieves the Plotkin bound and the inner code achieves Johnson bound, then the resulting MCWC is optimal. In the second method, the outer codes are q -ary codes and the inner codes are MCWCs. Furthermore, if the outer code achieves the Plotkin bound and the inner code achieves the Johnson bound, then the resulting MCWC is optimal.},
  archive      = {J_IJFCS},
  author       = {Jiejing Wen and Fang-Wei Fu},
  doi          = {10.1142/S012905412150026X},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {7},
  pages        = {861-870},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {On the construction of multiply constant-weight codes},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The (n,k)-modified-bubble-sort graph: A generalized
modified-bubble-sort graph. <em>IJFCS</em>, <em>32</em>(7), 849‚Äì860. (<a
href="https://doi.org/10.1142/S0129054121500258">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we present a new interconnection topology, called the ( n , k ) -modified-bubble-sort graph , which is a generalization of the modified-bubble-sort graph. Additionally, we show many of its properties, such as its hierarchical structure, vertex transitivity, connectivity, edge-connectivity, super connectivity and super edge-connectivity. The ( n , k ) -modified-bubble-sort graph presents more flexibility than the modified-bubble-sort graph in terms of its major design properties.},
  archive      = {J_IJFCS},
  author       = {Mengyue Cao and Tongtong Ding and Min Xu},
  doi          = {10.1142/S0129054121500258},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {7},
  pages        = {849-860},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {The (n,k)-modified-bubble-sort graph: A generalized modified-bubble-sort graph},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Error-free affine, unitary, and probabilistic OBDDs.
<em>IJFCS</em>, <em>32</em>(7), 827‚Äì847. (<a
href="https://doi.org/10.1142/S0129054121500246">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce the affine OBDD model and show that zero-error affine OBDDs can be exponentially narrower than bounded-error unitary and probabilistic OBDDs on certain problems. Moreover, we show that Las-Vegas unitary and probabilistic OBDDs can be quadratically narrower than deterministic OBDDs. We also obtain the same results for the automata counterparts of these models.},
  archive      = {J_IJFCS},
  author       = {Rishat Ibrahimov and Kamil Khadiev and Kri≈°jƒÅnis Pr≈´sis and Abuzer Yakaryƒ±lmaz},
  doi          = {10.1142/S0129054121500246},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {7},
  pages        = {827-847},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Error-free affine, unitary, and probabilistic OBDDs},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Space complexity of stack automata models. <em>IJFCS</em>,
<em>32</em>(6), 801‚Äì823. (<a
href="https://doi.org/10.1142/S0129054121420090">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper examines several measures of space complexity of variants of stack automata: non-erasing stack automata and checking stack automata. These measures capture the minimum stack size required to accept every word in the language of the automaton (weak measure), the maximum stack size used in any accepting computation on any accepted word (accept measure), and the maximum stack size used in any computation (strong measure). We give a detailed characterization of the accept and strong space complexity measures for checking stack automata. Exactly one of three cases can occur: the complexity is either bounded by a constant, behaves like a linear function, or it can not be bounded by any function of the length of the input word (and it is decidable which case occurs). However, this result does not hold for non-erasing stack automata; we provide an example where the space complexity grows proportionally to the square root of the length of the input. Furthermore, we study the complexity bounds of machines which accept a given language, and decidability of space complexity properties.},
  archive      = {J_IJFCS},
  author       = {Oscar H. Ibarra and Jozef Jir√°sek, Jr. and Ian McQuillan and Luca Prigioniero},
  doi          = {10.1142/S0129054121420090},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {6},
  pages        = {801-823},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Space complexity of stack automata models},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Normalish amenable subgroups of the r. Thompson groups.
<em>IJFCS</em>, <em>32</em>(6), 785‚Äì800. (<a
href="https://doi.org/10.1142/S0129054121420089">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Results in C ‚àó algebras, of Matte Bon and Le Boudec, and of Haagerup and Olesen, apply to the R. Thompson groups F ‚â§ T ‚â§ V . These results together show that F is non-amenable if and only if T has a simple reduced C ‚àó -algebra. In further investigations into the structure of C ‚àó -algebras, Breuillard, Kalantar, Kennedy, and Ozawa introduce the notion of a normalish subgroup of a group G . They show that if a group G admits no non-trivial finite normal subgroups and no normalish amenable subgroups then it has a simple reduced C ‚àó -algebra. Our chief result concerns the R. Thompson groups F &lt; T &lt; V ; we show that there is an elementary amenable group E &lt; F [where here, E ‚âÖ ‚Ä¶ ) ‚âÄ ‚Ñ§ ) ‚âÄ ‚Ñ§ ) ‚âÄ ‚Ñ§ ] with E normalish in V . The proof given uses a natural partial action of the group V on a regular language determined by a synchronising automaton in order to verify a certain stability condition: once again highlighting the existence of interesting intersections of the theory of V with various forms of formal language theory.},
  archive      = {J_IJFCS},
  author       = {Collin Bleak},
  doi          = {10.1142/S0129054121420089},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {6},
  pages        = {785-800},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Normalish amenable subgroups of the r. thompson groups},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the balancedness of tree-to-word transducers.
<em>IJFCS</em>, <em>32</em>(6), 761‚Äì783. (<a
href="https://doi.org/10.1142/S0129054121420077">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A language over an alphabet B = A ‚à™ A ¬Ø of opening ( A ) and closing ( A ¬Ø ) brackets, is balanced if it is a subset of the Dyck language ùîª B over B , and it is well-formed if all words are prefixes of words in ùîª B . We show that well-formedness of a context-free language is decidable in polynomial time, and that the longest common reduced suffix can be computed in polynomial time. With this at a hand we decide for the class 2- TW of non-linear tree transducers with output alphabet B whether or not the output language is balanced.},
  archive      = {J_IJFCS},
  author       = {Raphaela L√∂bel and Michael Luttenberger and Helmut Seidl},
  doi          = {10.1142/S0129054121420077},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {6},
  pages        = {761-783},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {On the balancedness of tree-to-word transducers},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Simplifications of uniform expressions specified by systems.
<em>IJFCS</em>, <em>32</em>(6), 733‚Äì760. (<a
href="https://doi.org/10.1142/S0129054121420065">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this article, we study the impact of applying simple reduction rules to random syntactic formulas encoded as trees. We assume that there is an operator that has an absorbing pattern and prove that if we use this property to simplify a uniform random expression with n nodes, then the expected size of the result is bounded by a constant. The same holds for higher moments, establishing the lack of expressivity of uniform random expressions. Our framework is quite general as we consider expressions defined by systems of combinatorial equations. For our proofs, we rely on Drmota‚Äôs multidimensional theorem for systems of generating functions.},
  archive      = {J_IJFCS},
  author       = {Florent Koechlin and Cyril Nicaud and Pablo Rotondo},
  doi          = {10.1142/S0129054121420065},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {6},
  pages        = {733-760},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Simplifications of uniform expressions specified by systems},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Sublinear-time language recognition and decision by
one-dimensional cellular automata. <em>IJFCS</em>, <em>32</em>(6),
713‚Äì731. (<a href="https://doi.org/10.1142/S0129054121420053">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {After an apparent hiatus of roughly 30 years, we revisit a seemingly neglected subject in the theory of (one-dimensional) cellular automata: sublinear-time computation. The model considered is that of ACAs, which are language acceptors whose acceptance condition depends on the states of all cells in the automaton. We prove a time hierarchy theorem for sublinear-time ACA classes, analyze their intersection with the regular languages, and, finally, establish strict inclusions in the parallel computation classes S C and (uniform) A C . As an addendum, we introduce and investigate the concept of a decider ACA (DACA) as a candidate for a decider counterpart to (acceptor) ACAs. We show the class of languages decidable in constant time by DACAs equals the locally testable languages, and we also determine Œ© ( n ) as the (tight) time complexity threshold for DACAs up to which no advantage compared to constant time is possible.},
  archive      = {J_IJFCS},
  author       = {Augusto Modanese},
  doi          = {10.1142/S0129054121420053},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {6},
  pages        = {713-731},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Sublinear-time language recognition and decision by one-dimensional cellular automata},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Descriptional complexity of semi-simple splicing systems.
<em>IJFCS</em>, <em>32</em>(6), 685‚Äì711. (<a
href="https://doi.org/10.1142/S0129054121420041">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Splicing systems are generative mechanisms introduced by Tom Head in 1987 to model the biological process of DNA recombination. The computational engine of a splicing system is the ‚Äúsplicing operation‚Äù, a cut-and-paste binary string operation defined by a set of ‚Äúsplicing rules‚Äù, quadruples r = ( u 1 , u 2 ; u 3 , u 4 ) where u 1 , u 2 , u 3 , u 4 are words over an alphabet Œ£ . For two strings x 1 u 1 u 2 y 1 and x 2 u 3 u 4 y 2 , applying the splicing rule r produces the string x 1 u 1 u 4 y 2 . In this paper we focus on a particular type of splicing systems, called ( i , j ) semi-simple splicing systems, i = 1 , 2 and j = 3 , 4 , wherein all splicing rules r have the property that the two strings in positions i and j in r are singleton letters, while the other two strings are empty. The language generated by such a system consists of the set of words that are obtained starting from an initial set called ‚Äúaxiom set‚Äù, by iteratively applying the splicing rules to strings in the axiom set as well as to intermediately produced strings. We consider semi-simple splicing systems where the axiom set is a regular language, and investigate the descriptional complexity of such systems in terms of the size of the minimal deterministic finite automata that recognize the languages they generate.},
  archive      = {J_IJFCS},
  author       = {Lila Kari and Timothy Ng},
  doi          = {10.1142/S0129054121420041},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {6},
  pages        = {685-711},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Descriptional complexity of semi-simple splicing systems},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the interplay of direct topological factorizations and
cellular automata dynamics on beta-shifts. <em>IJFCS</em>,
<em>32</em>(6), 663‚Äì683. (<a
href="https://doi.org/10.1142/S012905412142003X">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider the range of possible dynamics of cellular automata (CA) on two-sided beta-shifts S Œ≤ and its relation to direct topological factorizations. We show that any reversible CA F : S Œ≤ ‚Üí S Œ≤ has an almost equicontinuous direction whenever S Œ≤ is not sofic. This has the corollary that non-sofic beta-shifts are topologically direct prime, i.e. they are not conjugate to direct topological factorizations X √ó Y of two nontrivial subshifts X and Y . We also give a simple criterion to determine whether S n Œ≥ is conjugate to S n √ó S Œ≥ for a given integer n ‚â• 1 and a given real Œ≥ &gt; 1 when S Œ≥ is a subshift of finite type. When S Œ≥ is strictly sofic, we show that such a conjugacy is not possible at least when Œ≥ is a quadratic Pisot number of degree 2 . We conclude by using direct factorizations to give a new proof for the classification of reversible multiplication automata on beta-shifts with integral base and ask whether nontrivial multiplication automata exist when the base is not an integer.},
  archive      = {J_IJFCS},
  author       = {Johan Kopra},
  doi          = {10.1142/S012905412142003X},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {6},
  pages        = {663-683},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {On the interplay of direct topological factorizations and cellular automata dynamics on beta-shifts},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Recognizing lexicographically smallest words and computing
successors in regular languages. <em>IJFCS</em>, <em>32</em>(6),
641‚Äì662. (<a href="https://doi.org/10.1142/S0129054121420028">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {For a formal language L , the problem of language enumeration asks to compute the length-lexicographically smallest word in L larger than a given input w ‚àà Œ£ ‚àó (henceforth called the L -successor of w ). We investigate this problem for regular languages from a computational complexity and state complexity perspective. We first show that if L is recognized by a DFA with n states, then 2 Œò ( n log n ) states are (in general) necessary and sufficient for an unambiguous finite-state transducer to compute L -successors. As a byproduct, we obtain that if L is recognized by a DFA with n states, then 2 Œò ( n log n ) states are sufficient for a DFA to recognize the subset S ( L ) of L composed of its lexicographically smallest words. We give a matching lower bound that holds even if S ( L ) is represented as an NFA. It has been known that L -successors can be computed in polynomial time, even if the regular language is given as part of the input (assuming a suitable representation of the language, such as a DFA). In this paper, we refine this result in multiple directions. We show that if the regular language is given as part of the input and encoded as a DFA, the problem is in N L . If the regular language L is fixed, we prove that the enumeration problem of the language is reducible to deciding membership to the Myhill-Nerode equivalence classes of L under D L O G T I M E -uniform A C 0 reductions. In particular, this implies that fixed star-free languages can be enumerated in A C 0 , arbitrary fixed regular languages can be enumerated in N C 1 and that there exist regular languages for which the problem is N C 1 -complete.},
  archive      = {J_IJFCS},
  author       = {Lukas Fleischer and Jeffrey Shallit},
  doi          = {10.1142/S0129054121420028},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {6},
  pages        = {641-662},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Recognizing lexicographically smallest words and computing successors in regular languages},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Reconstructing words from right-bounded-block words.
<em>IJFCS</em>, <em>32</em>(6), 619‚Äì640. (<a
href="https://doi.org/10.1142/S0129054121420016">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A reconstruction problem of words from scattered factors asks for the minimal information, like multisets of scattered factors of a given length or the number of occurrences of scattered factors from a given set, necessary to uniquely determine a word. We show that a word w ‚àà { a , b } ‚àó can be reconstructed from the number of occurrences of at most min ( | w | a , | w | b ) + 1 scattered factors of the form a i b , where | w | a is the number of occurrences of the letter a in w . Moreover, we generalise the result to alphabets of the form { 1 , ‚Ä¶ , q } by showing that at most ‚àë i = 1 q ‚àí 1 | w | i ( q ‚àí i + 1 ) scattered factors suffices to reconstruct w . Both results improve on the upper bounds known so far. Complexity time bounds on reconstruction algorithms are also considered here.},
  archive      = {J_IJFCS},
  author       = {Pamela Fleischmann and Marie Lejeune and Florin Manea and Dirk Nowotka and Michel Rigo},
  doi          = {10.1142/S0129054121420016},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {6},
  pages        = {619-640},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Reconstructing words from right-bounded-block words},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Preface. <em>IJFCS</em>, <em>32</em>(6), 615‚Äì617. (<a
href="https://doi.org/10.1142/S0129054121020020">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_IJFCS},
  author       = {Nata≈°a Jonoska and Dmytro Savchuk},
  doi          = {10.1142/S0129054121020020},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {6},
  pages        = {615-617},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Preface},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). An inequality for the number of periods in a word.
<em>IJFCS</em>, <em>32</em>(5), 597‚Äì614. (<a
href="https://doi.org/10.1142/S0129054121410094">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We prove an inequality for the number of periods in a word x in terms of the length of x and its initial critical exponent. Next, we characterize all periods of the length- n prefix of a characteristic Sturmian word in terms of the lazy Ostrowski representation of n , and use this result to show that our inequality is tight for infinitely many words x . We propose two related measures of periodicity for infinite words. Finally, we also consider special cases where x is overlap-free or squarefree.},
  archive      = {J_IJFCS},
  author       = {Daniel Gabric and Narad Rampersad and Jeffrey Shallit},
  doi          = {10.1142/S0129054121410094},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {5},
  pages        = {597-614},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {An inequality for the number of periods in a word},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Linear bounds on the size of conformations in greedy
deterministic oritatami. <em>IJFCS</em>, <em>32</em>(5), 575‚Äì596. (<a
href="https://doi.org/10.1142/S0129054121410082">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Oritatami is a computational model of RNA cotranscriptional folding, in which an RNA transcript is folding upon itself while being synthesized from its template DNA. This model is known to be Turing universal. Under the restriction on its parameters delay and arity both being 1, however, any deterministically foldable conformation is known to be at most ten times as large as its initial conformation (seed), and hence, the model becomes weaker. In this paper, we shall improve the size upper bound from 1 0 n down to 4 n + 5 and also provide a system that can fold into a conformation of size 3 n ‚àí 2 0 . These tighter bounds result from a novel graph representation of deterministic oritatami folding pathways. We shall also study the case in which a transcript is trapped in a region closed by a seed and show that under this confinement, the upper bound is further improved to 1 1 3 n ‚àí 5 .},
  archive      = {J_IJFCS},
  author       = {Szil√°rd Zsolt Fazekas and Hwee Kim and Ryuichi Matsuoka and Reoto Morita and Shinnosuke Seki},
  doi          = {10.1142/S0129054121410082},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {5},
  pages        = {575-596},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Linear bounds on the size of conformations in greedy deterministic oritatami},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Union-freeness revisited ‚Äî between deterministic and
nondeterministic union-free languages. <em>IJFCS</em>, <em>32</em>(5),
551‚Äì573. (<a href="https://doi.org/10.1142/S0129054121410070">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Union-free expressions are regular expressions without using the union operation. Consequently, (nondeterministic) union-free languages are described by regular expressions using only concatenation and Kleene star. The language class is also characterised by a special class of finite automata: 1CFPAs have exactly one cycle-free accepting path from each of their states. Obviously such an automaton has exactly one accepting state. The deterministic counterpart of such class of automata defines the deterministic union-free (d-union-free, for short) languages. In this paper Œª -free nondeterministic variants of 1CFPAs are used to define n-union-free languages. The defined language class is shown to be properly between the classes of (nondeterministic) union-free and d-union-free languages (in case of at least binary alphabet). In case of unary alphabet the class of n-union-free languages coincides with the class of union-free languages. Some properties of the new subregular class of languages are discussed, e.g., closure properties. On the other hand, a regular expression is in union normal form if it is a finite union of union-free expressions. It is well known that every regular expression can be written in union normal form, i.e., all regular languages can be described as finite unions of (nondeterministic) union-free languages. It is also known that the same fact does not hold for deterministic union-free languages, that is, there are regular languages that cannot be written as finite unions of d-union-free languages. As an important result here we show that every regular language can be defined by a finite union of n-union-free languages. This fact also allows to define n-union-complexity of regular languages.},
  archive      = {J_IJFCS},
  author       = {Benedek Nagy},
  doi          = {10.1142/S0129054121410070},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {5},
  pages        = {551-573},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Union-freeness revisited ‚Äî between deterministic and nondeterministic union-free languages},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Left is better than right for reducing nondeterminism of
NFAs. <em>IJFCS</em>, <em>32</em>(5), 531‚Äì550. (<a
href="https://doi.org/10.1142/S0129054121410069">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the NFA reductions by invariant equivalences and preorders. It is well-known that the NFA minimization problem is PSPACE-complete. Therefore, there have been many approaches to reduce the size of NFAs in low polynomial time by computing invariant equivalence or preorder relation and merging the states within same equivalence class. Here we consider the nondeterminism reduction of NFAs by invariant equivalences and preorders. We, in particular, show that computing equivalence and preorder relation from the left is more useful than the right for reducing the degree of nondeterminism in NFAs. We also present experimental evidence for showing that NFA reduction from the left achieves the better reduction of nondeterminism than reduction from the right.},
  archive      = {J_IJFCS},
  author       = {Sang-Ki Ko and Yo-Sub Han},
  doi          = {10.1142/S0129054121410069},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {5},
  pages        = {531-550},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Left is better than right for reducing nondeterminism of NFAs},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Generalizations of code languages with marginal errors.
<em>IJFCS</em>, <em>32</em>(5), 509‚Äì529. (<a
href="https://doi.org/10.1142/S0129054121410057">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The k -prefix-free, k -suffix-free and k -infix-free languages generalize the prefix-free, suffix-free and infix-free languages by allowing marginal errors. For example, a string x in a k -prefix-free language L can be a prefix of up to k different strings in L . We also define finitely prefix-free languages in which a string x can be a prefix of finitely many strings. We present efficient algorithms that determine whether or not a given regular language is k -prefix-free, k -suffix-free or k -infix-free, and analyze the time complexity of the algorithms. We establish undecidability results for deciding these properties for (linear) context-free languages.},
  archive      = {J_IJFCS},
  author       = {Sang-Ki Ko and Yo-Sub Han and Kai Salomaa},
  doi          = {10.1142/S0129054121410057},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {5},
  pages        = {509-529},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Generalizations of code languages with marginal errors},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Generalizations of checking stack automata:
Characterizations and hierarchies. <em>IJFCS</em>, <em>32</em>(5),
481‚Äì508. (<a href="https://doi.org/10.1142/S0129054121410045">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We examine different generalizations of checking stack automata by allowing multiple input heads and multiple stacks, and characterize their computing power in terms of two-way multi-head finite automata and space-bounded Turing machines. For various models, we obtain hierarchies in terms of their computing power. Our characterizations and hierarchies expand or tighten some previously known results. We also discuss some decidability questions and the space/time complexity of the models.},
  archive      = {J_IJFCS},
  author       = {Oscar H. Ibarra and Ian McQuillan},
  doi          = {10.1142/S0129054121410045},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {5},
  pages        = {481-508},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Generalizations of checking stack automata: Characterizations and hierarchies},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Zero-avoiding transducers, length separable relations, and
the rational asymmetric partition problem. <em>IJFCS</em>,
<em>32</em>(5), 455‚Äì480. (<a
href="https://doi.org/10.1142/S0129054121410033">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider the problem of partitioning effectively a given irreflexive (and possibly symmetric) rational relation R into two asymmetric rational relations. This problem is motivated by a recent method of embedding an R -independent language into one that is maximal R -independent, where the method requires to use an asymmetric partition of R . We solve the problem when R is length-separable, which means that the following two subsets of R are rational: the subset of word pairs ( u , v ) where | u | ‚â§ | v | ; and the subset of word pairs ( u , v ) where | u | ‚â• | v | . This property is satisfied by all recognizable, all left synchronous, and all right synchronous relations. We leave it as an open problem when R is not length-separable. We also define zero-avoiding transducers for length-separable relations, which makes our partitioning solution constructive.},
  archive      = {J_IJFCS},
  author       = {Stavros Konstantinidis and Mitja Mastnak and Juraj ≈†ebej},
  doi          = {10.1142/S0129054121410033},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {5},
  pages        = {455-480},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Zero-avoiding transducers, length separable relations, and the rational asymmetric partition problem},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Further remarks on the operational nonterminal complexity.
<em>IJFCS</em>, <em>32</em>(5), 439‚Äì453. (<a
href="https://doi.org/10.1142/S0129054121410021">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {For a regular language L , let Var ( L ) be the minimal number of nonterminals necessary to generate L by right linear grammars. Moreover, for natural numbers k 1 , k 2 , ‚Ä¶ , k n and an n -ary regularity preserving operation f , let the range g f Var ( k 1 , k 2 , ‚Ä¶ , k n ) be the set of all numbers k such that there are regular languages L 1 , L 2 , ‚Ä¶ , L n with Var ( L i ) = k i for 1 ‚â§ i ‚â§ n and Var ( f ( L 1 , L 2 , ‚Ä¶ , L n ) ) = k . We show that, for the circular shift operation Circ , g Circ Var ( n ) is infinite for all n , and we completely determine the set g Circ Var ( 2 ) . Moreover, we give a precise range for the left right quotient and a partial result for the left quotient. Furthermore, we add some values to the range for the operation intersection which improves the result of [ 2 ].},
  archive      = {J_IJFCS},
  author       = {J√ºrgen Dassow},
  doi          = {10.1142/S0129054121410021},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {5},
  pages        = {439-453},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Further remarks on the operational nonterminal complexity},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Random regular expression over huge alphabets.
<em>IJFCS</em>, <em>32</em>(5), 419‚Äì438. (<a
href="https://doi.org/10.1142/S012905412141001X">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this article, we study some properties of random regular expressions of size n , when the cardinality of the alphabet also depends on n . For this, we revisit and improve the classical Transfer Theorem from the field of analytic combinatorics. This provides precise estimations for the number of regular expressions, the probability of recognizing the empty word and the expected number of Kleene stars in a random expression. For all these statistics, we show that there is a threshold when the size of the alphabet approaches n 2 , at which point the leading term in the asymptotics starts oscillating.},
  archive      = {J_IJFCS},
  author       = {Cyril Nicaud and Pablo Rotondo},
  doi          = {10.1142/S012905412141001X},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {5},
  pages        = {419-438},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Random regular expression over huge alphabets},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Preface. <em>IJFCS</em>, <em>32</em>(5), 417‚Äì418. (<a
href="https://doi.org/10.1142/S0129054121020019">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_IJFCS},
  author       = {Markus Holzer and Martin Kutrib},
  doi          = {10.1142/S0129054121020019},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {5},
  pages        = {417-418},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Preface},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The r-extra diagnosability of hyper petersen graphs.
<em>IJFCS</em>, <em>32</em>(4), 405‚Äì416. (<a
href="https://doi.org/10.1142/S0129054121500234">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The diagnosability of a multiprocessor system or an interconnection network plays an important role in measuring the fault tolerance of the network. In 2016, Zhang et al. proposed a new measure for fault diagnosis of the system, namely, the r -extra diagnosability, which restrains that every fault-free component has at least ( r + 1 ) fault-free nodes. As a famous topology structure of interconnection networks, the hyper Petersen graph H P n has many good properties. It is difficult to prove the r -extra diagnosability of an interconnection network. In this paper, we show that the r -extra diagnosability of H P n is ‚àí 1 2 r 2 + ( n ‚àí 1 2 ) r + n for n ‚â• 4 and 0 ‚â§ r ‚â§ n ‚àí 3 in the PMC model and for n ‚â• 7 and 0 ‚â§ r ‚â§ 1 2 ( n ‚àí 2 ) in the MM ‚àó model.},
  archive      = {J_IJFCS},
  author       = {Shiying Wang},
  doi          = {10.1142/S0129054121500234},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {4},
  pages        = {405-416},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {The r-extra diagnosability of hyper petersen graphs},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A lightweight key agreement protocol with authentication
capability. <em>IJFCS</em>, <em>32</em>(4), 389‚Äì404. (<a
href="https://doi.org/10.1142/S0129054121500222">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Computationally lightweight and unconditionally secure key agreement protocols are very useful for secure communication in public networks. Recently, Guan et al. proposed a key agreement protocol whose security is based on the unpredictability of channel noise rather than computationally hard problems. These protocols are efficient, computationally lightweight, and unconditionally secure. However, authentication was not integrated into these protocols. In this article, we propose a new protocol with authentication capability that enables two nodes in the network to establish a secret session key for secure communication. It is more efficient, and it also preserves the lightweight and unconditional secure features of the key agreement protocols proposed by Guan et al. Therefore, it is more suitable for devices with limited computing power, such as sensors in Internet of Things (IoT).},
  archive      = {J_IJFCS},
  author       = {Albert Guan},
  doi          = {10.1142/S0129054121500222},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {4},
  pages        = {389-404},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {A lightweight key agreement protocol with authentication capability},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Search on a line by byzantine robots. <em>IJFCS</em>,
<em>32</em>(4), 369‚Äì387. (<a
href="https://doi.org/10.1142/S0129054121500209">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider the problem of fault-tolerant parallel search on an infinite line by n robots. Starting from the origin, the robots are required to find a target at an unknown location. The robots can move with maximum speed 1 and can communicate wirelessly among themselves. However, among the n robots, there are f robots that exhibit byzantine faults . A faulty robot can fail to report the target even after reaching it, or it can make malicious claims about having found the target when in fact it has not. Given the presence of such faulty robots, the search for the target can only be concluded when the non-faulty robots have sufficient evidence that the target has been found. We aim to design algorithms that minimize the value of S d ( n , f ) , the time to find a target at a (unknown) distance d from the origin by n robots among which f are faulty. We give several different algorithms whose running time depends on the ratio f / n , the density of faulty robots, and also prove lower bounds. Our algorithms are optimal for some densities of faulty robots.},
  archive      = {J_IJFCS},
  author       = {Jurek Czyzowicz and Konstantinos Georgiou and Evangelos Kranakis and Danny Krizanc and Lata Narayanan and Jaroslav Opatrny and Sunil Shende},
  doi          = {10.1142/S0129054121500209},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {4},
  pages        = {369-387},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Search on a line by byzantine robots},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the commutative equivalence of algebraic formal series
and languages. <em>IJFCS</em>, <em>32</em>(4), 341‚Äì367. (<a
href="https://doi.org/10.1142/S0129054121500192">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The problem of the commutative equivalence of context-free and regular languages is studied. Conditions ensuring that a context-free language of exponential growth is commutatively equivalent with a regular language are investigated.},
  archive      = {J_IJFCS},
  author       = {Arturo Carpi and Flavio D‚ÄôAlessandro},
  doi          = {10.1142/S0129054121500192},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {4},
  pages        = {341-367},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {On the commutative equivalence of algebraic formal series and languages},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Algorithmic aspects of outer-independent total roman
domination in graphs. <em>IJFCS</em>, <em>32</em>(3), 331‚Äì339. (<a
href="https://doi.org/10.1142/S0129054121500180">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {For a simple, undirected graph G , a function h : V ( G ) ‚Üí { 0 , 1 , 2 } which satisfies the following conditions is called an outer-independent total Roman dominating function (OITRDF) of G with weight h ( V ) = ‚àë v ‚àà V h ( v ) . (C1) For all q ‚àà V with h ( q ) = 0 there exists a vertex r such that q r ‚àà E and h ( r ) = 2 , (C2) The induced subgraph with vertex set { p : h ( p ) ‚â• 1 } has no isolated vertices and (C3) The induced subgraph with vertex set { p : h ( p ) = 0 } is independent. For a graph G , the smallest possible weight of an OITRDF of G which is denoted by Œ≥ o i t R ( G ) , is known as the outer-independent total Roman domination number of G . The problem of determining Œ≥ o i t R ( G ) of a graph G is called minimum outer-independent total Roman domination problem (MOITRDP). In this article, we show that the problem of deciding if G has an OITRDF of weight at most l for bipartite graphs and split graphs, a subclass of chordal graphs is NP-complete. We also show that MOITRDP is linear time solvable for connected threshold graphs and bounded treewidth graphs. Finally, we show that the domination and outer-independent total Roman domination problems are not equivalent in computational complexity aspects.},
  archive      = {J_IJFCS},
  author       = {Amit Sharma and P. Venkata Subba Reddy},
  doi          = {10.1142/S0129054121500180},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {3},
  pages        = {331-339},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Algorithmic aspects of outer-independent total roman domination in graphs},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Subgraph-based strong menger connectivity of hypercube and
exchanged hypercube. <em>IJFCS</em>, <em>32</em>(3), 305‚Äì330. (<a
href="https://doi.org/10.1142/S0129054121500179">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Large scale multiprocessor systems or multicomputer systems, taking interconnection networks as underlying topologies, have been widely used in the big data era. Fault tolerance is becoming an essential attribute in multiprocessor systems as the number of processors is getting larger. A connected graph G is called strong Menger (edge) connected if, for any two distinct vertices u and v , there are min { d G ( u ) , d G ( v ) } vertex (edge)-disjoint paths between them. Exchanged hypercube E H ( s , t ) , as a variant of hypercube Q n , remains lots of preferable fault tolerant properties of hypercube. In this paper, we show that Q n ‚àí Q k ( 1 ‚â§ k ‚â§ n ‚àí 1 ) and E H ( s , t ) ‚àí Q k ( 2 ‚â§ k ‚â§ min { s , t } ) are strong Menger (edge) connected, respectively. Moreover, as a by-product, for dual cube D n = E H ( n ‚àí 1 , n ‚àí 1 ) , one popular generalization of hypercube, D n ‚àí Q k is also showed to be strong Menger (edge) connected, where 1 ‚â§ k ‚â§ n ‚àí 1 , n ‚â• 3 .},
  archive      = {J_IJFCS},
  author       = {Yihong Wang and Cheng-Kuan Lin and Shuming Zhou and Tao Tian},
  doi          = {10.1142/S0129054121500179},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {3},
  pages        = {305-330},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Subgraph-based strong menger connectivity of hypercube and exchanged hypercube},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). (N ‚àí 2)-fault-tolerant edge-pancyclicity of crossed cubes
CQn. <em>IJFCS</em>, <em>32</em>(3), 289‚Äì304. (<a
href="https://doi.org/10.1142/S0129054121500167">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {As one of the most fundamental networks for parallel and distributed computation, cycle is suitable for developing simple algorithms with low communication cost. A graph G is called k -fault-tolerant edge-pancyclic if after deleting any faulty set F of k vertices and/or edges from G , every correct edge in the resulting graph lies in a cycle of every length from g to | V ( G ‚àí F ) | , inclusively, where g is the girth of G , the length of a shortest cycle in G . The n -dimensional crossed cube C Q n is an important variant of the hypercube Q n , which possesses some properties superior to the hypercube. This paper investigates the fault-tolerant edge-pancyclicity of C Q n , and shows that if C Q n ( n ‚â• 5 ) contains at most n ‚àí 2 faulty vertices and/or edges then, for any fault-free edge u v and every length ‚Ñì from 6 to | V ( C Q n ‚àí F ) | except ‚Ñì = 7 , there is a fault-free cycle of length ‚Ñì containing the edge u v . The result is optimal in some senses.},
  archive      = {J_IJFCS},
  author       = {Xirong Xu and Huifeng Zhang and Ziming Wang and Qiang Zhang and Peng Zhang},
  doi          = {10.1142/S0129054121500167},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {3},
  pages        = {289-304},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {(n ‚àí 2)-fault-tolerant edge-pancyclicity of crossed cubes CQn},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Agglomeration-based node importance analysis in wheel-type
networks. <em>IJFCS</em>, <em>32</em>(3), 269‚Äì288. (<a
href="https://doi.org/10.1142/S0129054121500210">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Evaluating the importance of nodes for complex networks is an important part of invulnerability research. In this paper, node importance analysis is conducted in wheel-related networks by a method of evaluating node importance by node contraction based on network agglomeration in communication networks. Both degrees and positions of nodes are considered with this method. This method was also proved to be feasible and effective measure to identify influential nodes in a network.},
  archive      = {J_IJFCS},
  author       = {Zeynep Nihan Berberler and Halil ƒ∞brahim Yildirim and Tolga ƒ∞lt√ºzer and ƒ∞zzet Tun√ß},
  doi          = {10.1142/S0129054121500210},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {3},
  pages        = {269-288},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Agglomeration-based node importance analysis in wheel-type networks},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Infinite families of 2-designs from a class of linear codes
related to dembowski-ostrom functions. <em>IJFCS</em>, <em>32</em>(3),
253‚Äì267. (<a href="https://doi.org/10.1142/S0129054121500143">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Due to their important applications to coding theory, cryptography, communications and statistics, combinatorial t -designs have attracted lots of research interest for decades. The interplay between coding theory and t -designs started many years ago. It is generally known that t -designs can be used to derive linear codes over any finite field, and that the supports of all codewords with a fixed weight in a code also may hold a t -design. In this paper, we first construct a class of linear codes from cyclic codes related to Dembowski-Ostrom functions. By using exponential sums, we then determine the weight distribution of the linear codes. Finally, we obtain infinite families of 2 -designs from the supports of all codewords with a fixed weight in these codes. Furthermore, the parameters of 2 -designs are calculated explicitly.},
  archive      = {J_IJFCS},
  author       = {Rong Wang and Xiaoni Du and Cuiling Fan and Zhihua Niu},
  doi          = {10.1142/S0129054121500143},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {3},
  pages        = {253-267},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Infinite families of 2-designs from a class of linear codes related to dembowski-ostrom functions},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). An exchanged 3-ary n-cube interconnection network for
parallel computation. <em>IJFCS</em>, <em>32</em>(3), 235‚Äì252. (<a
href="https://doi.org/10.1142/S0129054121500131">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The interconnetion network plays an important role in a parallel system. To avoid the edge number of the interconnect network scaling rapidly with the increase of dimension and achieve a good balance of hardware costs and properties, this paper presents a new interconnection network called exchanged 3 -ary n -cube ( E 3 C ). Compared with the 3 -ary n -cube structures, E 3 C shows better performance in terms of many metrics such as small degree and fewer links. In this paper, we first introduce the structure of E 3 C and present some properties of E 3 C ; then, we propose a routing algorithm and obtain the diameter of E 3 C . Finally, we analyze the diagnosis of E 3 C and give the diagnosibility under PMC model and MM* model.},
  archive      = {J_IJFCS},
  author       = {Yali Lv and Cheng-Kuan Lin and Guijuan Wang},
  doi          = {10.1142/S0129054121500131},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {3},
  pages        = {235-252},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {An exchanged 3-ary n-cube interconnection network for parallel computation},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Graph orientation with edge modifications. <em>IJFCS</em>,
<em>32</em>(2), 209‚Äì233. (<a
href="https://doi.org/10.1142/S012905412150012X">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The goal of an outdegree-constrained edge-modification problem is to find a spanning subgraph or supergraph H of an input undirected graph G such that either: (Type I) the number of edges in H is minimized or maximized and H can be oriented to satisfy some specified constraints on the vertices‚Äô resulting outdegrees; or: (Type II) among all subgraphs or supergraphs of G that can be constructed by deleting or inserting a fixed number of edges, H admits an orientation optimizing some objective involving the vertices‚Äô outdegrees. This paper introduces eight new outdegree-constrained edge-modification problems related to load balancing called (Type I) MIN-DEL-MAX, MIN-INS-MIN, MAX-INS-MAX, and MAX-DEL-MIN and (Type II) p -DEL-MAX, p -INS-MIN, p -INS-MAX, and p -DEL-MIN. In each of the eight problems, the input is a graph and the goal is to delete or insert edges so that the resulting graph has an orientation in which the maximum outdegree (taken over all vertices) is small or the minimum outdegree is large. We first present a framework that provides algorithms for solving all eight problems in polynomial time on unweighted graphs. Next we investigate the inapproximability of the edge-weighted versions of the problems, and design polynomial-time algorithms for six of the problems on edge-weighted trees.},
  archive      = {J_IJFCS},
  author       = {Yuichi Asahiro and Jesper Jansson and Eiji Miyano and Hirotaka Ono and Sandhya T. P.},
  doi          = {10.1142/S012905412150012X},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {2},
  pages        = {209-233},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Graph orientation with edge modifications},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A more reasonable proof of cobham‚Äôs theorem. <em>IJFCS</em>,
<em>32</em>(2), 203‚Äì207. (<a
href="https://doi.org/10.1142/S0129054121500118">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present a short proof of Cobham‚Äôs theorem without using Kronecker‚Äôs approximation theorem, making it suitable for generalization beyond automatic sequences.},
  archive      = {J_IJFCS},
  author       = {Thijmen J. P. Krebs},
  doi          = {10.1142/S0129054121500118},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {2},
  pages        = {203-207},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {A more reasonable proof of cobham‚Äôs theorem},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Timed bounded verification of inclusion based on timed
bounded discretized language. <em>IJFCS</em>, <em>32</em>(2), 175‚Äì202.
(<a href="https://doi.org/10.1142/S0129054121500106">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The inclusion problem is one of the common problems in real-time systems. The general form of this problem is undecidable; however, the time-bounded verification of inclusion problem is decidable for timed automata. In this study, we propose a new discretization technique to verify the inclusion problem. The proposed technique is applied to a non-Zeno timed automaton with an upper bound that does not contain a non-reachable space for each transition. The new approach is based on the generation of timed bounded discretized language that represents an abstraction of timed words in the form of a set of a countable number of discrete timed words. A discrete timed word aggregates all timed words that share the same actions and their execution times that create the time continuous intervals. The lower and the upper bounds of an interval in a discrete timed word is defined by the minimum and maximum execution times associated to a given transition-run. In addition, we propose the verification schema of the inclusion between two timed bounded discretized languages generated by two non-Zeno timed automata.},
  archive      = {J_IJFCS},
  author       = {Ikhlass Ammar and Yamen El Touati and John Mullins and Moez Yeddes},
  doi          = {10.1142/S0129054121500106},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {2},
  pages        = {175-202},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Timed bounded verification of inclusion based on timed bounded discretized language},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A proof of parikh‚Äôs theorem via dickson‚Äôs lemma.
<em>IJFCS</em>, <em>32</em>(2), 163‚Äì173. (<a
href="https://doi.org/10.1142/S012905412150009X">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we give a proof of Parikh‚Äôs semilinear theorem via Dickson‚Äôs lemma. It is notable that our proof provides a clear separation between properties derived from Dickson‚Äôs lemma and tree decomposition for context-free grammars.},
  archive      = {J_IJFCS},
  author       = {Toshihiro Koga},
  doi          = {10.1142/S012905412150009X},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {2},
  pages        = {163-173},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {A proof of parikh‚Äôs theorem via dickson‚Äôs lemma},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Super ck and sub-ck connectivity of k-ary n-cube networks.
<em>IJFCS</em>, <em>32</em>(2), 151‚Äì162. (<a
href="https://doi.org/10.1142/S0129054121500088">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Let G be an undirected graph. An H -structure-cut (resp. H -substructure-cut ) of G is a set of subgraphs of G , if any, whose deletion disconnects G , where the subgraphs deleted are isomorphic to a certain graph H (resp. where for any T ‚Ä≤ of the subgraphs deleted, there is a subgraph T of G , isomorphic to H , such that T ‚Ä≤ is a subgraph of T ). G is super H | M -connected (resp. super sub- H | M -connected ) if the deletion of an arbitrary minimum H -structure-cut (resp. minimum H -substructure-cut) isolates a component isomorphic to a certain graph M . The k -ary n -cube Q n k is one of the most attractive interconnection networks for multiprocessor systems. In this paper, we prove that Q n k with n ‚â• 3 is super sub- C k | K 1 -connected if k ‚â• 3 and k is odd, and super C k | C k -connected if k ‚â• 5 and k is odd.},
  archive      = {J_IJFCS},
  author       = {Yuxing Yang},
  doi          = {10.1142/S0129054121500088},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {2},
  pages        = {151-162},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Super ck and sub-ck connectivity of k-ary n-cube networks},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Relation of extra edge connectivity and component edge
connectivity for regular networks. <em>IJFCS</em>, <em>32</em>(2),
137‚Äì149. (<a href="https://doi.org/10.1142/S0129054121500076">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Reliability of interconnection networks is important to design multiprocessor systems. The extra edge connectivity and component edge connectivity are two parameters for the reliability evaluation. The k -extra edge connectivity Œª k ( G ) is the cardinality of the minimum extra edge cut F such that G ‚àí F is not connected and each component of G ‚àí F has at least k vertices. The t -component edge connectivity Œª t ( G ) of a graph G = ( V , E ) is the minimum edge number of a set F such that G ‚àí F is not connected and G ‚àí F has at least t components. In this paper, we find the relation of extra edge connectivity and component edge connectivity for regular networks. As an application, we determine the component edge connectivity of BC networks, k -ary n -cubes, enhanced hypercubes.},
  archive      = {J_IJFCS},
  author       = {Litao Guo and Mingzu Zhang and Shaohui Zhai and Liqiong Xu},
  doi          = {10.1142/S0129054121500076},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {2},
  pages        = {137-149},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Relation of extra edge connectivity and component edge connectivity for regular networks},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Triple cyclic codes over ùîΩq + uùîΩq. <em>IJFCS</em>,
<em>32</em>(2), 115‚Äì135. (<a
href="https://doi.org/10.1142/S0129054121500064">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Let R = ùîΩ q + u ùîΩ q , where q is a power of a prime number p and u 2 = 0 . A triple cyclic code of length ( r , s , t ) over R is a set that can be partitioned into three parts that any cyclic shift of the coordinates of the three parts leaves the code invariant. These codes can be viewed as R [ x ] -submodules of R [ x ] / „Äà x r ‚àí 1 „Äâ √ó R [ x ] / „Äà x s ‚àí 1 „Äâ √ó R [ x ] / „Äà x t ‚àí 1 „Äâ . In this paper, we study the generator polynomials and the minimum generating sets of this kind of codes. Some optimal or almost optimal linear codes are obtained from this family of codes. We present the relationship between the generators of triple cyclic codes and their duals. As a special class of triple cyclic codes, separable codes over R are discussed briefly in the end.},
  archive      = {J_IJFCS},
  author       = {Ting Yao and Shixin Zhu and Binbin Pang},
  doi          = {10.1142/S0129054121500064},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {2},
  pages        = {115-135},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Triple cyclic codes over ùîΩq + uùîΩq},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Recognizing generating subgraphs revisited. <em>IJFCS</em>,
<em>32</em>(1), 93‚Äì114. (<a
href="https://doi.org/10.1142/S0129054121500052">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A graph G is well-covered if all its maximal independent sets are of the same cardinality. Assume that a weight function w is defined on its vertices. Then G is w well-covered if all maximal independent sets are of the same weight. For every graph G , the set of weight functions w such that G is w -well-covered is a vector space , denoted as WCW(G) . Deciding whether an input graph G is well-covered is co-NP -complete. Therefore, finding WCW(G) is co-NP -hard. A generating subgraph of a graph G is an induced complete bipartite subgraph B of G on vertex sets of bipartition B X and B Y , such that each of S ‚à™ B X and S ‚à™ B Y is a maximal independent set of G , for some independent set S . If B is generating, then w ( B X ) = w ( B Y ) for every weight function w ‚àà W C W ( G ) . Therefore, generating subgraphs play an important role in finding WCW(G) . The decision problem whether a subgraph of an input graph is generating is known to be NP- complete. In this article we prove NP- completeness of the problem for graphs without cycles of length 3 and 5, and for bipartite graphs with girth at least 6. On the other hand, we supply polynomial algorithms for recognizing generating subgraphs and finding WCW(G) , when the input graph is bipartite without cycles of length 6. We also present a polynomial algorithm which finds WCW(G) when G does not contain cycles of lengths 3, 4, 5, and 7.},
  archive      = {J_IJFCS},
  author       = {Vadim E. Levit and David Tankus},
  doi          = {10.1142/S0129054121500052},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {1},
  pages        = {93-114},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Recognizing generating subgraphs revisited},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Cryptanalysis of cramer-shoup like cryptosystems based on
index exchangeable family. <em>IJFCS</em>, <em>32</em>(1), 73‚Äì91. (<a
href="https://doi.org/10.1142/S0129054121500040">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Cramer-Shoup (CS) like cryptosystem based on index exchangeable family (IEF) construction is a novel scheme introduced in Asiaccs 2016 by Li et al. Its versatility was illustrated by building two public key encryption (PKE) schemes, a cramer-shoup encryption scheme based on IEFs, as well as an outsourcing technique based on non-abelian analog. However, the two schemes are not secure over the recommended linear group of Li et al. For them, we provide a new key-recovery attack by solving a linear equation respectively. Furthermore, we peel off complex encryption and decryption processes and propose more than three different attack methods. Finally, we give a corresponding example to illustrate the correctness of our attack methods. Our attack methods break an instance of claiming 80 bit security less than one minute under a personal computer.},
  archive      = {J_IJFCS},
  author       = {Jinhui Liu and Yong Yu and Bo Yang and Jianwei Jia and Qiqi Lai},
  doi          = {10.1142/S0129054121500040},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {1},
  pages        = {73-91},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Cryptanalysis of cramer-shoup like cryptosystems based on index exchangeable family},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Hamiltonian cycle embeddings in faulty hypercubes under the
forbidden faulty set model. <em>IJFCS</em>, <em>32</em>(1), 53‚Äì72. (<a
href="https://doi.org/10.1142/S0129054121500039">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we study the fault-tolerant capability of hypercubes with respect to the hamiltonian property based on the concept of forbidden faulty sets. We show, with the assumption that each vertex is incident with at least three fault-free edges, that an n -dimensional hypercube contains a fault-free hamiltonian cycle, even if there are up to ( 4 n ‚àí 1 3 ) edge faults. Moreover, we give an example to show that the result is optimal with respect to the number of edge faults tolerated.},
  archive      = {J_IJFCS},
  author       = {Chunfang Li and Shangwei Lin and Shengjia Li},
  doi          = {10.1142/S0129054121500039},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {1},
  pages        = {53-72},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Hamiltonian cycle embeddings in faulty hypercubes under the forbidden faulty set model},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Remarks on k-clique, k-independent set and 2-contamination
in complementary prisms. <em>IJFCS</em>, <em>32</em>(1), 37‚Äì52. (<a
href="https://doi.org/10.1142/S0129054121500027">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Complementary prism graphs arise from the disjoint union of a graph G and its complement ·∏† by adding the edges of a perfect matching joining pairs of corresponding vertices of G and ·∏† . Classical graph problems such as Clique and Independent Set were proved to be NP-complete on such a class of graphs. In this work, we study the complexity of both problems on complementary prism graphs from the parameterized complexity point of view. First, we prove that both problems admit a kernel and therefore are fixed-parameter tractable (FPT) when parameterized by the size of the solution, k . Then, we show that k -Clique and k -Independent Set on complementary prisms do not admit polynomial kernel when parameterized by k , unless N P ‚äÜ c o N P / p o l y . Furthermore, we address the 2 -Contamination problem in the context of complementary prisms. This problem consists in completely contaminating a given graph G using a minimum set of initially infected vertices. For a vertex to be contaminated, it is enough that at least two of its neighbors are contaminated. The propagation of the contamination follows this rule until no more vertex can be contaminated. It is known that the minimum set of initially contaminated vertices necessary to contaminate a complementary prism of connected graphs G and ·∏† has cardinality at most 5 . In this paper, we show that the tight upper bound for this invariant on complementary prisms is 3 , improving a result of Duarte et al. (2017).},
  archive      = {J_IJFCS},
  author       = {Priscila P. Camargo and U√©verton S. Souza and Julliano R. Nascimento},
  doi          = {10.1142/S0129054121500027},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {1},
  pages        = {37-52},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Remarks on k-clique, k-independent set and 2-contamination in complementary prisms},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Strict linearizability and abstract atomicity.
<em>IJFCS</em>, <em>32</em>(1), 1‚Äì35. (<a
href="https://doi.org/10.1142/S0129054121500015">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Linearizability is a commonly accepted consistency condition for concurrent objects. Filipoviƒá et al. show that linearizability is equivalent to observational refinement. However, linearizability does not permit concurrent objects to share memory spaces with their client programs. We show that linearizability (or observational refinement) can be broken even though a client program of an object accesses the shared memory spaces without interleaving with the methods of the object. In this paper, we present strict linearizability which lifts this limitation and can ensure client-side traces and final-states equivalence even in a relaxed program model allowing clients to directly access the internal states of concurrent objects. We also investigate several important properties of strict linearizability. At a high level of abstraction, a concurrent object can be viewed as a concurrent implementation of an abstract data type (ADT). We also present a correctness criterion for relating an ADT and its concurrent implementation, which is the combination of linearizability and data abstraction and can ensure observational equivalence. We also investigate its relationship with strict linearizability.},
  archive      = {J_IJFCS},
  author       = {Tangliu Wen and Jie Peng and Jinyun Xue and Zhen You and Lan Song},
  doi          = {10.1142/S0129054121500015},
  journal      = {International Journal of Foundations of Computer Science},
  number       = {1},
  pages        = {1-35},
  shortjournal = {Int. J. Found. Comput. Sci},
  title        = {Strict linearizability and abstract atomicity},
  volume       = {32},
  year         = {2021},
}
</textarea>
</details></li>
</ul>

</body>
</html>
