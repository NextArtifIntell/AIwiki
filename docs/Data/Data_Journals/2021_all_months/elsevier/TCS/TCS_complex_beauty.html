<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>TCS_complex_beauty</title>
  <style>
    html {font-size: 22px;}
    body {margin: 0 auto; max-width: 76em;}
    #copyID {font-size: 18px;}
  </style>
  <script>
    function copy(element) {
      if (element.type == "button"){
      element.type="text";
      }
      element.style.color="black";
      element.style.backgroundColor="#C7EDCC";
      element.select();
      element.setSelectionRange(0, 99999);
      navigator.clipboard.writeText(element.value);
      window.getSelection().removeAllRanges();
      element.type="button";
    }
  </script>
</head>
<body>

<h2 id="tcs---507">TCS - 507</h2>
<ul>
<li><details>
<summary>
(2021). A family of formulas with reversal of arbitrarily high
avoidability index. <em>TCS</em>, <em>896</em>, 168–170. (<a
href="https://doi.org/10.1016/j.tcs.2021.10.013">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present a family of avoidable formulas with reversal whose avoidability index is unbounded. We also complete the determination of the avoidability index of the formulas with reversal in the 3-avoidance basis.},
  archive      = {J_TCS},
  author       = {Pascal Ochem},
  doi          = {10.1016/j.tcs.2021.10.013},
  journal      = {Theoretical Computer Science},
  pages        = {168-170},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A family of formulas with reversal of arbitrarily high avoidability index},
  volume       = {896},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Improved upper bound for sorting permutations by prefix
transpositions. <em>TCS</em>, <em>896</em>, 158–167. (<a
href="https://doi.org/10.1016/j.tcs.2021.10.012">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Modelling of chromosomes with permutations has triggered the research of sorting permutations using global rearrangement operations in computational molecular biology. One such rearrangement is transposition which swaps two adjacent substrings. If one of the substrings is restricted to be the prefix of the permutation then that operation is called a prefix transposition . The symmetric prefix transposition distance between two permutations is defined to be the minimum number of prefix transpositions required to transform one into another. Group theory dictates that an upper bound for prefix transposition distance between any pair of permutations in the symmetric group S n Sn is equivalent to the upper bound for sorting any permutation with prefix transpositions. In this paper, we improve the upper bound for sorting permutations with prefix transpositions to n − log 2 ⁡ n n−log2⁡n .},
  archive      = {J_TCS},
  author       = {Pramod P Nair and Rajan Sundaravaradhan and Bhadrachalam Chitturi},
  doi          = {10.1016/j.tcs.2021.10.012},
  journal      = {Theoretical Computer Science},
  pages        = {158-167},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Improved upper bound for sorting permutations by prefix transpositions},
  volume       = {896},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The component connectivity, component diagnosability, and
t/k-diagnosability of bicube networks. <em>TCS</em>, <em>896</em>,
145–157. (<a href="https://doi.org/10.1016/j.tcs.2021.10.011">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {With the rapid expansion of the scale of multiprocessor systems , the importance of fault tolerance and fault diagnosis is increasingly concerned. For an interconnection network G , the h -component connectivity is an important indicator for evaluating the fault tolerance of G , which is defined as the minimum number of vertices whose deletion will disconnect G such that the remaining has at least h components. The h -component diagnosability, a newly precise diagnosis strategy to analyze the reliability of G , is the diagnosability under the condition that the number of components is at least h in the resulting graph after removing the faulty processor set. The t / k t/k -diagnosability is a classic imprecise diagnosis strategy, which can identify up to t faulty processors by sacrificing accuracy to a certain extent, namely misdiagnosing at most k fault-free processors. In this paper, we investigate some combinatorial properties and the fault tolerance ability of the n -dimensional Bicube network, denoted by B Q n BQn . Then we first prove that the ( h + 1 ) (h+1) -component connectivity of B Q n BQn is h ( n − 1 ) − h ( h − 1 ) 2 + 1 h(n−1)−h(h−1)2+1 ( n ≥ 6 n≥6 , 1 ≤ h ≤ n − 1 1≤h≤n−1 ). Moreover, we derive that the ( h + 1 ) (h+1) -component diagnosability of B Q n BQn is ( h + 1 ) ( n − 1 ) − h ( h + 1 ) 2 + 1 (h+1)(n−1)−h(h+1)2+1 under the PMC model and MM ⁎ model ( n ≥ 7 n≥7 , 1 ≤ h ≤ n − 3 1≤h≤n−3 ). Furthermore, under the PMC model, we propose the t / k t/k -diagnosis algorithm of B Q n BQn and then derive that B Q n BQn is [ ( k + 1 ) n − k ( k + 3 ) 2 ] / k [(k+1)n−k(k+3)2]/k -diagnosable ( n ≥ 6 n≥6 , 0 ≤ k ≤ n − 2 0≤k≤n−2 ).},
  archive      = {J_TCS},
  author       = {Hongbin Zhuang and Wenzhong Guo and Xiao-Yan Li and Ximeng Liu and Cheng-Kuan Lin},
  doi          = {10.1016/j.tcs.2021.10.011},
  journal      = {Theoretical Computer Science},
  pages        = {145-157},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The component connectivity, component diagnosability, and t/k-diagnosability of bicube networks},
  volume       = {896},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). I/o-optimal categorical 3-sided skyline queries.
<em>TCS</em>, <em>896</em>, 132–144. (<a
href="https://doi.org/10.1016/j.tcs.2021.10.010">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The skyline of a set of two-dimensional points is the subset of points not dominated by any other point. In this paper, we consider a set of two-dimensional points (in rank space) that are assigned an additional category, or color. The goal is to preprocess these points so that given a three-sided region of the form [ a , b ] × [ τ , ∞ ] [a,b]×[τ,∞] we can return the set of distinct colors on the skyline of the queried region. We approach this problem in the external memory model and present an I/O-optimal data structure that answers a query using O ( 1 + k B ) O(1+kB) I/Os and requires ⁎ O ( n log ⁎ ⁡ n ) O(nlog⁎⁡n) words of space, where n is the number of points, k is the size of the solution, and B is the block size. Additionally, we provide a space-time trade-off by presenting a data structure that answers a query using ⁎ O ( ( log ⁎ ⁡ n ) 2 + k B ) O((log⁎⁡n)2+kB) I/Os and requires O ( n ) O(n) words of space.},
  archive      = {J_TCS},
  author       = {Arnab Ganguly and Daniel Gibney and Sharma V. Thankachan and Rahul Shah},
  doi          = {10.1016/j.tcs.2021.10.010},
  journal      = {Theoretical Computer Science},
  pages        = {132-144},
  shortjournal = {Theor. Comput. Sci.},
  title        = {I/O-optimal categorical 3-sided skyline queries},
  volume       = {896},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Algorithms for energy conservation in heterogeneous data
centers. <em>TCS</em>, <em>896</em>, 111–131. (<a
href="https://doi.org/10.1016/j.tcs.2021.10.009">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Power consumption is the major cost factor in data centers . It can be reduced by dynamically right-sizing the data center according to the currently arriving jobs. If there is a long period with low load, servers can be powered down to save energy. For identical machines, the problem has already been solved optimally by Lin et al. (2013) and Albers and Quedenfeld (2018). In this paper, we study how a data-center with heterogeneous servers can dynamically be right-sized to minimize the energy consumption. There are d different server types with various operating and switching costs. We present a deterministic online algorithm that achieves a competitive ratio of 2 d as well as a randomized version that is 1.58 d -competitive. Furthermore, we show that there is no deterministic online algorithm that attains a competitive ratio smaller than 2 d . Hence our deterministic algorithm is optimal. In contrast to related problems like convex body chasing and convex function chasing, we investigate the discrete setting where the number of active servers must be integral, so we gain truly feasible solutions.},
  archive      = {J_TCS},
  author       = {Susanne Albers and Jens Quedenfeld},
  doi          = {10.1016/j.tcs.2021.10.009},
  journal      = {Theoretical Computer Science},
  pages        = {111-131},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Algorithms for energy conservation in heterogeneous data centers},
  volume       = {896},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Subnetwork reliability analysis of bubble-sort graph
networks. <em>TCS</em>, <em>896</em>, 98–110. (<a
href="https://doi.org/10.1016/j.tcs.2021.10.007">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The bubble-sort graph network B n Bn is recognized as an attractive interconnection network topology for building multiprocessor computer systems. In this paper, the subnetwork reliability of B n Bn is analyzed in the presence of node failures. An upper bound and a lower bound on the B n − 1 Bn−1 subnetwork reliability of B n Bn are established under the probability fault model, and the theoretical results are proved to be in accordance with and near to the simulation results. Moreover, under the node fault model, the mean time to failure to maintain the fault-free status of different number of disjoint B n − 1 Bn−1 subnetworks in B n Bn is evaluated by using the fixed partitioning and the flexible partitioning, respectively, and it is shown that B n Bn has better robustness under the flexible partitioning pattern when disjoint B n − 1 Bn−1 subnetworks need to be used.},
  archive      = {J_TCS},
  author       = {Kai Feng and Xinyu Ma and Wei Wei},
  doi          = {10.1016/j.tcs.2021.10.007},
  journal      = {Theoretical Computer Science},
  pages        = {98-110},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Subnetwork reliability analysis of bubble-sort graph networks},
  volume       = {896},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On doubly symmetric dyck words. <em>TCS</em>, <em>896</em>,
79–97. (<a href="https://doi.org/10.1016/j.tcs.2021.10.006">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper we consider doubly symmetric Dyck words , i.e. Dyck words which are fixed by two symmetry operations α and β introduced in [1] . We study combinatorial properties of doubly symmetric Dyck words, leading to the definition of two recursive algorithms to build these words. As a consequence we have a representation of doubly symmetric Dyck words as vectors of integers, called track vectors. Finally, we show some bijections between a subfamily of doubly symmetric Dyck words and a subfamily of integer partitions. The computation of the sequence f n fn of doubly symmetric Dyck words of semi-length n shows surprising properties giving rise to some conjectures.},
  archive      = {J_TCS},
  author       = {Robert Cori and Andrea Frosini and Giulia Palma and Elisa Pergola and Simone Rinaldi},
  doi          = {10.1016/j.tcs.2021.10.006},
  journal      = {Theoretical Computer Science},
  pages        = {79-97},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On doubly symmetric dyck words},
  volume       = {896},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). An optimal algorithm for 2-bounded delay buffer management
with lookahead. <em>TCS</em>, <em>896</em>, 65–78. (<a
href="https://doi.org/10.1016/j.tcs.2021.10.005">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The bounded delay buffer management problem, which was proposed by Kesselman et al. (STOC 2001 and SIAM Journal on Computing 33(3), 2004), is an online problem focusing on buffer management of a switch supporting Quality of Service (QoS). The problem definition is as follows: Packets arrive to a buffer over time and each packet is specified by the release time , deadline and value . An algorithm can transmit at most one packet from the buffer at each integer time and can gain its value as the profit if transmitting the packet by its deadline after its release time. The objective of this problem is to maximize the gained profit. We say that an instance of the problem is s -bounded if for any packet, an algorithm has at most s chances to transmit it. For any s ≥ 2 s≥2 , Hajek (CISS 2001) showed that the competitive ratio of any deterministic algorithm is at least ( 1 + 5 ) / 2 ≥ 1.618 (1+5)/2≥1.618 . Recently, Veselý et al. (SODA 2019) designed an online algorithm matching the lower bound. Böhm et al. (ISAAC 2016 and Theoretical Computer Science, 2019) introduced the lookahead ability to an online algorithm. At a time t , the algorithm obtains information about packets arriving at time t + 1 t+1 , and showed that for s = 2 s=2 , there is an algorithm which achieves the competitive ratio of ( − 1 + 13 ) / 2 ≤ 1.303 (−1+13)/2≤1.303 . Also, they showed that the competitive ratio of any deterministic algorithm is at least ( 1 + 17 ) / 4 ≥ 1.280 (1+17)/4≥1.280 . In this paper, for the 2-bounded model with lookahead, we design an algorithm with a matching competitive ratio of ( 1 + 17 ) / 4 (1+17)/4 .},
  archive      = {J_TCS},
  author       = {Koji M. Kobayashi},
  doi          = {10.1016/j.tcs.2021.10.005},
  journal      = {Theoretical Computer Science},
  pages        = {65-78},
  shortjournal = {Theor. Comput. Sci.},
  title        = {An optimal algorithm for 2-bounded delay buffer management with lookahead},
  volume       = {896},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A unique extension of rich words. <em>TCS</em>,
<em>896</em>, 53–64. (<a
href="https://doi.org/10.1016/j.tcs.2021.10.004">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A word w is called rich if it contains | w | + 1 |w|+1 palindromic factors, including the empty word. We say that a rich word w can be extended in at least two ways if there are two distinct letters x , y x,y such that w x , w y wx,wy are rich. Let R denote the set of all rich words. Given w ∈ R w∈R , let K ( w ) K(w) denote the set of all words u such that w u ∈ R wu∈R and wu can be extended in at least two ways. Let ω ( w ) = min ⁡ { | u | | u ∈ K ( w ) } ω(w)=min⁡{|u||u∈K(w)} and let ϕ ( n ) = max ⁡ { ω ( w ) | w ∈ R and | w | = n } ϕ(n)=max⁡{ω(w)|w∈R and |w|=n} , where n &gt; 0 n&amp;gt;0 . Vesti (2014) showed that ϕ ( n ) ≤ 2 n ϕ(n)≤2n . In other words, it says that for each w ∈ R w∈R there is a word u with | u | ≤ 2 | w | |u|≤2|w| such that w u ∈ R wu∈R and wu can be extended in at least two ways. We prove that ϕ ( n ) ≤ n ϕ(n)≤n and that lim sup n → ∞ ϕ ( n ) n ≥ 2 9 limsupn→∞ϕ(n)n≥29 . The results hold for each finite alphabet having at least two letters.},
  archive      = {J_TCS},
  author       = {Josef Rukavicka},
  doi          = {10.1016/j.tcs.2021.10.004},
  journal      = {Theoretical Computer Science},
  pages        = {53-64},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A unique extension of rich words},
  volume       = {896},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Adaptive learning of compressible strings. <em>TCS</em>,
<em>896</em>, 46–52. (<a
href="https://doi.org/10.1016/j.tcs.2021.10.003">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Suppose an oracle knows a string S that is unknown to us and that we want to determine. The oracle can answer queries of the form “Is s a substring of S ?”. In 1995, Skiena and Sundaram showed that, in the worst case, any algorithm needs to ask the oracle σ n / 4 − O ( n ) σn/4−O(n) queries in order to be able to reconstruct the hidden string, where σ is the size of the alphabet of S and n its length, and gave an algorithm that spends ( σ − 1 ) n + O ( σ n ) (σ−1)n+O(σn) queries to reconstruct S . The main contribution of our paper is to improve the above upper-bound in the context where the string is compressible. We first present a universal algorithm that, given a (computable) compressor that compresses the string to τ bits, performs q = O ( τ ) q=O(τ) substring queries; this algorithm, however, runs in exponential time . For this reason, the second part of the paper focuses on more time-efficient algorithms whose number of queries is bounded by specific compressibility measures. We first show that any string of length n over an integer alphabet of size σ with rle rle runs can be reconstructed with q = O ( rle ( σ + log ⁡ n rle ) ) q=O(rle(σ+log⁡nrle)) substring queries in linear time and space. We then present an algorithm that spends q ∈ O ( σ g log ⁡ n ) q∈O(σglog⁡n) substring queries and runs in O ( n ( log ⁡ n + log ⁡ σ ) + q ) O(n(log⁡n+log⁡σ)+q) time using linear space, where g is the size of a smallest straight-line program generating the string.},
  archive      = {J_TCS},
  author       = {Gabriele Fici and Nicola Prezza and Rossano Venturini},
  doi          = {10.1016/j.tcs.2021.10.003},
  journal      = {Theoretical Computer Science},
  pages        = {46-52},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Adaptive learning of compressible strings},
  volume       = {896},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). 2-colored point-set embeddings of partial 2-trees.
<em>TCS</em>, <em>896</em>, 31–45. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.045">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Let G be a planar graph whose vertices are colored either red or blue and let S be a set of points having as many red (resp. blue) points as the red (resp. blue) vertices of G . A 2-colored point-set embedding of G on S is a planar drawing that maps each red (resp. blue) vertex of G to a red (resp. blue) point of S . We show that there exist partial 2-trees that are properly 2-colored (i.e., they are 2-colored with no two adjacent vertices have the same color), whose point-set embeddings may require linearly many bends on linearly many edges. For a contrast, we show that two bends per edge are sufficient for 2-colored point-set embedding of properly 2-colored outerplanar graphs. For separable point sets this bound reduces to one, which is worst-case optimal. If the 2-coloring of the outerplanar graph is not proper, three bends per edge are sufficient and one bend per edge (which is worst-case optimal) is sufficient for caterpillars.},
  archive      = {J_TCS},
  author       = {Emilio Di Giacomo and Jaroslav Hančl Jr. and Giuseppe Liotta},
  doi          = {10.1016/j.tcs.2021.09.045},
  journal      = {Theoretical Computer Science},
  pages        = {31-45},
  shortjournal = {Theor. Comput. Sci.},
  title        = {2-colored point-set embeddings of partial 2-trees},
  volume       = {896},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). (K,p)-planarity: A relaxation of hybrid planarity.
<em>TCS</em>, <em>896</em>, 19–30. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.044">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present a new model for hybrid planarity that relaxes existing hybrid representation models. A graph G = ( V , E ) G=(V,E) is ( k , p ) (k,p) -planar if V can be partitioned into clusters of size at most k such that G admits a drawing where: (i) each cluster is associated with a closed, bounded planar region, called a cluster region ; (ii) cluster regions are pairwise disjoint , (iii) each vertex v ∈ V v∈V is identified with at most p distinct points, called ports , on the boundary of its cluster region; (iv) each inter-cluster edge ( u , v ) ∈ E (u,v)∈E is identified with a Jordan arc connecting a port of u to a port of v ; (v) inter-cluster edges do not cross or intersect cluster regions except at their end-points. We first tightly bound the number of edges in a ( k , p ) (k,p) -planar graph with p p&amp;lt;k . We then prove that ( 4 , 1 ) (4,1) -planarity testing and ( 2 , 2 ) (2,2) -planarity testing are NP-complete problems. Finally, we prove that neither the class of ( 2 , 2 ) (2,2) -planar graphs nor the class of 1-planar graphs contains the other, indicating that the ( k , p ) (k,p) -planar graphs are a large and novel class.},
  archive      = {J_TCS},
  author       = {Emilio Di Giacomo and William J. Lenhart and Giuseppe Liotta and Timothy W. Randolph and Alessandra Tappini},
  doi          = {10.1016/j.tcs.2021.09.044},
  journal      = {Theoretical Computer Science},
  pages        = {19-30},
  shortjournal = {Theor. Comput. Sci.},
  title        = {(k,p)-planarity: A relaxation of hybrid planarity},
  volume       = {896},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). New complexity estimation on the rainbow-band-separation
attack. <em>TCS</em>, <em>896</em>, 1–18. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.043">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Multivariate public key cryptography is a candidate for post-quantum cryptography, and it allows generating particularly short signatures and fast verification. The Rainbow signature scheme proposed by Ding and Schmidt is such a multivariate cryptosystem, and it is considered secure against all known attacks. The Rainbow-Band-Separation attack recovers a secret key of Rainbow by solving certain systems of quadratic equations , and its complexity is estimated by the well-known theoretical value called the degree of regularity. However, the degree of regularity is generally larger than the solving degree in experiments, and an accurate estimation cannot be obtained. In this article, we propose a new theoretical value for the complexity of the Rainbow-Band-Separation attack using a Gröbner basis algorithm , which provides a more precise estimation compared to that using the degree of regularity. This theoretical value is deduced by the two-variable power series ∏ i = 1 m ( 1 − t 1 d i 1 t 2 d i 2 ) ( 1 − t 1 ) n 1 ( 1 − t 2 ) n 2 . ∏i=1m(1−t1di1t2di2)(1−t1)n1(1−t2)n2. Since the two-variable power series coincides with the one-variable power series at t 1 = t 2 t1=t2 deriving the degree of regularity, the theoretical value is less than or equal to the degree of regularity under a certain condition. Moreover, we show a relation between the Rainbow-Band-Separation attack using the hybrid approach and the HighRank attack. By considering this relation and our theoretical value, we obtain a new complexity estimation for the Rainbow-Band-Separation attack. Furthermore, applying our theoretical value to the complexity formula used in the NIST PQC 2nd round, we show that a slight modification of the proposed Rainbow parameter sets is required. Consequently, we provide a new theoretical value for generally estimating the solving degree of a bi-graded polynomial system, which can influence the parameter selection of Rainbow in the NIST PQC standardization project.},
  archive      = {J_TCS},
  author       = {Shuhei Nakamura and Yasuhiko Ikematsu and Yacheng Wang and Jintai Ding and Tsuyoshi Takagi},
  doi          = {10.1016/j.tcs.2021.09.043},
  journal      = {Theoretical Computer Science},
  pages        = {1-18},
  shortjournal = {Theor. Comput. Sci.},
  title        = {New complexity estimation on the rainbow-band-separation attack},
  volume       = {896},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Hardware security without secure hardware: How to decrypt
with a password and a server. <em>TCS</em>, <em>895</em>, 178–211. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.042">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Hardware security tokens have now been used for several decades to store cryptographic keys. When deployed, the security of the corresponding schemes fundamentally relies on the tamper-resistance of the tokens – a very strong assumption in practice. Moreover, even secure tokens, which are expensive and cumbersome, can often be subverted. We introduce a new cryptographic primitive called Encryption schemes with Password-protected Assisted Decryption (EPAD schemes), in which a user&#39;s decryption key is shared between a user device (or token) on which no assumption is made, and an online server. The user shares a human-memorizable password with the server. To decrypt a ciphertext , the user launches, from a public computer, a distributed protocol with the device and the server, authenticating herself to the server with her password (unknown to the device); in such a way that her secret key is never reconstructed during the interaction. We propose a strong security model which guarantees that (1) for an efficient adversary to infer any information about a user&#39;s plaintexts, it must know her password and have corrupted her device (secrecy is guaranteed if only one of the two conditions is fulfilled), (2) the device and the server are unable to infer any information about the ciphertexts they help to decrypt (even though they could together reconstruct the secret key), and (3) the user is able to verify that the device and the server both performed the expected computations. These EPAD schemes are in the password-only model, meaning that the user is not required to remember a trusted public key , and her password remains safe even if she is led to interact with a wrong server and a malicious device. We then give a practical pairixng-based EPAD scheme. Our construction is provably secure under standard computational assumptions, using non-interactive proof systems which can be efficiently instantiated in the standard security model, i.e., without relying on the random oracle heuristic.},
  archive      = {J_TCS},
  author       = {Olivier Blazy and Laura Brouilhet and Celine Chevalier and Patrick Towa and Ida Tucker and Damien Vergnaud},
  doi          = {10.1016/j.tcs.2021.09.042},
  journal      = {Theoretical Computer Science},
  pages        = {178-211},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Hardware security without secure hardware: How to decrypt with a password and a server},
  volume       = {895},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Belief-invariant and quantum equilibria in games of
incomplete information. <em>TCS</em>, <em>895</em>, 151–177. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.041">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Drawing on ideas from game theory and quantum physics, we investigate nonlocal correlations from the point of view of equilibria in games of incomplete information. These equilibria can be classified in decreasing power as general communication equilibria , belief-invariant equilibria and correlated equilibria , all of which contain the familiar Nash equilibria . The notion of belief-invariant equilibrium appeared in game theory in the 90s. However, the class of non-signalling correlations associated to belief-invariance arose naturally already in the 80s in the foundations of quantum mechanics. In the present work, we explain and unify these two origins of the idea and study the above classes of equilibria, together with quantum correlated equilibria , using tools from quantum information but the language of (algorithmic) game theory. We present a general framework of belief-invariant communication equilibria, which contains correlated equilibria and quantum correlated equilibria as special cases. Our framework also contains the theory of Bell inequalities and their violations due to non-locality, which is a question of intense interest in the foundations of quantum mechanics, and it was indeed the original motivation for the aforementioned studies. Moreover, in our framework we can also model quantum games where players have conflicting interests, a recent developing topic in physics. We then use our framework to show new results related to the social welfare of equilibria. Namely, we exhibit a game where belief-invariance is socially better than any correlated equilibrium, and a game where all non-belief-invariant communication equilibria have a suboptimal social welfare. We also show that optimal social welfare can in certain cases be achieved by quantum mechanical correlations, which do not need an informed mediator to be implemented, and go beyond the classical “sunspot” or shared randomness approach.},
  archive      = {J_TCS},
  author       = {Vincenzo Auletta and Diodato Ferraioli and Ashutosh Rai and Giannicola Scarpa and Andreas Winter},
  doi          = {10.1016/j.tcs.2021.09.041},
  journal      = {Theoretical Computer Science},
  pages        = {151-177},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Belief-invariant and quantum equilibria in games of incomplete information},
  volume       = {895},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Colourful components in k-caterpillars and planar graphs.
<em>TCS</em>, <em>895</em>, 137–150. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.040">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A connected component of a vertex-coloured graph is said to be colourful if all its vertices have different colours. By extension, a graph is colourful if all its connected components are colourful. Given a vertex-coloured graph G and an integer p , the Colourful Components problem asks whether there exist at most p edges whose removal makes G colourful and the Colourful Partition problem asks whether there exists a partition of G into at most p colourful components. In order to refine our understanding of the complexity of the problems on trees, we study both problems on k -caterpillars, which are trees with a central path P such that every vertex not in P is within distance k from a vertex in P . We prove that Colourful Components and Colourful Partition are NP -complete on 4-caterpillars with maximum degree 3, 3-caterpillars with maximum degree 4 and 2-caterpillars with maximum degree 5. On the other hand, we show that the problems are linear-time solvable on 1-caterpillars. Hence, our results imply two complexity dichotomies on trees: Colourful Components and Colourful Partition are linear-time solvable on trees with maximum degree d if d ≤ 2 d≤2 (that is, on paths), and NP -complete otherwise; Colourful Components and Colourful Partition are linear-time solvable on k -caterpillars if k ≤ 1 k≤1 , and NP -complete otherwise. We leave three open cases which, if solved, would provide a complexity dichotomy for both problems on k -caterpillars, for every non-negative integer k , with respect to the maximum degree. We also show that Colourful Components is NP -complete on 5-coloured planar graphs with maximum degree 4 and on 12-coloured planar graphs with maximum degree 3. Our results answer two open questions of Bulteau et al. mentioned in Bulteau et al. (2019) [6] .},
  archive      = {J_TCS},
  author       = {Janka Chlebíková and Clément Dallard},
  doi          = {10.1016/j.tcs.2021.09.040},
  journal      = {Theoretical Computer Science},
  pages        = {137-150},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Colourful components in k-caterpillars and planar graphs},
  volume       = {895},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Geometric planar networks on bichromatic collinear points.
<em>TCS</em>, <em>895</em>, 124–136. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.035">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study three classical graph problems – Hamiltonian path , minimum spanning tree , and minimum perfect matching on geometric graphs induced by bichromatic (red and blue) points. These problems have been widely studied for points in the Euclidean plane , and many of them are NP NP -hard. In this work, we consider these problems for collinear points. We show that almost all of these problems can be solved in linear time in this setting.},
  archive      = {J_TCS},
  author       = {Sayan Bandyapadhyay and Aritra Banik and Sujoy Bhore and Martin Nöllenburg},
  doi          = {10.1016/j.tcs.2021.09.035},
  journal      = {Theoretical Computer Science},
  pages        = {124-136},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Geometric planar networks on bichromatic collinear points},
  volume       = {895},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021a). Physical zero-knowledge proof for ripple effect.
<em>TCS</em>, <em>895</em>, 115–123. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.034">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Ripple Effect is a logic puzzle where the player has to fill numbers into empty cells in a rectangular grid. The grid is divided into rooms, and each room must contain consecutive integers starting from 1 to its size. Also, if two cells in the same row or column contain the same number x , there must be a space of at least x cells separating the two cells. In this paper, we develop a physical zero-knowledge proof for the Ripple Effect puzzle using a deck of cards, which allows a prover to convince a verifier that he/she knows a solution without revealing it. In particular, given a secret number x and a list of numbers, our protocol can physically verify that x does not appear among the first x numbers in the list without revealing x or any number in the list.},
  archive      = {J_TCS},
  author       = {Suthee Ruangwises and Toshiya Itoh},
  doi          = {10.1016/j.tcs.2021.09.034},
  journal      = {Theoretical Computer Science},
  pages        = {115-123},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Physical zero-knowledge proof for ripple effect},
  volume       = {895},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The weisfeiler-leman algorithm and recognition of graph
properties. <em>TCS</em>, <em>895</em>, 96–114. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.033">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The k -dimensional Weisfeiler-Leman algorithm ( k - WL k-WL ) is a very useful combinatorial tool in graph isomorphism testing. We address the applicability of k - WL k-WL to recognition of graph properties. Let G be an input graph with n vertices. We show that, if n is prime, then vertex-transitivity of G can be seen in a straightforward way from the output of 2 - WL 2-WL on G and on the vertex-individualized copies of G . This is perhaps the first non-trivial example of using the Weisfeiler-Leman algorithm for recognition of a natural graph property rather than for isomorphism testing. On the other hand, we show that, if n is divisible by 16, then k - WL k-WL is unable to distinguish between vertex-transitive and non-vertex-transitive graphs with n vertices unless k = Ω ( n ) k=Ω(n) . Similar results are obtained for recognition of arc-transitivity. Our lower bounds are based on an analysis of the Cai-Fürer-Immerman construction, which might be of independent interest. In particular, we provide sufficient conditions under which the Cai-Fürer-Immerman graphs can be made colorless.},
  archive      = {J_TCS},
  author       = {Frank Fuhlbrück and Johannes Köbler and Ilia Ponomarenko and Oleg Verbitsky},
  doi          = {10.1016/j.tcs.2021.09.033},
  journal      = {Theoretical Computer Science},
  pages        = {96-114},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The weisfeiler-leman algorithm and recognition of graph properties},
  volume       = {895},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Query minimization under stochastic uncertainty.
<em>TCS</em>, <em>895</em>, 75–95. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.032">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study problems with stochastic uncertainty information on intervals for which the precise value can be queried by paying a cost. The goal is to devise an adaptive decision tree to find a correct solution to the problem in consideration while minimizing the expected total query cost. We show that, for the sorting problem, such a decision tree can be found in polynomial time . For the problem of finding the data item with minimum value, we have some evidence for hardness. This contradicts intuition, since the minimum problem is easier both in the online setting with adversarial inputs and in the offline verification setting. However, the stochastic assumption can be leveraged to beat both deterministic and randomized approximation lower bounds for the online setting.},
  archive      = {J_TCS},
  author       = {Steven Chaplick and Magnús M. Halldórsson and Murilo S. de Lima and Tigran Tonoyan},
  doi          = {10.1016/j.tcs.2021.09.032},
  journal      = {Theoretical Computer Science},
  pages        = {75-95},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Query minimization under stochastic uncertainty},
  volume       = {895},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). H-extra r-component connectivity of interconnection networks
with application to hypercubes. <em>TCS</em>, <em>895</em>, 68–74. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.030">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The connectivity and its generalizations have been well studied due to their impact on the fault tolerance and diagnosability of the interconnection networks . In this paper, we introduce a novel generalized connectivity, which combines the h -extra connectivity and r -component connectivity. Given a connected graph G = ( V , E ) G=(V,E) , for any h ≥ 0 h≥0 and r ≥ 2 r≥2 , an h -extra r -component cut of G is a subset S ⊆ V S⊆V such that there are at least r components in G ∖ S G∖S and each component has at least h + 1 h+1 vertices; h -extra r -component connectivity of G , denoted as c κ r h ( G ) cκrh(G) , is the minimum size of any h -extra r -component cut of G . We determine the h -extra r -component connectivity of n -dimensional hypercube Q n Qn , c κ r 1 ( Q n ) = 2 ( r − 1 ) ( n − r + 1 ) cκr1(Qn)=2(r−1)(n−r+1) for r ∈ { 2 , 3 , 4 } r∈{2,3,4} .},
  archive      = {J_TCS},
  author       = {Bi Li and Jingfen Lan and Wantao Ning and Yongcui Tian and Xin Zhang and Qiang Zhu},
  doi          = {10.1016/j.tcs.2021.09.030},
  journal      = {Theoretical Computer Science},
  pages        = {68-74},
  shortjournal = {Theor. Comput. Sci.},
  title        = {H-extra r-component connectivity of interconnection networks with application to hypercubes},
  volume       = {895},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Upper tail analysis of bucket sort and random tries.
<em>TCS</em>, <em>895</em>, 55–67. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.029">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Bucket Sort is known to run in expected linear time when the input keys are distributed independently and uniformly at random in the interval [ 0 , 1 ) [0,1) . The analysis holds even when a quadratic time algorithm is used to sort the keys in each bucket. We show how to obtain linear time guarantees on the running time of Bucket Sort that hold with very high probability . Specifically, we investigate the asymptotic behavior of the exponent in the upper tail probability of the running time of Bucket Sort. We consider large additive deviations from the expectation, of the form cn for large enough (constant) c , where n is the number of keys that are sorted. Our analysis shows a profound difference between variants of Bucket Sort that use a quadratic time algorithm within each bucket and variants that use a Θ ( b log ⁡ b ) Θ(blog⁡b) time algorithm for sorting b keys in a bucket. When a quadratic time algorithm is used to sort the keys in a bucket, the probability that Bucket Sort takes cn more time than expected is exponential in Θ ( n log ⁡ n ) Θ(nlog⁡n) . When a Θ ( b log ⁡ b ) Θ(blog⁡b) algorithm is used to sort the keys in a bucket, the exponent becomes Θ ( n ) Θ(n) . We prove this latter theorem by showing an upper bound on the tail of a random variable defined on tries, a result which we believe is of independent interest. This result also enables us to analyze the upper tail probability of a well-studied trie parameter, the external path length, and show that the probability that it deviates from its expected value by an additive factor of cn is exponentially small in Θ ( n ) Θ(n) .},
  archive      = {J_TCS},
  author       = {Ioana O. Bercea and Guy Even},
  doi          = {10.1016/j.tcs.2021.09.029},
  journal      = {Theoretical Computer Science},
  pages        = {55-67},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Upper tail analysis of bucket sort and random tries},
  volume       = {895},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The set of hyperbolic equilibria and of invertible zeros on
the unit ball is computable. <em>TCS</em>, <em>895</em>, 48–54. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.028">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this note, we construct an algorithm that, on input of a description of a structurally stable planar dynamical flow f defined on the closed unit disk , outputs the exact number of the (hyperbolic) equilibrium points and their locations with arbitrary accuracy. By arbitrary accuracy it is meant that any accuracy required by the input can be achieved. The algorithm can be further extended to a root-finding algorithm that computes the exact number of zeros as well the location of each zero of a continuously differentiable function f defined on the closed unit ball of R d Rd , provided that the Jacobian of f is invertible at each zero of f ; moreover, the computation is uniform in f .},
  archive      = {J_TCS},
  author       = {Daniel S. Graça and Ning Zhong},
  doi          = {10.1016/j.tcs.2021.09.028},
  journal      = {Theoretical Computer Science},
  pages        = {48-54},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The set of hyperbolic equilibria and of invertible zeros on the unit ball is computable},
  volume       = {895},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Differential logical relations, part II increments and
derivatives. <em>TCS</em>, <em>895</em>, 34–47. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.027">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the deep relation existing between differential logical relations and incremental computing by showing how self-differences in the former precisely correspond to derivatives in the latter. The byproduct of such a relationship is twofold: on the one hand, we show how differential logical relations can be seen as a powerful meta-theoretical tool in the analysis of incremental computations, enabling an easy proof of soundness of differentiation. On the other hand, we generalize differential logical relations so as to be able to interpret full recursion, something not possible in the original system.},
  archive      = {J_TCS},
  author       = {Ugo Dal Lago and Francesco Gavazzo},
  doi          = {10.1016/j.tcs.2021.09.027},
  journal      = {Theoretical Computer Science},
  pages        = {34-47},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Differential logical relations, part II increments and derivatives},
  volume       = {895},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Parallel load balancing on constrained client-server
topologies. <em>TCS</em>, <em>895</em>, 16–33. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.026">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study parallel Load Balancing protocols for the client-server distributed model defined as follows. There is a set C C of n clients and a set S S of n servers where each client has (at most) a constant number d ⩾ 1 d⩾1 of requests that must be assigned to some server. The client set and the server one are connected to each other via a fixed bipartite graph: the requests of client v can only be sent to the servers in its neighborhood N ( v ) N(v) . The goal is to assign every client request so as to minimize the maximum load of the servers. In this setting, efficient parallel protocols are available only for dense topologies. In particular, a simple protocol, named raes , has been recently introduced by Becchetti et al. [1] for regular dense bipartite graphs. They show that this symmetric, non-adaptive protocol achieves constant maximum load with parallel completion time O ( log ⁡ n ) O(log⁡n) and overall work O ( n ) O(n) , w.h.p. Motivated by proximity constraints arising in some client-server systems, we analyze raes over almost-regular bipartite graphs where nodes may have neighborhoods of small size. In detail, we prove that, w.h.p., the raes protocol keeps the same performances as above (in terms of maximum load, completion time, and work complexity, respectively) on any almost-regular bipartite graph with degree Ω ( log 2 ⁡ n ) Ω(log2⁡n) . Our analysis significantly departs from that in [1] since it requires to cope with non-trivial stochastic-dependence issues on the random choices of the algorithmic process which are due to the worst-case, sparse topology of the underlying graph.},
  archive      = {J_TCS},
  author       = {Andrea Clementi and Emanuele Natale and Isabella Ziccardi},
  doi          = {10.1016/j.tcs.2021.09.026},
  journal      = {Theoretical Computer Science},
  pages        = {16-33},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Parallel load balancing on constrained client-server topologies},
  volume       = {895},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Imbalance parameterized by twin cover revisited.
<em>TCS</em>, <em>895</em>, 1–15. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.017">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Imbalance is a classical graph layout problem with several applications, particularly in graph drawing. The imbalance of a layout σ is determined by how well-balanced the neighbors of the vertices are in σ . In the present work, we study the problem of Imbalance parameterized by the twin cover of a graph. We show that Imbalance is XP parameterized by twin cover, and FPT when parameterized by the twin cover and the size of the largest clique outside the twin cover. In contrast, we introduce a notion of succinct representations of graphs in terms of their twin cover and demonstrate that Imbalance is NP-hard in the setting of succinct representations, even for graphs that have a twin cover of size one.},
  archive      = {J_TCS},
  author       = {Neeldhara Misra and Harshil Mittal},
  doi          = {10.1016/j.tcs.2021.09.017},
  journal      = {Theoretical Computer Science},
  pages        = {1-15},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Imbalance parameterized by twin cover revisited},
  volume       = {895},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021a). Editorial. <em>TCS</em>, <em>894</em>, iii. (<a
href="https://doi.org/10.1016/S0304-3975(21)00643-5">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_TCS},
  author       = {Lila Kari ( Editor-in-Chief )},
  doi          = {10.1016/S0304-3975(21)00643-5},
  journal      = {Theoretical Computer Science},
  pages        = {iii},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Editorial},
  volume       = {894},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). RESCOT: Restriction enzyme set and combination optimization
tools for rNMP capture techniques. <em>TCS</em>, <em>894</em>, 203–213.
(<a href="https://doi.org/10.1016/j.tcs.2021.08.006">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The incorporation of ribonucleoside monophosphates (rNMPs) in genomic DNA is a frequent phenomenon in many species, often associated with genome instability and disease. The ribose-seq technique is one of a few techniques designed to capture and map rNMPs embedded in genomic DNA. The first step of ribose-seq is restriction enzyme (RE) fragmentation, which cuts the genome into smaller fragments for subsequent rNMP capture. The RE selection chosen for genomic DNA fragmentation in the first step of the rNMP-capture techniques determines the genomic regions in which the rNMPs can be captured. Here, we designed a computational method, Restriction Enzyme Set and Combination Optimization Tools (RESCOT), to calculate the genomic coverage of rNMP-captured regions for a given RE set and to optimize the RE set to significantly increase the rNMP-captured-region coverage. Analyses of ribose-seq libraries for which the RESCOT tools were applied reveal that many rNMPs were captured in the expected genomic regions. Since different rNMP-mapping techniques utilize RE fragmentation and purification steps based on size-selection of the DNA fragments in the protocol, we discuss the possible usage of RESCOT for other rNMP-mapping techniques. In summary, RESCOT generates optimized RE sets for the fragmentation step of many rNMP capture techniques to maximize rNMP capture rate and thus enable researchers to better study characteristics of rNMP incorporation.},
  archive      = {J_TCS},
  author       = {Penghao Xu and Francesca Storici},
  doi          = {10.1016/j.tcs.2021.08.006},
  journal      = {Theoretical Computer Science},
  pages        = {203-213},
  shortjournal = {Theor. Comput. Sci.},
  title        = {RESCOT: Restriction enzyme set and combination optimization tools for rNMP capture techniques},
  volume       = {894},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Multidimensional data organization and random access in
large-scale DNA storage systems. <em>TCS</em>, <em>894</em>, 190–202.
(<a href="https://doi.org/10.1016/j.tcs.2021.09.021">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {With impressive physical density and molecular-scale coding capacity, DNA is a promising substrate for building long-lasting data archival storage systems. To retrieve data from DNA storage, recent implementations typically rely on large libraries of meticulously designed orthogonal PCR primers, which fundamentally limit the capacity and scalability of practical DNA storage. This work combines nested and semi-nested PCR to enable multidimensional data organization and random access in large DNA storage. Our strategy effectively pushes the limit of DNA storage capacity and dramatically reduces the number of orthogonal primers needed for efficient PCR random access. Our design uses only ⁎ k ⁎ n k⁎n primers to uniquely address n k nk data-encoding oligos. The architecture inherently supports various well-defined PCR random-access patterns that can be tailored to organize and preserve the underlying DNA-encoded data structures and relations in simple database-like formats such as rows, columns, tables, and blocks of data entries. We design in silico PCR experiments of a four-dimensional DNA storage to illustrate the mechanisms of sixteen different random-access patterns each requiring no more than two PCR reactions to selectively amplify a target dataset of various sizes. To better approximate the physical system, we formulate mathematical models based on empirical distributions to analyze the effect of pipetting, PCR bias, and PCR stochasticity on the performance of multidimensional data queries from large DNA storage.},
  archive      = {J_TCS},
  author       = {Xin Song and Shalin Shah and John Reif},
  doi          = {10.1016/j.tcs.2021.09.021},
  journal      = {Theoretical Computer Science},
  pages        = {190-202},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Multidimensional data organization and random access in large-scale DNA storage systems},
  volume       = {894},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Cut-and-project graphs and other complexes. <em>TCS</em>,
<em>894</em>, 172–189. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.031">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The cut-and-project method may be applied to graphs and complexes, although there are technical difficulties, most notably “collisions,” i.e. when the images (under the projection) of two disjoint edges or cells intersect. Given a particular periodic structure, a particular projection space, an appropriate “window” in the orthogonal complement of that space, the induced substructure within the cartesian product of the window and the projection space is projected to the projection space to produce a “model structure.” We may use an index space of vectors from the orthogonal complement to move the window around and obtain a “model system” of model structures. We adapt the notion of “general position” to higher dimensions : the projection space is in “doubly general position” with respect to a graph or complex when the projection of that structure maps vertices of that structure injectively into the projection space and the edges or polytopes of that structure injectively so that their dimension is not reduced and disjoint edges and polytopes remain disjoint. We find that if the initial structure was a periodic graph, if the projection space and its complement are in general position with respect to the vertices and edges, and the window is also in general position, then the model system has uncountably many isomorphism classes - with distinct coordination sequences.},
  archive      = {J_TCS},
  author       = {Gregory L. McColm},
  doi          = {10.1016/j.tcs.2021.09.031},
  journal      = {Theoretical Computer Science},
  pages        = {172-189},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Cut-and-project graphs and other complexes},
  volume       = {894},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Explaining DNA structure. <em>TCS</em>, <em>894</em>,
152–171. (<a href="https://doi.org/10.1016/j.tcs.2021.06.011">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The logic of DNA molecules is explained as a consequence of their main functions: efficiently duplicating polymers conveying enormous quantities of biological information with minimal spatial occupancy. An abstract model is provided, where monomers are represented by triangles, that was materialized by means of a 3D printer.},
  archive      = {J_TCS},
  author       = {V. Manca and G. Scollo},
  doi          = {10.1016/j.tcs.2021.06.011},
  journal      = {Theoretical Computer Science},
  pages        = {152-171},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Explaining DNA structure},
  volume       = {894},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Block reversal on finite words. <em>TCS</em>, <em>894</em>,
135–151. (<a href="https://doi.org/10.1016/j.tcs.2021.06.046">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The block reversal of a word is a generalization of the concept of reversal of a word where in place of reversing individual letters, we take the blocks of the word in the reverse order. Since there can be multiple ways in which a word can be divided into blocks, the block reversal of a word forms a set. We study some properties of the block reversal of a word. We characterize words that have the same block reversal set. We find a relation between the block reversal and the non-overlapping inversion defined by Schöniger and Waterman in the year 1992. We characterize words with the minimum and the maximum number of elements in the block reversal. We then study the distribution of palindromes in the block reversal of a word.},
  archive      = {J_TCS},
  author       = {Kalpana Mahalingam and Anuran Maity and Palak Pandoh and Rama Raghavan},
  doi          = {10.1016/j.tcs.2021.06.046},
  journal      = {Theoretical Computer Science},
  pages        = {135-151},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Block reversal on finite words},
  volume       = {894},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Square network on a word. <em>TCS</em>, <em>894</em>,
121–134. (<a href="https://doi.org/10.1016/j.tcs.2021.08.004">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Left-aligned last occurrences of squares (double-square) have provided profound insights into the question of how many distinct squares can be packed on a word ω of length n and brought the best known upper bound 11 n / 6 11n/6 . Other types of alignments such as being center-aligned as well as long distance relations such as being the occurrences of the same square incorporate the squares on ω into a bipartite graph of the squares and positions { 1 , 2 , … , n } {1,2,…,n} , which we call the square network. Packing more and more squares in a limited space certainly induces specific kinds of subgraphs once the square density exceeds a threshold, and if one of the subgraphs is known to be forbidden, the threshold provides an upper bound on the number of distinct squares. In this paper, we designate a specific position of double-squares as P 1 P1 and obtain certain induced subgraphs as well as forbidden ones guaranteed by the presence of P 1 P1 -aligned double squares; an induced subgraph of particular interest expresses the global uniqueness of squares involved.},
  archive      = {J_TCS},
  author       = {Szilárd Zsolt Fazekas and Shinnosuke Seki},
  doi          = {10.1016/j.tcs.2021.08.004},
  journal      = {Theoretical Computer Science},
  pages        = {121-134},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Square network on a word},
  volume       = {894},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Abstract geometrical computation 11: Slanted firing squad
synchronisation on signal machines. <em>TCS</em>, <em>894</em>, 103–120.
(<a href="https://doi.org/10.1016/j.tcs.2021.06.009">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Firing Squad Synchronisation on Cellular Automata is the dynamical synchronisation of finitely many cells without any prior knowledge of their range. This can be conceived as a signal with an infinite speed. Most of the proposed constructions naturally translate to the continuous setting of signal machines and generate fractal figures with an accumulation on a horizontal line, i.e. synchronously, in the space-time diagram. Signal machines are studied in a series of articles named Abstract Geometrical Computation. In the present article, we design a signal machine that is able to synchronise/accumulate on any non-infinite slope. The slope is encoded in the initial configuration . This is done by constructing an infinite tree such that each node computes the way the tree expands. The interest of Abstract Geometrical computation is to do away with the constraint of discrete space, while tackling new difficulties from continuous space. The interest of this paper in particular is to provide basic tools for further study of computable accumulation lines in the signal machine model.},
  archive      = {J_TCS},
  author       = {Jérôme Durand-Lose and Aurélien Emmanuel},
  doi          = {10.1016/j.tcs.2021.06.009},
  journal      = {Theoretical Computer Science},
  pages        = {103-120},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Abstract geometrical computation 11: Slanted firing squad synchronisation on signal machines},
  volume       = {894},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A survey of size counting in population protocols.
<em>TCS</em>, <em>894</em>, 91–102. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.038">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The population protocol model describes a network of n anonymous agents who cannot control with whom they interact. The agents collectively solve a computational problem through random pairwise interactions, each agent updating its state in response to seeing the state of the other agent. Population protocols are equivalent to the model of chemical reaction networks , describing abstract chemical reactions such as A + B → C + D A+B→C+D , when the latter is subject to the restriction that all reactions have two reactants and two products, and all rate constants are 1. The counting problem is that of designing a protocol so that n agents, all starting in the same state, eventually converge to states where each agent encodes in its state an exact or approximate description of population size n . In this survey paper, we describe recent algorithmic advances on the counting problem .},
  archive      = {J_TCS},
  author       = {David Doty and Mahsa Eftekhari},
  doi          = {10.1016/j.tcs.2021.08.038},
  journal      = {Theoretical Computer Science},
  pages        = {91-102},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A survey of size counting in population protocols},
  volume       = {894},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Hybrid and generalized marked systems. <em>TCS</em>,
<em>894</em>, 79–90. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.037">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The circular splicing operation is a language-theoretic operation introduced by Head to model biological phenomena on circular DNA and RNAs. It acts on pairs of circular words under conditions defined by a set of rules. A circular splicing system S is defined by giving an initial set of circular words and a set of rules. S represents a circular language from a generative point of view (splicing language). There are open questions related to the computational power of these systems. For instance, a characterization of circular splicing systems generating regular circular languages is still lacking as well as a characterization of the structure of the regular splicing languages. In this paper we give results about these questions for a special class of hybrid systems named generalized marked systems .},
  archive      = {J_TCS},
  author       = {Clelia De Felice and Rocco Zaccagnino and Rosalba Zizza},
  doi          = {10.1016/j.tcs.2021.08.037},
  journal      = {Theoretical Computer Science},
  pages        = {79-90},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Hybrid and generalized marked systems},
  volume       = {894},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the effects of hierarchical self-assembly for reducing
program-size complexity. <em>TCS</em>, <em>894</em>, 50–78. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.011">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper we present a series of results which show separations between the standard seeded model of self-assembly, Winfree&#39;s abstract Tile Assembly Model (aTAM), and the “seedless” 2-Handed Assembly Model (2HAM), which incorporates the dynamics of hierarchical self-assembly. In particular, we focus on the problem of self-assembling various shapes while minimizing the sizes of tile sets, or “programs”, in each of these models in order to compare and contrast the models. A high-level overview of a subset of these results was presented in a paper by the authors in STACS 2013, but in this version we expand and improve the set of results related to showing separations between the two models according to their abilities to self-assemble various shapes. We exhibit classes of finite shapes that can be self-assembled more efficiently in each model. We also demonstrate infinite shapes that can self-assemble in one model but not in the other, as well as a shape which cannot self-assemble in either model.},
  archive      = {J_TCS},
  author       = {Sarah Cannon and Erik D. Demaine and Martin L. Demaine and Sarah Eisenstat and David Furcy and Matthew J. Patitz and Robert Schweller and Scott M. Summers and Andrew Winslow},
  doi          = {10.1016/j.tcs.2021.09.011},
  journal      = {Theoretical Computer Science},
  pages        = {50-78},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On the effects of hierarchical self-assembly for reducing program-size complexity},
  volume       = {894},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Bi-immunity over different size alphabets. <em>TCS</em>,
<em>894</em>, 31–49. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.005">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper we study various notions of bi-immunity over alphabets with b ≥ 2 b≥2 elements and recursive transformations between sequences on different alphabets which preserve them. Furthermore, we extend the study from sequences bounded by a constant to sequences over the alphabet of all natural numbers, which may or may not be bounded by a recursive function , and relate them to the Turing degrees in which they can occur.},
  archive      = {J_TCS},
  author       = {Cristian S. Calude and Karen Frilya Celine and Ziyuan Gao and Sanjay Jain and Ludwig Staiger and Frank Stephan},
  doi          = {10.1016/j.tcs.2021.09.005},
  journal      = {Theoretical Computer Science},
  pages        = {31-49},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Bi-immunity over different size alphabets},
  volume       = {894},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Spectral concepts in genome informational analysis.
<em>TCS</em>, <em>894</em>, 23–30. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.039">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The concept of k -spectrum for genomes is here investigated as a basic tool to analyze genomes. Related spectral notions based on k -mers are introduced with some related mathematical properties which are relevant for informational analysis of genomes. Procedures to generate spectral segmentations of genomes are provided and are tested (under several values of length k for k -mers) on cases of real genomes, such as some human chromosomes and Saccharomyces cerevisiae.},
  archive      = {J_TCS},
  author       = {V. Bonnici and G. Franco and V. Manca},
  doi          = {10.1016/j.tcs.2021.06.039},
  journal      = {Theoretical Computer Science},
  pages        = {23-30},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Spectral concepts in genome informational analysis},
  volume       = {894},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the domino problem of the baumslag-solitar groups.
<em>TCS</em>, <em>894</em>, 12–22. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.002">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In [1] we construct aperiodic tile sets on the Baumslag-Solitar groups B S ( m , n ) BS(m,n) . Aperiodicity plays a central role in the undecidability of the classical domino problem on Z 2 Z2 , and analogously to this we state as a corollary of the main construction that the Domino problem is undecidable on all Baumslag-Solitar groups. In the present work we elaborate on the claim and provide a full proof of this fact. We also provide details of another result reported in [1] : there are tiles that tile the Baumslag-Solitar group B S ( m , n ) BS(m,n) but none of the valid tilings is recursive. The proofs are based on simulating piecewise affine functions by tiles on B S ( m , n ) BS(m,n) .},
  archive      = {J_TCS},
  author       = {Nathalie Aubrun and Jarkko Kari},
  doi          = {10.1016/j.tcs.2021.09.002},
  journal      = {Theoretical Computer Science},
  pages        = {12-22},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On the domino problem of the baumslag-solitar groups},
  volume       = {894},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Coherent network partitions: Characterizations with cographs
and prime graphs. <em>TCS</em>, <em>894</em>, 3–11. (<a
href="https://doi.org/10.1016/j.tcs.2021.10.002">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We continue to study coherent partitions of graphs whereby the vertex set is partitioned into subsets that induce biclique spanned subgraphs. The problem of identifying the minimum number of edges to obtain biclique spanned connected components (CNP), called the coherence number, is NP-hard even on bipartite graphs . Here, we propose a graph transformation geared towards obtaining an O ( log ⁡ n ) O(log⁡n) -approximation algorithm for the CNP on a bipartite graph with n vertices. The transformation is inspired by a new characterization of biclique spanned subgraphs. In addition, we study coherent partitions on prime graphs, and show that finding coherent partitions reduces to the problem of finding coherent partitions in a prime graph. Therefore, these results provide future directions for approximation algorithms for the coherence number of a given graph.},
  archive      = {J_TCS},
  author       = {Angela Angeleska and Sara Omranian and Zoran Nikoloski},
  doi          = {10.1016/j.tcs.2021.10.002},
  journal      = {Theoretical Computer Science},
  pages        = {3-11},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Coherent network partitions: Characterizations with cographs and prime graphs},
  volume       = {894},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Building bridges – honoring nataša jonoska on the occasion
of her 60th birthday. <em>TCS</em>, <em>894</em>, 1–2. (<a
href="https://doi.org/10.1016/j.tcs.2021.10.021">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_TCS},
  author       = {Paola Bonizzoni and Lila Kari and Ion Petre and Grzegorz Rozenberg},
  doi          = {10.1016/j.tcs.2021.10.021},
  journal      = {Theoretical Computer Science},
  pages        = {1-2},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Building bridges – honoring nataša jonoska on the occasion of her 60th birthday},
  volume       = {894},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021b). Editorial. <em>TCS</em>, <em>893</em>, iii. (<a
href="https://doi.org/10.1016/S0304-3975(21)00633-2">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_TCS},
  author       = {Lila Kari ( Editor-in-Chief )},
  doi          = {10.1016/S0304-3975(21)00633-2},
  journal      = {Theoretical Computer Science},
  pages        = {iii},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Editorial},
  volume       = {893},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Automaton-ABC: A statistical method to estimate the
probability of spatio-temporal properties for parametric markov
population models. <em>TCS</em>, <em>893</em>, 191–219. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.039">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present an adaptation of the Approximate Bayesian Computation method to estimate the satisfaction probability function of a temporal logic property for Markov Population Models. In this paper, we tackle the problem of estimating the satisfaction probability function of a temporal logic property w.r.t. a parametric Markovian model of Chemical Reaction Network . We want to assess the probability with which the trajectories generated by a parametric Markov Population Model (MPM) satisfy a logical formula over the whole parameter space. In the first step of the work, we formally define a distance between a trajectory of an MPM and a logical property. If the distance is 0, the trajectory satisfies the property. The larger the distance is, further the trajectory is from satisfying the property. In the second step, we adapt the Approximate Bayesian Computation method using the distance defined in the first step. This adaptation yields a new algorithm, called automaton-ABC, whose output is a density function that directly leads to the estimation of the desired satisfaction probability function . We apply our methodology to several examples and models, and we compare it to state-of-the-art techniques. We show that the sequential version of our algorithm relying on ABC-SMC leads to an efficient exploration of the parameter space with respect to the formula and gives good approximations of the satisfaction probability function at a reduced computational cost.},
  archive      = {J_TCS},
  author       = {Mahmoud Bentriou and Paolo Ballarini and Paul-Henry Cournède},
  doi          = {10.1016/j.tcs.2021.09.039},
  journal      = {Theoretical Computer Science},
  pages        = {191-219},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Automaton-ABC: A statistical method to estimate the probability of spatio-temporal properties for parametric markov population models},
  volume       = {893},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The generalized 3-connectivity of two kinds of regular
networks. <em>TCS</em>, <em>893</em>, 183–190. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.013">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The locally twisted cube L T Q n LTQn and the generalized hypercube G Q ( m 1 GQ(m1 , m 2 m2 , ⋯ , m n ) ⋯,mn) are two important kinds of regular graphs in the modelling interconnection networks . For measuring the fault tolerance and reliability of interconnection networks , the generalized k -connectivity was introduced, which is a generalization of the traditional connectivity. More precisely, let S ⊆ V ( G ) S⊆V(G) and κ G ( S ) κG(S) denote the maximum number r of trees T 1 , T 2 , ⋯ , T r T1,T2,⋯,Tr such that V ( T i ) ∩ V ( T j ) = S V(Ti)∩V(Tj)=S and E ( T i ) ∩ E ( T j ) = ∅ E(Ti)∩E(Tj)=∅ for any integers 1 ≤ i ≠ j ≤ r 1≤i≠j≤r . For an integer k with 2 ≤ k ≤ | V ( G ) | 2≤k≤|V(G)| , the generalized k -connectivity of G , denoted by κ k ( G ) κk(G) , is defined as κ k ( G ) = min ⁡ { κ G ( S ) | S ⊆ V ( G ) and | S | = k } κk(G)=min⁡{κG(S)|S⊆V(G)and|S|=k} . In this paper, we study the generalized 3-connectivity of the locally twisted cube L T Q n LTQn and the generalized hypercube G Q ( m 1 , m 2 , ⋯ , m n ) GQ(m1,m2,⋯,mn) , and get two main results that κ 3 ( L T Q n ) = n − 1 κ3(LTQn)=n−1 and κ 3 ( G Q ( m 1 , m 2 , ⋯ , m n ) ) = ∑ i = 1 n ( m i − 1 ) − 1 κ3(GQ(m1,m2,⋯,mn))=∑i=1n(mi−1)−1 .},
  archive      = {J_TCS},
  author       = {Jing Wang},
  doi          = {10.1016/j.tcs.2021.09.013},
  journal      = {Theoretical Computer Science},
  pages        = {183-190},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The generalized 3-connectivity of two kinds of regular networks},
  volume       = {893},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The fractional (strong) matching preclusion number of
complete k-partite graph. <em>TCS</em>, <em>893</em>, 176–182. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.004">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The fractional (strong) matching preclusion number of a graph G , denoted by f ( s ) m p ( G ) f(s)mp(G) , is the minimum number of edges (and vertices) whose deletion results in a graph with no fractional perfect matching . Let G n 1 , n 2 , … , n k Gn1,n2,…,nk be the complete k -partite graph, whose vertex set can be partitioned into k parts, each has n i ( 1 ≤ i ≤ k ) ni(1≤i≤k) vertices and whose edge set contains all edges between two distinct parts. In this paper, we determine f m p ( G n 1 , n 2 , … , n k ) fmp(Gn1,n2,…,nk) and f s m p ( G n 1 , n 2 , … , n k ) fsmp(Gn1,n2,…,nk) .},
  archive      = {J_TCS},
  author       = {Yu Luan and Mei Lu and Yi Zhang},
  doi          = {10.1016/j.tcs.2021.09.004},
  journal      = {Theoretical Computer Science},
  pages        = {176-182},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The fractional (strong) matching preclusion number of complete k-partite graph},
  volume       = {893},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Time complexity analysis of evolutionary algorithms for
2-hop (1,2)-minimum spanning tree problem. <em>TCS</em>, <em>893</em>,
159–175. (<a href="https://doi.org/10.1016/j.tcs.2021.09.003">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Minimum Spanning Tree problem (abbr. MSTP) is a well-known combinatorial optimization problem that has been extensively studied by the researchers in the field of evolutionary computing to theoretically analyze the optimization performance of evolutionary algorithms . Within the paper, we consider a constrained version of the problem named 2-Hop ( 1 , 2 1,2 )-Minimum Spanning Tree problem (abbr. 2H-( 1 , 2 1,2 )-MSTP) in the context of evolutionary algorithms , which has been shown to be NP-hard. Following how evolutionary algorithms are applied to solve the MSTP, we first consider the evolutionary algorithms with search points in edge-based representation adapted to the 2H-( 1 , 2 1,2 )-MSTP (including the ( 1 + 1 1+1 ) EA, Global Simple Evolutionary Multi-Objective Optimizer and its two variants). More specifically, we separately investigate the upper bounds on their expected time (i.e., the expected number of fitness evaluations) to obtain a 3 2 32 -approximate solution with respect to different fitness functions. Inspired by the special structure of 2-hop spanning trees, we also consider the ( 1 + 1 1+1 ) EA with search points in vertex-based representation that seems not so natural for the problem and give an upper bound on its expected time to obtain a 3 2 32 -approximate solution, which is better than the above mentioned ones.},
  archive      = {J_TCS},
  author       = {Feng Shi and Frank Neumann and Jianxin Wang},
  doi          = {10.1016/j.tcs.2021.09.003},
  journal      = {Theoretical Computer Science},
  pages        = {159-175},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Time complexity analysis of evolutionary algorithms for 2-hop (1,2)-minimum spanning tree problem},
  volume       = {893},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Post-processing optimization for continuous-variable quantum
key distribution. <em>TCS</em>, <em>893</em>, 146–158. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.023">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The performance of a continuous-variable quantum key distribution (CVQKD) protocol depends on the efficiency of the post-processing of measurement results. The post-processing methods extract statistical information from the raw data, establish the mutual knowledge between the parties, and produce a final key that provides absolute security. The post-processing phase is a bottleneck in CVQKD with crucial importance to the efficiency and protocol attributes. Post-processing uses the raw data of the parties generated by the quantum-level transmission and a classical authenticated channel to generate a secret key between the parties. The current reconciliation procedures require high-complexity coding with moderate resulting efficiency. Here we define an optimization method for post-processing in continuous-variable quantum key distribution. The reconciliation method achieves additive Gaussian noise on the random secret for arbitrarily low dimensional blocks. The model consumes all information from the raw data blocks to provide maximal efficiency and security via standard operations. The results can be realized by generic Gaussian coding schemes, allowing an easily implementation for experimental CVQKD protocols.},
  archive      = {J_TCS},
  author       = {Laszlo Gyongyosi},
  doi          = {10.1016/j.tcs.2021.08.023},
  journal      = {Theoretical Computer Science},
  pages        = {146-158},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Post-processing optimization for continuous-variable quantum key distribution},
  volume       = {893},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Computational power of sequential dendrite p systems.
<em>TCS</em>, <em>893</em>, 133–145. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.008">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Dendrite P (DeP) systems are a new variant of neural-like P systems, abstracted by the information processing and feedback mechanisms of dendrites. In the variant, a global block is assumed to synchronize all of neurons, hence, DeP systems work in synchronous mode. This paper investigates sequential version of the variant, that is, sequential dendrite P (SDeP) systems. Based on maximum number of spikes in neurons, two sequential modes are distinguished: max-sequentiality and max-pseudo-sequentiality strategies. SDeP systems have two interesting and recognizable features: (i) it behaves as a firing-storing process; (ii) cooperative firing mechanism. The computational completeness of SDeP systems is discussed. We prove that SDeP systems can be used as Turing universal number generating/accepting devices for max-sequentiality and max-pseudo-sequentiality strategies. We also establish a small universal function computing device of SDeP systems with 91 neurons in max-sequentiality strategy.},
  archive      = {J_TCS},
  author       = {Tingting Bao and Qian Yang and Hong Peng and Xiaohui Luo and Jun Wang and Xiaoxiao Song},
  doi          = {10.1016/j.tcs.2021.08.008},
  journal      = {Theoretical Computer Science},
  pages        = {133-145},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Computational power of sequential dendrite p systems},
  volume       = {893},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Classically simulating quantum circuits with local
depolarizing noise. <em>TCS</em>, <em>893</em>, 117–132. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.025">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the effect of noise on the classical simulatability of quantum circuits defined by computationally tractable (CT) states and efficiently computable sparse (ECS) operations. Examples of such circuits, which we call CT-ECS circuits, are IQP , Clifford Magic, and conjugated Clifford circuits. This means that there exist various CT-ECS circuits such that their output probability distributions are anti-concentrated and not classically simulatable in the noise-free setting (under plausible assumptions). First, we consider a noise model where a depolarizing channel with an arbitrarily small constant rate is applied to each qubit at the end of computation. We show that, under this noise model, if an approximate value of the noise rate is known, any CT-ECS circuit with an anti-concentrated output probability distribution is classically simulatable. This indicates that the presence of small noise drastically affects the classical simulatability of CT-ECS circuits. Then, we consider an extension of the noise model where the noise rate can vary with each qubit, and provide a similar sufficient condition for classically simulating CT-ECS circuits with anti-concentrated output probability distributions.},
  archive      = {J_TCS},
  author       = {Yasuhiro Takahashi and Yuki Takeuchi and Seiichiro Tani},
  doi          = {10.1016/j.tcs.2021.07.025},
  journal      = {Theoretical Computer Science},
  pages        = {117-132},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Classically simulating quantum circuits with local depolarizing noise},
  volume       = {893},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Matrix approach to spanning matroids of rough sets and its
application to attribute reduction. <em>TCS</em>, <em>893</em>, 105–116.
(<a href="https://doi.org/10.1016/j.tcs.2021.06.037">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Rough set theory is a granular computing tool used to deal with ambiguity and uncertainty in information systems. However, many optimization problems in rough sets, such as attribute reduction , are NP-hard problems, and most of the algorithms for these problems are greedy. As a complex mathematical structure , matroids provide a powerful tool for solving combinatorial optimization problems related to attribute reduction . Therefore, it is necessary to study the combination of matroids and rough sets. This paper uses rough sets and matrix approaches to spanning matroids. Moreover, the features of spanning matroids are applied to attribute reduction in decision information systems. Firstly, we construct spanning sets based on equivalence relations which can induce matroids called spanning matroids. Secondly, some features of spanning matroids, such as closed sets, bases, are studied by matrix method. Finally, the judgment theorems with the features of spanning matroids are proposed for addressing the problems about attribute reduction in decision information systems. Simultaneously, the sufficient and necessary conditions for distinguishing upper approximation reduction in inconsistent decision information systems are obtained from the viewpoint of spanning matroids.},
  archive      = {J_TCS},
  author       = {Lirun Su and Fusheng Yu},
  doi          = {10.1016/j.tcs.2021.06.037},
  journal      = {Theoretical Computer Science},
  pages        = {105-116},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Matrix approach to spanning matroids of rough sets and its application to attribute reduction},
  volume       = {893},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Computing difference abstractions of linear equation
systems. <em>TCS</em>, <em>893</em>, 72–104. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.030">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Abstract interpretation was proposed for predicting changes of reaction networks with partial kinetic information in systems biology . This requires to compute the set of difference abstractions of a system of linear equations under nonlinear constraints. We present the first practical algorithm that can compute the difference abstractions of linear equation systems exactly. We also present a new heuristics based on minimal support consequences for overapproximating the set of difference abstractions. Our algorithms rely on elementary modes, first-order definitions, and finite domain constraint programming. We implemented our algorithms and applied them to change prediction in systems biology . It turns out experimentally that the new heuristics is often exact in practice, while outperforming the exact algorithm. This journal article extends on a paper published at the 17th International Conference on Computational Methods in Systems Biology (CMSB&#39;2019) [1] .},
  archive      = {J_TCS},
  author       = {Emilie Allart and Joachim Niehren and Cristian Versari},
  doi          = {10.1016/j.tcs.2021.06.030},
  journal      = {Theoretical Computer Science},
  pages        = {72-104},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Computing difference abstractions of linear equation systems},
  volume       = {893},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Control languages accepted by labeled spiking neural p
systems with rules on synapses. <em>TCS</em>, <em>893</em>, 60–71. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.027">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Spiking neural P systems with rules on synapses (RSSNP systems) are a class of computation models which are inspired by the information processing and communication manner of neurons. In this work, we consider labeled RSSNP systems (lRSSNP systems), where each rule is assigned either with a label chosen from an alphabet Σ or with the empty label λ . A string over an alphabet is accepted by an lRSSNP system if the string is processed from left to right by the system in the sense that in a step only rules labeled with the processed symbol or with λ are used (not both), and the system reaches a final configuration in the moment when the whole string is processed. The set of all accepted strings is categorized as the restricted (computations are done with the application of the rules labeled with symbols from the given alphabet) control language and the unrestricted (rules labeled with λ are allowed in the computations) control language of the system. We study the language accepting power of lRSSNP systems using only standard spiking rules by comparing the family of control languages of lRSSNP systems with the families of languages in the Chomsky hierarchy. It is proved that restricted lRSSNP systems can accept no more than context-sensitive languages, and unrestricted lRSSNP systems can accept recursively enumerable languages .},
  archive      = {J_TCS},
  author       = {Luping Zhang and Fei Xu and Ajeesh Ramanujan and K.G. Subramanian},
  doi          = {10.1016/j.tcs.2021.06.027},
  journal      = {Theoretical Computer Science},
  pages        = {60-71},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Control languages accepted by labeled spiking neural p systems with rules on synapses},
  volume       = {893},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A large-scale assessment of exact lumping of quantitative
models in the BioModels repository. <em>TCS</em>, <em>893</em>, 41–59.
(<a href="https://doi.org/10.1016/j.tcs.2021.06.026">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Chemical reaction networks are a popular formalism for modeling biological processes which supports both a deterministic and a stochastic interpretation based on ordinary differential equations and continuous-time Markov chains, respectively. In most cases, these models do not enjoy analytical solution, thus typically requiring expensive computational methods based on numerical solvers or stochastic simulations. Exact model reduction techniques can be used as an aid to lower the analysis cost by providing reduced networks that preserve the dynamics of interest to the modeler without incurring any approximation error. We hereby consider a family of techniques for both deterministic and stochastic networks which are based on equivalence relations over the species in the network, leading to a coarse graining which provides the exact aggregate time-course evolution for each equivalence class. We present a large-scale empirical assessment on the BioModels repository by measuring their compression capability over 579 models. Through a number of selected case studies, we also show their ability in yielding physically interpretable reductions that can reveal dynamical patterns of the bio-molecular processes under consideration, independently of the values of the kinetic parameters used in the models.},
  archive      = {J_TCS},
  author       = {Isabel Cristina Perez-Verona and Mirco Tribastone and Andrea Vandin},
  doi          = {10.1016/j.tcs.2021.06.026},
  journal      = {Theoretical Computer Science},
  pages        = {41-59},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A large-scale assessment of exact lumping of quantitative models in the BioModels repository},
  volume       = {893},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Push-forward method for piecewise deterministic biochemical
simulations. <em>TCS</em>, <em>893</em>, 17–40. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.025">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A biochemical network can be simulated by a set of ordinary differential equations (ODE) under well-stirred reactor conditions, for large numbers of molecules, and frequent reactions. This is no longer a robust representation when some molecular species are in small numbers and reactions changing them are infrequent. In this case, discrete stochastic events trigger changes of the smooth deterministic dynamics of the biochemical network. Piecewise-deterministic Markov processes (PDMP) are well adapted for describing such situations. Although PDMP models are now well established in biology, these models remain computationally challenging. Previously we have introduced the push-forward method to compute how the probability measure is spread by the deterministic ODE flow of PDMPs, through the use of analytic expressions of the corresponding semigroup. In this paper we provide a more general simulation algorithm that works also for non-integrable systems. The method can be used for biochemical simulations with applications in fundamental biology, biotechnology and biocomputing. This work is an extended version of the work presented at the conference CMSB2019.},
  archive      = {J_TCS},
  author       = {Guilherme C.P. Innocentini and Arran Hodgkinson and Fernando Antoneli and Arnaud Debussche and Ovidiu Radulescu},
  doi          = {10.1016/j.tcs.2021.05.025},
  journal      = {Theoretical Computer Science},
  pages        = {17-40},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Push-forward method for piecewise deterministic biochemical simulations},
  volume       = {893},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Long lived transients in gene regulation. <em>TCS</em>,
<em>893</em>, 1–16. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.023">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Gene expression is regulated by the set of transcription factors (TFs) that bind to the promoter. The ensuing regulating function is often represented as a combinational logic circuit, where output (gene expression) is determined by current input values (promoter bound TFs) only. However, the simultaneous arrival of TFs is a strong assumption, since transcription and translation of genes introduce intrinsic time delays and there is no global synchronisation among the arrival times of different molecular species at their targets. We present an experimentally implementable genetic circuit with two inputs and one output, which in the presence of small delays in input arrival, exhibits qualitatively distinct population-level phenotypes, over timescales that are longer than typical cell doubling times. From a dynamical systems point of view, these phenotypes represent long-lived transients: although they converge to the same value eventually, they do so after a very long time span. The key feature of this toy model genetic circuit is that, despite having only two inputs and one output, it is regulated by twenty-three distinct DNA-TF configurations, two of which are more stable than others (DNA looped states), one promoting and another blocking the expression of the output gene. Small delays in input arrival time result in a majority of cells in the population quickly reaching the stable state associated with the first input, while exiting of this stable state occurs at a slow timescale. In order to mechanistically model the behaviour of this genetic circuit, we used a rule-based modelling language , and implemented a grid-search to find parameter combinations giving rise to long-lived transients. Our analysis shows that in the absence of feedback, there exist path-dependent gene regulatory mechanisms based on the long timescale of transients. The behaviour of this toy model circuit suggests that gene regulatory networks can exploit event timing to create phenotypes, and it opens the possibility that they could use event timing to memorise events, without regulatory feedback. The model reveals the importance of (i) mechanistically modelling the transitions between the different DNA-TF states, and (ii) employing transient analysis thereof.},
  archive      = {J_TCS},
  author       = {Tatjana Petrov and Claudia Igler and Ali Sezgin and Thomas A. Henzinger and Calin C. Guet},
  doi          = {10.1016/j.tcs.2021.05.023},
  journal      = {Theoretical Computer Science},
  pages        = {1-16},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Long lived transients in gene regulation},
  volume       = {893},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Nonexistence of uniformly most reliable two-terminal graphs.
<em>TCS</em>, <em>892</em>, 279–288. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.025">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A two-terminal graph G = ( V , E ) G=(V,E) is a simple and undirected graph with two specified target vertices s and t in V . In G , if each edge survives independently with a fixed probability p , the two-terminal reliability is the probability that two target vertices are connected. A two-terminal graph is uniformly most reliable if its reliability is not less than the reliability of any other graph with same number of vertices and edges for all p . Betrand et al. proved that there is no uniformly most reliable two-terminal graph if either n ≥ 11 n≥11 and 20 ≤ m ≤ 3 n − 9 20≤m≤3n−9 or n ≥ 8 n≥8 and ( n 2 ) − ⌊ ( n − 2 ) / 2 ⌋ ≤ m ≤ ( n 2 ) − 2 (n2)−⌊(n−2)/2⌋≤m≤(n2)−2 . In this paper, we further prove that there is no uniformly most reliable two-terminal graph if n ≥ 6 n≥6 and 3 n − 6 3n−6&amp;lt;m≤(n2)−2 in a different way.},
  archive      = {J_TCS},
  author       = {Sun Xie and Haixing Zhao and Jun Yin},
  doi          = {10.1016/j.tcs.2021.09.025},
  journal      = {Theoretical Computer Science},
  pages        = {279-288},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Nonexistence of uniformly most reliable two-terminal graphs},
  volume       = {892},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Enumeration of subtrees and BC-subtrees with maximum degree
no more than k in trees. <em>TCS</em>, <em>892</em>, 258–278. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.024">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The subtrees and BC-subtrees (subtrees where any two leaves are at even distance apart) have been intensively studied in recent years. Such structures, under special constraints on degrees, have a wide range of applications in many fields. By way of an approach based on generating functions, we present novel recursive algorithms for enumerating various subtrees and BC-subtrees of maximum degree ≤ k in trees. The algorithms are explained through detailed examples. We also briefly discuss, in trees, the densities of subtrees (resp. BC-subtrees) with maximum degree ≤ k among all subtrees (resp. BC-subtrees). For a tree of order n , the novelly proposed algorithms have multiple advantages. (1) Novel ( k + 2 ) (resp. ( 2 k + 3 ) ) variable generating functions were introduced to construct the algorithms. (2) The proposed algorithms solved the fast enumerating problem of subtree (resp. BC-subtrees) with maximum degree constraint, and also make the subtree (resp. BC-subtrees) enumerating algorithms proposed by Yan and Yeh [1] (resp. Yang et al. [2] ) a special case of ours with k = n − 1 . (3) The time complexity of our algorithm for subtree (resp. BC-subtrees) is O ( k n ) (resp. O ( k n 2 ) ), which is much faster than the O ( n 2 ) (resp. O ( k n 3 ) ) time method based on algorithm proposed in [1] (resp. [2] ).},
  archive      = {J_TCS},
  author       = {Yu Yang and Xiao-xiao Li and Meng-yuan Jin and Long Li and Hua Wang and Xiao-Dong Zhang},
  doi          = {10.1016/j.tcs.2021.09.024},
  journal      = {Theoretical Computer Science},
  pages        = {258-278},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Enumeration of subtrees and BC-subtrees with maximum degree no more than k in trees},
  volume       = {892},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the role of 3s for the 1-2-3 conjecture. <em>TCS</em>,
<em>892</em>, 238–257. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.023">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The 1-2-3 Conjecture states that every connected graph different from K 2 admits a proper 3-(edge-)labelling, i.e. , can have its edges labelled with 1 , 2 , 3 so that no two adjacent vertices are incident to the same sum of labels. In connection with some recent optimisation variants of this conjecture, in this paper we investigate the role of the label 3 in proper 3-labellings of graphs. An intuition from previous investigations is that, in general, it should always be possible to produce proper 3-labellings assigning label 3 to a only few edges. We prove that, for every p ≥ 0 , there are various graphs needing at least p 3s in their proper 3-labellings. Actually, deciding whether a given graph can be properly 3-labelled with p 3s is NP -complete for every p ≥ 0 . We also focus on classes of 3-chromatic graphs. For various classes of such graphs (cacti, cubic graphs, triangle-free planar graphs , etc.), we prove that there is no p ≥ 1 such that all their graphs admit proper 3-labellings assigning label 3 to at most p edges. In such cases, we provide lower and upper bounds on the number of 3s needed.},
  archive      = {J_TCS},
  author       = {Julien Bensmail and Foivos Fioravantes and Fionn Mc Inerney},
  doi          = {10.1016/j.tcs.2021.09.023},
  journal      = {Theoretical Computer Science},
  pages        = {238-257},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On the role of 3s for the 1-2-3 conjecture},
  volume       = {892},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Tightly secure ring signatures in the standard model.
<em>TCS</em>, <em>892</em>, 208–237. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.022">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Ring signatures allow a user to sign messages as a member of a set of users, which is called the ring . This primitive ensures that nobody can detect which member in the ring signs the message. Libert, Peters, and Qian (2018) [24] proposed the first tightly secure ring signature scheme with O ( log ⁡ n ) O(log⁡n) signature size in the random oracle model , where n is the size of a ring. To our knowledge, a tightly secure ring signature scheme has never been reported without depending on the random oracle methodology. In this paper, we propose two generic constructions of tightly secure ring signatures in the standard model. Our first (resp., second) construction is secure in the common reference string model (resp., the plain model). Both of our constructions are secure under the decisional linear assumption over the pairing groups. Our first generic construction has a more efficient instantiation than our second one. While our second generic construction does not have an efficient instantiation, its signature size achieves O ( log ⁡ n ) O(log⁡n) asymptotically, which is the same as one of the Libert et al.&#39;s scheme.},
  archive      = {J_TCS},
  author       = {Keisuke Hara and Keisuke Tanaka},
  doi          = {10.1016/j.tcs.2021.09.022},
  journal      = {Theoretical Computer Science},
  pages        = {208-237},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Tightly secure ring signatures in the standard model},
  volume       = {892},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Uniform bipartition in the population protocol model with
arbitrary graphs. <em>TCS</em>, <em>892</em>, 187–207. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.020">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we focus on the uniform bipartition problem in the population protocol model. This problem aims to divide a population into two groups of equal size. In particular, we consider the problem in the context of arbitrary communication graphs . As a result, we investigate the solvability of the uniform bipartition problem with arbitrary communication graphs when agents in the population have designated initial states, under various assumptions such as the existence of a base station, symmetry of the protocol, and fairness of the execution. When the problem is solvable, we present protocols for uniform bipartition. When global fairness is assumed, the space complexity of our solutions is tight.},
  archive      = {J_TCS},
  author       = {Hiroto Yasumi and Fukuhito Ooshita and Michiko Inoue and Sébastien Tixeuil},
  doi          = {10.1016/j.tcs.2021.09.020},
  journal      = {Theoretical Computer Science},
  pages        = {187-207},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Uniform bipartition in the population protocol model with arbitrary graphs},
  volume       = {892},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Polynomial-time algorithms for submodular laplacian systems.
<em>TCS</em>, <em>892</em>, 170–186. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.019">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Let G = ( V , E ) G=(V,E) be an undirected graph , L G ∈ R V × V LG∈RV×V be the associated Laplacian matrix , and b ∈ R V b∈RV be a vector. Solving the Laplacian system L G x = b LGx=b has numerous applications in theoretical computer science , machine learning , and network analysis. Recently, the notion of the Laplacian operator L F : R V → 2 R V LF:RV→2RV for a submodular transformation F : 2 V → R + E F:2V→R+E was introduced, which can handle undirected graphs, directed graphs, hypergraphs , and joint distributions in a unified manner. In this study, we show that the submodular Laplacian system L F ( x ) ∋ b LF(x)∋b can be solved in polynomial time . Furthermore, we prove that even when the submodular Laplacian system has no solution, we can solve its regression form in polynomial time . Finally, we discuss potential applications of submodular Laplacian systems in machine learning and network analysis.},
  archive      = {J_TCS},
  author       = {Kaito Fujii and Tasuku Soma and Yuichi Yoshida},
  doi          = {10.1016/j.tcs.2021.09.019},
  journal      = {Theoretical Computer Science},
  pages        = {170-186},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Polynomial-time algorithms for submodular laplacian systems},
  volume       = {892},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Computable subcontinua of semicomputable chainable hausdorff
continua. <em>TCS</em>, <em>892</em>, 155–169. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.018">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In the setting of computable topological spaces, we consider semicomputable, chainable Hausdorff continua. If such a continuum S is decomposable, it can be computably approximated; more precisely, for every open cover U U , there exist two computable points a ˆ aˆ , b ˆ bˆ and a computable subcontinuum S ˆ Sˆ that is chainable from a ˆ aˆ to b ˆ bˆ and is U U -close to S .},
  archive      = {J_TCS},
  author       = {Vedran Čačić and Marko Horvat and Zvonko Iljazović},
  doi          = {10.1016/j.tcs.2021.09.018},
  journal      = {Theoretical Computer Science},
  pages        = {155-169},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Computable subcontinua of semicomputable chainable hausdorff continua},
  volume       = {892},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Re-embedding a 1-plane graph for a straight-line drawing in
linear time. <em>TCS</em>, <em>892</em>, 132–154. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.015">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A graph is called a 1-planar graph, if it admits a 1-plane embedding (i.e., an embedding with at most one crossing per edge). Thomassen characterized forbidden configuration for straight-line drawings of 1-plane graphs [Thomassen (1988) [38] ]. In this paper, we investigate the problem of re-embedding a 1-plane graph (i.e., 1-planar graph with a given 1-planar embedding) to admit a straight-line drawing, preserving the original set of edge crossings of 1-plane graphs. More specifically, we characterize forbidden configurations such that a given 1-plane graph can be re-embedded into a straight-line drawable 1-plane embedding if and only if it does not contain the configurations. We present a linear-time algorithm for computing a straight-line drawable 1-plane re-embedding, if one exists, or finding the forbidden configuration, otherwise. To design a linear-time algorithm, we exploit a data structure called an inclusion-forest that summarizes the inclusion relationships between non-intersecting cycles of a plane graph.},
  archive      = {J_TCS},
  author       = {Seok-Hee Hong and Hiroshi Nagamochi},
  doi          = {10.1016/j.tcs.2021.09.015},
  journal      = {Theoretical Computer Science},
  pages        = {132-154},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Re-embedding a 1-plane graph for a straight-line drawing in linear time},
  volume       = {892},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Efficient computation of spatial queries over points stored
in k2-tree compact data structures. <em>TCS</em>, <em>892</em>, 108–131.
(<a href="https://doi.org/10.1016/j.tcs.2021.09.012">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present efficient algorithms to compute two spatial queries over points stored in compact data structures . The former is the K -Nearest Neighbors Query (KNN) which given a point q gets the K -nearest points to q . The latter query is the K -Closest Pair Query (KCPQ), which obtains the K -pairs of closest neighbors between two set of points R and S on the same spatial plane. There are several efficient implementations of these queries, which work mainly with data stored in secondary memory. However, these implementations do not scale well over large datasets. Our algorithms compute the queries over large datasets of points stored in compact data structures , in main memory. Compact data structures are structures that allow efficiently storage data in main memory and query them in their compressed form. We use the k 2 k2 -tree compact structure to represent points of interest. Through experimentation over synthetic and real datasets, we show that by using the k 2 k2 -tree we can work with large datasets in main memory, and that the KNN and KCPQ spatial data queries can be efficiently computed over the compact data structures. We also implement a JAVA library that is available for the academic and industrial community.},
  archive      = {J_TCS},
  author       = {Fernando Santolaya and Mónica Caniupán and Luis Gajardo and Miguel Romero and Rodrigo Torres-Avilés},
  doi          = {10.1016/j.tcs.2021.09.012},
  journal      = {Theoretical Computer Science},
  pages        = {108-131},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Efficient computation of spatial queries over points stored in k2-tree compact data structures},
  volume       = {892},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Efficient public-key encryption with equality test from
lattices. <em>TCS</em>, <em>892</em>, 85–107. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.010">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Public-key encryption with equality (PKEET) test enables testing if two ciphertexts , possibly under two different public keys , encrypt the same messages. Recent research on PKEET considers the setting where the testing ability is delegated to semi-trusted parties to negate unfettered chosen-plaintext attacks. In this work, we revise and enhance the PKEET security model, and introduce a new property of unmaskability which further prevents an attacker from skirting the test. We then propose a simple and efficient PKEET system with adaptive chosen-ciphertext security, provably secure under our revised security model, from either plain or ring lattice assumptions. The construction adopts a direct approach which significantly departs from the existing way of building such systems. Compared with existing literature, our system relies on weaker learning-with-errors assumptions while also being more efficient and providing better security.},
  archive      = {J_TCS},
  author       = {Qinyi Li and Xavier Boyen},
  doi          = {10.1016/j.tcs.2021.09.010},
  journal      = {Theoretical Computer Science},
  pages        = {85-107},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Efficient public-key encryption with equality test from lattices},
  volume       = {892},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Faster exponential-time algorithms for approximately
counting independent sets. <em>TCS</em>, <em>892</em>, 48–84. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.009">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Counting the independent sets of a graph is a classical #P-complete problem, even in the bipartite case. We give an exponential-time approximation scheme for this problem which is faster than the best known algorithm for the exact problem. The running time of our algorithm on general graphs with error tolerance ε is at most O ( 2 0.2680 n ) O(20.2680n) times a polynomial in 1 / ε 1/ε . On bipartite graphs , the exponential term in the running time is improved to O ( 2 0.2372 n ) O(20.2372n) . Our methods combine techniques from exact exponential algorithms with techniques from approximate counting. Along the way we generalise (to the multivariate case) the FPTAS of Sinclair, Srivastava , Štefankovič and Yin for approximating the hard-core partition function on graphs with bounded connective constant. Also, we obtain an FPTAS for counting independent sets on graphs with no vertices with degree at least 6 whose neighbours&#39; degrees sum to 27 or more. By a result of Sly, there is no FPTAS that applies to all graphs with maximum degree 6 unless P = NP P=NP .},
  archive      = {J_TCS},
  author       = {Leslie Ann Goldberg and John Lapinskas and David Richerby},
  doi          = {10.1016/j.tcs.2021.09.009},
  journal      = {Theoretical Computer Science},
  pages        = {48-84},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Faster exponential-time algorithms for approximately counting independent sets},
  volume       = {892},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Automata for solid codes. <em>TCS</em>, <em>892</em>, 25–47.
(<a href="https://doi.org/10.1016/j.tcs.2021.09.007">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Solid codes provide outstanding fault-tolerance when used for information transmission through a noisy channel involving not only symbol substitutions, but also synchronisation errors and black-outs. In this paper we provide an automaton theoretic characterisation of solid codes which takes this fault-tolerance into account. The fault-tolerance afforded by a solid code L can be summarised as follows: Consider messages, encoded using L , being sent through a noisy channel. Any code words in L , which are present in the received message, will be decoded correctly, unless they themselves happen to be the results of errors. Thus, errors in the received message will not lead to incorrect decodings of those parts which are error-free. In this paper we consider acceptors which are fault-tolerant in this sense when analysing such received messages. These acceptors characterise the class of solid codes. For finite solid codes an automaton characterisation was published in the sixties by Levenshtein and Romanov. The characterisation uses state-invariant finite-state transducers which act as decoders in such a way that an output is generated exactly when a code word has been read completely. State-invariance means that acceptance does not depend on the initial state — every state can be used as the initial state. The results of Levenshtein and Romanov depend strongly on the fact that the code is finite. In this paper we provide a general automaton theoretic characterisation of arbitrary solid codes without any such restriction. Moreover, the solid code is regular as a language if and only if the automaton used in the characterisation can be reduced to an equivalent finite automaton with equivalent properties. The main results of this paper are as follows: Every acceptor defines a solid code. For every solid code there is a fault-tolerant acceptor defining the code. Such acceptors expose the decomposition of potentially faulty received messages according to the code. For solid codes which are regular as languages these acceptors can be chosen to be finite while preserving all important combinatorial properties. Part of this work was presented at the 14th Journées Montoises of Theoretical Computer Science [32] .},
  archive      = {J_TCS},
  author       = {Helmut Jürgensen and Ludwig Staiger},
  doi          = {10.1016/j.tcs.2021.09.007},
  journal      = {Theoretical Computer Science},
  pages        = {25-47},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Automata for solid codes},
  volume       = {892},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The exponential-time hypothesis and the relative complexity
of optimization and logical reasoning problems. <em>TCS</em>,
<em>892</em>, 1–24. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.006">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Obtaining lower bounds for NP-hard problems has for a long time been an active area of research. Algebraic techniques introduced by Jonsson et al. (2017) [4] show that the fine-grained time complexity of the parameterized problem correlates to the lattice of strong partial clones. With this ordering they isolated a relation R such that can be solved at least as fast as any other NP-hard problem. In this paper we extend this method and show that such languages also exist for the surjective SAT problem , the max ones problem , the propositional abduction problem , and the Boolean valued constraint satisfaction problem over finite-valued constraint languages. These languages may be interesting when investigating the borderline between polynomial time , subexponential time and exponential-time algorithms since they in a precise sense can be regarded as NP-hard problems with minimum time complexity. Indeed, with the help of these languages we relate all of the above problems to the exponential time hypothesis (ETH) in several different ways.},
  archive      = {J_TCS},
  author       = {Peter Jonsson and Victor Lagerkvist and Johannes Schmidt and Hannes Uppman},
  doi          = {10.1016/j.tcs.2021.09.006},
  journal      = {Theoretical Computer Science},
  pages        = {1-24},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The exponential-time hypothesis and the relative complexity of optimization and logical reasoning problems},
  volume       = {892},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Adaptive oblivious transfer with access control from lattice
assumptions. <em>TCS</em>, <em>891</em>, 210–229. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.001">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Adaptive oblivious transfer (OT) is a protocol where a sender initially commits to a database { M i } i = 1 N {Mi}i=1N . Then, a receiver can query the sender up to k times with private indexes ρ 1 , … , ρ k ρ1,…,ρk so as to obtain M ρ 1 , … , M ρ k Mρ1,…,Mρk and nothing else. Moreover, for each i ∈ [ k ] i∈[k] , the receiver&#39;s choice ρ i ρi may depend on previously obtained messages { M ρ j } j {Mρj}j&amp;lt;i . Oblivious transfer with access control (OT-AC) is a flavor of adaptive OT where database records are protected by distinct access control policies that specify which credentials a receiver should obtain in order to access each M i Mi . So far, all known OT-AC protocols only support access policies made of conjunctions or rely on ad hoc assumptions in pairing-friendly groups (or both). In this paper, we provide an OT-AC protocol where access policies may consist of any branching program of polynomial length, which is sufficient to realize any access policy in NC1 NC1 . The security of our protocol is proved under the Learning-with-Errors ( LWE LWE ) and Short-Integer-Solution ( SIS SIS ) assumptions. As a result of independent interest, we provide protocols for proving the correct evaluation of a committed branching program on a committed input.},
  archive      = {J_TCS},
  author       = {Benoît Libert and San Ling and Fabrice Mouhartem and Khoa Nguyen and Huaxiong Wang},
  doi          = {10.1016/j.tcs.2021.09.001},
  journal      = {Theoretical Computer Science},
  pages        = {210-229},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Adaptive oblivious transfer with access control from lattice assumptions},
  volume       = {891},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Computational complexity characterization of protecting
elections from bribery. <em>TCS</em>, <em>891</em>, 189–209. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.036">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The bribery problem in election has received considerable attention in the literature, upon which various algorithmic and complexity results have been obtained. In this setting, it is natural to ask whether we can protect an election from potential bribery attacks. We consider a scenario where the protector (or defender) can protect a voter at some cost such that a protected voter cannot be bribed (e.g., by isolating the voter from potential bribers). This leads to the following bi-level decision problem: Is it possible for the protector to protect a proper subset of voters such that no briber with a fixed budget for bribery can alter the election result? The goal of this paper is to give a full characterization of the complexity of the associated protection problems. We conduct an extensive study on the protection problem and provide algorithmic and complexity results. When compared with the bribery problems that have been studied in the literature, we observe that the protection problem we study is significantly harder in general. Indeed, it becomes Σ 2 p Σ2p -complete even for very restricted special cases, while most bribery problems lie in NP. However, it is not necessarily the case that the protection problem is always harder. Some of the protection problems can still be solved in polynomial time , while some of them remain as hard as the bribery problem with the same setting.},
  archive      = {J_TCS},
  author       = {Lin Chen and Ahmed Imtiaz Sunny and Lei Xu and Shouhuai Xu and Zhimin Gao and Yang Lu and Weidong Shi and Nolan Shah},
  doi          = {10.1016/j.tcs.2021.08.036},
  journal      = {Theoretical Computer Science},
  pages        = {189-209},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Computational complexity characterization of protecting elections from bribery},
  volume       = {891},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On perfectly secure 2PC in the OT-hybrid model.
<em>TCS</em>, <em>891</em>, 166–188. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.035">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A well known result by Kilian (1988) [23] asserts that general secure two computation (2PC) with statistical security, can be based on OT. Specifically, in the client-server model, where only one party – the client – receives an output, Kilian&#39;s result shows that given the ability to call an ideal oracle that computes OT, two parties can securely compute an arbitrary function of their inputs with unconditional security. Ishai et al. (2011) [20] further showed that this can be done efficiently for every two-party functionality in NC 1 NC1 in a single round . However, their results only achieve statistical security, namely, it is allowed to have some error in security. This leaves open the natural question as to which client-server functionalities can be computed with perfect security in the OT-hybrid model, and what is the round complexity of such computation. So far, only a handful of functionalities were known to have such protocols. In addition to the obvious theoretical appeal of the question towards better understanding secure computation, perfect, as opposed to statistical reductions, may be useful for designing secure multiparty protocols with high concrete efficiency, achieved by eliminating the dependence on a security parameter. In this work, we identify a large class of client-server functionalities f : X × Y ↦ { 0 , 1 } f:X×Y↦{0,1} , where the server&#39;s domain X X is larger than the client&#39;s domain Y Y , that have a perfect reduction to OT. Furthermore, our reduction is 1-round using an oracle to secure evaluation of many parallel invocations of 1-out-of-2 bit OT, as done by Ishai et al. (2011) [20] . Interestingly, the set of functions that we are able to compute was previously identified by Asharov (2014) [3] in the context of fairness in two-party computation, naming these functions full-dimensional . Our result also extends to randomized non-Boolean functions f : X × Y ↦ { 0 , … , k − 1 } f:X×Y↦{0,…,k−1} satisfying | X | &gt; ( k − 1 ) ⋅ | Y | |X|&amp;gt;(k−1)⋅|Y| .},
  archive      = {J_TCS},
  author       = {Bar Alon and Anat Paskin-Cherniavsky},
  doi          = {10.1016/j.tcs.2021.08.035},
  journal      = {Theoretical Computer Science},
  pages        = {166-188},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On perfectly secure 2PC in the OT-hybrid model},
  volume       = {891},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Distance restricted manipulation in voting. <em>TCS</em>,
<em>891</em>, 149–165. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.034">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce the notion of Distance Restricted Manipulation , where colluding manipulator(s) need to compute if there exist votes which make their preferred alternative win the election when their knowledge about the others&#39; votes is a little inaccurate. We use the Kendall-Tau distance to model the manipulators&#39; confidence in the non-manipulators&#39; votes. To this end, we study this problem in two settings - one where the manipulators need to compute a manipulating vote that succeeds irrespective of perturbations in others&#39; votes ( Distance Restricted Pessimistic Manipulation ), and the second where the manipulators need to compute a manipulating vote that succeeds for at least one possible vote profile of the others ( Distance Restricted Optimistic Manipulation ). We show that Distance Restricted Pessimistic Manipulation admits polynomial-time algorithms for every scoring rule, maximin, Bucklin, and simplified Bucklin voting rules for a single manipulator, and for the k -approval rule for any number of manipulators, but becomes intractable for the Copeland α voting rule for every α ∈ [ 0 , 1 ] α∈[0,1] even for a single manipulator. In contrast, Distance Restricted Optimistic Manipulation is intractable for almost all the common voting rules, with the exception of the plurality rule. For a constant number of alternatives, we show that both the problems are polynomial-time solvable for every anonymous and efficient voting rule.},
  archive      = {J_TCS},
  author       = {Aditya Anand and Palash Dey},
  doi          = {10.1016/j.tcs.2021.08.034},
  journal      = {Theoretical Computer Science},
  pages        = {149-165},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Distance restricted manipulation in voting},
  volume       = {891},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Almost fully anonymous attribute-based group signatures with
verifier-local revocation and member registration from lattice
assumptions. <em>TCS</em>, <em>891</em>, 131–148. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.033">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Attribute-Based Group Signature (ABGS) schemes permit any group member with required attributes to generate signatures for the sake of the group anonymously. Even though existing ABGS schemes with Verifier-local Revocation (VLR) method facilitate efficient user and attribute revocation, they cannot achieve stronger security for the users and user attributes. In this paper, we present a new approach to overcome this weakness delivering a new ABGS scheme with VLR that achieves stronger security, almost full anonymity , for both users and their attributes. We construct our scheme from lattices as lattice cryptography is quantum resist. Moreover, we present a simple member joining protocol and a new zero-knowledge argument system that supports the new scheme. Finally, we prove that the proposed scheme meets the security requirements of almost full anonymity , traceability, and non-frameability.},
  archive      = {J_TCS},
  author       = {Maharage Nisansala Sevwandi Perera and Toru Nakamura and Masayuki Hashimoto and Hiroyuki Yokoyama and Kouichi Sakurai},
  doi          = {10.1016/j.tcs.2021.08.033},
  journal      = {Theoretical Computer Science},
  pages        = {131-148},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Almost fully anonymous attribute-based group signatures with verifier-local revocation and member registration from lattice assumptions},
  volume       = {891},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On group-characterizability of homomorphic secret sharing
schemes. <em>TCS</em>, <em>891</em>, 116–130. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.032">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A group-characterizable (GC) random variable is induced by a finite group, called main group, and a collection of its subgroups. The notion extends directly to secret sharing schemes (SSSs). It is known that linear and abelian SSSs can be equivalently described in terms of GC SSSs. In this paper, we present a necessary and sufficient condition for a SSS to be equivalent to a GC one. Using this result, we show that homomorphic SSSs (HSSSs) are equivalent to GC SSSs whose subgroups are normal in the main group. We also present two applications for this equivalent description of HSSSs. One concerns lower bounding the information ratio of access structures for the class of HSSSs, and the other is about the coincidence between statistical, almost-perfect and perfect security notions for the same class.},
  archive      = {J_TCS},
  author       = {Reza Kaboli and Shahram Khazaei and Maghsoud Parviz},
  doi          = {10.1016/j.tcs.2021.08.032},
  journal      = {Theoretical Computer Science},
  pages        = {116-130},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On group-characterizability of homomorphic secret sharing schemes},
  volume       = {891},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Approximation algorithms for sorting permutations by extreme
block-interchanges. <em>TCS</em>, <em>891</em>, 105–115. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.031">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Sorting permutations with various operations has applications in macro rearrangement of genes in a genome and the design of computer interconnection networks . Block-interchange is a powerful operation that swaps two substrings that are called as blocks in literature, in a given permutation. When the blocks are restricted to be adjacent then one obtains a well studied operation: transposition . We call either a prefix or a suffix as an extreme . Restricting one of the swapped blocks to be an extreme in block-interchange operation yields a prefix or a suffix block-interchange respectively, the two types of extreme block-interchanges. For prefix block-interchange operation over permutations we design: (i) an optimum algorithm to sort reverse permutation, R n Rn , in n /2 moves, (ii) a simple 2-approximation algorithm, and (iii) for permutations with O ( 1 ) O(1) cycles, a 4/3 approximation algorithm . Due to symmetry, these results apply to suffix block-interchange operation also.},
  archive      = {J_TCS},
  author       = {Jayakumar Pai and Bhadrachalam Chitturi},
  doi          = {10.1016/j.tcs.2021.08.031},
  journal      = {Theoretical Computer Science},
  pages        = {105-115},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Approximation algorithms for sorting permutations by extreme block-interchanges},
  volume       = {891},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Optimal radio labellings of block graphs and line graphs of
trees. <em>TCS</em>, <em>891</em>, 90–104. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.029">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A radio labeling of a graph G is a mapping f : V ( G ) V(G) → {0, 1, 2,...} such that | f ( u ) − f ( v ) | ⩾ d ( G ) + 1 − d ( u , v ) |f(u)−f(v)|⩾d(G)+1−d(u,v) holds for every pair of vertices u and v , where d ( G ) d(G) is the diameter of G and d ( u , v ) d(u,v) is the distance between u and v in G . The radio number of G , denoted by r n ( G ) rn(G) , is the smallest t such that G admits a radio labeling with t = max ⁡ { | f ( v ) − f ( u ) | : v , u ∈ V ( G ) } t=max⁡{|f(v)−f(u)|:v,u∈V(G)} . A block graph is a graph such that each block (induced maximal 2-connected subgraph) is a complete graph. In this paper, a lower bound for the radio number of block graphs is established. The block graph which achieves this bound is called a lower bound block graph . We prove three necessary and sufficient conditions for lower bound block graphs. Moreover, we give three sufficient conditions for a graph to be a lower bound block graph. Using these results, we present several families of lower bound block graphs, including the level-wise regular block graphs and the extended star of blocks. The line graph of a graph G ( V , E ) G(V,E) has E ( G ) E(G) as the vertex set, where two vertices are adjacent if they are incident edges in G . We extend our results to trees as trees and its line graphs are block graphs. We prove that if a tree is a lower bound block graph then, under certain conditions, its line graph is also a lower bound block graph, and vice versa. Consequently, we show that the line graphs of many known lower bound trees, excluding paths, are lower bound block graphs.},
  archive      = {J_TCS},
  author       = {Devsi Bantva and Daphne Der-Fen Liu},
  doi          = {10.1016/j.tcs.2021.08.029},
  journal      = {Theoretical Computer Science},
  pages        = {90-104},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Optimal radio labellings of block graphs and line graphs of trees},
  volume       = {891},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Quasi-universal k-regular sequences. <em>TCS</em>,
<em>891</em>, 84–89. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.028">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the k -regular sequences introduced by Allouche and Shallit. We call a k -regular integer sequence s quasi-universal, if for every recursively enumerable set A of positive integers, the k -kernel of s contains a sequence t such that A equals the set of positive terms of t . We show that there are quasi-universal k -regular sequences for every integer k ≥ 2 k≥2 . As a consequence, no nontrivial property is decidable for the set of positive terms of a k -regular sequence.},
  archive      = {J_TCS},
  author       = {Juha Honkala},
  doi          = {10.1016/j.tcs.2021.08.028},
  journal      = {Theoretical Computer Science},
  pages        = {84-89},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Quasi-universal k-regular sequences},
  volume       = {891},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Subcomputable hausdorff function dimension. <em>TCS</em>,
<em>891</em>, 59–83. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.027">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We propose notions of effective Hausdorff function dimension for subcomputable classes such that while the classical numerical Hausdorff dimension notions coincide as shown by Downey, Merkle and Reimann for Computable and Schnorr dimensions, the corresponding function dimensions disagree.},
  archive      = {J_TCS},
  author       = {Claude Sureson},
  doi          = {10.1016/j.tcs.2021.08.027},
  journal      = {Theoretical Computer Science},
  pages        = {59-83},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Subcomputable hausdorff function dimension},
  volume       = {891},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Golden games. <em>TCS</em>, <em>891</em>, 50–58. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.026">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider extensive form 2-player win-lose games, with alternating moves, of perfect and complete information. The games are played over a complete binary-tree of depth n , where 0/1 payoffs in the leaves are drawn according to an i.i.d. Bernoulli distribution with probability p . Whenever p differs from the golden ratio, asymptotically as n → ∞ n→∞ , the winner of the game is determined. In the case where p equals the golden ratio, we call such a random game a golden game . In golden games the winner is the player that acts first with probability equal to the golden ratio. We suggest the notion of fragility as a measure for “fairness” of a game&#39;s rules. Fragility counts how many leaves&#39; payoffs should be flipped in order to convert the identity of the winning player. Our main result provides a recursive formula for asymptotic fragility of golden games. Surprisingly, golden games are extremely fragile. For instance, with probability ≈0.77 a losing player could flip a single payoff (out of 2 n 2n ) and become a winner. With probability ≈0.999 a losing player could flip 3 payoffs and become the winner.},
  archive      = {J_TCS},
  author       = {Urban Larsson and Yakov Babichenko},
  doi          = {10.1016/j.tcs.2021.08.026},
  journal      = {Theoretical Computer Science},
  pages        = {50-58},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Golden games},
  volume       = {891},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Symmetric PMC model of diagnosis, b-matchings in graphs and
fault identification in t-diagnosable systems. <em>TCS</em>,
<em>891</em>, 35–49. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.025">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A major breakthrough in the diagnosis of t -diagnosable systems occurred when Dahbura and Mason developed a diagnosis algorithm under the PMC model using the matching theory in bipartite graphs . In this paper we introduce a new testing model called the symmetric PMC(SPMC) model. Our main contributions are as follows: We prove that the diagnosability of an n -dimensional hypercube under the SPMC model is almost twice its diagnosability under the PMC model. We then show that the fault diagnosis problem for a t -diagnosable system under the SPMC model reduces to that of determining a maximum weighted b -matching in its diagnosis graph. Algorithm LABEL is then given to identify all the faulty vertices using the maximum b -matching of the diagnosis graph. Finally, using certain results from the theory of partitions of integers we establish the worst case complexity of our t -diagnosis algorithm. The complexity is much better than the worst case complexity of the Dahbura-Mason algorithm for the t -diagnosable problem under the PMC model.},
  archive      = {J_TCS},
  author       = {Qiang Zhu and Krishnaiyan Thulasiraman and Kshirasagar Naik and Sridhar Radhakrishnan and Min Xu},
  doi          = {10.1016/j.tcs.2021.08.025},
  journal      = {Theoretical Computer Science},
  pages        = {35-49},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Symmetric PMC model of diagnosis, b-matchings in graphs and fault identification in t-diagnosable systems},
  volume       = {891},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Scheduling to tradeoff between the number and the length of
accepted jobs. <em>TCS</em>, <em>891</em>, 24–34. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.020">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider the single-machine scheduling problem to tradeoff between the number and the length of accepted jobs. The algorithm introduced by Lin and Wang (2007) (called Lin-Wang&#39;s algorithm ), for solving the single-machine scheduling problem to minimize the number of tardy jobs, is closely related to our research. The original version of Lin-Wang&#39;s algorithm runs in O ( n 2 ) O(n2) time. By using the technique of the preemptive scheduling combined with a data structure , we show in this paper that a variant of Lin-Wang&#39;s algorithm actually runs in O ( n log ⁡ n ) O(nlog⁡n) time. This enables us to further show that the tradeoff problem can be solved in O ( n log ⁡ n ) O(nlog⁡n) time.},
  archive      = {J_TCS},
  author       = {Qiulan Zhao and Jinjiang Yuan},
  doi          = {10.1016/j.tcs.2021.08.020},
  journal      = {Theoretical Computer Science},
  pages        = {24-34},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Scheduling to tradeoff between the number and the length of accepted jobs},
  volume       = {891},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On prefix palindromic length of automatic words.
<em>TCS</em>, <em>891</em>, 13–23. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.016">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The prefix palindromic length PPL u ( n ) PPLu(n) of an infinite word u is the minimal number of concatenated palindromes needed to express the prefix of length n of u . Since 2013, it is still unknown if PPL u ( n ) PPLu(n) is unbounded for every aperiodic infinite word u , even though this has been proven for almost all aperiodic words. At the same time, the only well-known nontrivial infinite word for which the function PPL u ( n ) PPLu(n) has been precisely computed is the Thue-Morse word t . This word is 2-automatic and, predictably, its function PPL t ( n ) PPLt(n) is 2-regular, but is this the case for all automatic words? In this paper, we prove that this function is k -regular for every k -automatic word containing only a finite number of palindromes. For two such words, namely the paperfolding word and the Rudin-Shapiro word, we derive a formula for this function. Our computational experiments suggest that generally this is not true: for the period-doubling word, the prefix palindromic length does not look 2-regular, and for the Fibonacci word, it does not look Fibonacci-regular. If proven, these results would give rare (if not first) examples of a natural function of an automatic word which is not regular.},
  archive      = {J_TCS},
  author       = {Anna E. Frid and Enzo Laborde and Jarkko Peltomäki},
  doi          = {10.1016/j.tcs.2021.08.016},
  journal      = {Theoretical Computer Science},
  pages        = {13-23},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On prefix palindromic length of automatic words},
  volume       = {891},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Polynomial kernels for paw-free edge modification problems.
<em>TCS</em>, <em>891</em>, 1–12. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.015">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Given a graph G and an integer k , the paw-free completion problem asks whether it is possible to add at most k edges to G to make it paw-free. The paw-free edge deletion problem is defined analogously. Sandeep and Sivadasan (IPEC 2015) asked whether these problems admit polynomial kernels. We answer both questions affirmatively by presenting, respectively, O ( k ) O(k) -vertex and O ( k 4 ) O(k4) -vertex kernels for them. This is part of an ongoing program that aims at understanding the compressibility of H -free edge modification problems for general H .},
  archive      = {J_TCS},
  author       = {Hanchun Yuan and Yuping Ke and Yixin Cao},
  doi          = {10.1016/j.tcs.2021.08.015},
  journal      = {Theoretical Computer Science},
  pages        = {1-12},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Polynomial kernels for paw-free edge modification problems},
  volume       = {891},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Approximate set union via approximate randomization.
<em>TCS</em>, <em>890</em>, 210–239. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.016">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We develop a randomized approximation algorithm for the size of set union problem | A 1 ∪ A 2 ∪ . . . ∪ A m | |A1∪A2∪...∪Am| , which is given a list of sets A 1 , . . . , A m A1,...,Am with approximate set size m i mi for A i Ai with m i ∈ ( ( 1 − β L ) | A i | mi∈((1−βL)|Ai| , ( 1 + β R ) | A i | ) (1+βR)|Ai|) , and biased random generators with probability Prob ( x = RandomElement ( A i ) ) ∈ [ 1 − α L | A i | , 1 + α R | A i | ] Prob(x=RandomElement(Ai))∈[1−αL|Ai|,1+αR|Ai|] for each input set A i Ai and element x ∈ A i x∈Ai , where i = 1 , 2 , . . . , m i=1,2,...,m and α L , α R , β L , β R ∈ ( 0 , 1 ) αL,αR,βL,βR∈(0,1) . The approximation ratio for | A 1 ∪ A 2 ∪ . . . ∪ A m | |A1∪A2∪...∪Am| is in the range [ ( 1 − ϵ ) ( 1 − α L ) ( 1 − β L ) , ( 1 + ϵ ) ( 1 + α R ) [(1−ϵ)(1−αL)(1−βL),(1+ϵ)(1+αR) ( 1 + β R ) ] (1+βR)] for any ϵ ∈ ( 0 , 1 ) ϵ∈(0,1) . The complexity of the algorithm is measured by both time complexity and round complexity. One round of the algorithm has non-adaptive accesses to those RandomElement ( A i ) RandomElement(Ai) functions 1 ≤ i ≤ m 1≤i≤m , and membership queries ( x ∈ A i x∈Ai ?) to input sets A i Ai with 1 ≤ i ≤ m 1≤i≤m . Our algorithm gives an approximation scheme with O ( m ⋅ ( log ⁡ m ) 7 ) O(m⋅(log⁡m)7) running time and O ( log ⁡ m ) O(log⁡m) rounds in contrast to the existing algorithm [1] that needs Ω ( m ) Ω(m) rounds in the worst case with O ( ( 1 + ϵ ) m / ϵ 2 ) O((1+ϵ)m/ϵ2) running time, where m is the number of sets. Our algorithm gives a flexible tradeoff with time complexity O ( m 1 + ξ ) O(m1+ξ) and round complexity O ( 1 ξ ) O(1ξ) for any ξ ∈ ( 0 , 1 ) ξ∈(0,1) . Our algorithm runs sublinear in time under certain condition that each element in A 1 ∪ A 2 ∪ . . . ∪ A m A1∪A2∪...∪Am belongs to m a ma sets for any fixed a &gt; 0 a&amp;gt;0 , to our best knowledge, we have not seen any sublinear results about this problem. Our algorithm can handle input sets that can generate random elements with bias, and its approximation ratio depends on the bias. We prove that it is #P-hard to count the number of lattice points in a set of balls, and we also show that there is no polynomial time algorithm to approximate the number of lattice points in the intersection of n -dimensional balls unless P=NP. As applications of our algorithm, we propose approximation algorithms for counting the number of lattice points in a union of high dimensional balls and for the maximal coverage problem with balls.},
  archive      = {J_TCS},
  author       = {Bin Fu and Pengfei Gu and Yuming Zhao},
  doi          = {10.1016/j.tcs.2021.09.016},
  journal      = {Theoretical Computer Science},
  pages        = {210-239},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Approximate set union via approximate randomization},
  volume       = {890},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Algorithms for diameters of unicycle graphs and
diameter-optimally augmenting trees. <em>TCS</em>, <em>890</em>,
192–209. (<a href="https://doi.org/10.1016/j.tcs.2021.09.014">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider the problem of computing the diameter of a unicycle graph (i.e., a graph with a unique cycle). We present an O ( n ) O(n) time algorithm for the problem, where n is the number of vertices of the graph. This improves the previous best O ( n log ⁡ n ) O(nlog⁡n) time solution [Oh and Ahn, ISAAC 2016]. Using this algorithm as a subroutine, we solve the problem of adding a shortcut to a tree so that the diameter of the new graph (which is a unicycle graph) is minimized; our algorithm takes O ( n 2 log ⁡ n ) O(n2log⁡n) time and O ( n ) O(n) space. The previous best algorithms solve the problem in O ( n 2 log 3 ⁡ n ) O(n2log3⁡n) time and O ( n ) O(n) space [Oh and Ahn, ISAAC 2016], or in O ( n 2 ) O(n2) time and O ( n 2 ) O(n2) space [Bilò, ISAAC 2018].},
  archive      = {J_TCS},
  author       = {Haitao Wang and Yiming Zhao},
  doi          = {10.1016/j.tcs.2021.09.014},
  journal      = {Theoretical Computer Science},
  pages        = {192-209},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Algorithms for diameters of unicycle graphs and diameter-optimally augmenting trees},
  volume       = {890},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On coresets for support vector machines. <em>TCS</em>,
<em>890</em>, 171–191. (<a
href="https://doi.org/10.1016/j.tcs.2021.09.008">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present an efficient coreset construction algorithm for large-scale Support Vector Machine (SVM) training in Big Data and streaming applications. A coreset is a small, representative subset of the original data points such that a model trained on the coreset is provably competitive with that trained on the original data set. Since the size of the coreset is generally much smaller than the original set, our preprocess-then-train scheme has potential to lead to significant speedups when training SVM models. We prove lower and upper bounds on the size of the coreset required to obtain small data summaries for the SVM problem. As a corollary, we show that our algorithm can be used to extend the applicability of any off-the-shelf SVM solver to streaming, distributed, and dynamic data settings. We evaluate the performance of our algorithm on real-world and synthetic data sets. Our experimental results reaffirm the favorable theoretical properties of our algorithm and demonstrate its practical effectiveness in accelerating SVM training.},
  archive      = {J_TCS},
  author       = {Murad Tukan and Cenk Baykal and Dan Feldman and Daniela Rus},
  doi          = {10.1016/j.tcs.2021.09.008},
  journal      = {Theoretical Computer Science},
  pages        = {171-191},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On coresets for support vector machines},
  volume       = {890},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Constrained synchronization and commutativity. <em>TCS</em>,
<em>890</em>, 147–170. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.030">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In the constrained synchronization problem we want to know if a given input automaton admits a synchronizing word contained in a (fixed) regular constraint language. Here we study the computational complexity of the constrained synchronization problem for the class of regular commutative constraint languages and the computational complexity of the problem restricted to commutative input semi-automata. We give a full classification of the computational complexity of the constrained synchronization problem for commutative regular constraints. Depending on the constraint language, our problem becomes PSPACE -complete, NP -complete or polynomial time solvable. In addition, we derive a polynomial time decision procedure for the complexity of the constrained synchronization problem, given a constraint automaton accepting a commutative language as input. Furthermore, for commutative input semi-automata, the problem is decidable in polynomial time, regardless of the regular constraint language.},
  archive      = {J_TCS},
  author       = {Stefan Hoffmann},
  doi          = {10.1016/j.tcs.2021.08.030},
  journal      = {Theoretical Computer Science},
  pages        = {147-170},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Constrained synchronization and commutativity},
  volume       = {890},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A process calculus approach to detection and mitigation of
PLC malware. <em>TCS</em>, <em>890</em>, 125–146. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.021">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We define a simple process calculus, based on Hennessy and Regan&#39;s Timed Process Language , for specifying networks of communicating programmable logic controllers (PLCs) enriched with monitors enforcing specification compliance at runtime. We define a synthesis algorithm that given an uncorrupted PLC returns a monitor that enforces the correctness of the PLC, even when injected with malware that may forge/drop actuator commands and inter-controller communications. Then, we strengthen the capabilities of our monitors by allowing the insertion of actions to mitigate malware activities. This gives us deadlock-freedom monitoring : malware may not drag monitored controllers into deadlock states. Our enforcing monitors represent a formal mechanism for prompt detection of malicious activities within PLCs. Finally, we illustrate our results by implementing in Simulink a non-trivial Water Transmission Network (WTN) system, and testing the effectiveness of our monitors in detecting and mitigating three different attacks targeting the PLCs of our WTN.},
  archive      = {J_TCS},
  author       = {Ruggero Lanotte and Massimo Merro and Andrei Munteanu},
  doi          = {10.1016/j.tcs.2021.08.021},
  journal      = {Theoretical Computer Science},
  pages        = {125-146},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A process calculus approach to detection and mitigation of PLC malware},
  volume       = {890},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Complexity of scorpion solitaire and applications to
klondike. <em>TCS</em>, <em>890</em>, 105–124. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.019">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Scorpion is a puzzle game that falls under the category of Solitaires. The problem of determining whether a starting configuration of a Solitaire game (generalized to contain an arbitrary number of cards) can lead to a winning configuration has been studied from the perspective of Computational Complexity for some of the most popular Solitaires, namely Free Cell [1] , Klondike [2] and Spider [3] , all resulting in hardness proofs. Scorpion, though, has a unique twist compared to the aforementioned ones: each card can be moved to cover only one other card. This property narrows the set of possible moves and makes a worthwhile issue investigating whether the same problem proved NP-complete for Free Cell, Klondike and Spider falls in P as far as Scorpion is considered. In this paper we prove that the problem of deciding whether an n -card s -suits initial configuration of Scorpion allows for a winning sequence of moves is NP-complete for any s ≥ 1 s≥1 , and it remains so also when the initial configuration contains no face down (locked) cards and under a constant ratio constraint between deck size and tableau size. As a side effect of our results, we have also succeeded in negatively answering a question posed in [2] , in that we prove that it is NP-complete to decide whether an n -card one red suit-one black suit configuration of the Klondike Solitaire allows for a winning sequence of moves.},
  archive      = {J_TCS},
  author       = {Francesco Arena and Miriam Di Ianni},
  doi          = {10.1016/j.tcs.2021.08.019},
  journal      = {Theoretical Computer Science},
  pages        = {105-124},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Complexity of scorpion solitaire and applications to klondike},
  volume       = {890},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A substructure based lower bound for eternal vertex cover
number. <em>TCS</em>, <em>890</em>, 87–104. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.018">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The eternal vertex cover (EVC) problem is to compute the minimum number of guards to be placed on the vertices of a graph so that any sequence of attacks on its edges can be defended by dynamically reconfiguring the guards. The problem is NP-hard in general and polynomial time algorithms are unknown even for simple graph classes like cactus graphs and bipartite graphs. A major difficulty is that only few lower bounds, other than the trivial lower bound of vertex cover, is known in general and the known bounds are too weak to yield useful results even for the graph classes mentioned above. We introduce the notion of substructure property in the context of the EVC problem and derive a new lower bounding technique for the problem based on the property. We apply the technique to cactus graphs and chordal graphs and obtain new algorithms for solving the eternal vertex cover problem in linear time for cactus graphs and quadratic time for a family of graphs that includes all chordal graphs and cactus graphs.},
  archive      = {J_TCS},
  author       = {Jasine Babu and Veena Prabhakaran and Arko Sharma},
  doi          = {10.1016/j.tcs.2021.08.018},
  journal      = {Theoretical Computer Science},
  pages        = {87-104},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A substructure based lower bound for eternal vertex cover number},
  volume       = {890},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Copy complexity of horn formulas with respect to unit
read-once resolution. <em>TCS</em>, <em>890</em>, 70–86. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.017">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we discuss the copy complexity of Horn formulas with respect to unit resolution. A Horn formula is a boolean formula in conjunctive normal form (CNF) with at most one positive literal per clause. Horn formulas find applications in a number of domains, such as program verification (abstract interpretation) and logic programming (answer set programming). Quantified Horn clauses are used extensively in temporal verification of universal properties. Resolution is one of the oldest proof systems (refutation systems) for the boolean satisfiability problem (SAT), when the input is presented in conjunctive normal form (CNF). It is both sound and complete, although inefficient, when compared to other stronger proof systems for boolean formulas. Despite its inefficiency, the simple nature of resolution makes it an integral part of several theorem provers. Unit resolution is a restricted form of resolution in which each resolution step needs to use a clause with only one literal (unit literal clause). While not complete for general CNF formulas, unit resolution is complete for Horn formulas. Read-once resolution is a form of resolution in which each clause (input or derived) may be used in at most one resolution step. As with unit resolution, read-once resolution is incomplete in general and complete for Horn clauses. This paper focuses on a combination of unit resolution and read-once resolution called unit read-once resolution . Unit read-once resolution is incomplete for Horn clauses. In this paper, we study the copy complexity problem in Horn formulas with respect to unit read-once resolution. Briefly, the copy complexity of a formula with respect to unit read-once resolution, is the smallest number k , such that replicating each clause k times guarantees the existence of a unit read-once resolution refutation (UROR). This paper focuses on two problems related to the copy complexity of Horn formulas with respect to unit read-once resolution. We first relate the copy complexity of Horn formulas with respect to unit read-once resolution to the copy complexity of the corresponding Horn constraint system with respect to the addition rule . We also examine a form of copy complexity in which we permit replication of derived clauses, in addition to the input clauses. Finally, we provide a polynomial time algorithm for the problem of checking if a 2-CNF formula has a UROR.},
  archive      = {J_TCS},
  author       = {Piotr Wojciechowski and K. Subramani},
  doi          = {10.1016/j.tcs.2021.08.017},
  journal      = {Theoretical Computer Science},
  pages        = {70-86},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Copy complexity of horn formulas with respect to unit read-once resolution},
  volume       = {890},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the parameterized complexity of the synthesis of boolean
nets with restricted place environments. <em>TCS</em>, <em>890</em>,
36–69. (<a href="https://doi.org/10.1016/j.tcs.2021.08.014">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Though constructing a sequential system model may be technically uncomplicated and rather ‘straightforward’, its result is often cumbersome and difficult to analyze since all possible interleavings of system&#39;s actions have to be present. This naturally raises the interest to the possibility of automatic synthesis of models that are able to grasp behavioral parallelism of the system. Boolean Petri nets are a classical formalism that enjoys generic concepts of concurrency, synchronization and conflict, and allows to obtain a concise yet expressive system representation. Let τ be a Boolean type of nets. The problem of τ -synthesis consists in deciding whether a given transition system A is isomorphic to the reachability graph of a Boolean Petri net N of type τ (a τ -net, for short). In case of a positive decision, N should be constructed. Another instance of the synthesis problem takes the dependencies of places into account: A place p of a τ -net depends on a transition t if p can influence t , that is, a marking of p can inhibit the firing of t , or if p can be influenced by t , that is, the firing of t can change a marking of p . The problem τ-synthesis of Boolean nets with restricted dependencies (τ -SOBNWRD ) consists in deciding for a given transition system A and natural number d whether there exists a Boolean Petri net N of type τ such that, firstly, the reachability graph of N and A are isomorphic and, secondly, every place p of N depends on at most d transitions. For many Boolean types that allow independence, the (unrestricted) τ -synthesis problem is NP-complete, and for all of them τ -SOBNWRD inherits the NP-completeness. In this paper, we enhance our understanding of τ -SOBNWRD from a parameterized point of view: We show for 27 of the 128 thinkable Boolean types that allow independence that τ -SOBNWRD parameterized by d is W [ 1 ] W[1] -hard, and for 75 of them that the problem is W [ 2 ] W[2] -hard.},
  archive      = {J_TCS},
  author       = {Ronny Tredup and Evgeny Erofeev},
  doi          = {10.1016/j.tcs.2021.08.014},
  journal      = {Theoretical Computer Science},
  pages        = {36-69},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On the parameterized complexity of the synthesis of boolean nets with restricted place environments},
  volume       = {890},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Efficient computation of the oriented chromatic number of
recursively defined digraphs. <em>TCS</em>, <em>890</em>, 16–35. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.013">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper we consider colorings of oriented graphs, i.e. digraphs without cycles of length 2. Given some oriented graph G = ( V , E ) G=(V,E) , an oriented r -coloring for G is a partition of the vertex set V into r independent sets, such that all the arcs between two of these sets have the same direction. The oriented chromatic number of G is the smallest integer r such that G permits an oriented r -coloring. Deciding whether an acyclic digraph has an oriented 4-coloring is NP-hard, which motivates to consider the problem on special graph classes. In this paper we consider the Oriented Chromatic Number problem on classes of recursively defined oriented graphs. Oriented co-graphs (short for oriented complement reducible graphs) can be recursively defined from the single vertex graph by applying the disjoint union and order composition. This recursive structure allows to compute an optimal oriented coloring and the oriented chromatic number in linear time. We generalize this result using the concept of perfect orderable graphs. Therefore, we show that for acyclic transitive digraphs every greedy coloring along a topological ordering leads to an optimal oriented coloring. Msp-digraphs (short for minimal series-parallel digraphs) can be defined from the single vertex graph by applying the parallel composition and series composition. We prove an upper bound of 7 for the oriented chromatic number for msp-digraphs and we give an example to show that this is bound best possible. We apply this bound and the recursive structure of msp-digraphs to obtain a linear time solution for computing the oriented chromatic number of msp-digraphs. In order to generalize the results on computing the oriented chromatic number of special graph classes, we consider the parameterized complexity of the Oriented Chromatic Number problem by so-called structural parameters, which are measuring the difficulty of decomposing a graph into a special tree-structure.},
  archive      = {J_TCS},
  author       = {Frank Gurski and Dominique Komander and Marvin Lindemann},
  doi          = {10.1016/j.tcs.2021.08.013},
  journal      = {Theoretical Computer Science},
  pages        = {16-35},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Efficient computation of the oriented chromatic number of recursively defined digraphs},
  volume       = {890},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Deterministic approximation algorithm for submodular
maximization subject to a matroid constraint. <em>TCS</em>,
<em>890</em>, 1–15. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.012">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we study the generalized submodular maximization problem with a non-negative monotone submodular set function as the objective function and subject to a matroid constraint. The problem is generalized through the curvature parameter α ∈ [ 0 , 1 ] α∈[0,1] which measures how far a set function deviates from linearity to submodularity. We propose a deterministic approximation algorithm which uses the approximation algorithm proposed by Buchbinder et al. [2] as a building block and inherits the approximation guarantee for α = 1 α=1 . For general value of the curvature parameter α ∈ [ 0 , 1 ] α∈[0,1] , we present an approximation algorithm with a factor of 1 + h α ( y ) + Δ ⋅ [ 3 + α − ( 2 + α ) y − ( 1 + α ) h α ( y ) ] 2 + α + ( 1 + α ) ( 1 − y ) 1+hα(y)+Δ⋅[3+α−(2+α)y−(1+α)hα(y)]2+α+(1+α)(1−y) , where y ∈ [ 0 , 1 ] y∈[0,1] is a predefined parameter for tuning the ratio. In particular, when α = 1 α=1 we obtain a ratio 0.5008 when setting y = 0.9 y=0.9 , coinciding with the renowned state-of-art approximate ratio; when α = 0 α=0 that the object is a linear function, the approximation factor equals one and our algorithm is indeed an exact algorithm that always produces optimum solutions.},
  archive      = {J_TCS},
  author       = {Xin Sun and Dachuan Xu and Longkun Guo and Min Li},
  doi          = {10.1016/j.tcs.2021.08.012},
  journal      = {Theoretical Computer Science},
  pages        = {1-15},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Deterministic approximation algorithm for submodular maximization subject to a matroid constraint},
  volume       = {890},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The steiner k-eccentricity on trees. <em>TCS</em>,
<em>889</em>, 182–188. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.010">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the Steiner k -eccentricity on trees, which generalizes the previous one in the paper [On the average Steiner 3-eccentricity of trees, arXiv:2005.10319 ]. We achieve much stronger properties for the Steiner k -ecc tree than that in the previous paper. Based on this, a linear time algorithm is devised to calculate the Steiner k -eccentricity of a vertex in a tree. On the other hand, lower and upper bounds of the average Steiner k -eccentricity index of a tree on order n are established based on a novel technique which is quite different and also much easier to follow than the earlier one.},
  archive      = {J_TCS},
  author       = {Xingfu Li and Guihai Yu and Sandi Klavžar and Jie Hu and Bo Li},
  doi          = {10.1016/j.tcs.2021.08.010},
  journal      = {Theoretical Computer Science},
  pages        = {182-188},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The steiner k-eccentricity on trees},
  volume       = {889},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Minimizing total interference in asymmetric sensor networks.
<em>TCS</em>, <em>889</em>, 171–181. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.003">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The problem of computing a connected network with minimum interference is a fundamental problem in wireless sensor networks . Several models of interference have been studied in the literature. The most common one is the receiver-centric, in which the interference of a node p is defined as the number of other nodes whose transmission range covers p . In this paper, we study the problem of assigning a transmission range to each sensor, such that the resulting network is strongly connected and the total interference of the network is minimized. For the one-dimensional case, we show how to solve the problem optimally in O ( n 3 ) O(n3) time. For the two-dimensional case, we show that the problem is NP-complete and give a polynomial-time 2-approximation algorithm for the problem.},
  archive      = {J_TCS},
  author       = {A. Karim Abu-Affash and Paz Carmi and Matthew J. Katz},
  doi          = {10.1016/j.tcs.2021.08.003},
  journal      = {Theoretical Computer Science},
  pages        = {171-181},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Minimizing total interference in asymmetric sensor networks},
  volume       = {889},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A compiler for multi-key homomorphic signatures for turing
machines. <em>TCS</em>, <em>889</em>, 145–170. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.002">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {At SCN 2018, Fiore and Pagnin proposed a generic compiler (called “Matrioska”) allowing to transform sufficiently expressive single-key homomorphic signatures (SKHSs) into multi-key homomorphic signatures (MKHSs) under falsifiable assumptions in the standard model. Matrioska is designed for homomorphic signatures that support programs represented as circuits. The MKHS schemes obtained through Matrioska support the evaluation and verification of arbitrary circuits over data signed from multiple users, but they require the underlying SKHS scheme to work with circuits whose size is exponential in the number of users, and thus can only support a constant number of users. In this work, we propose a new generic compiler to convert an SKHS scheme into an MKHS scheme. Our compiler is a generalization of Matrioska for homomorphic signatures that support programs in any model of computation . When instantiated with SKHS for circuits, we recover the Matrioska compiler of Fiore and Pagnin. As an additional contribution, we show how to instantiate our generic compiler in the Turing Machines (TM) model and argue that this instantiation allows to overcome some limitations of Matrioska:},
  archive      = {J_TCS},
  author       = {Somayeh Dolatnezhad Samarin and Dario Fiore and Daniele Venturi and Morteza Amini},
  doi          = {10.1016/j.tcs.2021.08.002},
  journal      = {Theoretical Computer Science},
  pages        = {145-170},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A compiler for multi-key homomorphic signatures for turing machines},
  volume       = {889},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Cryptanalysis of the RSA variant based on cubic pell
equation. <em>TCS</em>, <em>889</em>, 135–144. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.001">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {RSA (Rivest-Shamir-Adleman) cryptosystem is the most popular asymmetric key cryptographic algorithm used in computer science and information security. Recently, an RSA-like cryptosystem was proposed using a novel product that arises from a cubic field connected to the cubic Pell equation. The relevant key equation is e d ≡ 1 mod ( p 2 + p + 1 ) ( q 2 + q + 1 ) ed≡1mod(p2+p+1)(q2+q+1) with N = p q N=pq . This RSA variant is claimed to be robust against the Wiener&#39;s attack and hence the bit-size of the private key could be shorter, namely d d&amp;lt;N1/4 . In this paper, we explore the further security analysis and investigate the potential small private exponent attack. We show that such RSA variant is particularly vulnerable to the lattice-based method. To be specific, we can carry out the lattice-based small private exponent attack if d d&amp;lt;N2−2 , which is less secure than the standard RSA. Furthermore, we conduct numerical experiments to verify the validity of the proposed attack.},
  archive      = {J_TCS},
  author       = {Mengce Zheng and Noboru Kunihiro and Yuanzhi Yao},
  doi          = {10.1016/j.tcs.2021.08.001},
  journal      = {Theoretical Computer Science},
  pages        = {135-144},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Cryptanalysis of the RSA variant based on cubic pell equation},
  volume       = {889},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A certifying and dynamic algorithm for the recognition of
proper circular-arc graphs. <em>TCS</em>, <em>889</em>, 105–134. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.040">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present a dynamic algorithm for the recognition of proper circular-arc (PCA) graphs, that supports the insertion and removal of vertices (together with its incident edges). The main feature of the algorithm is that it outputs a minimally non-PCA induced subgraph when the insertion of a vertex fails. Each operation cost O ( log ⁡ n + d ) O(log⁡n+d) time, where n is the number vertices and d is the degree of the modified vertex. When removals are disallowed, each insertion is processed in O ( d ) O(d) time. The algorithm also provides two constant-time operations to query if the dynamic graph is proper Helly (PHCA) or proper interval (PIG). When the dynamic graph is not PHCA (resp. PIG), a minimally non-PHCA (resp. non-PIG) induced subgraph is obtained.},
  archive      = {J_TCS},
  author       = {Francisco J. Soulignac},
  doi          = {10.1016/j.tcs.2021.07.040},
  journal      = {Theoretical Computer Science},
  pages        = {105-134},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A certifying and dynamic algorithm for the recognition of proper circular-arc graphs},
  volume       = {889},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The g-component connectivity of graphs. <em>TCS</em>,
<em>889</em>, 96–104. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.039">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Connectivity is a classic metric to evaluate reliability of multiprocessor system under the circumstances of processor failures. Based on connectivity, more refined quantitative indicators for fault tolerance of multiprocessor system have been extensively explored. The g -component connectivity of a graph G , denoted by c κ g ( G ) cκg(G) , is the minimum number of vertices whose removal from G results in a disconnected graph with at least g -components. So far, the values of the g -component (edge) connectivity of special networks with small g have been extensively investigated. For general graphs, the results of the g -component connectivity are very few. In this paper, we propose some lower and upper bounds for the g -component connectivity along with their sharpness, and then suggest some characterization of trees and general graphs with given g -component connectivity. Furthermore, we fix some related extremal problems.},
  archive      = {J_TCS},
  author       = {He Li and Shumin Zhang and Chengfu Ye and Shuming Zhou},
  doi          = {10.1016/j.tcs.2021.07.039},
  journal      = {Theoretical Computer Science},
  pages        = {96-104},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The g-component connectivity of graphs},
  volume       = {889},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). New complexity results for shop scheduling problems with
agreement graphs. <em>TCS</em>, <em>889</em>, 85–95. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.037">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We investigate the problem of scheduling jobs on open shop and flow shop systems of two machines, subject to the constraints that only some jobs can be scheduled simultaneously on different machines. These constraints are given by a simple undirected graph G , called the agreement graph. The objective is to minimize the makespan. We first show that the open shop problem with two distinct values of release times is NP-hard even for operation sizes in { 1 , 2 } {1,2} and we present a restricted case that can be solved in polynomial time . Then, we consider the problem with null release times and we show that when restricted to arbitrary trees, the problem is NP-hard. We also present a linear algorithm when restricted to caterpillars and we show that this algorithm can be used to solve the case of cycles in polynomial time . For the flow shop problem, we show that the problem is NP-hard for trees and that this result holds even if the preemption is allowed.},
  archive      = {J_TCS},
  author       = {Nour ElHouda Tellache},
  doi          = {10.1016/j.tcs.2021.07.037},
  journal      = {Theoretical Computer Science},
  pages        = {85-95},
  shortjournal = {Theor. Comput. Sci.},
  title        = {New complexity results for shop scheduling problems with agreement graphs},
  volume       = {889},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Improved algorithms for the general exact satisfiability
problem. <em>TCS</em>, <em>889</em>, 60–84. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.036">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Exact Satisfiability problem asks if we can find a satisfying assignment to each clause such that exactly one literal in each clause is assigned 1, while the rest are all assigned 0. We can generalise this problem further by defining that a C j Cj clause is solved iff exactly j of the literals in the clause are 1 and all others are 0. We now introduce the family of Generalised Exact Satisfiability problems called G i XSAT as the problem to check whether a given instance consisting of C j Cj clauses with j ∈ { 0 , 1 , … , i } j∈{0,1,…,i} for each clause has a satisfying assignment. In this paper, we present faster exact polynomial space algorithms, using a nonstandard measure, to solve G i XSAT, for i ∈ { 2 , 3 , 4 } i∈{2,3,4} , in O ( 1.3674 n ) O(1.3674n) time, O ( 1.5687 n ) O(1.5687n) time and O ( 1.6545 n ) O(1.6545n) time, respectively, using polynomial space , where n is the number of variables. This improves the current state of the art for polynomial space algorithms from O ( 1.4203 n ) O(1.4203n) time for G2XSAT by Zhou, Jiang and Yin and from O ( 1.6202 n ) O(1.6202n) time for G3XSAT by Dahllöf and from O ( 1.6844 n ) O(1.6844n) time for G4XSAT which was by Dahllöf as well. In addition, we present faster exact algorithms solving G2XSAT, G3XSAT and G4XSAT in O ( 1.3188 n ) O(1.3188n) time, O ( 1.3407 n ) O(1.3407n) time and O ( 1.3536 n ) O(1.3536n) time respectively at the expense of using exponential space .},
  archive      = {J_TCS},
  author       = {Gordon Hoi and Frank Stephan},
  doi          = {10.1016/j.tcs.2021.07.036},
  journal      = {Theoretical Computer Science},
  pages        = {60-84},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Improved algorithms for the general exact satisfiability problem},
  volume       = {889},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Majority rule cellular automata. <em>TCS</em>, <em>889</em>,
41–59. (<a href="https://doi.org/10.1016/j.tcs.2021.07.035">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Consider a graph G = ( V , E ) G=(V,E) and a random initial coloring where each vertex is black independently with probability p b pb , and white with probability p w = 1 − p b pw=1−pb . In each step, all vertices change their current color synchronously to the most frequent color in their neighborhood and in case of a tie, a vertex keeps its current color. This model is called the majority model . If in case of a tie a vertex always selects black color, it is called the biased majority model . We are interested in the behavior of these two processes, especially when the underlying graph is a two-dimensional torus (cellular automaton with (biased) majority rule). In the present paper, as our main result we prove that both majority and biased majority cellular automata exhibit a threshold behavior with two phase transitions. More precisely, we prove for a two-dimensional torus T n , n Tn,n , there are two threshold values 0 ≤ p 1 , p 2 ≤ 1 0≤p1,p2≤1 such that p b ≪ p 1 pb≪p1 , p 1 ≪ p b ≪ p 2 p1≪pb≪p2 , and p 2 ≪ p b p2≪pb result in final complete occupancy by white, stable coexistence of both colors, and final complete occupancy by black, respectively in O ( n 2 ) O(n2) number of steps. (For two functions f ( n ) f(n) and g ( n ) g(n) , we shortly write f ( n ) ≪ g ( n ) f(n)≪g(n) instead of f ( n ) ∈ o ( g ( n ) ) f(n)∈o(g(n)) .) We finally argue that our proof techniques can be used to prove a similar threshold behavior for a larger class of models.},
  archive      = {J_TCS},
  author       = {Bernd Gärtner and Ahad N. Zehmakan},
  doi          = {10.1016/j.tcs.2021.07.035},
  journal      = {Theoretical Computer Science},
  pages        = {41-59},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Majority rule cellular automata},
  volume       = {889},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Super fault-tolerance assessment of locally twisted cubes
based on the structure connectivity. <em>TCS</em>, <em>889</em>, 25–40.
(<a href="https://doi.org/10.1016/j.tcs.2021.07.034">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The connectivity of a connected graph G is the minimum cardinality over all vertex-cuts, which can be determined using Menger&#39;s theorem (1927). Then G is super connected if its minimum vertex-cut is always composed of a vertex&#39;s neighborhood. Two generalized extensions to this classic notion of connectivity include the T -structure connectivity κ ( G ; T ) κ(G;T) and the T -substructure connectivity κ s ( G ; T ) κs(G;T) , for which T is the given structure isomorphic to a connected subgraph of G . Let ⁎ T ⁎ T⁎ denote the union of the set of all connected subgraphs of T and the set of the trivial graph. In this article, a connected graph G is called super T -connected if the minimum degree of G − F G−F is zero for each minimum T -cut F of G ; analogously, G is super ⁎ T ⁎ T⁎ -connected if the minimum degree of G − F G−F is zero for each minimum ⁎ T ⁎ T⁎ -cut F of G . Considering the n -dimensional locally twisted cube L T Q n LTQn with n ≥ 3 n≥3 , we first establish both κ ( L T Q n ; T ) κ(LTQn;T) and κ s ( L T Q n ; T ) κs(LTQn;T) and then determine whether L T Q n LTQn is super T -connected and super ⁎ T ⁎ T⁎ -connected, where T ∈ { K 1 , 1 , K 1 , 2 , K 1 , 3 , C 4 } ∪ { P k | 4 ≤ k ≤ n } T∈{K1,1,K1,2,K1,3,C4}∪{Pk|4≤k≤n} .},
  archive      = {J_TCS},
  author       = {Tzu-Liang Kung and Yuan-Hsiang Teng and Cheng-Kuan Lin},
  doi          = {10.1016/j.tcs.2021.07.034},
  journal      = {Theoretical Computer Science},
  pages        = {25-40},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Super fault-tolerance assessment of locally twisted cubes based on the structure connectivity},
  volume       = {889},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The complexity of counting edge colorings for simple graphs.
<em>TCS</em>, <em>889</em>, 14–24. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.033">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We prove #P-completeness results for counting edge colorings on simple graphs. These strengthen the corresponding results on multigraphs from [4] . We prove that for any κ ≥ r ≥ 3 κ≥r≥3 counting κ -edge colorings on r -regular simple graphs is #P-complete. Furthermore, we show that for planar r -regular simple graphs, where r ∈ { 3 , 4 , 5 } r∈{3,4,5} , counting edge colorings with κ colors for any κ ≥ r κ≥r is also #P-complete. As there are no planar r -regular simple graphs for any r &gt; 5 r&amp;gt;5 , these statements cover all interesting cases in terms of the parameters ( κ , r ) (κ,r) .},
  archive      = {J_TCS},
  author       = {Jin-Yi Cai and Artem Govorov},
  doi          = {10.1016/j.tcs.2021.07.033},
  journal      = {Theoretical Computer Science},
  pages        = {14-24},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The complexity of counting edge colorings for simple graphs},
  volume       = {889},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Succinct certification of monotone circuits. <em>TCS</em>,
<em>889</em>, 1–13. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.032">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Monotone Boolean circuits are circuits where each gate is either an AND gate or an OR gate. In other words, negation gates are not allowed on monotone circuits. This class of circuits has sparked the attention of researchers working in several subfields of combinatorics and complexity theory. In this work, we consider the notion of certification-width of a monotone Boolean circuit, a complexity measure that intuitively quantifies the minimum number of edges that need to be traversed by a minimal set of positive weight inputs in order to certify that a given circuit is satisfied. We call the problem of computing this invariant as Succinct Monotone Circuit Certification (SMCC) . We prove that SMCC is NP-complete even when the input monotone circuit is planar. Subsequently, we show that k -SMCC , the problem parameterized by the size of the solution, is W[1]-hard, but still in W[P]. In contrast, we show that k -SMCC is fixed-parameter tractable when restricted to monotone circuits of bounded genus.},
  archive      = {J_TCS},
  author       = {Mateus Rodrigues Alves and Mateus de Oliveira Oliveira and Janio Carlos Nascimento Silva and Uéverton dos Santos Souza},
  doi          = {10.1016/j.tcs.2021.07.032},
  journal      = {Theoretical Computer Science},
  pages        = {1-13},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Succinct certification of monotone circuits},
  volume       = {889},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the proper orientation number of chordal graphs.
<em>TCS</em>, <em>888</em>, 117–132. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.031">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {An orientation D of a graph G = ( V , E ) G=(V,E) is a digraph obtained from G by replacing each edge by exactly one of the two possible arcs with the same end vertices. For each v ∈ V ( G ) v∈V(G) , the indegree of v in D , denoted by d D − ( v ) dD−(v) , is the number of arcs with head v in D . An orientation D of G is proper if d D − ( u ) ≠ d D − ( v ) dD−(u)≠dD−(v) , for all u v ∈ E ( G ) uv∈E(G) . An orientation with maximum indegree at most k is called a k -orientation. The proper orientation number of G , denoted by χ → ( G ) χ→(G) , is the minimum integer k such that G admits a proper k -orientation. We prove that determining whether χ → ( G ) ≤ k χ→(G)≤k is NP - complete for chordal graphs of bounded diameter, but can be solved in linear-time in the subclass of quasi-threshold graphs. When parameterizing by k , we argue that this problem is FPT for chordal graphs and argue that no polynomial kernel exists, unless NP ⊆ coNP / poly ⊆coNP/poly . We present a better kernel to the subclass of split graphs and a linear kernel to the class of cobipartite graphs. Concerning bounds, we first prove that if G is split, then χ → ( G ) ≤ 2 ω ( G ) − 2 χ→(G)≤2ω(G)−2 and that if G is a k -uniform block graph, then χ → ( G ) ≤ 3 k − 2 χ→(G)≤3k−2 . These bounds are tight. We also present new families of trees having proper orientation number at most 2 and at most 3. Actually, we prove a general bound stating that any graph G having no adjacent vertices of degree at least c + 1 c+1 has proper orientation number at most c . This implies new classes of (outer)planar graphs with bounded proper orientation number. We also prove that maximal outerplanar graphs G whose weak-dual is a path satisfy χ → ( G ) ≤ 13 χ→(G)≤13 . Finally, we present simple bounds to the classes of chordal claw-free graphs and cographs.},
  archive      = {J_TCS},
  author       = {J. Araujo and A. Cezar and C.V.G.C. Lima and V.F. dos Santos and A. Silva},
  doi          = {10.1016/j.tcs.2021.07.031},
  journal      = {Theoretical Computer Science},
  pages        = {117-132},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On the proper orientation number of chordal graphs},
  volume       = {888},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Hybrid fault-tolerant prescribed hyper-hamiltonian
laceability of hypercubes. <em>TCS</em>, <em>888</em>, 108–116. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.030">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The n -dimensional hypercube Q n Qn is one of the most attractive interconnection networks for multiprocessor systems and it is a bipartite graph . Let F v Fv be a set of the end-nodes of k independent edges in Q n Qn and F e Fe be a set of f edges in Q n − F v Qn−Fv . Given a linear forest L of Q n − F v − F e Qn−Fv−Fe , in this paper, we prove that ( i ) Q n − F v − F e Qn−Fv−Fe admits a hamiltonian cycle passing through L if | E ( L ) | + k + f ≤ n − 2 |E(L)|+k+f≤n−2 ; and ( i i ) (ii) for any two nodes x and y of the opposite partite sets in Q n − F v − F e Qn−Fv−Fe such that none of the paths in L has x or y as internal node or both of them as end-nodes, Q n − F v − F e Qn−Fv−Fe admits a hamiltonian path between x and y passing through L if | E ( L ) | + k + f ≤ n − 3 |E(L)|+k+f≤n−3 ; and ( i i i ) (iii) for any two distinct nodes u and v of the partite set not containing w in Q n − F v − F e − w Qn−Fv−Fe−w such that none of the paths in L has u or v as internal node or both of them as end-nodes, Q n − F v − F e − w Qn−Fv−Fe−w admits a hamiltonian path between u and v passing through L if | E ( L ) | + k + f ≤ n − 3 |E(L)|+k+f≤n−3 , where w is an arbitrary node in Q n − F v − F e Qn−Fv−Fe .},
  archive      = {J_TCS},
  author       = {Yuxing Yang and Jing Li},
  doi          = {10.1016/j.tcs.2021.07.030},
  journal      = {Theoretical Computer Science},
  pages        = {108-116},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Hybrid fault-tolerant prescribed hyper-hamiltonian laceability of hypercubes},
  volume       = {888},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Reliability analysis of the cactus-based networks.
<em>TCS</em>, <em>888</em>, 95–107. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.029">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The attackers may have a tendency of targeting on a vulnerable network due to the fact that the cost of this attack is lower and the probability of successful attack is higher. Therefore, in order to enhance the invulnerability of a network, designers of massively networked multiprocessor systems concentrate on the robustness and reliability of the network. Connectivity and diagnosability are two significant indicators to measure the anti-attack ability of a network. In this paper, we introduce a novel class of topological structure based on group theory, the n -dimensional cactus-based network, denoted by C N n CNn . Then we show the characterization of algebraic and combinatorial properties for the cactus network as well as its connectivity, super connectivity, extra connectivity and corresponding diagnosabilities.},
  archive      = {J_TCS},
  author       = {Jiafei Liu and Shuming Zhou and Eddie Cheng and Qianru Zhou and Xiaoqing Liu},
  doi          = {10.1016/j.tcs.2021.07.029},
  journal      = {Theoretical Computer Science},
  pages        = {95-107},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Reliability analysis of the cactus-based networks},
  volume       = {888},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Satisfiability threshold for power law random 2-SAT in
configuration model. <em>TCS</em>, <em>888</em>, 70–94. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.028">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study Random 2-SAT problem, in which 2-CNFs are sampled from a wide range of non-uniform distributions, including heavy-tailed using random model that is quite different from the standard uniform Random 2-SAT. This model of random SAT is the so-called configuration model , given by a distribution ξ for the degree (or the number of occurrences) of each variable. To generate a formula the degree of each variable is sampled from ξ , generating several clones of the variable. Then 2-clauses are created by choosing a random partitioning into 2-element sets on the set of clones and assigning the polarity of literals at random. Here we consider the random 2-SAT problem in the configuration model for power-law-like distributions ξ . More precisely, we assume that ξ is such that its right tail F ξ ( x ) Fξ(x) satisfies the conditions W ℓ − α ≤ F ξ ( ℓ ) ≤ V ℓ − α Wℓ−α≤Fξ(ℓ)≤Vℓ−α for some constants V , W V,W . The main goal is to study the satisfiability threshold phenomenon, and we show that the threshold exists and is determined by a simple relation between the first and second moments of ξ .},
  archive      = {J_TCS},
  author       = {Oleksii Omelchenko and Andrei A. Bulatov},
  doi          = {10.1016/j.tcs.2021.07.028},
  journal      = {Theoretical Computer Science},
  pages        = {70-94},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Satisfiability threshold for power law random 2-SAT in configuration model},
  volume       = {888},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Which is the fairest allocation in the max-min
fairness-based coalitional game? <em>TCS</em>, <em>888</em>, 56–69. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.020">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In the coalitional game, the agents (nodes) cooperate or compete with each other to maximize their own benefits, thereby creating different coalitions. Designing a fair resource-allocation mechanism can reduce conflicts among agents and enable an all-win scenario. One popular resource-exchange mechanism, the max-min fairness-based coalitional (MMFC) mechanism, achieves fair allocation of resource by finding the max-min resource-exchange rate in a resource exchange network. However, this mechanism cannot ensure envy-free allocation of resource among the agents. To solve this problem, we proposed an envy-free resource-allocation mechanism called the envy-free max-min fairness-based coalitional (EFMMFC) mechanism, in which the resource-exchange rates of all agents constitute a max-min fair vector. EFMMFC mechanism opens new research directions in developing simple and efficient protocol that can produce envy-free allocation subject to the max-min resource exchange rate in coalitional game.},
  archive      = {J_TCS},
  author       = {Zheng Chen and Zhaoquan Gu and Yuexuan Wang},
  doi          = {10.1016/j.tcs.2021.07.020},
  journal      = {Theoretical Computer Science},
  pages        = {56-69},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Which is the fairest allocation in the max-min fairness-based coalitional game?},
  volume       = {888},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). How to construct physical zero-knowledge proofs for puzzles
with a “single loop” condition. <em>TCS</em>, <em>888</em>, 41–55. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.019">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We propose a technique to construct physical Zero-Knowledge Proof (ZKP) protocols for puzzles that require a single loop draw feature. Our approach is based on the observation that a loop has only one hole and this property remains stable by some simple transformations. Using this trick, we can transform a simple big loop, which is visible to anyone, into the solution loop by using transformations that do not disclose any information about the solution. We illustrate our technique by applying it to construct physical ZKP protocols for two Nikoli puzzles: Slitherlink and Masyu.},
  archive      = {J_TCS},
  author       = {Pascal Lafourcade and Daiki Miyahara and Takaaki Mizuki and Léo Robert and Tatsuya Sasaki and Hideaki Sone},
  doi          = {10.1016/j.tcs.2021.07.019},
  journal      = {Theoretical Computer Science},
  pages        = {41-55},
  shortjournal = {Theor. Comput. Sci.},
  title        = {How to construct physical zero-knowledge proofs for puzzles with a “single loop” condition},
  volume       = {888},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Cops and robber on some families of oriented graphs.
<em>TCS</em>, <em>888</em>, 31–40. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.016">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Cops and Robber is a two-player pursuit-evasion game in which a set of cops , controlled by Player 1, try to capture the robber , controlled by Player 2. We study three models of this game on oriented graphs which differ based on the kind of moves the players can make. These models are (i) the normal cop model , where both cops and robber can only move along the direction of the arcs; (ii) the strong cop model , where the cops can move along or against the direction of the arcs while the robber can only move along them; and (iii) the weak cop model , where the robber can move along or against the direction of the arcs while the cops can only move along them. The cop number is the minimum number of cops required to capture the robber in a graph, and a graph is cop-win if its cop number is 1. We begin our study by comparing the cop number in these three models for oriented graphs . For the normal cop model, we show that there exist strongly connected oriented graphs having high girth, high minimum degree, and high cop number. We also characterize the cop-win graphs in various graph classes like transitive-triangle-free, outerplanar, and subcubic graphs. For the strong cop model, we construct graphs with unbounded cop number, and also study the cop number of grids, outerplanar, and planar graphs . For the weak cop model, we characterize the cop-win graphs.},
  archive      = {J_TCS},
  author       = {Sandip Das and Harmender Gahlawat and Uma kant Sahoo and Sagnik Sen},
  doi          = {10.1016/j.tcs.2021.07.016},
  journal      = {Theoretical Computer Science},
  pages        = {31-40},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Cops and robber on some families of oriented graphs},
  volume       = {888},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Approximation algorithms for the maximum vertex coverage
problem on bounded degree graphs. <em>TCS</em>, <em>888</em>, 22–30. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.015">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Maximum Vertex Coverage problem (abbreviated as MVC) is to maximum the number of edges covered by a set of vertices of size exactly K on a graph. This problem is the dual of the vertex cover problem and has attracted a lot of interests in the literature of approximation algorithm . So far, the best approximation factor for the MVC problem is 3/4, which is obtained using an LP-rounding method. The main results of this paper are new approximation algorithms for MVC on cubic graphs and 3-bounded graphs (the vertex degrees are at most 3). The approximation factor on cubic graphs is 79/90 (≈0.878), which is tight by analyzing the existence of a feasible solution for a linear programming system. This algorithm can also be extended to 3-bounded graphs and guarantees an approximation factor of 19/24 (≈0.792).},
  archive      = {J_TCS},
  author       = {Peiyan Zhou and Haitao Jiang and Daming Zhu and Binhai Zhu},
  doi          = {10.1016/j.tcs.2021.07.015},
  journal      = {Theoretical Computer Science},
  pages        = {22-30},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Approximation algorithms for the maximum vertex coverage problem on bounded degree graphs},
  volume       = {888},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Generic construction for tightly-secure signatures from
discrete log. <em>TCS</em>, <em>888</em>, 13–21. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.014">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Tightly secure signature plays a significant role in the research of cryptography and has been studied extensively in the literature. In this paper, we present a generic construction for tightly-secure signatures from the discrete log (DL) assumption in the existential-unforgeability against key only attacks (EUF-KOA) security model, where the adversary is allowed to obtain only the public key , but not any sample signature. Moreover, the generic construction can also be extended into the multi-user setting with corruptions (MU-C) model. Roughly speaking, given any signature scheme, we can efficiently convert it into a signature scheme that features tight security under the DL assumption in the MU-EUF-KOA-C security model with random oracles. Our transformation shows it is easy to construct a DL-equivalent signature in the EUF-KOA security model, although many known DL-based signatures are not equivalent to DL. If the given signature scheme is key-re-randomizable, the transformed scheme is also key-re-randomizable. Hence, our result provides a supplement to Bader et al.&#39;s work (EUROCRYPT 2016).},
  archive      = {J_TCS},
  author       = {Jianchang Lai and Ge Wu and Peng Jiang and Zhen Zhao and Willy Susilo and Fuchun Guo},
  doi          = {10.1016/j.tcs.2021.07.014},
  journal      = {Theoretical Computer Science},
  pages        = {13-21},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Generic construction for tightly-secure signatures from discrete log},
  volume       = {888},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the effectiveness of the incremental approach to minimal
chordal edge modification. <em>TCS</em>, <em>888</em>, 1–12. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.013">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Because edge modification problems are computationally difficult for most target graph classes, considerable attention has been devoted to inclusion-minimal edge modifications, which are usually polynomial-time computable and which can serve as an approximation of minimum cardinality edge modifications, albeit with no guarantee on the cardinality of the resulting modification set. Over the past fifteen years, the primary design approach used for inclusion-minimal edge modification algorithms is based on a specific incremental scheme. Unfortunately, nothing guarantees that the set E E of edge modifications of a graph G that can be obtained in this specific way spans all the inclusion-minimal edge modifications of G . Here, we focus on edge modification problems into the class of chordal graphs and we show that for this the set E E may not even contain any solution of minimum size and may not even contain a solution close to the minimum; in fact, we show that it may not contain a solution better than within an Ω ( n ) Ω(n) factor of the minimum. These results show strong limitations on the use of the current favored algorithmic approach to inclusion-minimal edge modification in heuristics for computing a minimum cardinality edge modification. They suggest that further developments might be better using other approaches.},
  archive      = {J_TCS},
  author       = {Jean R.S. Blair and Christophe Crespelle},
  doi          = {10.1016/j.tcs.2021.07.013},
  journal      = {Theoretical Computer Science},
  pages        = {1-12},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On the effectiveness of the incremental approach to minimal chordal edge modification},
  volume       = {888},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A new construction of odd-variable rotation symmetric
boolean functions with optimal algebraic immunity and higher
nonlinearity. <em>TCS</em>, <em>887</em>, 152–163. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.018">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Rotation symmetric Boolean functions are potentially rich in functions of cryptographic significance. In this paper, a new construction of odd-variable rotation symmetric Boolean functions with optimal algebraic immunity is presented. By a direct calculation, the nonlinearity of the newly constructed functions is higher than the nonlinearities of all the known odd-variable rotation symmetric Boolean functions with optimal algebraic immunity. The algebraic degree and the fast algebraic immunity of our functions are also considered.},
  archive      = {J_TCS},
  author       = {Sihong Su and Jingjing Li and Bingxin Wang},
  doi          = {10.1016/j.tcs.2021.07.018},
  journal      = {Theoretical Computer Science},
  pages        = {152-163},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A new construction of odd-variable rotation symmetric boolean functions with optimal algebraic immunity and higher nonlinearity},
  volume       = {887},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Efficiently computing runs on a trie. <em>TCS</em>,
<em>887</em>, 143–151. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.011">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A maximal repetition, or run, in a string, is a maximal periodic substring whose smallest period is at most half the length of the substring. In this paper, we consider runs that correspond to a path on a trie, or in other words, on a rooted edge-labeled tree where each edge is labeled with a single symbol, and the endpoints of the path must be a descendant/ancestor of the other. For a trie with n edges, we show that the number of runs is less than n . We also show an asymptotic lower bound on the maximum density of runs in tries: lim n → ∞ ⁡ ρ T ( n ) / n &gt; 0.9932348 limn→∞⁡ρT(n)/n&amp;gt;0.9932348 where ρ T ( n ) ρT(n) is the maximum number of runs in a trie with n edges. Furthermore, we also show an O ( n log ⁡ log ⁡ n ) O(nlog⁡log⁡n) time and O ( n ) O(n) space algorithm for finding all runs.},
  archive      = {J_TCS},
  author       = {Ryo Sugahara and Yuto Nakashima and Shunsuke Inenaga and Hideo Bannai and Masayuki Takeda},
  doi          = {10.1016/j.tcs.2021.07.011},
  journal      = {Theoretical Computer Science},
  pages        = {143-151},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Efficiently computing runs on a trie},
  volume       = {887},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Algorithms for the rainbow vertex coloring problem on graph
classes. <em>TCS</em>, <em>887</em>, 122–142. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.009">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Given a vertex-colored graph, we say a path is a rainbow vertex path if all its internal vertices have distinct colors. The graph is rainbow vertex-connected if there is a rainbow vertex path between every pair of its vertices. In the Rainbow Vertex Coloring (RVC) problem we want to decide whether the vertices of a given graph can be colored with at most k colors so that the graph becomes rainbow vertex-connected. This problem is known to be NP -complete even in very restricted scenarios, and very few efficient algorithms are known for it. In this work, we give polynomial-time algorithms for RVC on permutation graphs, powers of trees and split strongly chordal graphs . The algorithm for the latter class also works for the strong variant of the problem, where the rainbow vertex paths between each vertex pair must be shortest paths. We complement the polynomial-time solvability results for split strongly chordal graphs by showing that, for any fixed p ≥ 3 p≥3 both variants of the problem become NP -complete when restricted to split ( S 3 , … , S p ) (S3,…,Sp) -free graphs, where S q Sq denotes the q -sun graph.},
  archive      = {J_TCS},
  author       = {Paloma T. Lima and Erik Jan van Leeuwen and Marieke van der Wegen},
  doi          = {10.1016/j.tcs.2021.07.009},
  journal      = {Theoretical Computer Science},
  pages        = {122-142},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Algorithms for the rainbow vertex coloring problem on graph classes},
  volume       = {887},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Optimal dispersion on an anonymous ring in the presence of
weak byzantine robots. <em>TCS</em>, <em>887</em>, 111–121. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.008">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The problem of dispersion of mobile robots on a graph asks that n robots initially placed arbitrarily on the nodes of an n -node anonymous graph, autonomously move to reach a final configuration where each node has at most one robot on it. This problem is of significant interest due to its relationship to other fundamental robot coordination problems, such as exploration, scattering, load balancing, relocation of self-driving electric cars to recharge stations, etc. The robots have unique IDs, typically in the range [ 1 , p o l y ( n ) ] [1,poly(n)] and limited memory, whereas the graph is anonymous, i.e., the nodes do not have identifiers. The objective is to simultaneously minimize two performance metrics: (i) time to achieve dispersion and (ii) memory requirement at each robot. This problem has been relatively well-studied when robots are non-faulty. In this paper, we introduce the notion of Byzantine faults to this problem, i.e., we formalize the problem of dispersion in the presence of up to f Byzantine robots. We then study the problem on a ring while simultaneously optimizing the time complexity of algorithms and the memory requirement per robot. Specifically, we design deterministic algorithms that attempt to match the time lower bound ( Ω ( n ) Ω(n) rounds) and memory lower bound ( Ω ( log ⁡ n ) Ω(log⁡n) bits per robot). Our main result is a deterministic algorithm that is both time and memory optimal, i.e., O ( n ) O(n) rounds and O ( log ⁡ n ) O(log⁡n) bits of memory required per robot, subject to certain constraints. We subsequently provide results that require less assumptions but are either only time or memory optimal but not both. We also provide a primitive, utilized often, that takes robots initially gathered at a node of the ring and disperses them in a time and memory optimal manner without additional assumptions required.},
  archive      = {J_TCS},
  author       = {Anisur Rahaman Molla and Kaushik Mondal and William K. Moses Jr.},
  doi          = {10.1016/j.tcs.2021.07.008},
  journal      = {Theoretical Computer Science},
  pages        = {111-121},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Optimal dispersion on an anonymous ring in the presence of weak byzantine robots},
  volume       = {887},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021b). Securely computing the n-variable equality function with 2n
cards. <em>TCS</em>, <em>887</em>, 99–110. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.007">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Research in the area of secure multi-party computation using a deck of playing cards, often called card-based cryptography, started from the introduction of the five-card trick protocol to compute the logical AND function by den Boer in 1989. Since then, many card-based protocols to compute various functions have been developed. In this paper, we propose two new protocols that securely compute the n -variable equality function (determining whether all inputs are equal) E : { 0 , 1 } n → { 0 , 1 } E:{0,1}n→{0,1} using 2 n cards. The first protocol can be generalized to compute any doubly symmetric function f : { 0 , 1 } n → Z f:{0,1}n→Z using 2 n cards, and any symmetric function f : { 0 , 1 } n → Z f:{0,1}n→Z using 2 n + 2 2n+2 cards. The second protocol can be generalized to compute the k -candidate n -variable equality function E : ( Z / k Z ) n → { 0 , 1 } E:(Z/kZ)n→{0,1} using 2 ⌈ lg ⁡ k ⌉ n 2⌈lg⁡k⌉n cards.},
  archive      = {J_TCS},
  author       = {Suthee Ruangwises and Toshiya Itoh},
  doi          = {10.1016/j.tcs.2021.07.007},
  journal      = {Theoretical Computer Science},
  pages        = {99-110},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Securely computing the n-variable equality function with 2n cards},
  volume       = {887},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The t/s-diagnosability and t/s-diagnosis algorithm of folded
hypercube under the PMC/MM* model. <em>TCS</em>, <em>887</em>, 85–98.
(<a href="https://doi.org/10.1016/j.tcs.2021.07.006">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A t / s t/s -diagnosable system refers to such a system that all the faulty nodes of the system can be isolated within a set of size at most s in the presence of at most t faulty nodes. Moreover, it increases the allowed faulty nodes, hence enhancing the diagnosability of the system. We can find that the t / s t/s -diagnosability of n -dimensional folded hypercube F Q n FQn has not been studied under the PMC model and MM* model. In this paper, we determine the t / s t/s -diagnosability of F Q n FQn under the PMC model and MM* model. First, we propose some new fault tolerant properties of F Q n FQn . Then we prove that the t / s t/s -diagnosability of n -dimensional folded hypercube F Q n FQn is ( n + 1 ) g − 1 2 ( g − 1 ) ( g + 2 ) (n+1)g−12(g−1)(g+2) for 2 ≤ g ≤ 1 2 ( n − 1 ) 2≤g≤12(n−1) where s = ( n + 1 ) g − 1 2 ( g − 1 ) ( g + 2 ) + g − 2 s=(n+1)g−12(g−1)(g+2)+g−2 under both the PMC model and MM* model. In addition, we establish two t / s t/s -diagnosis algorithms of complexity O ( N l o g 2 N ) O(Nlog2N) and complexity O ( N ( l o g 2 N ) 2 ) O(N(log2N)2) to isolate the faulty nodes in a node subset of the system under the PMC model and MM* model, respectively. The comparison analysis results showed that the t / s t/s -diagnosability of F Q n FQn is the largest, and it increases faster than the other types of diagnosability as n increases.},
  archive      = {J_TCS},
  author       = {Yuhang Lin and Limei Lin and Yanze Huang and Jiaru Wang},
  doi          = {10.1016/j.tcs.2021.07.006},
  journal      = {Theoretical Computer Science},
  pages        = {85-98},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The t/s-diagnosability and t/s-diagnosis algorithm of folded hypercube under the PMC/MM* model},
  volume       = {887},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Derandomization and absolute reconstruction for sums of
powers of linear forms. <em>TCS</em>, <em>887</em>, 63–84. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.005">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the decomposition of multivariate polynomials as sums of powers of linear forms. As one of our main results, we give a randomized algorithm for the following problem: given a homogeneous polynomial f ( x 1 , … , x n ) f(x1,…,xn) of degree 3, decide whether it can be written as a sum of cubes of linearly independent linear forms with complex coefficients . Compared to previous algorithms for the same problem, the two main novel features of this algorithm are: Finally we give several related derandomization results on black box polynomial identity testing, the minimization of the number of variables in a polynomial, the computation of Lie algebras and factorization into products of linear forms.},
  archive      = {J_TCS},
  author       = {Pascal Koiran and Mateusz Skomra},
  doi          = {10.1016/j.tcs.2021.07.005},
  journal      = {Theoretical Computer Science},
  pages        = {63-84},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Derandomization and absolute reconstruction for sums of powers of linear forms},
  volume       = {887},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). An improved upper bound for SAT. <em>TCS</em>, <em>887</em>,
51–62. (<a href="https://doi.org/10.1016/j.tcs.2021.06.045">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We show that the CNF satisfiability problem can be solved in ⁎ O ⁎ ( 1.2226 m ) O⁎(1.2226m) time, where m is the number of clauses in the formula, improving the known upper bounds ⁎ O ⁎ ( 1.234 m ) O⁎(1.234m) given by Yamamoto 15 years ago and ⁎ O ⁎ ( 1.239 m ) O⁎(1.239m) given by Hirsch 22 years ago. By using an amortized technique and careful case analysis, we successfully avoid the bottlenecks in previous algorithms and get the improvement.},
  archive      = {J_TCS},
  author       = {Huairui Chu and Mingyu Xiao and Zhe Zhang},
  doi          = {10.1016/j.tcs.2021.06.045},
  journal      = {Theoretical Computer Science},
  pages        = {51-62},
  shortjournal = {Theor. Comput. Sci.},
  title        = {An improved upper bound for SAT},
  volume       = {887},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). General cops and robbers games with randomness.
<em>TCS</em>, <em>887</em>, 30–50. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.043">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Cops and Robbers games have been studied for the last few decades in computer science and mathematics. As in general pursuit evasion games, pursuers (cops) seek to capture evaders (robbers); however, players move in turn and are constrained to move on a discrete structure, usually a graph, and know the exact location of their opponent. In 2017, Bonato and MacGillivray [2] presented a general characterization of Cops and Robbers games in order for them to be globally studied. However, their model doesn&#39;t cover cases where stochastic events may occur, such as the robbers moving in a random fashion. In this paper we present a novel model with stochastic elements that we call a Generalized Probabilistic Cops and Robbers game (GPCR). A typical such game is one where the robber moves according to a probabilistic distribution , either because she is rather lost or drunk than evading, or because she is a robot. We present results to solve GPCR games, thus enabling one to study properties relating to the optimal strategies in large classes of Cops and Robbers games. Some classic Cops and Robbers games properties are also extended.},
  archive      = {J_TCS},
  author       = {Frédéric Simard and Josée Desharnais and François Laviolette},
  doi          = {10.1016/j.tcs.2021.06.043},
  journal      = {Theoretical Computer Science},
  pages        = {30-50},
  shortjournal = {Theor. Comput. Sci.},
  title        = {General cops and robbers games with randomness},
  volume       = {887},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Searching for an evader in an unknown dark cave by an
optimal number of asynchronous searchers. <em>TCS</em>, <em>887</em>,
11–29. (<a href="https://doi.org/10.1016/j.tcs.2021.06.042">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The graph search problem is the problem of searching for a mobile evader in a dark cave by a group of mobile searchers, where the cave is modeled by an undirected connected graph G . An offline and centralized version of the graph search problem is formalized as a pebble game on G , and has been extensively investigated under the name of the edge search problem. By es ( G ) es(G) we denote the number of pebbles (i.e., searchers) necessary and sufficient to edge search G . An online and distributed version of the graph search problem is the graph search by mobile agents . We investigate the graph search problem under a weaker online and distributed setting called the dark cave model , which models the dark cave more directly than a graph; G is completely anonymous, and we do not introduce any artificial facilities in G such as a port numbering, a homebase, and a whiteboard. Instead, we assume that the searchers can exchange information wherever they meet. Under the dark cave model, we propose a search algorithm OLSEARCH for es ( G ) es(G) searchers, and show that it is optimal in terms of the number of searchers.},
  archive      = {J_TCS},
  author       = {Takahiro Yakami and Yukiko Yamauchi and Shuji Kijima and Masafumi Yamashita},
  doi          = {10.1016/j.tcs.2021.06.042},
  journal      = {Theoretical Computer Science},
  pages        = {11-29},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Searching for an evader in an unknown dark cave by an optimal number of asynchronous searchers},
  volume       = {887},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On synchronization and orientation in distributed barrier
coverage with relocatable sensors. <em>TCS</em>, <em>887</em>, 1–10. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.038">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Consider n identical relocatable sensors , with sensing range r and visibility range 2 r , initially placed at arbitrary positions on a line segment barrier; each sensor can detect the presence of an intruder in its sensing range, and is said to cover the portion of the barrier that intersects with its sensing range. Sensors operate in Look-Compute-Move cycles: in a cycle a sensor determines the positions of sensors in its visibility range, it computes its next position (within its visibility range), and then moves to the calculated position . The barrier coverage problem we consider is for the sensors to independently make decisions and movements so to reach final positions whereby they collectively cover the barrier; in particular we are interested in oblivious (or memoryless) sensors, and focus on the impact that the level of synchrony and the presence/absence of orientation (i.e., global notion of “left-right”) have on the solvability of the problem. It is known that without orientation, oblivious sensors can solve the problem if they are fully synchronous (i.e., they operate in synchronous rounds and are all active at every round). In this paper, we prove that orientation is critical to being able to solve the problem if we relax the assumption of full synchronization. We first show that if sensors are unoriented, then barrier coverage is unsolvable even in the semi-synchronous setting. In contrast, if sensors agree on a global orientation, then we give an algorithm for barrier coverage, even in the completely asynchronous setting. Finally, we extend the existing result of Cohen and Peleg and show that convergence to barrier coverage by unoriented sensors in the semi-synchronous model is possible with bounded visibility range 2 r + ρ 2r+ρ (for arbitrarily small ρ &gt; 0 ρ&amp;gt;0 ) and bounded mobility range r .},
  archive      = {J_TCS},
  author       = {Mohsen Eftekhari and Paola Flocchini and Lata Narayanan and Jaroslav Opatrny and Nicola Santoro},
  doi          = {10.1016/j.tcs.2021.06.038},
  journal      = {Theoretical Computer Science},
  pages        = {1-10},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On synchronization and orientation in distributed barrier coverage with relocatable sensors},
  volume       = {887},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Dispersing and grouping points on planar segments.
<em>TCS</em>, <em>886</em>, 169–177. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.011">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Motivated by (continuous) facility location, we study the problem of dispersing and grouping points on a set of segments (of streets) in the plane. In the former problem, given a set of n disjoint line segments in the plane, we investigate the problem of computing a point on each of the n segments such that the minimum Euclidean distance between any two of these points is maximized. We prove that this 2D dispersion problem is NP-hard, in fact, it is NP-hard even if all the segments are parallel and are of unit length. This is in contrast to the polynomial solvability of the corresponding 1D problem by Li and Wang (2016), where the intervals are in 1D and are all disjoint. With this result, we also show that the Independent Set problem on Colored Linear Unit Disk Graph (meaning the convex hulls of points with the same color form disjoint line segments) remains NP-hard, and the parameterized version of it is in W[2]. In the latter problem, given a set of n disjoint line segments in the plane we study the problem of computing a point on each of the n segments such that the maximum Euclidean distance between any two of these points is minimized. We present a factor-1.1547 approximation algorithm which runs in O ( n log ⁡ n ) O(nlog⁡n) time. Our results can be generalized to the Manhattan distance.},
  archive      = {J_TCS},
  author       = {Xiaozhou He and Wenfeng Lai and Binhai Zhu and Peng Zou},
  doi          = {10.1016/j.tcs.2021.08.011},
  journal      = {Theoretical Computer Science},
  pages        = {169-177},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Dispersing and grouping points on planar segments},
  volume       = {886},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On finding maximum disjoint paths with different colors:
Computational complexity and practical LP-based algorithms.
<em>TCS</em>, <em>886</em>, 157–168. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.009">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {With the rapid development of wireless networks, the burden on data transmission is becoming much higher, so are the requirements for bandwidth and load balancing. To cope with these changing requirements, we investigate a novel problem of finding maximum disjoint paths with different colors ( MDPDC ). In MDPDC , transmission frequencies in a network are modeled as different colors on network nodes. The aim is to find a maximum number of color-constrained node-disjoint paths where nodes must share the same color within any disjoint path, and differ in color among different disjoint paths. For this proposed problem, we first prove MDPDC is NP NP -complete in both directed and undirected graphs. Then we provide two practical linear programming based solutions with theoretical justifications of their correctness and time complexity. Extensive computer experiments are also carried out with several compared baseline methods to demonstrate the effectiveness of proposed algorithms both in running time and solution quality.},
  archive      = {J_TCS},
  author       = {Yunyun Deng and Longkun Guo and Kewen Liao and Yi Chen},
  doi          = {10.1016/j.tcs.2021.08.009},
  journal      = {Theoretical Computer Science},
  pages        = {157-168},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On finding maximum disjoint paths with different colors: Computational complexity and practical LP-based algorithms},
  volume       = {886},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). One-visibility cops and robber on trees. <em>TCS</em>,
<em>886</em>, 139–156. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.038">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The one-visibility cops and robber game is a variation of the classic cops and robber game, where one-visibility means that the information of the robber is known to all cops only when the distance between the robber and at least one cop is at most one. In this paper, we give a lower bound on the one-visibility copnumber of general trees. We present strategies to clear trees according to their structures. We propose a linear-time algorithm for computing the one-visibility copnumber of trees.},
  archive      = {J_TCS},
  author       = {Boting Yang and Tanzina Akter},
  doi          = {10.1016/j.tcs.2021.07.038},
  journal      = {Theoretical Computer Science},
  pages        = {139-156},
  shortjournal = {Theor. Comput. Sci.},
  title        = {One-visibility cops and robber on trees},
  volume       = {886},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Extremal set theory and LWE based access structure hiding
verifiable secret sharing with malicious-majority and free verification.
<em>TCS</em>, <em>886</em>, 106–138. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.022">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Secret sharing allows a dealer to distribute a secret among a set of parties such that only authorized subsets, specified by an access structure, can reconstruct the secret. Sehrawat and Desmedt (COCOON 2020 [80] ) introduced hidden access structures , that remain secret until some authorized subset of parties collaborate. However, their scheme assumes semi-honest parties and supports only restricted access structures. We address these shortcomings by constructing a novel access structure hiding verifiable secret sharing scheme that supports all monotone access structures. Our scheme is the first secret sharing solution to support malicious behavior identification and share verifiability in malicious-majority settings. Furthermore, the verification procedure of our scheme incurs no communication overhead , and is therefore “free”. As the building blocks of our scheme, we introduce and construct the following:},
  archive      = {J_TCS},
  author       = {Vipin Singh Sehrawat and Foo Yee Yeo and Yvo Desmedt},
  doi          = {10.1016/j.tcs.2021.07.022},
  journal      = {Theoretical Computer Science},
  pages        = {106-138},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Extremal set theory and LWE based access structure hiding verifiable secret sharing with malicious-majority and free verification},
  volume       = {886},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Scheduling with variable-length calibrations: Two agreeable
variants. <em>TCS</em>, <em>886</em>, 94–105. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.021">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Machines usually require maintenance after running a fixed period. A calibration at a cost has to be performed during the process. Finding a feasible schedule minimizing the total cost of calibrations is of great importance. In this paper, we deal with a single machine scheduling model with K types of calibrations. A calibration of type k ∈ { 1 , … , K } k∈{1,…,K} can be made instantaneously at any time point, which incurs a cost f k fk and can keep the machine active for a length T k Tk . Given a set of n jobs with release times, deadlines, and processing times, the goal is to minimize the total cost of calibrations by assigning all jobs in the calibrated state, where job preemption is allowed. We investigate two agreeable settings. Regarding agreeable jobs, later release times imply later deadlines. We establish a pseudo-polynomial time optimal algorithm and a ( 3 + ε ) (3+ε) -approximation algorithm. Moreover, if the largest job processing time is no more than any calibration length, it admits a ( 2 + ε ) (2+ε) -approximation algorithm. As for agreeable calibrations, where the cost of each calibration is proportional to its length, a 2-approximation algorithm is presented.},
  archive      = {J_TCS},
  author       = {Hua Chen and Lin Chen and Guochuan Zhang and Vincent Chau},
  doi          = {10.1016/j.tcs.2021.07.021},
  journal      = {Theoretical Computer Science},
  pages        = {94-105},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Scheduling with variable-length calibrations: Two agreeable variants},
  volume       = {886},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The small set vertex expansion problem. <em>TCS</em>,
<em>886</em>, 84–93. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.017">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In the Small Set Vertex Expansion (SSVE) problem, we are given a graph G = ( V , E ) G=(V,E) and a positive integer k ≤ | V ( G ) | 2 k≤|V(G)|2 , the goal is to return a set S ⊂ V ( G ) S⊂V(G) of k nodes minimizing the vertex expansion Φ V ( S ) = | N ( S ) | ΦV(S)=|N(S)| . The Small Set Vertex Expansion problem has not been as well studied as its edge-based counterpart Small Set Expansion (SSE). SSE, and SSVE to a less extend, have been studied due to their connection to other hard problems including the Unique Games Conjecture and Graph Colouring. The Small Set Vertex Expansion is known to be NP-complete. We enhance our understanding of the problem from the viewpoint of parameterized complexity by showing that (1) the problem is W[1]-hard when parameterized by the solution size, (2) the problem is fixed-parameter tractable (FPT) when parameterized by the neighbourhood diversity of the input graph, (3) it can be solved in polynomial time for graphs of bounded clique-width, and (4) it is fixed-parameter tractable (FPT) when parameterized by treewidth of the input graph.},
  archive      = {J_TCS},
  author       = {Garima Agrawal and Soumen Maity},
  doi          = {10.1016/j.tcs.2021.07.017},
  journal      = {Theoretical Computer Science},
  pages        = {84-93},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The small set vertex expansion problem},
  volume       = {886},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Complexity and inapproximability results for balanced
connected subgraph problem. <em>TCS</em>, <em>886</em>, 69–83. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.010">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This work is devoted to the study of the Balanced Connected Subgraph Problem (BCS) from a complexity, inapproximability and approximation point of view. The input is a graph G = ( V , E ) G=(V,E) , with each vertex having been colored, “red” or “blue”; the goal is to find a maximum connected subgraph G ′ = ( V ′ , E ′ ) G′=(V′,E′) from G that is color-balanced (having exactly | V ′ | / 2 |V′|/2 red vertices and | V ′ | / 2 |V′|/2 blue vertices). This problem is known to be NP NP -complete in general but polynomial in paths and trees. We propose a polynomial-time algorithm for block graph. We propose some complexity results for bounded-degree or bounded-diameter graphs, and also for bipartite graphs. We also propose inapproximability results for some graph classes, including chordal, planar, or subcubic graphs.},
  archive      = {J_TCS},
  author       = {T. Martinod and V. Pollet and B. Darties and R. Giroudeau and J.-C. König},
  doi          = {10.1016/j.tcs.2021.07.010},
  journal      = {Theoretical Computer Science},
  pages        = {69-83},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Complexity and inapproximability results for balanced connected subgraph problem},
  volume       = {886},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Set-constrained delivery broadcast: A communication
abstraction for read/write implementable distributed objects.
<em>TCS</em>, <em>886</em>, 49–68. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.044">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper introduces a new communication abstraction, called Set-Constrained Delivery Broadcast (SCD-broadcast), whose aim is to provide its users with an appropriate abstraction level when they have to implement objects or distributed tasks in an asynchronous message-passing system prone to process crash failures. This abstraction allows each process to broadcast messages and deliver a sequence of sets of messages in such a way that, if a process delivers a set of messages including a message m and later delivers a set of messages including a message m ′ m′ , no process delivers first a set of messages including m ′ m′ and later a set of message including m . After having presented an algorithm implementing SCD-broadcast, the paper investigates its programming power and its computability limits. On the “power” side it presents SCD-broadcast-based algorithms, which are both simple and efficient, building objects (such as snapshot and conflict-free replicated data types), and distributed tasks. On the “computability limits” side it shows that SCD-broadcast and read/write registers are computationally equivalent.},
  archive      = {J_TCS},
  author       = {Damien Imbs and Achour Mostéfaoui and Matthieu Perrin and Michel Raynal},
  doi          = {10.1016/j.tcs.2021.06.044},
  journal      = {Theoretical Computer Science},
  pages        = {49-68},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Set-constrained delivery broadcast: A communication abstraction for read/write implementable distributed objects},
  volume       = {886},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Concurrent linearizable nearest neighbour search in
LockFree-kD-tree. <em>TCS</em>, <em>886</em>, 27–48. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.041">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Nearest neighbour search (NNS) is a fundamental problem in many application domains dealing with multidimensional data. In a concurrent setting, where dynamic modifications are allowed, a linearizable implementation of the NNS is highly desirable. This paper introduces the LockFree-kD-tree (LFkD-tree ): a lock-free concurrent kD-tree, which implements an abstract data type (ADT) that provides the operations Add , Remove , Contains , and NNS . Our implementation is linearizable. The operations in the LFkD-tree use single-word read and compare-and-swap ( ) atomic primitives, which are readily supported on available multi-core processors. We experimentally evaluate the LFkD-tree using several benchmarks comprising real-world and synthetic datasets. The experiments show that the presented design is scalable and achieves significant speed-up compared to the implementations of an existing sequential kD-tree and a recently proposed multidimensional indexing structure, PH-tree.},
  archive      = {J_TCS},
  author       = {Bapi Chatterjee and Ivan Walulya and Philippas Tsigas},
  doi          = {10.1016/j.tcs.2021.06.041},
  journal      = {Theoretical Computer Science},
  pages        = {27-48},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Concurrent linearizable nearest neighbour search in LockFree-kD-tree},
  volume       = {886},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The assignment problem. <em>TCS</em>, <em>886</em>, 13–26.
(<a href="https://doi.org/10.1016/j.tcs.2021.06.040">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In the allocation problem, asynchronous processors must partition a set of items so that each processor leaves knowing all items exclusively allocated to it. We introduce a new variant of the allocation problem called the assignment problem, in which processors might leave having only partial knowledge of their assigned items. The missing items in a processor&#39;s assignment must eventually be announced by other processors. While allocation has consensus number 2, we show that the assignment problem is solvable read-write wait-free when k processors compete for at least 2 k − 1 2k−1 items. Moreover, we propose a long-lived read-write wait-free assignment algorithm which is fair, allocating no more than 2 items per processor, and in which a slow processor may delay the assignment of at most n items, where n is the number of processors. The assignment problem and its read-write solution may be of practical interest for implementing resource allocators and work queues, which are pervasive concurrent programming patterns, as well as stream-processing systems.},
  archive      = {J_TCS},
  author       = {Carole Delporte-Gallet and Hugues Fauconnier and Eli Gafni and Giuliano Losa},
  doi          = {10.1016/j.tcs.2021.06.040},
  journal      = {Theoretical Computer Science},
  pages        = {13-26},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The assignment problem},
  volume       = {886},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Fixed-parameter tractability for the tree assembly problem.
<em>TCS</em>, <em>886</em>, 3–12. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.036">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Calculating the “distance” between two given objects with respect to a designated “editing” operation is a hot research area in bioinformatics, where the “distance” is always defined as the minimum number of the “editing” operations required to transform one object into the other one. One of the famous problems in the area is the Minimum Common String Partition problem, which is the simplified variant of the Minimum Tree Cut/Paste Distance problem. Within the paper, we consider another simplified variant of the Minimum Tree Cut/Paste Distance problem, named Tree Assembly problem, of which the edge-deletion operations are specified. More specifically, the Tree Assembly problem aims to transform a given forest into a given tree by edge-addition operations only. In our investigations, we present a fixed-parameter algorithm with runtime 2 O ( k log ⁡ k ) n O ( 1 ) 2O(klog⁡k)nO(1) for the Tree Assembly problem, where k is the number of trees in the given forest, and n is the number of nodes in the given tree and forest. Additionally, we give a polynomial time algorithm for a restricted variant of the problem.},
  archive      = {J_TCS},
  author       = {Feng Shi and Jie You and Zhen Zhang and Jingyi Liu and Jianxin Wang},
  doi          = {10.1016/j.tcs.2021.06.036},
  journal      = {Theoretical Computer Science},
  pages        = {3-12},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Fixed-parameter tractability for the tree assembly problem},
  volume       = {886},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Editorial: The 27th london stringology days &amp; london
algorithmic workshop (LSD &amp; LAW) 2019. <em>TCS</em>, <em>886</em>,
1–2. (<a href="https://doi.org/10.1016/j.tcs.2021.08.024">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_TCS},
  author       = {Lorraine A.K. Ayad ( Guest Editor ) and Carl Barton (Guest Editor) and Costas Iliopoulos (Guest Editor)},
  doi          = {10.1016/j.tcs.2021.08.024},
  journal      = {Theoretical Computer Science},
  pages        = {1-2},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Editorial: The 27th london stringology days &amp; london algorithmic workshop (LSD &amp; LAW) 2019},
  volume       = {886},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Approximation algorithms for fuzzy c-means problem based on
seeding method. <em>TCS</em>, <em>885</em>, 146–158. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.035">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {As a kind of important soft clustering model, the fuzzy C -means method is widely applied in many fields. In this method, instead of the strict distributive ability in the classical k -means method, all the sample points are endowed with degrees of membership to each center to depict the fuzzy clustering. In this paper, we show that the fuzzy C -means++ algorithm, which introduces the k -means++ algorithm as a seeding strategy, gives a solution for which the approximation guarantee is O ( k 2 ln ⁡ k ) O(k2ln⁡k) . A novel seeding algorithm is then designed based on the contribution of the fuzzy potential function, which improves the approximation ratio to O ( k ln ⁡ k ) O(kln⁡k) . Preliminary numerical experiments are proposed to support the theoretical results of this paper.},
  archive      = {J_TCS},
  author       = {Qian Liu and Jianxin Liu and Min Li and Yang Zhou},
  doi          = {10.1016/j.tcs.2021.06.035},
  journal      = {Theoretical Computer Science},
  pages        = {146-158},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Approximation algorithms for fuzzy C-means problem based on seeding method},
  volume       = {885},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Antipodal number of full m-ary trees. <em>TCS</em>,
<em>885</em>, 131–145. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.034">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Let G = ( V ( G ) , E ( G ) ) G=(V(G),E(G)) be a simple connected graph . For any two distinct vertices u and v , d ( u , v ) d(u,v) represents the distance between u and v . Suppose k be any positive integer with 1 ⩽ k ⩽ diam ( G ) 1⩽k⩽diam(G) , where the diam ( G ) diam(G) represents the diameter of G . A radio k-labeling of G is a mapping f : V ( G ) → { 0 , 1 , 2 , … } f:V(G)→{0,1,2,…} such that | f ( u ) − f ( v ) | ⩾ k + 1 − d ( u , v ) |f(u)−f(v)|⩾k+1−d(u,v) for each pair of distinct vertices u and v of G . The absolute difference of the largest and smallest values in f ( V ( G ) ) f(V(G)) is termed as the span of f , and is denoted by span ( f ) span(f) . The antipodal number is the minimum span of a radio ( diam ( G ) − 1 ) (diam(G)−1) -labeling of G and the radio number is the minimum span of a radio diam ( G ) diam(G) -labeling of G . In this article we determine the antipodal number of the m -ary tree for any m ≥ 3 m≥3 with any height h ≥ 3 h≥3 and construct explicitly an optimal antipodal labeling.},
  archive      = {J_TCS},
  author       = {Alamgir Rahaman Basunia and Satyabrata Das and Laxman Saha and Kalishankar Tiwary},
  doi          = {10.1016/j.tcs.2021.06.034},
  journal      = {Theoretical Computer Science},
  pages        = {131-145},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Antipodal number of full m-ary trees},
  volume       = {885},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A wiener-type attack on an RSA-like cryptosystem constructed
from cubic pell equations. <em>TCS</em>, <em>885</em>, 125–130. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.033">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper investigates a novel RSA-like cryptosystem proposed by Murru-Saettone. This cryptosystem is constructed from a cubic field connected to the cubic Pell equation and Redei rational functions. The scheme is claimed to be secure against the Wiener-type attack. However, in this paper, we show a Wiener-type attack that can recover the secret key from the continued fraction constructed from public information.},
  archive      = {J_TCS},
  author       = {Willy Susilo and Joseph Tonien},
  doi          = {10.1016/j.tcs.2021.06.033},
  journal      = {Theoretical Computer Science},
  pages        = {125-130},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A wiener-type attack on an RSA-like cryptosystem constructed from cubic pell equations},
  volume       = {885},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Some i-mark games. <em>TCS</em>, <em>885</em>, 116–124. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.032">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Let S be a set of positive integers, and let D be a set of integers larger than 1. The game is an impartial combinatorial game introduced by Sopena (2016), which is played with a single pile of tokens. In each turn, a player can subtract s ∈ S s∈S from the pile, or divide the size of the pile by d ∈ D d∈D , if the pile size is divisible by d . Sopena partially analyzed the games with S = [ 1 , t − 1 ] S=[1,t−1] and D = { d } D={d} for d ≢ 1 ( mod t ) d≢1(modt) , but left the case d ≡ 1 ( mod t ) d≡1(modt) open. We solve this problem by calculating the Sprague–Grundy function of for d ≡ 1 ( mod t ) d≡1(modt) , for all t , d ≥ 2 t,d≥2 . We also calculate the Sprague–Grundy function of for all k , and show that it exhibits similar behavior. Finally, following Sopena&#39;s suggestion to look at games with | D | &gt; 1 |D|&amp;gt;1 , we derive some partial results for the game , whose Sprague–Grundy function seems to behave erratically and does not show any clear pattern. We prove that each value 0 , 1 , 2 0,1,2 occurs infinitely often in its SG sequence, with a maximum gap length between consecutive appearances.},
  archive      = {J_TCS},
  author       = {Oren Friman and Gabriel Nivasch},
  doi          = {10.1016/j.tcs.2021.06.032},
  journal      = {Theoretical Computer Science},
  pages        = {116-124},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Some i-mark games},
  volume       = {885},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Dominating induced matching in some subclasses of bipartite
graphs. <em>TCS</em>, <em>885</em>, 104–115. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.031">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A subset M ⊆ E M⊆E of edges of a graph G = ( V , E ) G=(V,E) is called a matching if no two edges of M share a common vertex. An edge e ∈ E e∈E is said to dominate itself and all other edges adjacent to it. A matching M in a graph G = ( V , E ) G=(V,E) is called a dominating induced matching ( d.i.m. ) if every edge of G is dominated by edges of M exactly once. The dominating induced matching decide ( DIM-Decide ) problem asks whether a graph G contains a dominating induced matching. The dominating induced matching ( DIM ) problem asks to compute a dominating induced matching ( d.i.m. ) in a graph G that admits a dominating induced matching. The DIM-Decide problem is known to be NP-complete for general graphs as well as for bipartite graphs . In this paper, we strengthen the NP-completeness result of the DIM-Decide problem by showing that this problem remains NP-complete for perfect elimination bipartite graphs , a proper subclass of bipartite graphs. On the positive side, we characterize the class of star-convex bipartite graphs admitting a d.i.m. This characterization leads to a linear time algorithm to test whether a star-convex bipartite graph admits a d.i.m. and, if so, constructs a d.i.m. in such a star-convex bipartite graph in linear time. We also propose polynomial time algorithms to construct a d.i.m. in long- k -star-convex bipartite graphs as well as in circular-convex bipartite graphs if the input graph admits a d.i.m.},
  archive      = {J_TCS},
  author       = {B.S. Panda and Juhi Chaudhary},
  doi          = {10.1016/j.tcs.2021.06.031},
  journal      = {Theoretical Computer Science},
  pages        = {104-115},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Dominating induced matching in some subclasses of bipartite graphs},
  volume       = {885},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). CPA/CCA2-secure PKE with squared-exponential DFR from
low-noise LPN. <em>TCS</em>, <em>885</em>, 91–103. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.025">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {LPN (learning parity with noise) problem is a good candidate for post-quantum cryptography which enjoys simplicity and suitability for weak-power devices. Döttling et al. (ASIACRYPT 2012) initiated the first secure public key encryption (PKE) under the low-noise LPN assumption. Kiltz et al. (PKC 2014) proposed a simpler and more efficient scheme using double-trapdoor technique from the same assumption. Both schemes abide the decoding failure rate (DFR) 2 − Θ ( k ) 2−Θ(k) ( k is the security parameter) and there exists CPA/CCA2-secure PKE with squared-exponential DFR 2 − Θ ( k 2 ) 2−Θ(k2) from constant-noise LPN (Yu and Zhang, CRYPTO 2016). In this work, we give a positive answer with squared-exponential DFR in the low-noise setting. More precisely, we first introduce a variant (VxLPN) of the low-noise Exact LPN (xLPN, proposed by Jain et al. at ASIACRYPT 2012 and used as building block in commitments and zero-knowledge proofs), where the coefficient matrix A follows the uniform distribution over { 0 , 1 } q × n {0,1}q×n ( n = Θ ( k 2 ) , q = Θ ( n ) n=Θ(k2),q=Θ(n) ), the secret x is sampled from B μ n Bμn ( B μ Bμ is the Bernoulli distribution with noise rate μ = Θ ( 1 q ) μ=Θ(1q) ), and the noise e follows a column vector distribution uniform over { z ∈ { 0 , 1 } q : | z | = q μ } {z∈{0,1}q:|z|=qμ} . A series of reductions show that VxLPN is at least as hard as the standard LPN for the same noise rate μ . We then construct from the VxLPN CPA/CCA2 secure PKE schemes with squared-exponential DFR 2 − Θ ( k 2 ) 2−Θ(k2) which share the common structure extrinsically with Kiltz et al. and Yu-Zhang schemes. The secret key(s) in our schemes are simply sampled from the Bernoulli distribution , and comparatively, the secret key(s) in Yu-Zhang schemes must be chosen from a tailored version of Bernoulli distribution (along with the coefficient matrix A that follows a distribution D λ n × n = U n × λ ⋅ U λ × n Dλn×n=Un×λ⋅Uλ×n induced by multiplying two random matrices in the public key , λ = Θ ( log 2 ⁡ n ) λ=Θ(log2⁡n) ) in order to guarantee the correctness of their schemes. Consider the performance on 128-bit security level , our CCA2-secure scheme only holds 117.79 MB public keys, 67.31 MB secret keys and 10.15 KB ciphertexts , and thus is more efficient than the schemes of Döttling et al. and Kiltz et al. ((14.53 GB, 14.48 GB, 14.06 KB) and (161.78 MB, 92.45 MB, 13.60 KB) respectively).},
  archive      = {J_TCS},
  author       = {Shengfeng Xu and Xiangxue Li and Haifeng Qian and Kefei Chen},
  doi          = {10.1016/j.tcs.2021.06.025},
  journal      = {Theoretical Computer Science},
  pages        = {91-103},
  shortjournal = {Theor. Comput. Sci.},
  title        = {CPA/CCA2-secure PKE with squared-exponential DFR from low-noise LPN},
  volume       = {885},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The difficulty of being moral. <em>TCS</em>, <em>885</em>,
77–90. (<a href="https://doi.org/10.1016/j.tcs.2021.06.024">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A family of Markov blankets , if learned purely as a set of subsets of variables, may not be consistent with any Bayesian network . This inconsistency may have a negative impact on Markov blanket-based structure learning . In this paper, we propose checking Markov blanket consistency using graph morality. We define an alternative concept of moral graph – weak recursive simpliciality – without relying on Bayesian networks. Although it is NP-complete to decide if an undirected graph in general is moral, we propose linear and quadratic time algorithms for deciding morality for maximum degree 3 and 4 graphs respectively. In addition, we prove that the problem remains NP-complete for graphs with maximum degree higher than 4, hence there are no remaining unknown complexities for this kind of problem.},
  archive      = {J_TCS},
  author       = {Yang Li and Lloyd Allison and Kevin B. Korb},
  doi          = {10.1016/j.tcs.2021.06.024},
  journal      = {Theoretical Computer Science},
  pages        = {77-90},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The difficulty of being moral},
  volume       = {885},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On rainbow-free colourings of uniform hypergraphs.
<em>TCS</em>, <em>885</em>, 69–76. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.022">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study rainbow-free colourings of k -uniform hypergraphs ; that is, colourings that use k colours but with the property that no hyperedge attains all colours. We show that ⁎ p ⁎ = ( k − 1 ) ( ln ⁡ n ) / n p⁎=(k−1)(ln⁡n)/n is the threshold function for the existence of a rainbow-free colouring in a random k -uniform hypergraph.},
  archive      = {J_TCS},
  author       = {Ragnar Groot Koerkamp and Stanislav Živný},
  doi          = {10.1016/j.tcs.2021.06.022},
  journal      = {Theoretical Computer Science},
  pages        = {69-76},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On rainbow-free colourings of uniform hypergraphs},
  volume       = {885},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Byzantine-tolerant causal broadcast. <em>TCS</em>,
<em>885</em>, 55–68. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.021">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Causal broadcast is a communication abstraction built on top of point-to-point send/receive networks that ensures that any two messages whose broadcasts are causally related (as captured by Lamport&#39;s “happened before” relation) are delivered in their sending order. Several causal broadcast algorithms have been designed for failure-free and crash-prone asynchronous message-passing systems. This article first gives a formal definition of a causal broadcast abstraction in the presence of Byzantine processes, in the form of two equivalent characterizations, and then presents a simple causal broadcast algorithm that implements it. The main difficulty in the design and the proof of this algorithm comes from the very nature of Byzantine faults: Byzantine processes may have arbitrary behavior, and the algorithm must ensure that correct processes (i) maintain a coherent view of causality and (ii) are never prevented from communicating between themselves. To this end, the algorithm is built modularly, namely it works on top of any Byzantine-tolerant reliable broadcast algorithm. Due to this modularity, the proposed algorithm is easy to understand and inherits the computability assumptions (notably the maximal number of processes that may be Byzantine) and the message/time complexities of the underlying reliable broadcast on top of which it is built.},
  archive      = {J_TCS},
  author       = {Alex Auvolat and Davide Frey and Michel Raynal and François Taïani},
  doi          = {10.1016/j.tcs.2021.06.021},
  journal      = {Theoretical Computer Science},
  pages        = {55-68},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Byzantine-tolerant causal broadcast},
  volume       = {885},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021b). Functional encryption for cubic polynomials and
implementation. <em>TCS</em>, <em>885</em>, 41–54. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.020">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Functional encryption (FE), which provides fine-grained access control on encrypted data, is becoming a new hot spot in the field of cryptography. Recent applications, such as outsourcing computation, searchable encryption and so on, suggest that FE has unlimited possibilities. It especially shows great feasibility to construct indistinguishability obfuscation and reuseable garbled circuits. Furthermore, bounded collusion functional encryption is an extension of FE which is against more than one key query and protects the security of messages under more than one function keys. In this paper, we proposed a bounded collusion FE for cubic polynomials, which follows from Agrawal and Rosen&#39;s work on TCC 2017. Our construction only invokes the Regev public key encryption and a linear FE scheme which avoids complex encodings defined recursively. What&#39;s more, we proposes an FE scheme for all circuit with FULL-SIM security. Finally, we also implement these schemes and do some analyses on parameters&#39; size, time and space performance.},
  archive      = {J_TCS},
  author       = {Zheng Zhang and Fangguo Zhang},
  doi          = {10.1016/j.tcs.2021.06.020},
  journal      = {Theoretical Computer Science},
  pages        = {41-54},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Functional encryption for cubic polynomials and implementation},
  volume       = {885},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the computational complexity of data flow analysis over
finite bounded meet semilattices. <em>TCS</em>, <em>885</em>, 30–40. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.019">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The problem of computing the meet over all paths (MOP) solution in a monotone data flow framework over an infinite meet semilattice is generally undecidable [1] . Hence, the maximum fixed point (MFP) solution, which is polynomial time computable on semi-lattices of finite height, is generally used in practice for program analysis questions in monotone data flow frameworks. However, we show that if the semi-lattice is finite, computing MOP solution is NL NL -complete with respect to log space reductions, which implies parallelizability and polynomial time computability. It is also shown that the problem of computing the maximum fixed point (MFP) solution is P P -complete with respect to log space reductions, and hence not efficiently parallelizable, even when the flow graph is directed acyclic and the semilattice has just four elements. These results appear in contrast with the fact that when the semilattice is not finite, solving the MOP problem is significantly harder than MFP.},
  archive      = {J_TCS},
  author       = {Gaurav Sood and K. Murali Krishnan},
  doi          = {10.1016/j.tcs.2021.06.019},
  journal      = {Theoretical Computer Science},
  pages        = {30-40},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On the computational complexity of data flow analysis over finite bounded meet semilattices},
  volume       = {885},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The classes PPA-k: Existence from arguments modulo k.
<em>TCS</em>, <em>885</em>, 15–29. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.016">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The complexity classes PPA- k , k ≥ 2 k≥2 , have recently emerged as the main candidates for capturing the complexity of important problems in fair division, in particular Alon&#39;s Necklace-Splitting problem with k thieves. Indeed, the problem with two thieves has been shown complete for PPA = PPA-2. In this work, we present structural results which provide a solid foundation for the further study of these classes. Namely, we investigate the classes PPA- k in terms of (i) equivalent definitions, (ii) inner structure, (iii) relationship to each other and to other TFNP classes, and (iv) closure under Turing reductions.},
  archive      = {J_TCS},
  author       = {Alexandros Hollender},
  doi          = {10.1016/j.tcs.2021.06.016},
  journal      = {Theoretical Computer Science},
  pages        = {15-29},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The classes PPA-k: Existence from arguments modulo k},
  volume       = {885},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Approximate query processing over static sets and sliding
windows. <em>TCS</em>, <em>885</em>, 1–14. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.015">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Indexing of static and dynamic sets is fundamental to a large set of applications such as information retrieval and caching. Denoting the characteristic vector of the set by B , we consider the problem of encoding sets and multisets to support approximate versions of the operations rank ( i ) rank(i) (i.e., computing ∑ j ≤ i B [ j ] ∑j≤iB[j] ) and select ( i ) select(i) (i.e., finding min ⁡ { p | rank ( p ) ≥ i } min⁡{p|rank(p)≥i} ) queries. We study multiple types of approximations (allowing an error in the query or the result) and present lower bounds and succinct data structures for several variants of the problem. We also extend our model to sliding windows, in which we process a stream of elements and compute suffix sums . This is a generalization of the window summation problem that allows the user to specify the window size at query time . Here, we provide an algorithm that supports updates and queries in constant time while requiring just ( 1 + o ( 1 ) ) (1+o(1)) factor more space than the fixed-window summation algorithms.},
  archive      = {J_TCS},
  author       = {Ran Ben Basat and Seungbum Jo and Srinivasa Rao Satti and Shubham Ugare},
  doi          = {10.1016/j.tcs.2021.06.015},
  journal      = {Theoretical Computer Science},
  pages        = {1-14},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Approximate query processing over static sets and sliding windows},
  volume       = {885},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). D_PSNI: Delimited persistent stochastic non-interference.
<em>TCS</em>, <em>884</em>, 116–135. (<a
href="https://doi.org/10.1016/j.tcs.2021.08.007">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Non-Interference is an information flow security property which aims to protect confidential data by ensuring the complete absence of any information flow from high level entities to low level ones. However, this requirement is too demanding when dealing with real applications: indeed, no real policy ever guarantees a total absence of information flow. In order to deal with real applications, it is often necessary to allow mechanisms for downgrading or declassifying information such as information filters and channel control. In this paper we introduce the notion of Delimited Persistent Stochastic Non-Interference ( D _ PSNI ) that allows information to flow from a higher to a lower security level through a downgrader. We provide two algebraic characterizations of D _ PSNI and prove some compositionality properties. Finally, we present a decision algorithm and discuss its time complexity.},
  archive      = {J_TCS},
  author       = {Andrea Marin and Carla Piazza and Sabina Rossi},
  doi          = {10.1016/j.tcs.2021.08.007},
  journal      = {Theoretical Computer Science},
  pages        = {116-135},
  shortjournal = {Theor. Comput. Sci.},
  title        = {D_PSNI: Delimited persistent stochastic non-interference},
  volume       = {884},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Rewriting theory for the life sciences: A unifying theory of
CTMC semantics. <em>TCS</em>, <em>884</em>, 68–115. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.026">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Kappa biochemistry and the MØD organic chemistry frameworks are amongst the most intensely developed applications of rewriting-based methods in the life sciences to date. A typical feature of these types of rewriting theories is the necessity to implement certain structural constraints on the objects to be rewritten (a protein is empirically found to have a certain signature of sites, a carbon atom can form at most four bonds, ...). In this paper, we contribute a number of original developments that permit to implement a universal theory of continuous-time Markov chains (CTMCs) for stochastic rewriting systems . Our core mathematical concepts are a novel rule algebra construction for the relevant setting of rewriting rules with conditions, both in Double- and in Sesqui-Pushout semantics, augmented by a suitable stochastic mechanics formalism extension that permits to derive dynamical evolution equations for pattern-counting statistics. A second main contribution of our paper is a novel framework of restricted rewriting theories, which comprises a rule-algebra calculus under the restriction to so-called constraint-preserving completions of application conditions (for rules considered to act only upon objects of the underlying category satisfying a globally fixed set of structural constraints). This novel framework in turn renders a faithful encoding of bio- and organo-chemical rewriting in the sense of Kappa and MØD possible, which allows us to derive a rewriting-based formulation of reaction systems including a full-fledged CTMC semantics as instances of our universal CTMC framework. While offering an interesting new perspective and conceptual simplification of this semantics in the setting of Kappa , both the formal encoding and the CTMC semantics of organo-chemical reaction systems as motivated by the MØD framework are the first such results of their kind.},
  archive      = {J_TCS},
  author       = {Nicolas Behr and Jean Krivine and Jakob L. Andersen and Daniel Merkle},
  doi          = {10.1016/j.tcs.2021.07.026},
  journal      = {Theoretical Computer Science},
  pages        = {68-115},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Rewriting theory for the life sciences: A unifying theory of CTMC semantics},
  volume       = {884},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Transformation rules with nested application conditions:
Critical pairs, initial conflicts &amp; minimality. <em>TCS</em>,
<em>884</em>, 44–67. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.023">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Recently, initial conflicts were introduced in the framework of M M -adhesive categories as an important optimization of critical pairs. In particular, they represent a proper subset such that each conflict is represented in a minimal context by a unique initial one. The theory of critical pairs has been extended in the framework of M M -adhesive categories to rules with nested application conditions (ACs), restricting the applicability of a rule and generalizing the well-known negative application conditions. A notion of initial conflicts for rules with ACs does not exist yet. In this paper, on the one hand, we extend the theory of initial conflicts in the framework of M M -adhesive categories to transformation rules with ACs. They represent a proper subset again of critical pairs for rules with ACs, and represent each conflict in a minimal context uniquely. They are moreover symbolic because we can show that in general no finite and complete set of conflicts for rules with ACs exists. On the other hand, we show that critical pairs are minimally M M -complete, whereas initial conflicts are minimally complete. Finally, we introduce important special cases of rules with ACs for which we can obtain finite, minimally ( M M -)complete sets of conflicts.},
  archive      = {J_TCS},
  author       = {Leen Lambers and Fernando Orejas},
  doi          = {10.1016/j.tcs.2021.07.023},
  journal      = {Theoretical Computer Science},
  pages        = {44-67},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Transformation rules with nested application conditions: Critical pairs, initial conflicts &amp; minimality},
  volume       = {884},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Single pushout rewriting in comprehensive systems of
graph-like structures. <em>TCS</em>, <em>884</em>, 23–43. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.002">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The elegance of the single-pushout (SPO) approach to graph transformations arises from substituting total morphisms by partial ones in the underlying category. SPO&#39;s applicability depends on the durability of pushouts after this transition. There is a wide range of work on the question when pushouts exist in categories with partial morphisms starting with the pioneering work of Löwe and Kennaway and ending with an essential characterisation in terms of an exactness property (for the interplay between pullbacks and pushouts) and an adjointness condition (w.r.t. inverse image functions) by Hayman and Heindel. Triple graphs and graph diagrams are frameworks to synchronise two or more updatable data sources by means of internal mappings, which identify common sub-structures. Comprehensive systems generalise these frameworks, treating the network of data sources and their structural inter-relations as a homogeneous comprehensive artefact, in which partial maps identify commonalities. Although this inherent partiality produces amplified complexity, we can show that Heindel&#39;s characterisation still yields existence of pushouts in the category of comprehensive systems and reflective partial morphisms and thus enables computing by typed SPO graph transformation.},
  archive      = {J_TCS},
  author       = {Patrick Stünkel and Harald König},
  doi          = {10.1016/j.tcs.2021.07.002},
  journal      = {Theoretical Computer Science},
  pages        = {23-43},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Single pushout rewriting in comprehensive systems of graph-like structures},
  volume       = {884},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Confluence up to garbage in graph transformation.
<em>TCS</em>, <em>884</em>, 1–22. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.010">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The transformation of graphs and graph-like structures is ubiquitous in computer science. When a system is described by graph-transformation rules, it is often desirable that the rules are both terminating and confluent so that rule applications in an arbitrary order produce unique resulting graphs. However, there are application scenarios where the rules are not globally confluent but confluent on a subclass of graphs that are of interest. In other words, non-resolvable conflicts can only occur on graphs that are considered as “garbage”. In this paper, we introduce the notion of confluence up to garbage and generalise Plump&#39;s critical pair lemma for double-pushout graph transformation, providing a sufficient condition for confluence up to garbage by non-garbage critical pair analysis. We apply our results in two case studies about efficient language recognition: we present backtracking-free graph reduction systems which recognise a class of flow diagrams and a class of labelled series-parallel graphs, respectively. Both systems are non-confluent but confluent up to garbage. We also give a critical pair condition for subcommutativity up to garbage which, together with closedness, implies confluence up to garbage even in non-terminating systems.},
  archive      = {J_TCS},
  author       = {Graham Campbell and Detlef Plump},
  doi          = {10.1016/j.tcs.2021.06.010},
  journal      = {Theoretical Computer Science},
  pages        = {1-22},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Confluence up to garbage in graph transformation},
  volume       = {884},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). CCA-security from adaptive all-but-one lossy trapdoor
functions. <em>TCS</em>, <em>883</em>, 99–121. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.014">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we propose the notion of adaptive all-but-one lossy trapdoor functions (aABO-LTFs), a variant of all-but-one lossy trapdoor functions. An aABO-LTF is parameterised by a set of branches. Given the lossy branch, the function statistically loses the information of its inputs. Given injective branches, the function is injective, and there is a trapdoor that enables efficient function inversion. What differentiates an aABO-LTF and an ABO-LTF is that for an aABO-LTF, the lossy branch is indistinguishable from the other branches even if the adversary gets to ask for function inversions on any injective branches apart from the lossy branch. We demonstrate the usefulness of the adaptivity of aABO-LTFs by providing generic and efficient constructions of an adaptively chosen-ciphertext secure (CCA-secure) public-key encapsulation mechanism (KEM) and an adaptive deterministic public-key encryption (DPKE) without random oracles using aABO-LTFs in a very simple black-box way. Our constructions are direct in the sense of that it avoids generic transformations using one-time signatures or message authentication codes typically found in standard model CCA-secure constructions. Moreover, we show that aABO-LTFs can be instantiated generically by lossy trapdoor primitives, including lossy trapdoor functions (LTFs) and identity-based (lossy) trapdoor functions (IB-LTFs). We also demonstrate that the lattice-based ABO-LTFs proposed by Alwen et al. (CRYPTO&#39;13) are aABO-LTFs. Several existing CCA-secure KEM and DPKE schemes can be described by our generic constrictions. Therefore, our work unifies these seemingly unrelated schemes and explains the design principles behind these schemes.},
  archive      = {J_TCS},
  author       = {Qinyi Li and Xavier Boyen and Ernest Foo},
  doi          = {10.1016/j.tcs.2021.06.014},
  journal      = {Theoretical Computer Science},
  pages        = {99-121},
  shortjournal = {Theor. Comput. Sci.},
  title        = {CCA-security from adaptive all-but-one lossy trapdoor functions},
  volume       = {883},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). New and improved algorithms for unordered tree inclusion.
<em>TCS</em>, <em>883</em>, 83–98. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.013">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The tree inclusion problem is, given two node-labeled trees P and T (the “pattern tree” and the “target tree”), to locate every minimal subtree in T (if any) that can be obtained by applying a sequence of node insertion operations to P . Although the ordered tree inclusion problem is solvable in polynomial time , the unordered tree inclusion problem is NP-hard. The currently fastest algorithm for the latter is a classic algorithm by Kilpeläinen and Mannila from 1995 that runs in O ( d 2 2 d m n ) O(d22dmn) time, where m and n are the sizes of the pattern and target trees, respectively, and d is the degree of the pattern tree. Here, we develop a new algorithm that runs in O ( d 2 d m n 2 ) O(d2dmn2) time, improving the exponential factor from 2 2 d 22d to 2 d 2d by considering a particular type of ancestor-descendant relationships that is suitable for dynamic programming . We also study restricted variants of the unordered tree inclusion problem.},
  archive      = {J_TCS},
  author       = {Tatsuya Akutsu and Jesper Jansson and Ruiming Li and Atsuhiro Takasu and Takeyuki Tamura},
  doi          = {10.1016/j.tcs.2021.06.013},
  journal      = {Theoretical Computer Science},
  pages        = {83-98},
  shortjournal = {Theor. Comput. Sci.},
  title        = {New and improved algorithms for unordered tree inclusion},
  volume       = {883},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Computing the depth distribution of a set of boxes.
<em>TCS</em>, <em>883</em>, 69–82. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.007">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Motivated by the analysis of range queries in databases, we introduce the computation of the depth distribution of a set B B of n d -dimensional boxes (i.e., axis aligned d -dimensional hyperrectangles), which generalizes the computation of the Klee&#39;s measure and maximum depth of B B . We present an algorithm to compute the depth distribution running in time within O ( n d + 1 2 log ⁡ n ) O(nd+12log⁡n) , using space within O ( n log ⁡ n ) O(nlog⁡n) , and refine these upper bound for various measures of difficulty of the input instances. Moreover, we introduce conditional lower bounds for this problem which not only provide insights on how fast the depth distribution can be computed, but also clarify the relation between the Depth Distribution problem and other fundamental problems in computer science.},
  archive      = {J_TCS},
  author       = {Jérémy Barbay and Pablo Pérez-Lantero and Javiel Rojas-Ledesma},
  doi          = {10.1016/j.tcs.2021.06.007},
  journal      = {Theoretical Computer Science},
  pages        = {69-82},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Computing the depth distribution of a set of boxes},
  volume       = {883},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Constrained inverse minimum flow problems under the weighted
hamming distance. <em>TCS</em>, <em>883</em>, 59–68. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.006">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In an inverse combinatorial optimization problem , a feasible solution is given and is not optimal under the current parameters. The aim is to make the feasible solution optimal by modifying the current parameters as little as possible. The modification cost can be measured by different norms, such as weighted l 1 l1 norm, weighted l 2 l2 norm, weighted l ∞ l∞ norm, weighted Hamming distance and so on. In this paper, we focus on the constrained inverse minimum flow problems under the weighted Hamming distance . Three different models are considered: the general problem under the weighted bottleneck-type Hamming distance and two cases under the mixed of sum-type and bottleneck type. Strongly polynomial algorithms are presented for the models we studied.},
  archive      = {J_TCS},
  author       = {Yong Jiang and Weifeng Lin and Longcheng Liu and Anzhen Peng},
  doi          = {10.1016/j.tcs.2021.06.006},
  journal      = {Theoretical Computer Science},
  pages        = {59-68},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Constrained inverse minimum flow problems under the weighted hamming distance},
  volume       = {883},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Component conditional fault tolerance of hierarchical folded
cubic networks. <em>TCS</em>, <em>883</em>, 44–58. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.001">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {For the sake of achieving higher reliability, conditional connectivity has gradually become well-known. Component connectivity, as a kind of conditional connectivity, is an extension of the classical connectivity. Given a simple and undirected graph G and a nonnegative integer r , the ( r + 1 ) (r+1) -component connectivity of graph G , say c κ r + 1 ( G ) cκr+1(G) , is the minimum number of a vertex cut whose removal causes the surviving graph to have at least r + 1 r+1 components. Another basic parameter of reliability, diagnosability is often related to the number of components in the surviving graph. The ( r + 1 ) (r+1) -component diagnosability, say c t r + 1 ( G ) ctr+1(G) , is the maximum size of fault sets subject to at least r + 1 r+1 components in the surviving graph, provided that all faulty vertices can be detected. A graph is t / k t/k -diagnosable if all faulty vertices can be isolated into a set in which up to k vertices are fault-free, provided that the number of faulty vertices is at most t . As a two-level interconnection network , the hierarchical folded cubic network H F Q ( n ) HFQ(n) possesses a great deal of nice properties. In this paper, we first show that the n -dimensional hierarchical folded cubic network is tightly super connected. Then, we explore that c κ r + 1 ( H F Q ( n ) ) = r ( n + 1 ) − ( r 2 ) + 1 ( n ≥ 4 , 1 ≤ r ≤ n − 4 ) cκr+1(HFQ(n))=r(n+1)−(r2)+1(n≥4,1≤r≤n−4) , and obtain that c t r + 1 ( H F Q ( n ) ) = ( r + 1 ) n − ( r 2 ) + 2 ( n ≥ 4 , 1 ≤ r ≤ n − 4 ) ctr+1(HFQ(n))=(r+1)n−(r2)+2(n≥4,1≤r≤n−4) under the PMC and MM* models. Last, we show that the hierarchical folded cubic network H F Q ( n ) HFQ(n) is [ ( k + 1 ) n − ( k 2 ) + 2 ] / k [(k+1)n−(k2)+2]/k -diagnosable, where n ≥ 4 n≥4 and 1 ≤ k ≤ n − 4 1≤k≤n−4 .},
  archive      = {J_TCS},
  author       = {Xueli Sun and Jianxi Fan and Baolei Cheng and Zhao Liu and Jia Yu},
  doi          = {10.1016/j.tcs.2021.06.001},
  journal      = {Theoretical Computer Science},
  pages        = {44-58},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Component conditional fault tolerance of hierarchical folded cubic networks},
  volume       = {883},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Balanced stable marriage: How close is close enough?
<em>TCS</em>, <em>883</em>, 19–43. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.015">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Balanced Stable Marriage (BSM) is a central optimization version of the classic Stable Marriage (SM) problem. We study BSM from the viewpoint of Parameterized Complexity. Informally, the input of BSM consists of n men, n women, and an integer k . Each person a has a (sub)set of acceptable partners, A ( a ) A(a) , whom a ranks strictly; we use p a ( b ) pa(b) to denote the position of b ∈ A ( a ) b∈A(a) in a &#39;s preference list. The objective is to decide whether there exists a stable matching μ such that balance ( μ ) ≜ max ⁡ { ∑ ( m , w ) ∈ μ p m ( w ) , ∑ ( m , w ) ∈ μ p w ( m ) } ≤ k balance(μ)≜max⁡{∑(m,w)∈μpm(w),∑(m,w)∈μpw(m)}≤k . In SM , all stable matchings match the same set of agents, A ⋆ A⋆ which can be computed in polynomial time . As balance ( μ ) ≥ | A ⋆ | 2 balance(μ)≥|A⋆|2 for any stable matching μ , BSM is trivially fixed-parameter tractable (FPT) with respect to k . Thus, a natural question is whether BSM is FPT with respect to k − | A ⋆ | 2 k−|A⋆|2 . With this viewpoint in mind, we draw a line between tractability and intractability in relation to the target value. This line separates additional natural parameterizations higher/lower than ours (e.g., we automatically resolve the parameterization k − | A ⋆ | 2 k−|A⋆|2 ). The two extreme stable matchings are the man-optimal μ M μM and the woman-optimal μ W μW . Let O M = ∑ ( m , w ) ∈ μ M p m ( w ) OM=∑(m,w)∈μMpm(w) , and O W = ∑ ( m , w ) ∈ μ W p w ( m ) OW=∑(m,w)∈μWpw(m) . In this work, we prove that},
  archive      = {J_TCS},
  author       = {Sushmita Gupta and Sanjukta Roy and Saket Saurabh and Meirav Zehavi},
  doi          = {10.1016/j.tcs.2021.05.015},
  journal      = {Theoretical Computer Science},
  pages        = {19-43},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Balanced stable marriage: How close is close enough?},
  volume       = {883},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the parametrized complexity of read-once refutations in
UTVPI+ constraint systems. <em>TCS</em>, <em>883</em>, 1–18. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.007">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we study the problem of finding read-once refutations (ROR) of linear feasibility in a specialized class of constraint systems called UTVPI+ constraint systems ( UCS + UCS+ ). The refutations in this paper are analyzed using the ADD inference rule. Recall that a Unit Two Variable Per Inequality (UTVPI) constraint is a constraint of the form a i ⋅ x i + a j ⋅ x j ≤ b ai⋅xi+aj⋅xj≤b , where b ∈ Z b∈Z , and a i , a j ∈ { 0 , 1 , − 1 } ai,aj∈{0,1,−1} . A conjunction of such constraints is called a UTVPI constraint system (UCS). UCSs find applications in a number of domains such as abstract interpretation and scheduling. We examine a more general form of UCSs that allows for a limited number of non-UTVPI constraints to be added to a UCS. We refer to these more general UCSs as UTVPI+ constraint systems or UCS + s UCS+s . If a UCS + UCS+ has only k non-UTVPI constraints, then we refer to it as a UCS k + UCSk+ . Our focus in this paper is on refutations, i.e., proofs of infeasibility in UCS + s UCS+s . In particular, we study read-once refutations of linear feasibility in UCS + s UCS+s . Although the problem of finding read-once refutations of UCSs is polynomial time solvable, the presence of non-UTVPI constraints makes the problem NP-hard . However, if the number of non-UTVPI constraints is fixed, then read-once refutations can be found in polynomial time . In fact, in this paper, we show that the ROR problem is fixed-parameter tractable ( FPT ) for UCS k + s UCSk+s , with respect to k , the number of non-UTVPI constraints in the system. We also provide a lower bound on the efficiency of a class of parameterized algorithms for this problem, based on the Strong Exponential Time Hypothesis.},
  archive      = {J_TCS},
  author       = {K. Subramani and P. Wojciechowski},
  doi          = {10.1016/j.tcs.2021.05.007},
  journal      = {Theoretical Computer Science},
  pages        = {1-18},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On the parametrized complexity of read-once refutations in UTVPI+ constraint systems},
  volume       = {883},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Voronoi game on polygons. <em>TCS</em>, <em>882</em>,
125–142. (<a href="https://doi.org/10.1016/j.tcs.2021.06.023">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The competitive facility location problem is the problem of determining facility locations involving multiple players to optimize their various gains. The Voronoi game is a competitive facility location problem on a given arena played by two players, the server and the adversary . The players alternately take turns, one or more times, to place their facilities in the arena with a predetermined set of n clients , where both facilities and clients are denoted by points, to maximize some resource gain. The Voronoi game on a polygon P P is a type of competitive facility location problem where n clients are located on the boundary of P P . The server, Alice, and adversary, Bob, are respectively in the interior and the exterior of the polygon P P at locations A A and B B , respectively. Additionally, the metrics for Alice and Bob are the internal and external geodesic distances for the polygon P P , respectively. In this paper, we present some surprising results on the Voronoi games on polygons. We prove lower and upper bounds of ⌈ n / 3 ⌉ ⌈n/3⌉ and n − 1 n−1 respectively in the single-round game for the number of clients won by the server for n clients. Both bounds are tight. In the process, we show that in some convex polygons, the adversary wins no more than k clients in a k -round Voronoi game for any k ≤ n k≤n . Consequentially, the adversary Bob does not have a guaranteed good winning strategy even for the simpler case of convex polygons, i.e., there exist convex polygons such that no placement of B B guarantees more than k clients in the k -round game. We also design O ( n log 2 ⁡ n + m log ⁡ n ) O(nlog2⁡n+mlog⁡n) and O ( n + m ) O(n+m) time algorithms to compute the optimal locations for the server and the adversary respectively to maximize their client counts where the convex polygon has size m . Moreover, we present an O ( n log ⁡ n ) O(nlog⁡n) time algorithm to compute the common intersection of a set of n ellipses . This is needed in our algorithm and may be of independent interest. Lastly, we present some results on the Voronoi games, where the arena is a convex polytope. The server and adversary are respectively in the interior and exterior of P P , and the clients are on the polytope boundary.},
  archive      = {J_TCS},
  author       = {Aritra Banik and Arun Kumar Das and Sandip Das and Anil Maheshwari and Sarvottamananda},
  doi          = {10.1016/j.tcs.2021.06.023},
  journal      = {Theoretical Computer Science},
  pages        = {125-142},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Voronoi game on polygons},
  volume       = {882},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the maximum edge-pair embedding bipartite matching.
<em>TCS</em>, <em>882</em>, 109–124. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.018">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Given a set of edge pairs in a complete bipartite graph, we want to find a bipartite matching that includes the maximum number of those edge pairs. While the problem has many applications to wireless localization and computer vision, to the best of our knowledge, there is no theoretical work for the problem. In this work, unless P = N P P=NP , we show that there is no constant approximation for the problem. Then, we consider two special cases of the problem. Suppose that k denotes the maximum number of input edge pairs such that a particular node can be in. Inspired by experimental results, the first case is for when k is not large. While there is a simple polynomial-time algorithm for the problem when k is one, we show that the problem is NP-hard when k is greater than one. We also devise an efficient O ( k ) O(k) -approximation algorithm for the problem. For the second case, every pair of nodes in the same partition of the input bipartite graph are labeled with one of χ colors. We want to match, between the two partitions, a pair of nodes to a pair of nodes with the same color. Denote n as the number of nodes, we give an O ( χ n ) O(χn) -approximation algorithm for this case.},
  archive      = {J_TCS},
  author       = {Cam Ly Nguyen and Vorapong Suppakitpaisarn and Athasit Surarerks and Phanu Vajanopath},
  doi          = {10.1016/j.tcs.2021.06.018},
  journal      = {Theoretical Computer Science},
  pages        = {109-124},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On the maximum edge-pair embedding bipartite matching},
  volume       = {882},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Acyclic edge coloring conjecture is true on planar graphs
without intersecting triangles. <em>TCS</em>, <em>882</em>, 77–108. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.017">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {An acyclic edge coloring of a graph G is a proper edge coloring such that no bichromatic cycles are produced. The acyclic edge coloring conjecture by Fiamčik (1978) and Alon, Sudakov and Zaks (2001) states that every simple graph with maximum degree Δ is acyclically edge ( Δ + 2 ) (Δ+2) -colorable. Despite many milestones, the conjecture remains open even for planar graphs . In this paper, we confirm affirmatively the conjecture on planar graphs without intersecting triangles. We do so by first showing, by discharging methods, that every planar graph without intersecting triangles must have at least one of the six specified groups of local structures, and then proving the conjecture by recoloring certain edges in each such local structure and by induction on the number of edges in the graph.},
  archive      = {J_TCS},
  author       = {Qiaojun Shu and Yong Chen and Shuguang Han and Guohui Lin and Eiji Miyano and An Zhang},
  doi          = {10.1016/j.tcs.2021.06.017},
  journal      = {Theoretical Computer Science},
  pages        = {77-108},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Acyclic edge coloring conjecture is true on planar graphs without intersecting triangles},
  volume       = {882},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). New bounds on guarding problems for orthogonal polygons in
the plane using vertex guards with halfplane vision. <em>TCS</em>,
<em>882</em>, 63–76. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.012">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Given a set F of k disjoint monotone orthogonal polygons with a total of m vertices, we present bounds on the number of vertex guards required to guard the free space and the boundaries of the polygons in F when the range of vision of each guard is bounded by 180 ∘ (the region in front of the guard). When the orthogonal polygons are axis aligned we prove that m 2 + ⌊ k 4 ⌋ + 4 m2+⌊k4⌋+4 vertex guards are always sufficient. When the orthogonal polygons are arbitrary oriented, we show that m 2 + k + 1 m2+k+1 vertex guards are sometimes necessary and conjecture the bound is tight.},
  archive      = {J_TCS},
  author       = {Ovidiu Daescu and Hemant Malik},
  doi          = {10.1016/j.tcs.2021.06.012},
  journal      = {Theoretical Computer Science},
  pages        = {63-76},
  shortjournal = {Theor. Comput. Sci.},
  title        = {New bounds on guarding problems for orthogonal polygons in the plane using vertex guards with halfplane vision},
  volume       = {882},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Syntactic view of sigma-tau generation of permutations.
<em>TCS</em>, <em>882</em>, 49–62. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.008">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We give a syntactic view of the Sawada-Williams ( σ , τ ) (σ,τ) -generation of permutations . The corresponding sequence Seq n Seqn of στ -operations of length n ! − 1 n!−1 is shown to have a compact description of size Θ ( n 2 ) Θ(n2) in terms of straight-line programs. Using the compact description, we design almost linear time ranking and unranking algorithms.},
  archive      = {J_TCS},
  author       = {Wojciech Rytter and Wiktor Zuba},
  doi          = {10.1016/j.tcs.2021.06.008},
  journal      = {Theoretical Computer Science},
  pages        = {49-62},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Syntactic view of sigma-tau generation of permutations},
  volume       = {882},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The exact multiple pattern matching problem solved by a
reference tree approach. <em>TCS</em>, <em>882</em>, 29–48. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.003">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Given a text T and a set of r patterns P 1 , P 2 , … , P r P1,P2,…,Pr , the exact multiple pattern matching problem reports the ending positions of all occurrences of P i Pi in T for 1 ≤ i ≤ r 1≤i≤r . By transforming all substrings with a fixed length of T into a reference tree such that each internal node stores a reference string, the exact multiple pattern matching problem can be efficiently solved by searching patterns in the tree via the guidance of the reference strings. We design elegant algorithms to construct the reference tree (the preprocessing phase) and to search patterns in the tree (the searching phase) using bitwise operations. The experiments involving problem instances from the DNA sequence and the English language are conducted to compare the performance of our approach against those of the suffix tree and suffix array algorithms. The computational results demonstrate the advantage of our approach over these algorithms. In spite of the simplicity, our approach is quite efficient, flexible and robust.},
  archive      = {J_TCS},
  author       = {Yi-Kung Shieh and Shyong Jian Shyu and Chin Lung Lu and Richard Chia-Tung Lee},
  doi          = {10.1016/j.tcs.2021.06.003},
  journal      = {Theoretical Computer Science},
  pages        = {29-48},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The exact multiple pattern matching problem solved by a reference tree approach},
  volume       = {882},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the complexity of minimum maximal uniquely restricted
matching. <em>TCS</em>, <em>882</em>, 15–28. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.036">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A subset M ⊆ E M⊆E of edges of a graph G = ( V , E ) G=(V,E) is called a matching if no two edges of M share a common vertex. A matching M in a graph G is called a uniquely restricted matching if, G [ V ( M ) ] G[V(M)] , the subgraph of G induced by the set of M -saturated vertices of G contains exactly one perfect matching. A uniquely restricted matching M is maximal if M is not properly contained in any uniquely restricted matching of G . Given a graph G , the Min-Max-UR Matching problem asks to find a maximal uniquely restricted matching in G of minimum cardinality and Decide-Min-Max-UR Matching problem, the decision version of this problem takes a graph G and an integer k and asks whether G admits a maximal uniquely restricted matching of cardinality at most k . It is known that the Decide-Min-Max-UR Matching problem is NP-complete. In this paper, we strengthen this result by proving that the Decide-Min-Max-UR Matching problem remains NP NP -complete for chordal bipartite graphs, star-convex bipartite graphs, chordal graphs, and doubly chordal graphs. On the positive side, we prove that the Min-Max-UR Matching problem is polynomial time solvable for bipartite distance-hereditary graphs and linear time solvable for bipartite permutation graphs, proper interval graphs , and threshold graphs. Finally, we prove that the Min-Max-UR Matching problem is APX APX -complete for graphs with maximum degree 4.},
  archive      = {J_TCS},
  author       = {Juhi Chaudhary and B.S. Panda},
  doi          = {10.1016/j.tcs.2021.05.036},
  journal      = {Theoretical Computer Science},
  pages        = {15-28},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On the complexity of minimum maximal uniquely restricted matching},
  volume       = {882},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Two-stage pricing strategy with price discount in online
social networks. <em>TCS</em>, <em>882</em>, 1–14. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.035">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The rapid development of online social networks (OSNs) has changed the way people communicate and has brought many new opportunities for Internet product marketing. For a product company, the profit gained is directly related to the price of the product and the number of products used. Designing an effective marketing strategy is crucial to obtaining more profits. However, most existing research only focuses on maximizing product influence, rather than explicitly incorporating pricing factors into the design of marketing strategies. This article studies product marketing strategies and pricing models, and proposes a two-stage pricing discount model (TPDM). The TPDM model divides product marketing into two stages: the original price stage and the discount stage. It also studies the impact of advertising marketing (AM) and word-of-mouth marketing (WM) on the number of products used. Based on the TPDM model, a two-stage discount greedy (TSDG) algorithm is proposed to realize product pricing for product companies. At last, we use several real social network data sets for comparative experiments. The experimental results show that the TSDG algorithm divides the product marketing into two stages and pricing can tap the economic benefits of the product, so that more users can use the product. Compared with other algorithms, it not only increases the profit of the product company by more than 20\%, but also improves efficiency.},
  archive      = {J_TCS},
  author       = {Ziwei Liang and He Yuan and Hongwei Du},
  doi          = {10.1016/j.tcs.2021.05.035},
  journal      = {Theoretical Computer Science},
  pages        = {1-14},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Two-stage pricing strategy with price discount in online social networks},
  volume       = {882},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021c). Editorial. <em>TCS</em>, <em>881</em>, iii. (<a
href="https://doi.org/10.1016/S0304-3975(21)00455-2">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_TCS},
  author       = {Lila Kari ( Editor-in-Chief )},
  doi          = {10.1016/S0304-3975(21)00455-2},
  journal      = {Theoretical Computer Science},
  pages        = {iii},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Editorial},
  volume       = {881},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A categorial approach to reaction systems: First steps.
<em>TCS</em>, <em>881</em>, 111–128. (<a
href="https://doi.org/10.1016/j.tcs.2020.08.013">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In the literature, one encounters the intensely studied classical set-based reaction systems and the more recently introduced generalization to graph-based reaction systems where the considered graphs are directed, simple, and edge-labeled. In this paper, we propose a categorical approach to reaction systems so that a wider spectrum of data structures becomes available on which reaction systems can be based including various types of graphs and of graph-like structures like unlabeled graphs, vertex-labeled graphs, bipartite graphs , and a variety of types of hypergraphs . But also algebraic structures like monoids fit into the framework.},
  archive      = {J_TCS},
  author       = {Hans-Jörg Kreowski and Aaron Lye},
  doi          = {10.1016/j.tcs.2020.08.013},
  journal      = {Theoretical Computer Science},
  pages        = {111-128},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A categorial approach to reaction systems: First steps},
  volume       = {881},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Asynchrony and persistence in reaction systems.
<em>TCS</em>, <em>881</em>, 97–110. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.040">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Reaction systems are a model of interactive computation, where the interaction between a system — itself built up of a number of reactions — and its environment is modelled through context sequences provided by the environment. The standard execution semantics of reaction systems is synchronous, i.e., at each computational step all the enabled reactions are executed. In this paper, we ‘de-synchronise’ such an execution model by allowing only a subset of enabled reactions to be executed. We then study the resulting asynchronous model assuming two fundamental execution policies. The first one allows any subset of reactions to be executed, and the second one draws each subset from a pre-defined pool. We also introduce and discuss the notion of persistence of reactions and sets of reactions in the resulting models of asynchronous reaction systems. In particular, we demonstrate that reaction persistence can be implemented.},
  archive      = {J_TCS},
  author       = {Maciej Koutny and Marta Pietkiewicz-Koutny and Alex Yakovlev},
  doi          = {10.1016/j.tcs.2020.11.040},
  journal      = {Theoretical Computer Science},
  pages        = {97-110},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Asynchrony and persistence in reaction systems},
  volume       = {881},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Comparing reactions in reaction systems. <em>TCS</em>,
<em>881</em>, 83–96. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.050">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Originally, reaction systems were introduced to describe in a formal way the interactions between biochemical reactions taking place in living cells. They are also investigated as an abstract model of interactive computation. A reaction system is determined by a finite background set of entities and a finite set of reactions. Each reaction specifies the entities that it needs to be able to occur, the entities which block its execution, and the entities that it produces if it occurs. Based on the entities available in a state of the system, all reactions of the system that are enabled take place and together produce the entities that form the next state. In this paper we compare reactions in terms of their enabledness and results. We investigate three partial orders on reactions that build on two definitions of equivalence of (sets of) reactions. It is demonstrated how each partial order defines a lattice (with greatest lower bounds and least upper bounds) for all nontrivial reactions. Together, these orders provide an insight in possible redundancies and (re)combinations of the reactions of a reaction system.},
  archive      = {J_TCS},
  author       = {Daniela Genova and Hendrik Jan Hoogeboom and Jetty Kleijn},
  doi          = {10.1016/j.tcs.2020.11.050},
  journal      = {Theoretical Computer Science},
  pages        = {83-96},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Comparing reactions in reaction systems},
  volume       = {881},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021b). A process algebraic approach to reaction systems.
<em>TCS</em>, <em>881</em>, 62–82. (<a
href="https://doi.org/10.1016/j.tcs.2020.09.001">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In the area of Natural Computing, Reaction Systems (RSs) are a qualitative abstraction inspired by the functioning of living cells, suitable to model the main mechanisms of biochemical reactions. RSs interact with a context, and pose challenges for modularity, compositionality, extendibility and behavioural equivalence. In this paper we define a modular encoding of RSs as processes in the chained Core Network Algebra (cCNA), which is a new variant of the link -calculus. The encoding represents the behaviour of each entity separately and preserves faithfully their features, and we prove its correctness and completeness. Our encoding provides a Labelled Transition System (LTS) semantics for RSs. Based on the LTS semantics, we adapt the classical notion of bisimulation to define a novel equivalence, called bio-similarity, for studying properties of RSs. In particular, we define a new assertion language based on regular expressions, which allows us to specify the properties of interest, and use it to extend Hennessy-Milner logic to our setting. We prove that our bio-similarity relation and the logical equivalence, that are defined parametrically on some assertion of interest, coincide. Finally, we claim that our encoding contributes to increase the expressiveness of RSs, by exploiting the interaction among different RSs.},
  archive      = {J_TCS},
  author       = {Linda Brodo and Roberto Bruni and Moreno Falaschi},
  doi          = {10.1016/j.tcs.2020.09.001},
  journal      = {Theoretical Computer Science},
  pages        = {62-82},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A process algebraic approach to reaction systems},
  volume       = {881},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021b). Transactions and contracts based on reaction systems.
<em>TCS</em>, <em>881</em>, 25–61. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.012">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Smart contracts are currently en vogue , thanks to the infrastructure provided by the blockchain technology . However, their effective use requires that the textual (legalese) specification of the contract be accompanied by a precise computational definition of the actions leading to its satisfaction or breach, as well as of their admissible sequences. Insofar as contracts can be viewed as prescribing transactional exchanges of well-specified resources among well-specified actors, contract execution can be modelled as following some protocol in a closed world. This suggests a modelling of such executions as interactive processes in reaction systems, where the entities in the background set represent possible allocations of resources to actors and reactions describe changes in such allocations. We use this type of reaction systems and interactive processes as a basis for the modelling of transactions and contracts and explore properties of such processes, highlighting their peculiarities with respect to the original notion of interactive processes in reaction systems. We also discuss several constructions for composition and decomposition of processes, which guarantee equivalence of effects: two interactive processes are equivalent if, starting from the same initial set of allocations, they produce the same final set of allocations.},
  archive      = {J_TCS},
  author       = {Paolo Bottoni and Anna Labella},
  doi          = {10.1016/j.tcs.2021.07.012},
  journal      = {Theoretical Computer Science},
  pages        = {25-61},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Transactions and contracts based on reaction systems},
  volume       = {881},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Encoding boolean networks into reaction systems for
investigating causal dependencies in gene regulation. <em>TCS</em>,
<em>881</em>, 3–24. (<a
href="https://doi.org/10.1016/j.tcs.2020.07.031">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Gene regulatory networks represent the interactions among genes regulating the activation of specific cell functionalities. They have been successfully modelled using Boolean networks, where a set of Boolean variables model the activation state of each gene, and Boolean functions model positive and negative influences among genes. Moreover, when the effect of such influences is additive, threshold Boolean networks, in which Boolean functions are replaced by simpler threshold functions, turned out to be particularly effective. In this paper we propose a systematic translation of threshold Boolean networks into Ehrenfeucht and Rozenberg&#39;s reaction systems. Our translation produces a non redundant set of reactions, each using a minimal set of objects. This translation allows us to simulate the behaviour of a general threshold Boolean network by simply executing the (closed) reaction system we obtain, and to investigate causality relations among genes by applying tools available for reaction systems. We implemented our translation in an open-source tool and applied it in two case studies: the gene regulation network of segment polarity in Drosophila melanogaster and the one controlling the differentiation of Th cells in the immune system. In both case studies, we investigate causalities among genes in the reaction system obtained from the translation by applying a tool for the computation of formula based predictors. In the context of the second case study, we show that also Boolean networks with non-additive influences and modelling genes with multiple expression levels can be dealt with by our approach.},
  archive      = {J_TCS},
  author       = {Roberto Barbuti and Roberta Gori and Paolo Milazzo},
  doi          = {10.1016/j.tcs.2020.07.031},
  journal      = {Theoretical Computer Science},
  pages        = {3-24},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Encoding boolean networks into reaction systems for investigating causal dependencies in gene regulation},
  volume       = {881},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Preface: Special issue on reaction systems. <em>TCS</em>,
<em>881</em>, 1–2. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.027">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_TCS},
  author       = {Łukasz Mikulski and Ion Petre},
  doi          = {10.1016/j.tcs.2021.07.027},
  journal      = {Theoretical Computer Science},
  pages        = {1-2},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Preface: Special issue on reaction systems},
  volume       = {881},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Preface. <em>TCS</em>, <em>880</em>, 138. (<a
href="https://doi.org/10.1016/j.tcs.2021.07.001">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_TCS},
  author       = {Robert M. Hierons and Mohamed Mosbah},
  doi          = {10.1016/j.tcs.2021.07.001},
  journal      = {Theoretical Computer Science},
  pages        = {138},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Preface},
  volume       = {880},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A metalanguage for guarded iteration. <em>TCS</em>,
<em>880</em>, 111–137. (<a
href="https://doi.org/10.1016/j.tcs.2021.04.005">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Notions of guardedness serve to delineate admissible recursive definitions in various settings in a compositional manner. In recent work, we have introduced an axiomatic notion of guardedness in symmetric monoidal categories, which serves as a unifying framework for various examples from program semantics, process algebra , and beyond. In the present paper, we propose a generic metalanguage for guarded iteration based on combining this notion with the fine-grain call-by-value paradigm, which we intend as a unifying programming language for guarded and unguarded iteration in the presence of computational effects. We give a generic (categorical) semantics of this language over a suitable class of strong monads supporting guarded iteration, and show it to be in touch with the standard operational behaviour of iteration by giving a concrete big-step operational semantics for a certain specific instance of the metalanguage and establishing soundness and (computational) adequacy for this case.},
  archive      = {J_TCS},
  author       = {Sergey Goncharov and Christoph Rauch and Lutz Schröder},
  doi          = {10.1016/j.tcs.2021.04.005},
  journal      = {Theoretical Computer Science},
  pages        = {111-137},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A metalanguage for guarded iteration},
  volume       = {880},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). DESN: An unsupervised MR image denoising network with deep
image prior. <em>TCS</em>, <em>880</em>, 97–110. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.005">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Magnetic Resonance Imaging (MRI) is a widely used medical diagnosis technique. However, the quality of MR image is affected by the noise which is caused by mechanical and environmental reasons during the MR image acquisition process. For decades, various kinds of methods including filtering approaches, transform domain approaches and statistical approaches have been applied to the MR image denoising problem, while there are also some drawbacks exiting in these methods such as arising undesirable change of texture and long computation time needed. In this paper, we proposed a novel MR image denoising method called DESN which is a neural network method and has a novel network architecture with well-designed loss function. In DESN, the convolutional neural networks itself is considered as a regularizer or image prior information for the inverse problems such as denoising . The network architecture of DESN is designed from the auto-encoder architecture, it has three main parts: encoder network for extracting low-resolution image features , decoder network for restoring high-resolution features and skip connections for transmitting abstract information from encoder network to decoder network. Besides, we also design a novel loss function which contains two main parts: data fidelity loss ( L f i d e l i t y Lfidelity ), image quality penalty ( L q Lq ) and three loss terms: mean squared error term ( L M S E LMSE ), image structure similarity term ( L S LS ), image information entropy term ( L I E LIE ). We compare the performance of DESN with DIP and some state of the art denoising methods, and the performance of our network with different loss terms are also compared in three MR modalities. The comparative results show that DESN have the superior performance in generating high-quality MR image with enough edge and texture information.},
  archive      = {J_TCS},
  author       = {Yazhou Zhu and Xiang Pan and Tianxu Lv and Yuan Liu and Lihua Li},
  doi          = {10.1016/j.tcs.2021.06.005},
  journal      = {Theoretical Computer Science},
  pages        = {97-110},
  shortjournal = {Theor. Comput. Sci.},
  title        = {DESN: An unsupervised MR image denoising network with deep image prior},
  volume       = {880},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Computation of the suffix array, burrows-wheeler transform
and FM-index in v-order. <em>TCS</em>, <em>880</em>, 82–96. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.004">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {V -order is a total order on strings that determines an instance of Unique Maximal Factorization Families (UMFFs), a generalization of Lyndon words. The fundamental V -comparison of strings can be done in linear time and constant space. V -order has been proposed as an alternative to lexicographic order (lexorder) in the computation of suffix arrays and in the suffix-sorting induced by the Burrows-Wheeler transform (BWT). In line with the recent interest in the connection between suffix arrays and Lyndon factorization, in this paper we obtain similar results for the V -order factorization. Indeed, we show that the results describing the connection between suffix arrays and Lyndon factorization are matched by analogous V -order processing. We also describe a methodology for efficiently computing the FM-Index in V -order, as well as V -order substring pattern matching using backward search.},
  archive      = {J_TCS},
  author       = {Jacqueline W. Daykin and Neerja Mhaskar and W.F. Smyth},
  doi          = {10.1016/j.tcs.2021.06.004},
  journal      = {Theoretical Computer Science},
  pages        = {82-96},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Computation of the suffix array, burrows-wheeler transform and FM-index in V-order},
  volume       = {880},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). An improved parametric algorithm on two-machine scheduling
with given lower and upper bounds for the total processing time.
<em>TCS</em>, <em>880</em>, 69–81. (<a
href="https://doi.org/10.1016/j.tcs.2021.06.002">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider the scheduling model with two identical machines and jobs which arrive online in a list and are assigned to the machines with the objective of minimizing the makespan. Differently from the pure online version, we know in advance a lower bound and also an upper bound on the total size of all jobs. Our algorithm improves previous results on some interval of r , where r is the ratio of the upper and lower bounds on the total size. For most ranges of r our algorithm is best possible. Our technique is based on a smart application of so-called “safe sets”.},
  archive      = {J_TCS},
  author       = {Gyorgy Dosa and Hans Kellerer and Tomas Olaj and Zsolt Tuza},
  doi          = {10.1016/j.tcs.2021.06.002},
  journal      = {Theoretical Computer Science},
  pages        = {69-81},
  shortjournal = {Theor. Comput. Sci.},
  title        = {An improved parametric algorithm on two-machine scheduling with given lower and upper bounds for the total processing time},
  volume       = {880},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Revocable hierarchical identity-based encryption with
adaptive security. <em>TCS</em>, <em>880</em>, 37–68. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.034">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Hierarchical identity-based encryption (HIBE) can be extended to revocable HIBE (RHIBE) if a private key of a user can be revoked when the private key is revealed or expired. Previously, many selectively secure RHIBE schemes were proposed, but it is still unsolved problem to construct an adaptively secure RHIBE scheme. In this work, we propose two RHIBE schemes in composite-order bilinear groups and prove their adaptive security under simple static assumptions. To prove the adaptive security, we use the dual system encryption framework, but it is not simple to use the dual system encryption framework in RHIBE since the security model of RHIBE is quite different with that of HIBE. We show that it is possible to solve the problem of the RHIBE security proof by carefully designing hybrid games.},
  archive      = {J_TCS},
  author       = {Kwangsu Lee},
  doi          = {10.1016/j.tcs.2021.05.034},
  journal      = {Theoretical Computer Science},
  pages        = {37-68},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Revocable hierarchical identity-based encryption with adaptive security},
  volume       = {880},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Structure and substructure connectivity of divide-and-swap
cube. <em>TCS</em>, <em>880</em>, 20–36. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.033">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {High fault tolerance and reliability of multiprocessor systems , modeled by interconnection network , are of great significance to assess the flexibility and effectiveness of the systems. Connectivity is an important metric to evaluate the fault tolerance and reliability of interconnection networks. As classical connectivity is not suitable for such large scale systems , a novel and generalized connectivity, structure connectivity and substructure connectivity, has been proposed to measure the robustness of networks and has witnessed rich achievements. The divide-and-swap cube D S C n DSCn is an interesting variant of hypercube that has nice hierarchical properties. In this paper, we mainly investigate H H -structure-connectivity, denoted by κ ( D S C n ; H ) κ(DSCn;H) , and H H -substructure-connectivity, denoted by κ s ( D S C n ; H ) κs(DSCn;H) , for H ∈ { K 1 , K 1 , 1 , K 1 , m ( 2 ≤ m ≤ d + 1 ) , C 4 } H∈{K1,K1,1,K1,m(2≤m≤d+1),C4} , respectively. In detail, we show that κ ( D S C n ; K 1 ) = κ s ( D S C n ; K 1 ) = d + 1 κ(DSCn;K1)=κs(DSCn;K1)=d+1 for n ≥ 2 n≥2 , κ ( D S C n ; K 1 , 1 ) = κ s ( D S C n ; K 1 , 1 ) = d + 1 κ(DSCn;K1,1)=κs(DSCn;K1,1)=d+1 for n ≥ 8 n≥8 , κ ( D S C n ; K 1 , m ) = κ s ( D S C n ; K 1 , m ) = ⌊ d 2 ⌋ + 1 κ(DSCn;K1,m)=κs(DSCn;K1,m)=⌊d2⌋+1 with 2 ≤ m ≤ d + 1 2≤m≤d+1 for n ≥ 4 n≥4 , κ ( D S C n ; C 4 ) = 3 + 2 ( d − 2 ) κ(DSCn;C4)=3+2(d−2) for 4 ≤ n ≤ 8 4≤n≤8 , ⌊ d 2 ⌋ + 1 ≤ κ ( D S C n ; C 4 ) ≤ d + 1 ⌊d2⌋+1≤κ(DSCn;C4)≤d+1 for n ≥ 16 n≥16 and κ s ( D S C n ; C 4 ) = ⌊ d 2 ⌋ + 1 κs(DSCn;C4)=⌊d2⌋+1 for n ≥ 4 n≥4 . Finally, we compare and analyze the ratios of structure (resp. substructure) connectivity to vertex degree of divide-and-swap cube with that of several well-known variants of hypercube .},
  archive      = {J_TCS},
  author       = {Qianru Zhou and Shuming Zhou and Jiafei Liu and Xiaoqing Liu},
  doi          = {10.1016/j.tcs.2021.05.033},
  journal      = {Theoretical Computer Science},
  pages        = {20-36},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Structure and substructure connectivity of divide-and-swap cube},
  volume       = {880},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Modified schelling games. <em>TCS</em>, <em>880</em>, 1–19.
(<a href="https://doi.org/10.1016/j.tcs.2021.05.032">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce the class of modified Schelling games in which there are different types of agents who occupy the nodes of a location graph; agents of the same type are friends, and agents of different types are enemies. Every agent is strategic and jumps to empty nodes of the graph aiming to maximize her utility, defined as the ratio of her friends in her neighborhood over the neighborhood size including herself. This is in contrast to the related literature on Schelling games which typically assumes that an agent is excluded from her neighborhood whilst computing its size. Our model enables the utility function to capture likely cases where agents would rather be around a lot of friends instead of just a few, an aspect that was partially ignored in previous work. We provide a thorough analysis of the (in)efficiency of equilibria that arise in such modified Schelling games, by bounding the price of anarchy and price of stability for both general graphs and interesting special cases. Most of our results are tight and exploit the structure of equilibria as well as sophisticated constructions.},
  archive      = {J_TCS},
  author       = {Panagiotis Kanellopoulos and Maria Kyropoulou and Alexandros A. Voudouris},
  doi          = {10.1016/j.tcs.2021.05.032},
  journal      = {Theoretical Computer Science},
  pages        = {1-19},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Modified schelling games},
  volume       = {880},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Constructing dual-CISTs with short diameters using a generic
adjustment scheme on bicubes. <em>TCS</em>, <em>878-879</em>, 102–112.
(<a href="https://doi.org/10.1016/j.tcs.2021.05.031">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_TCS},
  author       = {Yu-Han Chen and Shyue-Ming Tang and Kung-Jui Pai and Jou-Ming Chang},
  doi          = {10.1016/j.tcs.2021.05.031},
  journal      = {Theoretical Computer Science},
  pages        = {102-112},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Constructing dual-CISTs with short diameters using a generic adjustment scheme on bicubes},
  volume       = {878-879},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Universal locally verifiable codes and 3-round interactive
proofs of proximity for CSP. <em>TCS</em>, <em>878-879</em>, 83–101. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.030">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Universal locally testable codes ( universal - LTC universal-LTC s), recently introduced in our companion paper ( CJTCS , 2018), are codes that admit local tests for membership in numerous subcodes, allowing for testing properties of the encoded message. Unfortunately, universal - LTC universal-LTC s suffer strong limitations, which motivate us to initiate, in this work, the study of the “NP analogue” of these codes, wherein the testing procedures are also given free access to a short proof, akin the MA MA proofs of proximity of Gur and Rothblum ( Computational Complexity 2018). We call such codes “universal locally verifiable codes” ( universal - LVC universal-LVC s). A universal - LVC universal-LVC C : { 0 , 1 } k → { 0 , 1 } η C:{0,1}k→{0,1}η for a family of functions F = { f i : { 0 , 1 } k → { 0 , 1 } } i ∈ [ M ] F={fi:{0,1}k→{0,1}}i∈[M] is a code such that, for every i ∈ [ M ] i∈[M] , membership in the subcode { C ( x ) : f i ( x ) = 1 } {C(x):fi(x)=1} can be verified locally using explicit access to a short (sublinear length) proof. A universal - LVC universal-LVC can be viewed as providing an encoding of inputs under which a large family of properties of the encoded inputs can be locally testable using a short proof . We show universal - LVC universal-LVC s of block length O ˜ ( n 2 ) O˜(n2) for the family of all functions expressible by t -ary constraint satisfaction problems ( t -CSP) over n constraints and k variables, with proof length and query complexity O ˜ ( n 2 / 3 ) O˜(n2/3) , where t = O ( 1 ) t=O(1) and n ≥ k n≥k . In addition, we prove a lower bound of p ⋅ q = Ω ˜ ( k ) p⋅q=Ω˜(k) for every polynomial length universal - LVC universal-LVC , having proof complexity p and query complexity q , for such CSP functions. We give an application of universal - LVC universal-LVC s for interactive proofs of proximity ( IPP IPP ), introduced by Rothblum, Vadhan, and Wigderson ( STOC 2013), which are interactive proof systems wherein the verifier queries only a sublinear number of input bits to the end of asserting that, with high probability , the input is close to an accepting input. Specifically, we show a 3-round IPP IPP for the set of assignments that satisfy fixed CSP instances, with sublinear communication and query complexity, which we derive from our universal - LVC universal-LVC for CSP functions.},
  archive      = {J_TCS},
  author       = {Oded Goldreich and Tom Gur},
  doi          = {10.1016/j.tcs.2021.05.030},
  journal      = {Theoretical Computer Science},
  pages        = {83-101},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Universal locally verifiable codes and 3-round interactive proofs of proximity for CSP},
  volume       = {878-879},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021b). Improved approximation for prize-collecting red-blue
median. <em>TCS</em>, <em>878-879</em>, 67–82. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.029">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The red-blue median problem considers a set of red facilities, a set of blue facilities, and a set of clients located in some metric space. The goal is to open k r kr red facilities and k b kb blue facilities such that the sum of the distance from each client to its nearest opened facility is minimized, where k r kr , k b ≥ 0 kb≥0 are two given integers. Designing approximation algorithms for this problem remains an active area of research due to its applications in various fields. However, in many applications, the existence of noisy data poses a big challenge for the problem. In this paper, we consider the prize-collecting red-blue median problem, where the noisy data can be removed by paying a penalty cost. The current best approximation guarantee for the prize-collecting red-blue median problem is a ratio of 24, which was obtained by LP-rounding. We deal with this problem using a local search algorithm . We construct a layered structure of the swap pairs, which yields a ( 9 + ϵ ) (9+ϵ) -approximation for the prize-collecting red-blue median problem. Our techniques generalize to a more general prize-collecting τ-color median problem, where the facilities have τ different types, and give a ( 4 τ + 1 + ϵ ) (4τ+1+ϵ) -approximation for the case where τ is a constant.},
  archive      = {J_TCS},
  author       = {Zhen Zhang and Yutian Guo and Junyu Huang and Jianxin Wang and Feng Shi},
  doi          = {10.1016/j.tcs.2021.05.029},
  journal      = {Theoretical Computer Science},
  pages        = {67-82},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Improved approximation for prize-collecting red-blue median},
  volume       = {878-879},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Nonuniform SINR+voronoi diagrams are effectively uniform.
<em>TCS</em>, <em>878-879</em>, 53–66. (<a
href="https://doi.org/10.1016/j.tcs.2021.04.018">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper concerns the behavior of an SINR diagram of wireless systems , composed of a set S of n stations embedded in R d Rd , when restricted to the corresponding Voronoi diagram imposed on S . The diagram obtained by restricting the SINR zones to their corresponding Voronoi cells is referred to hereafter as an SINR + Voronoi diagram . Uniform SINR diagrams, where all stations transmit with the same power, are simple and nicely structured, e.g., the station reception zones are convex and “fat”. In contrast, nonuniform SINR diagrams might be complex; the reception zones might be fractured and their boundaries might contain many singular points . In this paper, we establish the perhaps surprising fact that a nonuniform SINR+Voronoi diagram is topologically almost as nice as a uniform SINR diagram. In particular, it is convex and effectively 5 fat. This holds for every power assignment, every path-loss parameter α and every dimension d ≥ 1 d≥1 . The convexity property also holds for every SINR threshold β &gt; 0 β&amp;gt;0 , and the effective fatness property holds for any β &gt; 1 β&amp;gt;1 . These fundamental properties provide a theoretical justification to engineering practices basing zonal tessellations on the Voronoi diagram, and help to explain the soundness and efficacy of such practices. We also consider two algorithmic applications. The first concerns the Power Control with Voronoi Diagram (PCVD) problem, where given n stations embedded in some polygon P P , it is required to find the power assignment that optimizes the SINR threshold of the transmission station s i si for any given reception point p ∈ P p∈P in its Voronoi cell . The second application is approximate point location ; we show that for SINR+Voronoi zones, this task can be solved considerably more efficiently than in the general non-uniform case.},
  archive      = {J_TCS},
  author       = {Erez Kantor and Zvi Lotker and Merav Parter and David Peleg},
  doi          = {10.1016/j.tcs.2021.04.018},
  journal      = {Theoretical Computer Science},
  pages        = {53-66},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Nonuniform SINR+Voronoi diagrams are effectively uniform},
  volume       = {878-879},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Exhaustive generation of some lattice paths and their
prefixes. <em>TCS</em>, <em>878-879</em>, 47–52. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.013">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We refer to positive lattice paths as to paths in the discrete plane constituted by different kinds of steps (north-east, east and south-east), starting from the origin and never going under the x -axis. They have been deeply studied both from a combinatorial and an algorithmic point of view. We propose some algorithms for the exhaustive generation of positive paths which are Motzkin and Schröder paths and their prefixes, according to their length. For each kind of paths we define a recursive algorithm as well as an iterative one, specifying which path follows a given one in the lexicographic order . Furthermore we study the complexity of these algorithms by using the relations between the number of paths of a given size and the number of final north-east or south-east steps.},
  archive      = {J_TCS},
  author       = {Elena Barcucci and Antonio Bernini and Renzo Pinzani},
  doi          = {10.1016/j.tcs.2020.12.013},
  journal      = {Theoretical Computer Science},
  pages        = {47-52},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Exhaustive generation of some lattice paths and their prefixes},
  volume       = {878-879},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Influence: A partizan scoring game on graphs. <em>TCS</em>,
<em>878-879</em>, 26–46. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.028">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce the game influence , a scoring combinatorial game, played on a directed graph where each vertex is either colored black or white. The two players, Black and White, play alternately by taking a vertex of their color and all its successors (for Black) or all its predecessors (for White). The score of each player is the number of vertices he has taken. We prove that influence is a nonzugzwang game, meaning that no player has interest to pass at any step of the game, and thus belongs to Milnor&#39;s universe. We study this game in the particular class of paths where black and white vertices are alternated. We give an almost tight strategy for both players when there is one path. More precisely, we prove that the first player always gets a strictly better score than the second one, but that the difference between the scores is bounded by 5. Finally, we exhibit some graphs for which the initial proportion of vertices of the color of a player is as small as possible but where this player can get almost all the vertices.},
  archive      = {J_TCS},
  author       = {Eric Duchêne and Stéphane Gonzalez and Aline Parreau and Eric Rémila and Philippe Solal},
  doi          = {10.1016/j.tcs.2021.05.028},
  journal      = {Theoretical Computer Science},
  pages        = {26-46},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Influence: A partizan scoring game on graphs},
  volume       = {878-879},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Maximum weight independent sets for (S1,2,4,triangle)-free
graphs in polynomial time. <em>TCS</em>, <em>878-879</em>, 11–25. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.027">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Maximum Weight Independent Set (MWIS) problem on finite undirected graphs with vertex weights asks for a set of pairwise nonadjacent vertices of maximum weight sum. MWIS is one of the most investigated and most important algorithmic graph problems; it is well known to be NP-complete, and it remains NP-complete even under various strong restrictions such as for triangle-free graphs. Its complexity for Pk -free graphs, k≥7 , is an open problem. In [7] , it is shown that MWIS can be solved in polynomial time for ( P7 ,triangle)-free graphs. This result is extended by Maffray and Pastor [22] showing that MWIS can be solved in polynomial time for ( P7 ,bull)-free graphs. In the same paper, they also showed that MWIS can be solved in polynomial time for ( S1,2,3 ,bull)-free graphs. In this paper, using a similar approach as in [7] , we show that MWIS can be solved in polynomial time for ( S1,2,4 ,triangle)-free graphs which generalizes the result for ( P7 ,triangle)-free graphs.},
  archive      = {J_TCS},
  author       = {Andreas Brandstädt and Raffaele Mosca},
  doi          = {10.1016/j.tcs.2021.05.027},
  journal      = {Theoretical Computer Science},
  pages        = {11-25},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Maximum weight independent sets for (S1,2,4,triangle)-free graphs in polynomial time},
  volume       = {878-879},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Incidence coloring of mycielskians with fast algorithm.
<em>TCS</em>, <em>878-879</em>, 1–10. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.026">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {An incidence of a graph G is a vertex-edge pair ( v , e ) (v,e) such that the vertex v is incident with the edge e . A proper incidence k-coloring of a graph is a coloring of its incidences involving k colors so that two incidences ( u , e ) (u,e) and ( w , f ) (w,f) receive distinct colors if and only if u = w u=w , or e = f e=f , or u w ∈ { e , f } uw∈{e,f} . In this paper, we present some idea of using the incidence coloring to model a kind of multi-frequency assignment problem , in which each transceiver can be simultaneously in both sending and receiving modes, and then establish some theoretical and algorithmic aspects of the incidence coloring. Specifically, we conjecture that if G is the Mycielskian of some graph then it has a proper incidence ( Δ ( G ) + 2 ) (Δ(G)+2) -coloring. Actually, our conjecture is motivated by the “ ( Δ + 2 ) (Δ+2) conjecture” of Brualdi and Quinn Massey in 1993, which states that every graph G has a proper incidence ( Δ ( G ) + 2 ) (Δ(G)+2) -coloring, and was disproved in 1997 by Guiduli, who pointed out that the Paley graphs with large maximum degree are counterexamples (yet they are all known counterexamples to the “ ( Δ + 2 ) (Δ+2) conjecture”, and are not Mycielskians of any graph). To support our conjecture, we prove in this paper that if G is the Mycielskian of a graph H with | H | ≥ 3 Δ ( H ) + 2 |H|≥3Δ(H)+2 , then we can construct a proper incidence ( Δ ( G ) + 1 ) (Δ(G)+1) -coloring of G in cubic time, and if G is the Mycielskian of an incidence ( Δ ( H ) + 1 ) (Δ(H)+1) -colorable graph H with | H | ≤ 2 Δ ( H ) |H|≤2Δ(H) , or the Mycielskian of an incidence ( Δ ( H ) + 2 ) (Δ(H)+2) -colorable graph H with | H | ≥ 2 Δ ( H ) + 1 |H|≥2Δ(H)+1 , then G has a proper incidence ( Δ ( G ) + 2 ) (Δ(G)+2) -coloring. The minimum positive integer k such that the Mycielskian of a cycle or a path has a proper incidence k -coloring is also determined.},
  archive      = {J_TCS},
  author       = {Huimin Bi and Xin Zhang},
  doi          = {10.1016/j.tcs.2021.05.026},
  journal      = {Theoretical Computer Science},
  pages        = {1-10},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Incidence coloring of mycielskians with fast algorithm},
  volume       = {878-879},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Approximation of the double traveling salesman problem with
multiple stacks. <em>TCS</em>, <em>877</em>, 74–89. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.016">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Double Traveling Salesman Problem with Multiple Stacks, DTSPMS DTSPMS , deals with the collect and delivery of n commodities in two distinct cities, where the pickup and the delivery tours are related by LIFO constraints. During the pickup tour, commodities are loaded into a container of k rows, or stacks, with capacity c . This paper focuses on computational aspects of the DTSPMS DTSPMS , which is NP-hard. We first review the complexity of two critical subproblems : deciding whether a given pair of pickup and delivery tours is feasible and, given a loading plan, finding an optimal pair of pickup and delivery tours, are both polynomial under some conditions on k and c . We then prove a ( 3 k ) / 2 (3k)/2 standard approximation for the Min Metric k DTSPMS Min Metric k DTSPMS , where k is a universal constant, and other approximation results for various versions of the problem. We finally present a matching-based heuristic for the 2 DTSPMS 2 DTSPMS , which is a special case with k = 2 k=2 rows, when the distances are symmetric. This yields a 1 / 2 − o ( 1 ) 1/2−o(1) , 3 / 4 − o ( 1 ) 3/4−o(1) and 3 / 2 + o ( 1 ) 3/2+o(1) standard approximation for respectively Max 2 DTSPMS Max 2 DTSPMS , its restriction Max 2 DTSPMS ( 1 , 2 ) Max 2 DTSPMS(1,2) with distances 1 and 2, and Min 2 DTSPMS ( 1 , 2 ) Min 2 DTSPMS(1,2) , and a 1 / 2 − o ( 1 ) 1/2−o(1) differential approximation for Min 2 DTSPMS Min 2 DTSPMS and Max 2 DTSPMS Max 2 DTSPMS .},
  archive      = {J_TCS},
  author       = {Laurent Alfandari and Sophie Toulouse},
  doi          = {10.1016/j.tcs.2021.05.016},
  journal      = {Theoretical Computer Science},
  pages        = {74-89},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Approximation of the double traveling salesman problem with multiple stacks},
  volume       = {877},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Generalised online colouring problems in overlap graphs.
<em>TCS</em>, <em>877</em>, 58–73. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.004">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper we consider an online version of different colouring problems in overlap graphs, motivated by some stacking problems. The instance is a system of time intervals presented in non-decreasing order of the left endpoint. We consider the usual colouring problem as well as b -bounded colouring (colour class have a maximum capacity b ) and the same problems in the complement graph. We also consider the case where at most b intervals of the same colour can intersect. For all these versions we obtain a logarithmic competitive ratio w.r.t. the maximum ratio of interval lengths while the best known ratio for the usual colouring was linear. To our knowledge it is the first time the other variants are considered in online overlap graphs. Moreover, in the offline case, a pre-processing allows us to deduce a logarithmic approximation ratio w.r.t. the maximum number of pairwise disjoint intervals in the system. Our method is based on a partition of the overlap graph into permutation graphs, leading to a competitive-preserving reduction of the problem in overlap graphs to the same problem in permutation graphs. We think that this new partition problem by itself is of interest for future work.},
  archive      = {J_TCS},
  author       = {Marc Demange and Martin Olsen},
  doi          = {10.1016/j.tcs.2021.05.004},
  journal      = {Theoretical Computer Science},
  pages        = {58-73},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Generalised online colouring problems in overlap graphs},
  volume       = {877},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Algorithmic aspects of upper edge domination. <em>TCS</em>,
<em>877</em>, 46–57. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.038">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the problem of finding a minimal edge dominating set of maximum size in a given graph G=(V,E) , called Upper EDS . We show that this problem is not approximable within a ratio of nε−12 , for any ε∈(0,12) , assuming P≠NP , where n=|V| . On the other hand, for graphs of minimum degree at least 2, we give an approximation algorithm with ratio 1n , matching this lower bound. We further show that Upper EDS is APX -complete in bipartite graphs of maximum degree 4, and NP -hard in planar bipartite graphs of maximum degree 4.},
  archive      = {J_TCS},
  author       = {Jérôme Monnot and Henning Fernau and David Manlove},
  doi          = {10.1016/j.tcs.2021.03.038},
  journal      = {Theoretical Computer Science},
  pages        = {46-57},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Algorithmic aspects of upper edge domination},
  volume       = {877},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Recoloring subgraphs of k2n for sports scheduling.
<em>TCS</em>, <em>877</em>, 36–45. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.029">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The exploration of one-factorizations of complete graphs is the foundation of some classical sports scheduling problems. One has to traverse the landscape of such one-factorizations by moving from one of those to a so-called neighbor one-factorization. This approach amounts to modifying locally the coloring associated with a one-factorization. We consider some particular types of modifications and describe various constructions which give one-factorizations which may be modified or not by these techniques. Among those are recoloring of bichromatic cycles, altering of optimally colored subcliques of even size, or recoloring of chordless lanterns.},
  archive      = {J_TCS},
  author       = {Sebastián Urrutia and Dominique de Werra and Tiago Januario},
  doi          = {10.1016/j.tcs.2021.03.029},
  journal      = {Theoretical Computer Science},
  pages        = {36-45},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Recoloring subgraphs of k2n for sports scheduling},
  volume       = {877},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Blocking total dominating sets via edge contractions.
<em>TCS</em>, <em>877</em>, 18–35. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.028">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we study the problem of deciding whether the total domination number of a given graph G can be reduced using exactly one edge contraction (called 1 -Edge Contraction( γ t γt ) ). We focus on several graph classes and determine the computational complexity of this problem. By putting together these results, we manage to obtain a complete complexity dichotomy for H -free graphs.},
  archive      = {J_TCS},
  author       = {E. Galby and F. Mann and B. Ries},
  doi          = {10.1016/j.tcs.2021.03.028},
  journal      = {Theoretical Computer Science},
  pages        = {18-35},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Blocking total dominating sets via edge contractions},
  volume       = {877},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Local fairness in hedonic games via individual threshold
coalitions. <em>TCS</em>, <em>877</em>, 1–17. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.027">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Hedonic games are coalition formation games where players only specify preferences over coalitions they are part of. We introduce and systematically study three local fairness notions in hedonic games called max-min fairness, grand-coalition fairness, and min-max fairness. To this end, we define suitable threshold coalitions for these three concepts. A coalition structure (i.e., a partition of the players into coalitions) is considered locally fair if all players&#39; coalitions in this structure are each at least as good as their threshold coalitions. Based on this approach, we then introduce three specific notions of local fairness by suitably adapting fairness notions from fair division. We show that they form a proper hierarchy and how they are related to previously studied solution concepts in hedonic games. We also study the computational aspects of finding threshold coalitions and of deciding whether fair coalition structures exist in additively separable hedonic games, and we investigate the related price of local fairness.},
  archive      = {J_TCS},
  author       = {Anna Maria Kerkmann and Nhan-Tam Nguyen and Jörg Rothe},
  doi          = {10.1016/j.tcs.2021.03.027},
  journal      = {Theoretical Computer Science},
  pages        = {1-17},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Local fairness in hedonic games via individual threshold coalitions},
  volume       = {877},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Vertex-pancyclicity of the (n,k)-bubble-sort networks.
<em>TCS</em>, <em>876</em>, 70–78. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.024">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The cycle embedding is an important problem of networks, which can determine the fault tolerance of the networks. A network can be viewed as a graph. Let m be an integer with m≥4 , G be a graph and w∈V(G) be an arbitrary vertex. The graph G is vertex-pancyclic if G has a cycle Cl of length l with w∈V(Cl) for every l∈{3,4,⋯,|V(G)|} and G is m -weak-vertex-pancyclic if G has a cycle Cl of length l with w∈V(Cl) for every l∈{m,m+1,⋯,|V(G)|} . Let G′ be a bipartite graph and w′∈V(G′) be an arbitrary vertex. The graph G′ is vertex-bipancyclic if G′ has a cycle Ch of length h with w′∈V(Ch) for any even integer h with 4≤h≤|V(G′)| . In this paper, we study the cycle embedding in the (n,k) -bubble-sort network Bn,k . We obtain that (1) Bn,1 is vertex-pancyclic for n≥3 . (2) Bn,n−1 is vertex-bipancyclic for n≥4 . (3) B4,2 and B5,2 are 6-weak-vertex-pancyclic and B5,3 is vertex-pancyclic. (4) Bn,k is vertex-pancyclic for n≥6 with 2≤k≤n−2 and every constructed cycle of Bn,k contains a residual edge for n≥4 with 2≤k≤n−2 .},
  archive      = {J_TCS},
  author       = {Xin Wang and Chaoqun Ma and Jia Guo},
  doi          = {10.1016/j.tcs.2021.05.024},
  journal      = {Theoretical Computer Science},
  pages        = {70-78},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Vertex-pancyclicity of the (n,k)-bubble-sort networks},
  volume       = {876},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). An improved algorithm for a two-stage production scheduling
problem with an outsourcing option. <em>TCS</em>, <em>876</em>, 59–69.
(<a href="https://doi.org/10.1016/j.tcs.2021.05.022">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider a two-stage production scheduling problem where each operation can be outsourced or processed in-house. For each operation in the same machine, the ratio of its outsourcing cost to its processing time is constant. The objective is to minimize the sum of the makespan and the total outsourcing cost. It is known that this problem is either polynomial time solvable or NP-hard according to the conditions of the ratios. Even though approximation algorithms for NP-hard cases had been developed, their tight worst-case performance ratios are still open. In this paper, we carefully analyze the approximation algorithms to identify their tight worst-case performance ratios for cases. In one case, we propose a new approximation algorithm with a better and tight worst-case performance ratio. In the process of analyzing the algorithm, we propose a technique utilizing nonlinear optimization.},
  archive      = {J_TCS},
  author       = {Xiaojuan Jiang and An Zhang and Yong Chen and Guangting Chen and Kangbok Lee},
  doi          = {10.1016/j.tcs.2021.05.022},
  journal      = {Theoretical Computer Science},
  pages        = {59-69},
  shortjournal = {Theor. Comput. Sci.},
  title        = {An improved algorithm for a two-stage production scheduling problem with an outsourcing option},
  volume       = {876},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Differentiating-total domination: Approximation and hardness
results. <em>TCS</em>, <em>876</em>, 45–58. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.021">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A total dominating set of a graph G = ( V , E ) G=(V,E) is a subset D of V such that every vertex in V is adjacent to at least one vertex of the set D . A total dominating set D of G is a differentiating-total dominating set of G if for every pair of distinct vertices u , v ∈ V u,v∈V , N G [ u ] ∩ D ≠ N G [ v ] ∩ D NG[u]∩D≠NG[v]∩D . Given a graph G , Minimum Differentiating-Total Domination is to find a differentiating-total dominating set of minimum cardinality of G and Decide Differentiating-Total Domination is the decision version of Minimum Differentiating-Total Domination . In this paper, we initiate the algorithmic study of Minimum Differentiating-Total Domination . We show that Decide Differentiating-Total Domination is NP -complete for chordal graphs , chordal bipartite graphs , star-convex bipartite graphs , and planar graphs . On the positive side, we propose an O ( log ⁡ Δ ) O(log⁡Δ) factor approximation algorithm for Minimum Differentiating-Total Domination for any graph G with maximum degree Δ. We match the above upper bound by showing that for general graphs as well as for bipartite graphs Minimum Differentiating-Total Domination cannot be approximated within a factor of ( 1 2 − ε ) ln ⁡ | V | (12−ε)ln⁡|V| for any ε &gt; 0 ε&amp;gt;0 unless P = NP . Finally, we show that Minimum Differentiating-Total Domination is APX -complete for bounded degree bipartite graphs.},
  archive      = {J_TCS},
  author       = {B.S. Panda and Pooja Goyal and D. Pradhan},
  doi          = {10.1016/j.tcs.2021.05.021},
  journal      = {Theoretical Computer Science},
  pages        = {45-58},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Differentiating-total domination: Approximation and hardness results},
  volume       = {876},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A fast algorithm for source-wise round-trip spanners.
<em>TCS</em>, <em>876</em>, 34–44. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.019">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we study the problem of fast constructions of source-wise round-trip spanners in weighted directed graphs . For a source vertex set S ⊆ V S⊆V in a graph G ( V , E ) G(V,E) , an S -sourcewise round-trip spanner of G of stretch k is a subgraph H of G such that for every pair of vertices u , v ∈ S × V u,v∈S×V , their round-trip distance in H is at most k times of their round-trip distance in G . We show that for a graph G ( V , E ) G(V,E) with n vertices and m edges, an s -sized source vertex set S ⊆ V S⊆V and an integer k &gt; 1 k&amp;gt;1 , there exists an algorithm that in time O ( m s 1 / k log 5 ⁡ n ) O(ms1/klog5⁡n) constructs an S -sourcewise round-trip spanner of stretch O ( k log ⁡ n ) O(klog⁡n) and O ( n s 1 / k log 2 ⁡ n ) O(ns1/klog2⁡n) edges with high probability . Compared to the fast algorithms for constructing all-pairs round-trip spanners [26] , [12] , our algorithm improves the running time and the number of edges in the spanner when k is super-constant. Compared with the existing algorithm for constructing source-wise round-trip spanners [36] , our algorithm significantly improves their construction time Ω ( min ⁡ { m s , n ω } ) Ω(min⁡{ms,nω}) (where ω ∈ [ 2 , 2.373 ) ω∈[2,2.373) and 2.373 is the matrix multiplication exponent) to nearly linear O ( m s 1 / k log 5 ⁡ n ) O(ms1/klog5⁡n) , at the expense of paying an extra O ( log ⁡ n ) O(log⁡n) in the stretch. As an important building block of the algorithm, we develop a graph partitioning algorithm to partition G into clusters of bounded radius and prove that for every u , v ∈ S × V u,v∈S×V at small round-trip distance, the probability of separating them in different clusters is small. The algorithm takes the size of S as input and does not need the knowledge of S . With the algorithm and a reachability vertex size estimation algorithm , we show that the recursive algorithm for constructing standard round-trip spanners [26] can be adapted to the source-wise setting. We rigorously prove the correctness and computational complexity of the adapted algorithms. Finally, we show how to remove the dependence on the edge weight in the source-wise case.},
  archive      = {J_TCS},
  author       = {Chun Jiang Zhu and Song Han and Kam-Yiu Lam},
  doi          = {10.1016/j.tcs.2021.05.019},
  journal      = {Theoretical Computer Science},
  pages        = {34-44},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A fast algorithm for source-wise round-trip spanners},
  volume       = {876},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Buffer minimization with conflicts on a line. <em>TCS</em>,
<em>876</em>, 25–33. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.013">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In the buffer minimization in multiprocessor systems with conflicts or simply buffer minimization problem, a multi-processor system is modelled as an undirected graph. A conflict occurs if two processors are connected by an edge. Conflicting processors can not run at the same time. At any time, load may arrive on one or more processors. Incoming workload is stored in an input buffer and a machine that is running reduces its workload at a constant rate. The goal is to find a schedule that minimizes the maximum workload over all machines and over time. We consider the special case where the graph is a path. We give upper and lower bounds on the competitive ratio for paths of various lengths. We also consider online algorithms that have resource augmentation on their speed (processing rate), and give a ( 1 + 2 ε ) (1+2ε) -speed ( 1 / ε + 2 ) (1/ε+2) -competitive algorithm.},
  archive      = {J_TCS},
  author       = {Felix Höhne and Rob van Stee},
  doi          = {10.1016/j.tcs.2021.05.013},
  journal      = {Theoretical Computer Science},
  pages        = {25-33},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Buffer minimization with conflicts on a line},
  volume       = {876},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Role colouring graphs in hereditary classes. <em>TCS</em>,
<em>876</em>, 12–24. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.010">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A locally surjective homomorphism from a graph G to a graph H is called an H -role colouring of G . Deciding the existence of such a colouring with | H | = k |H|=k is known to be NP -hard even under substantial restrictions on the input graph G . We study the family of hereditary classes for which the problem can be solved efficiently. Our main result is the first boundary class for this problem; that is, a minimal obstruction to solving the problem efficiently in a finitely defined hereditary class. We also give the first boundary class for the related k -coupon colouring problem, in which H is a complete graph with each vertex incident to a loop, when k is a prime power. As additional results, we show that 2-role colouring 2 K 2 2K2 -free graphs and 2-coupon colouring cographs can be done in linear time.},
  archive      = {J_TCS},
  author       = {Christopher Purcell and Puck Rombach},
  doi          = {10.1016/j.tcs.2021.05.010},
  journal      = {Theoretical Computer Science},
  pages        = {12-24},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Role colouring graphs in hereditary classes},
  volume       = {876},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Minimum membership covering and hitting. <em>TCS</em>,
<em>876</em>, 1–11. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.002">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Set Cover is a well-studied problem with application in many fields. A well-known variant of this problem is the Minimum Membership Set Cover problem: Given a set of points and a set of objects, the objective is to cover all points while minimizing the maximum number of objects that contain any one point. A dual of this problem is the Minimum Membership Hitting Set problem: Given a set of points and a set of objects, the objective is to stab all of the objects while minimizing the maximum number of points that an object contains. We study both of these variants in a geometric setting with various types of geometric objects in the plane, including axis-parallel line segments, axis-parallel strips, rectangles that are anchored on a horizontal line from one side, rectangles that are stabbed by a horizontal line, and rectangles that are anchored on one of two horizontal lines (i.e., each rectangle shares its top or its bottom edge (or both) with one of the input horizontal lines). For each of these problems we either prove NP-hardness or we give a polynomial-time algorithm. In particular, we show that it is NP-complete to decide whether there exists a solution with depth exactly 1 for either the Minimum Membership Set Cover or the Minimum Membership Hitting Set problem. In addition, we study a generalized version of the Minimum Membership Hitting Set problem.},
  archive      = {J_TCS},
  author       = {Joseph S.B. Mitchell and Supantha Pandit},
  doi          = {10.1016/j.tcs.2021.05.002},
  journal      = {Theoretical Computer Science},
  pages        = {1-11},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Minimum membership covering and hitting},
  volume       = {876},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021d). Editorial. <em>TCS</em>, <em>875</em>, iii. (<a
href="https://doi.org/10.1016/S0304-3975(21)00320-0">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_TCS},
  author       = {Lila Kari ( Editor-in-Chief )},
  doi          = {10.1016/S0304-3975(21)00320-0},
  journal      = {Theoretical Computer Science},
  pages        = {iii},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Editorial},
  volume       = {875},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Prefix-free quantum kolmogorov complexity. <em>TCS</em>,
<em>875</em>, 65–80. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.017">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce quantum-K ( QK ), a measure of the descriptive complexity of density matrices using classical prefix-free Turing machines and show that the initial segments of weak Solovay random and quantum Schnorr random states are incompressible in the sense of QK . Many properties enjoyed by prefix-free Kolmogorov complexity ( K ) have analogous versions for QK ; notably a counting condition. Several connections between Solovay randomness and K , including the Chaitin type characterization of Solovay randomness, carry over to those between weak Solovay randomness and QK . We work towards a Levin–Schnorr type characterization of weak Solovay randomness in terms of QK . Schnorr randomness has a Levin–Schnorr characterization using K C KC ; a version of K using a computable measure machine, C . We similarly define Q K C QKC , a version of QK . Quantum Schnorr randomness is shown to have a Levin–Schnorr and a Chaitin type characterization using Q K C QKC . The latter implies a Chaitin type characterization of classical Schnorr randomness using K C KC .},
  archive      = {J_TCS},
  author       = {Tejas Bhojraj},
  doi          = {10.1016/j.tcs.2021.05.017},
  journal      = {Theoretical Computer Science},
  pages        = {65-80},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Prefix-free quantum kolmogorov complexity},
  volume       = {875},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Colouring fuzziness for systems biology. <em>TCS</em>,
<em>875</em>, 52–64. (<a
href="https://doi.org/10.1016/j.tcs.2021.04.011">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Snoopy is a powerful modelling and simulation tool for various types of Petri nets , which have been applied to a wide range of biochemical reaction networks. We present an enhanced version of Snoopy , now supporting coloured and uncoloured stochastic, continuous and hybrid Petri Nets with fuzzy kinetic parameters . Colour helps to cope with modelling challenges imposed by larger and more complex networks. Fuzzy parameters are specifically useful when kinetic parameter values can not be precisely measured or estimated. By running fuzzy simulation we obtain output bands of the variables of interest induced by the effect of the fuzzy kinetic parameters. Simulation is always done on the uncoloured level. For this purpose, coloured fuzzy Petri nets are automatically unfolded to their corresponding uncoloured counterparts. Combining the power of fuzzy kinetic parameters with the modelling convenience of coloured Petri nets provides a new quality in user support with sophisticated modelling and analysis features.},
  archive      = {J_TCS},
  author       = {George Assaf and Monika Heiner and Fei Liu},
  doi          = {10.1016/j.tcs.2021.04.011},
  journal      = {Theoretical Computer Science},
  pages        = {52-64},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Colouring fuzziness for systems biology},
  volume       = {875},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Exponential slowdown for larger populations: The (μ + 1)-EA
on monotone functions. <em>TCS</em>, <em>875</em>, 28–51. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.025">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Pseudo-Boolean monotone functions are unimodal functions which are trivial to optimize for some hillclimbers, but are challenging for a surprising number of evolutionary algorithms . A general trend is that evolutionary algorithms are efficient if parameters like the mutation rate are set conservatively, but may need exponential time otherwise. In particular, it was known that the (1+1) -EA and the (1+λ) -EA can optimize every monotone function in pseudolinear time if the mutation rate is c/n for some c&amp;lt;1 , but that they need exponential time for some monotone functions for c&amp;gt;2.2 . The second part of the statement was also known for the (μ+1) -EA. In this paper we show that the first statement does not apply to the (μ+1) -EA. More precisely, we prove that for every constant c&amp;gt;0 there is a constant μ0∈N such that the (μ+1) -EA with mutation rate c/n and population size μ0≤μ≤n needs superpolynomial time to optimize some monotone functions. Thus, increasing the population size by just a constant has devastating effects on the performance. This is in stark contrast to many other benchmark functions on which increasing the population size either increases the performance significantly, or affects performance only mildly. The reason why larger populations are harmful lies in the fact that larger populations may temporarily decrease the selective pressure on parts of the population. This allows unfavorable mutations to accumulate in single individuals and their descendants. If the population moves sufficiently fast through the search space, then such unfavorable descendants can become ancestors of future generations, and the bad mutations are preserved. Remarkably, this effect only occurs if the population renews itself sufficiently fast, which can only happen far away from the optimum. This is counter-intuitive since usually optimization becomes harder as we approach the optimum. Previous work missed the effect because it focused on monotone functions that are only deceptive close to the optimum.},
  archive      = {J_TCS},
  author       = {Johannes Lengler and Xun Zou},
  doi          = {10.1016/j.tcs.2021.03.025},
  journal      = {Theoretical Computer Science},
  pages        = {28-51},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Exponential slowdown for larger populations: The (μ + 1)-EA on monotone functions},
  volume       = {875},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021a). A logical and graphical framework for reaction systems.
<em>TCS</em>, <em>875</em>, 1–27. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.024">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Reaction Systems (RSs) are a successful computational framework inspired by biological systems. A RS pairs a set of entities with a set of reactions over them. Entities can be used to enable or inhibit each reaction, and are produced by reactions. Entities can also be provided by an external context sequence to simulate in silico biological experiments. In this paper we define an extension of RSs considering nondeterministic and recursive context operators, and give an original labelled transition system (LTS) for extended RSs in the structural operational semantics (SOS) style. Thanks to extended contexts, a single LTS can now account for several biological experiments. The rich information recorded in transition labels is useful to guarantee the compositionality of SOS inference rules as well as to define an assertion language to tailor behavioural and logical equivalences on some specific properties or entities. The SOS rules have been also exploited to design a flexible prototype implementation in logic programming that allows to inspect the LTS and to extract useful information when performing experiments on a RS. Our implementation provides a rapid prototyping tool for (extensions of) RSs, with a user friendly online interface to our interpreter. A parser allows to introduce the logical formulas and the contexts using the usual comfortable concrete syntax . The user can visualise and inspect the LTS for a RS and make some analysis of its underlying computation patterns, can check if the main RS satisfies a given property and if it is equivalent to a second adversarial RS. Finally, the SOS approach is suited to drive additional enhancements of RSs.},
  archive      = {J_TCS},
  author       = {Linda Brodo and Roberto Bruni and Moreno Falaschi},
  doi          = {10.1016/j.tcs.2021.03.024},
  journal      = {Theoretical Computer Science},
  pages        = {1-27},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A logical and graphical framework for reaction systems},
  volume       = {875},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The game of cops and eternal robbers. <em>TCS</em>,
<em>874</em>, 80–93. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.014">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce the game of Cops and Eternal Robbers played on graphs, where there are infinitely many robbers that appear sequentially over distinct plays of the game. A positive integer t is fixed, and the cops are required to capture the robber in at most t time-steps in each play. The associated optimization parameter is the eternal cop number, denoted by c t ∞ ct∞ , which equals the eternal domination number in the case t = 1 t=1 , and the cop number for sufficiently large t . We study the complexity of Cops and Eternal Robbers, and show that the game is NP -hard when t is a fixed constant and EXPTIME -complete for large values of t . We determine precise values of c t ∞ ct∞ for paths and cycles. The eternal cop number is studied for retracts, and this approach is applied to give bounds for trees, as well as for strong and Cartesian grids.},
  archive      = {J_TCS},
  author       = {Anthony Bonato and Melissa A. Huggan and Trent G. Marbach and Fionn Mc Inerney},
  doi          = {10.1016/j.tcs.2021.05.014},
  journal      = {Theoretical Computer Science},
  pages        = {80-93},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The game of cops and eternal robbers},
  volume       = {874},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Simultaneous FPQ-ordering and hybrid planarity testing.
<em>TCS</em>, <em>874</em>, 59–79. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.012">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce and study a constrained planarity testing problem, called 1 -Fixed Constrained Planarity , and prove that this problem can be solved in quadratic time for biconnected graphs. Our solution is based on a novel definition of fixedness that makes it possible to simplify and extend known techniques about Simultaneous PQ-Ordering . We exploit this result to study different versions of the hybrid planarity testing problem. Namely, we show polynomial-time solutions for a variant of NodeTrix Planarity with fixed sides, for PolyLink Planarity , and for Clique Planarity with fixed sides.},
  archive      = {J_TCS},
  author       = {Giuseppe Liotta and Ignaz Rutter and Alessandra Tappini},
  doi          = {10.1016/j.tcs.2021.05.012},
  journal      = {Theoretical Computer Science},
  pages        = {59-79},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Simultaneous FPQ-ordering and hybrid planarity testing},
  volume       = {874},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Optimal deterministic group testing algorithms to estimate
the number of defectives. <em>TCS</em>, <em>874</em>, 46–58. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.011">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this work, we study the problem of estimating the number of defectives d in a set of n items up to a multiplicative factor of Δ &gt; 1 Δ&amp;gt;1 using deterministic group testing algorithms. Particularly, given Δ &gt; 1 Δ&amp;gt;1 and D &gt; d D&amp;gt;d , we give upper and lower bounds on the number of tests required for the task of generating an estimation d ˆ dˆ such that d / Δ ≤ d ˆ ≤ d Δ d/Δ≤dˆ≤dΔ . In the adaptive settings, we prove that any adaptive deterministic algorithm for estimating d must perform at least Ω ( ( D / Δ 2 ) log ⁡ ( n / D ) ) Ω((D/Δ2)log⁡(n/D)) tests. This extends the same lower bound achieved in [1] for non-adaptive algorithms. In addition, we show that our bound is tight up to a small additive term by constructing an adaptive algorithm for this task. Furthermore, we give a non-constructive proof of an upper bound of O ( ( D / Δ 2 ) O((D/Δ2) ( log ⁡ ( n / D ) + log ⁡ Δ ) ) (log⁡(n/D)+log⁡Δ)) for the non-adaptive settings. This bound is an improvement over the upper bound O ( ( log ⁡ D ) / ( log ⁡ Δ ) ) D log ⁡ n ) O((log⁡D)/(log⁡Δ))Dlog⁡n) from [1] , and matches the lower bound up to a small additive term. Moreover, we use existing techniques for building expander regular bipartite graphs , extractors and condensers from [2] , [3] to construct two polynomial-time non-adaptive algorithms for estimating d . Using the construction from [2] , a polynomial non-adaptive algorithm that makes O ( ( D 1 + o ( 1 ) / Δ 2 ) ⋅ log ⁡ n ) O((D1+o(1)/Δ2)⋅log⁡n) tests are defined. The second algorithm exploits the construction from [3] to build another non-adaptive algorithm that performs ( D / Δ 2 ) ⋅ Q u a z i p o l y (D/Δ2)⋅Quazipoly ( log ⁡ n ) (log⁡n) tests. This is the first explicit construction with an almost optimal test complexity.},
  archive      = {J_TCS},
  author       = {Nader H. Bshouty and Catherine A. Haddad-Zaknoon},
  doi          = {10.1016/j.tcs.2021.05.011},
  journal      = {Theoretical Computer Science},
  pages        = {46-58},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Optimal deterministic group testing algorithms to estimate the number of defectives},
  volume       = {874},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A note on the price of bandit feedback for mistake-bounded
online learning. <em>TCS</em>, <em>874</em>, 42–45. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.009">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The standard model and the bandit model are two generalizations of the mistake-bound model to online multiclass classification . In both models the learner guesses a classification in each round, but in the standard model the learner receives the correct classification after each guess, while in the bandit model the learner is only told whether or not their guess is correct in each round. For any set F of multiclass classifiers , define op t std ( F ) optstd(F) and op t bandit ( F ) optbandit(F) to be the optimal worst-case number of prediction mistakes in the standard and bandit models respectively. Long (Theoretical Computer Science, 2020) claimed that for all M &gt; 2 M&amp;gt;2 and infinitely many k , there exists a set F of functions from a set X to a set Y of size k such that op t std ( F ) = M optstd(F)=M and op t bandit ( F ) ≥ ( 1 − o ( 1 ) ) ( | Y | ln ⁡ | Y | ) op t std ( F ) optbandit(F)≥(1−o(1))(|Y|ln⁡|Y|)optstd(F) . The proof of this result depended on the following lemma, which is false e.g. for all prime p ≥ 5 p≥5 , s = 1 s=1 (the all 1 vector), t = 2 t=2 (the all 2 vector), and all z . Lemma: Fix n ≥ 2 n≥2 and prime p , and let u be chosen uniformly at random from { 0 , … , p − 1 } n {0,…,p−1}n . For any s , t ∈ { 1 , … , p − 1 } n s,t∈{1,…,p−1}n with s ≠ t s≠t and for any z ∈ { 0 , … , p − 1 } z∈{0,…,p−1} , we have Pr ⁡ ( t ⋅ u = z mod p | s ⋅ u = z mod p ) = 1 p Pr⁡(t⋅u=zmodp|s⋅u=zmodp)=1p . We show that this lemma is false precisely when s and t are multiples of each other mod p . Then using a new lemma, we fix Long&#39;s proof.},
  archive      = {J_TCS},
  author       = {Jesse Geneson},
  doi          = {10.1016/j.tcs.2021.05.009},
  journal      = {Theoretical Computer Science},
  pages        = {42-45},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A note on the price of bandit feedback for mistake-bounded online learning},
  volume       = {874},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A constant amortized time enumeration algorithm for
independent sets in graphs with bounded clique number. <em>TCS</em>,
<em>874</em>, 32–41. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.008">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this study, we address the independent set enumeration problem. Although several efficient enumeration algorithms and careful analyses have been proposed for maximal independent sets , no fine-grained analysis has been given for the non-maximal variant. As the main result, we propose an enumeration algorithm for the non-maximal variant that runs in O ( q ) O(q) amortized time and linear space, where q is the clique number, i.e., the maximum size of a clique in an input graph. Note that the proposed algorithm works correctly even if the exact value of q is unknown. It is optimal for graphs with a bounded clique number, such as, triangle-free graphs, bipartite graphs , planar graphs , bounded degenerate graphs, nowhere dense graphs, and F -free graphs for any fixed graph F , where a F -free graph is a graph that has no copy of F as a subgraph. Furthermore, with a slight modification of our proposed algorithm, we can enumerate independent sets with the size at most k in the same time and space complexity. This problem is a generalization of the original problem since this is equal to the original problem if k = n k=n .},
  archive      = {J_TCS},
  author       = {Kazuhiro Kurita and Kunihiro Wasa and Takeaki Uno and Hiroki Arimura},
  doi          = {10.1016/j.tcs.2021.05.008},
  journal      = {Theoretical Computer Science},
  pages        = {32-41},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A constant amortized time enumeration algorithm for independent sets in graphs with bounded clique number},
  volume       = {874},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A parameterized perspective on protecting elections.
<em>TCS</em>, <em>874</em>, 15–31. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.006">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the parameterized complexity of the Optimal Defense and Optimal Attack problems in voting. In both the problems, the input is a set of voter groups (every voter group is a district consisting of a set of votes) and two integers k a ka and k d kd corresponding to respectively the number of voter groups the attacker can attack and the number of voter groups the defender can defend. A voter group gets removed from the election if it is attacked but not defended. In the Optimal Defense problem, we want to know if it is possible for the defender to commit to a strategy of defending at most k d kd voter groups such that, no matter which k a ka voter groups the attacker attacks, the outcome of the election does not change. In the Optimal Attack problem, we want to know if it is possible for the attacker to commit to a strategy of attacking k a ka voter groups such that, no matter which k d kd voter groups the defender defends, the outcome of the election is always different from the original one (without any attack). We show that both the Optimal Defense problem and the Optimal Attack problem are computationally intractable for every scoring rule and the Condorcet voting rule even when we have only 3 candidates. We also show that the Optimal Defense problem for every scoring rule and the Condorcet voting rule is W [ 2 ] W[2] -hard for both the parameters k a ka and k d kd , while it admits a fixed parameter tractable algorithm parameterized by the combined parameter ( k a , k d ) (ka,kd) . The Optimal Attack problem for every scoring rule and the Condorcet voting rule turns out to be much harder – it is W [ 1 ] W[1] -hard even for the combined parameter ( k a , k d ) (ka,kd) . We propose two greedy algorithms for the Optimal Defense problem and empirically show that they perform effectively on many voting profiles.},
  archive      = {J_TCS},
  author       = {Palash Dey and Neeldhara Misra and Swaprava Nath and Garima Shakya},
  doi          = {10.1016/j.tcs.2021.05.006},
  journal      = {Theoretical Computer Science},
  pages        = {15-31},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A parameterized perspective on protecting elections},
  volume       = {874},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A self-stabilizing algorithm for constructing a minimal
reachable directed acyclic graph with two senders and two targets.
<em>TCS</em>, <em>874</em>, 1–14. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.005">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we introduce a new graph structure named an ST ST -reachable directed acyclic graph which is a directed acyclic graph (DAG) that guarantees reachability (i.e., a directed path exists) from every sender to every target. When an arbitrarily connected undirected graph G = ( V , E ) G=(V,E) and two sets of the vertices, senders S S (⊂ V ) and targets T T (⊂ V ), are given, we consider the construction of a minimal ST ST -reachable DAG by changing some undirected edges to arcs and removing the remaining edges. In this paper, we present the necessary and sufficient condition under which a minimal ST ST -reachable DAG can be constructed when | S | ≤ 2 |S|≤2 and | T | ≤ 2 |T|≤2 , and propose a self-stabilizing algorithm for constructing a minimal ST ST -reachable DAG (if it exists) when an arbitrarily connected undirected graph , S ( | S | ≤ 2 ) S(|S|≤2) and T ( | T | ≤ 2 ) T(|T|≤2) are given. Moreover, our proposed algorithm can detect the non-existence of any ST ST -reachable DAG if the ST ST -reachable DAG of the given graph and two sets of vertices, S S and T T , do not exist.},
  archive      = {J_TCS},
  author       = {Yonghwan Kim and Masahiro Shibata and Yuichi Sudo and Junya Nakamura and Yoshiaki Katayama and Toshimitsu Masuzawa},
  doi          = {10.1016/j.tcs.2021.05.005},
  journal      = {Theoretical Computer Science},
  pages        = {1-14},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A self-stabilizing algorithm for constructing a minimal reachable directed acyclic graph with two senders and two targets},
  volume       = {874},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Almost linear time algorithms for minsum k-sink problems on
dynamic flow path networks. <em>TCS</em>, <em>873</em>, 87–113. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.003">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We address the facility location problems on dynamic flow path networks. A dynamic flow path network consists of an undirected path with positive edge lengths, positive edge capacities, and positive vertex weights. A path can be considered as a road, an edge length as the distance along the road and a vertex weight as the number of people at the site. An edge capacity limits the number of people that can enter the edge per unit time. In the dynamic flow network, given particular points on edges or vertices, called sinks , all the people evacuate from the vertices to the sinks as quickly as possible. The problem is to find the location of sinks on a dynamic flow path network in such a way that the aggregate evacuation time (i.e., the sum of evacuation times for all the people) to sinks is minimized. We consider two models of the problem: the confluent flow model and the non-confluent flow model . In the former model, the way of evacuation is restricted so that all the people at a vertex have to evacuate to the same sink, and in the latter model, there is no such restriction. In this paper, for both the models, we develop algorithms which run in almost linear time regardless of the number of sinks. It should be stressed that for the confluent flow model, our algorithm improves upon the previous result by Benkoczi et al. [Theoretical Computer Science, 2020], and one for the non-confluent flow model is the first polynomial time algorithm.},
  archive      = {J_TCS},
  author       = {Yuya Higashikawa and Naoki Katoh and Junichi Teruyama and Koji Watase},
  doi          = {10.1016/j.tcs.2021.05.003},
  journal      = {Theoretical Computer Science},
  pages        = {87-113},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Almost linear time algorithms for minsum k-sink problems on dynamic flow path networks},
  volume       = {873},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). An improved algorithm for learning sparse parities in the
presence of noise. <em>TCS</em>, <em>873</em>, 76–86. (<a
href="https://doi.org/10.1016/j.tcs.2021.04.026">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We revisit the Learning Sparse Parities with Noise (LSPN) problem on k out of n variables for k ≪ n k≪n , and present the following findings.},
  archive      = {J_TCS},
  author       = {Di Yan and Yu Yu and Hanlin Liu and Shuoyao Zhao and Jiang Zhang},
  doi          = {10.1016/j.tcs.2021.04.026},
  journal      = {Theoretical Computer Science},
  pages        = {76-86},
  shortjournal = {Theor. Comput. Sci.},
  title        = {An improved algorithm for learning sparse parities in the presence of noise},
  volume       = {873},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Digraphs with proper connection number two. <em>TCS</em>,
<em>873</em>, 64–75. (<a
href="https://doi.org/10.1016/j.tcs.2021.04.025">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A directed path in a digraph is proper if any two consecutive arcs on the path have distinct colors. An arc-colored digraph D is proper connected if for any two distinct vertices x and y of D , there are both proper ( x , y ) (x,y) -directed paths and proper ( y , x ) (y,x) -directed paths in D . The proper connection number p c → ( D ) pc→(D) of a digraph D is the minimum number of colors that can be used to make D proper connected. Obviously, if a digraph has a proper connection number, it must be strongly connected, and p c → ( D ) = 1 pc→(D)=1 if and only if D is complete. Magnant et al. showed that p c → ( D ) ≤ 3 pc→(D)≤3 for all strong digraphs D , and Ducoffe et al. proved that deciding whether a given digraph has proper connection number at most two is NP-complete. In this paper, we give a few classes of strong digraphs with proper connection number two, and from our proofs one can construct an optimal arc-coloring for a digraph of order n in time O ( n 3 ) O(n3) .},
  archive      = {J_TCS},
  author       = {Luyi Li and Xueliang Li},
  doi          = {10.1016/j.tcs.2021.04.025},
  journal      = {Theoretical Computer Science},
  pages        = {64-75},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Digraphs with proper connection number two},
  volume       = {873},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the solution bound of two-sided scaffold filling.
<em>TCS</em>, <em>873</em>, 47–63. (<a
href="https://doi.org/10.1016/j.tcs.2021.04.024">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we propose an algorithm which approximates the Two-Sided Scaffold Filling problem to a performance ratio 1.4 + ε 1.4+ε . This is achieved through a deep investigation of the optimal solution structure of Two-Sided Scaffold Filling. We make use of a relevant graph aiming at a solution of a Two-Sided Scaffold Filling instance, and evaluate the optimal solution value by the number of connected components in this graph. We show that an arbitrary optimal solution can be transformed into one whose relevant graph admits connected components that are available to compare with the solution of our algorithm in terms of their values. The performance ratio 1.4 + ε 1.4+ε is obtained by comparing the bound of such an optimal solution with the solution of our algorithm.},
  archive      = {J_TCS},
  author       = {Jingjing Ma and Daming Zhu and Haitao Jiang and Binhai Zhu},
  doi          = {10.1016/j.tcs.2021.04.024},
  journal      = {Theoretical Computer Science},
  pages        = {47-63},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On the solution bound of two-sided scaffold filling},
  volume       = {873},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A (probably) optimal algorithm for bisection on
bounded-treewidth graphs. <em>TCS</em>, <em>873</em>, 38–46. (<a
href="https://doi.org/10.1016/j.tcs.2021.04.023">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The maximum/minimum bisection problems are, given an edge-weighted graph, to find a bipartition of the vertex set into two sets whose sizes differ by at most one, such that the total weight of edges between the two sets is maximized/minimized. Although these two problems are known to be NP-hard, there is an efficient algorithm for bounded-treewidth graphs. In particular, Jansen et al. (2005) [5] gave an O ( 2 t n 3 ) O(2tn3) -time algorithm when given a tree decomposition of width t of the input graph, where n is the number of vertices of the input graph. Eiben et al. (2021) [10] improved the dependency of n in the running time by giving an O ( 8 t t 5 n 2 log ⁡ n ) O(8tt5n2log⁡n) -time algorithm. Moreover, they showed that there is no O ( n 2 − ε ) O(n2−ε) -time algorithm for trees under some reasonable complexity assumption. In this paper, we show an O ( 2 t ( t n ) 2 ) O(2t(tn)2) -time algorithm for both problems, which is asymptotically tight to their conditional lower bound. We also show that the exponential dependency of the treewidth is asymptotically optimal under the Strong Exponential Time Hypothesis. Finally, we discuss the (in)tractability of both problems with respect to special graph classes.},
  archive      = {J_TCS},
  author       = {Tesshu Hanaka and Yasuaki Kobayashi and Taiga Sone},
  doi          = {10.1016/j.tcs.2021.04.023},
  journal      = {Theoretical Computer Science},
  pages        = {38-46},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A (probably) optimal algorithm for bisection on bounded-treewidth graphs},
  volume       = {873},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Maximum rooted connected expansion. <em>TCS</em>,
<em>873</em>, 25–37. (<a
href="https://doi.org/10.1016/j.tcs.2021.04.022">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Prefetching constitutes a valuable tool toward the goal of efficient Web surfing. As a result, estimating the amount of resources that need to be preloaded during a surfer&#39;s browsing becomes an important task. In this regard, prefetching can be modeled as a two-player combinatorial game (Fomin et al. (2014) [6] ), where a surfer and a marker alternately play on a given graph (representing the Web graph). During its turn, the marker chooses a set of k nodes to mark (prefetch), whereas the surfer, represented as a token resting on graph nodes, moves to a neighboring node (Web resource). The surfer&#39;s objective is to reach an unmarked node before all nodes become marked and the marker wins. Intuitively, since the surfer is step-by-step traversing a subset of nodes in the Web graph , a satisfactory prefetching procedure would load in cache (without any delay) all resources lying in the neighborhood of this growing subset. Motivated by the above, we consider the following maximization problem to which we refer to as the Maximum Rooted Connected Expansion (MRCE) problem. Given a graph G and a root node v 0 v0 , we wish to find a subset of vertices S such that S is connected, S contains v 0 v0 and the ratio | N [ S ] | | S | |N[S]||S| is maximized, where N [ S ] N[S] denotes the closed neighborhood of S , that is, N [ S ] N[S] contains all nodes in S and all nodes with at least one neighbor in S . We prove that the problem is NP-hard even when the input graph G is restricted to be a split graph. On the positive side, we demonstrate a Polynomial Time Approximation Scheme (PTAS) for split graphs. Furthermore, we present a 1 6 ( 1 − 1 e ) 16(1−1e) -approximation algorithm for general graphs based on techniques for the Budgeted Connected Domination problem (Khuller et al. (2014) [20] ). Finally, we provide a polynomial-time algorithm for the special case of interval graphs . Our algorithm returns an optimal solution for MRCE in O ( n 3 ) O(n3) time, where n is the number of nodes in G , and in logarithmic space .},
  archive      = {J_TCS},
  author       = {Ioannis Lamprou and Russell Martin and Sven Schewe and Ioannis Sigalas and Vassilis Zissimopoulos},
  doi          = {10.1016/j.tcs.2021.04.022},
  journal      = {Theoretical Computer Science},
  pages        = {25-37},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Maximum rooted connected expansion},
  volume       = {873},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On parameterized algorithms for fixed-order book thickness
with respect to the pathwidth of the vertex ordering. <em>TCS</em>,
<em>873</em>, 16–24. (<a
href="https://doi.org/10.1016/j.tcs.2021.04.021">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Given a graph G = ( V , E ) G=(V,E) with a vertex ordering ≺, the fixed-order book thickness problem asks whether there is a page assignment σ such that 〈 ≺ , σ 〉 〈≺,σ〉 is a k -page book embedding of G . This problem is NP-complete even for any fixed k greater than 3. Recently, Bhore et al. (2019, 2020) [1] , [2] presented a parameterized algorithm with respect to the pathwidth κ of the vertex ordering. In this paper, we first re-analyze the running time for Bhore et al.&#39;s algorithm, and prove a bound of 2 O ( κ 2 ) ⋅ | V | 2O(κ2)⋅|V| improving Bhore et al.&#39;s bound of κ O ( κ 2 ) ⋅ | V | κO(κ2)⋅|V| . Then, we show that fixed-order book thickness parameterized by the pathwidth of the vertex ordering does not admit a polynomial kernel unless NP ⊆ coNP/poly. Finally, we show that a generalized fixed-order book thickness problem, in which a budget of at most c crossings over all pages was given, admits a parameterized algorithm running in time ( c + 2 ) O ( κ 2 ) (c+2)O(κ2) ⋅ | V | ⋅|V| .},
  archive      = {J_TCS},
  author       = {Yunlong Liu and Jie Chen and Jingui Huang and Jianxin Wang},
  doi          = {10.1016/j.tcs.2021.04.021},
  journal      = {Theoretical Computer Science},
  pages        = {16-24},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On parameterized algorithms for fixed-order book thickness with respect to the pathwidth of the vertex ordering},
  volume       = {873},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Degree-anonymization using edge rotations. <em>TCS</em>,
<em>873</em>, 1–15. (<a
href="https://doi.org/10.1016/j.tcs.2021.04.020">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Min Anonymous-Edge-Rotation problem asks for an input graph G and a positive integer k to find a minimum number of edge rotations that transform G into a graph such that for each vertex there are at least k − 1 k−1 other vertices of the same degree (a k -degree-anonymous graph). In this paper, we prove that the Min Anonymous-Edge-Rotation problem is NP-hard even for k = n / q k=n/q , where n is the order of a graph and q any positive integer, q ≥ 3 q≥3 . We argue that under some constrains on the number of edges in a graph and k , Min Anonymous-Edge-Rotation is polynomial-time 2-approximable. Furthermore, we show that the problem is solvable in polynomial time for any graph when k = n k=n and for trees when k = θ ( n ) k=θ(n) . Additionally, we establish sufficient conditions for an input graph and k such that a solution for Min Anonymous-Edge-Rotation exists.},
  archive      = {J_TCS},
  author       = {Cristina Bazgan and Pierre Cazals and Janka Chlebíková},
  doi          = {10.1016/j.tcs.2021.04.020},
  journal      = {Theoretical Computer Science},
  pages        = {1-15},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Degree-anonymization using edge rotations},
  volume       = {873},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021e). Editorial. <em>TCS</em>, <em>872</em>, iii. (<a
href="https://doi.org/10.1016/S0304-3975(21)00289-9">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_TCS},
  author       = {Lila Kari ( Editor-in-Chief )},
  doi          = {10.1016/S0304-3975(21)00289-9},
  journal      = {Theoretical Computer Science},
  pages        = {iii},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Editorial},
  volume       = {872},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Sequential reprogramming of biological network fate.
<em>TCS</em>, <em>872</em>, 97–116. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.013">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Network controllability is a major challenge in network medicine. The problem is to rewire the molecular network for reprogramming the cell fate. The reprogramming action is considered as a control usually performed once. However, in some cases, a therapy has to follow a time-scheduled drug administration protocol. Furthermore, some diseases are induced by a sequence of mutations leading to a sequence of actions on molecules. In this paper, we extend the single control action method by investigating the sequential control of Boolean networks. We present a novel theoretical framework for formal study of control sequences, leading to algorithms resolving the PSPACE-hard problem of inferring minimal parsimonious control sequences under the synchronous dynamics.},
  archive      = {J_TCS},
  author       = {Jérémie Pardo and Sergiu Ivanov and Franck Delaplace},
  doi          = {10.1016/j.tcs.2021.03.013},
  journal      = {Theoretical Computer Science},
  pages        = {97-116},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Sequential reprogramming of biological network fate},
  volume       = {872},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). (Imperfect) strategies to generate primitive polynomials
over GF(2). <em>TCS</em>, <em>872</em>, 79–96. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.007">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present three greedy strategies for finding primitive polynomials of large degree over GF(2). Maximal length cellular automata (CAs) are used as tools to generate the primitive polynomials. The proposed strategies greedily synthesize (linear) CAs of different sizes, which are almost always of maximal length. Since the characteristic polynomial of a maximal length cellular automaton is primitive, characteristic polynomials of the synthesized CAs are claimed as primitive.},
  archive      = {J_TCS},
  author       = {Sumit Adak and Sukanta Das},
  doi          = {10.1016/j.tcs.2021.03.007},
  journal      = {Theoretical Computer Science},
  pages        = {79-96},
  shortjournal = {Theor. Comput. Sci.},
  title        = {(Imperfect) strategies to generate primitive polynomials over GF(2)},
  volume       = {872},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Self-assembly of and optimal encoding within thin rectangles
at temperature-1 in 3D. <em>TCS</em>, <em>872</em>, 55–78. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.001">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we study the self-assembly of rectangles in a non-cooperative, 3D version of Winfree&#39;s abstract Tile Assembly Model. We prove two results. First, we give the full details for the proof of a general construction for the efficient self-assembly of thin rectangles that was first reported by Furcy, Summers and Wendlandt (2019). This construction is non-cooperative and “just-barely” 3D in the sense that it places tiles at most one step into the third dimension. Second, we give a non-cooperative, just-barely 3D optimal encoding construction that self-assembles the bits of a given binary string along the perimeter of a thin rectangle of constant height.},
  archive      = {J_TCS},
  author       = {David Furcy and Scott M. Summers and Christian Wendlandt},
  doi          = {10.1016/j.tcs.2021.02.001},
  journal      = {Theoretical Computer Science},
  pages        = {55-78},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Self-assembly of and optimal encoding within thin rectangles at temperature-1 in 3D},
  volume       = {872},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Analyzing the quality of local and global multidimensional
projections using performance evaluation planning. <em>TCS</em>,
<em>872</em>, 41–54. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.043">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Among the challenges of the big data era, the analysis of high-dimensional data is still an open research area. As a result, several multidimensional projection techniques have been developed to reduce data dimensionality, becoming important visualization and visual analytics tools. In order to ensure the quality of projections, it is necessary to assess the low-dimensional embeddings by using different dataset configurations as input and analyzing evaluation metrics . However, it is not clear to the user how factors such as the number of dimensions, instances, or clusters, can affect the projection mapping and its quality regarding different projection techniques and assessment metrics. The research reported in this paper aims to clarify how much these factors affect each response variable via performance evaluation planning. We present an evaluation approach, supported by factorial design, that carries out a complete analysis, in the sense of measuring all possible combinations of all the input factors. The results of the analyses of local and global structure preservation in the projections yield a better understanding of how distinct dataset properties can influence the choice of projections based on quality metrics results.},
  archive      = {J_TCS},
  author       = {Danilo B. Coimbra and Rafael M. Martins and Edson Mota and Tacito Tiburtino and Pedro Diamantino and Maycon L.M. Peixoto},
  doi          = {10.1016/j.tcs.2020.12.043},
  journal      = {Theoretical Computer Science},
  pages        = {41-54},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Analyzing the quality of local and global multidimensional projections using performance evaluation planning},
  volume       = {872},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Dynamic preference logic meets iterated belief change:
Representation results and postulates characterization. <em>TCS</em>,
<em>872</em>, 15–40. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.042">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {AGM&#39;s belief revision is one of the main paradigms in the study of belief change operations. Recently, several logics for belief and information change have been proposed in the literature and used to encode belief change operations in rich and expressive semantic frameworks. While the connections of AGM-like operations and their encoding in dynamic doxastic logics have been studied before by the work of Segerberg, most works on the area of Dynamic Epistemic Logics (DEL) have not, to our knowledge, attempted to use those logics as tools to investigate mathematical properties of belief change operators. This work investigates how Dynamic Preference Logic, a logic in the DEL family, can be used to study properties of dynamic belief change operators, focusing on well-known postulates of iterated belief change.},
  archive      = {J_TCS},
  author       = {Marlo Souza and Renata Vieira and Álvaro Moreira},
  doi          = {10.1016/j.tcs.2020.12.042},
  journal      = {Theoretical Computer Science},
  pages        = {15-40},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Dynamic preference logic meets iterated belief change: Representation results and postulates characterization},
  volume       = {872},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Ranks of strictly minimal reaction systems induced by
permutations. <em>TCS</em>, <em>872</em>, 1–14. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.015">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Reaction system is a computing model inspired by the biochemical interaction taking place within the living cells. Various extended or modified frameworks motivated by biological, physical, or purely mathematically considerations have been proposed and received significant amount of attention, notably in the recent years. This study, however, takes after particular early works that concentrated on the mathematical nature of minimal reaction systems in the context-free basic framework and motivated by a recent result on the sufficiency of strictly minimal reaction systems to simulate every reaction system. This paper focuses on the largest reaction system rank attainable by strictly minimal reaction systems, where the rank pertains to the minimum size of a functionally equivalent reaction system. Precisely, we provide a very detailed study for specific strictly minimal reaction system induced by permutations , up to the quaternary alphabet. Along the way, we obtain a general result about reaction system rank for Cartesian product of functions specified by reaction systems.},
  archive      = {J_TCS},
  author       = {Wen Chean Teh and Kien Trung Nguyen and Chuei Yee Chen},
  doi          = {10.1016/j.tcs.2020.12.015},
  journal      = {Theoretical Computer Science},
  pages        = {1-14},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Ranks of strictly minimal reaction systems induced by permutations},
  volume       = {872},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The number of short cycles in fibonacci cubes. <em>TCS</em>,
<em>871</em>, 134–146. (<a
href="https://doi.org/10.1016/j.tcs.2021.04.019">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Fibonacci cube is the subgraph of the hypercube induced by the vertices whose binary string representations do not contain two consecutive 1s. These cubes were presented as an alternative interconnection network . In this paper, we calculate the number of induced paths and cycles of small length in Fibonacci cubes by using the recursive structure of these graphs.},
  archive      = {J_TCS},
  author       = {Ömer Eğecioğlu and Elif Saygı and Zülfükar Saygı},
  doi          = {10.1016/j.tcs.2021.04.019},
  journal      = {Theoretical Computer Science},
  pages        = {134-146},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The number of short cycles in fibonacci cubes},
  volume       = {871},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Approximation algorithms for the submodular edge cover
problem with submodular penalties. <em>TCS</em>, <em>871</em>, 126–133.
(<a href="https://doi.org/10.1016/j.tcs.2021.04.017">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we consider the submodular edge cover problem with submodular penalties. In this problem, we are given an undirected graph G = ( V , E ) G=(V,E) with vertex set V and edge set E . Assume the covering cost function c : 2 E → R + c:2E→R+ and the penalty function p : 2 V → R + p:2V→R+ are both submodular with p non-decreasing, c ( ∅ ) = 0 c(∅)=0 and p ( ∅ ) = 0 p(∅)=0 . The goal of the submodular edge cover problem with submodular penalties is to select an edge subset to cover some vertices and penalize the vertex subset containing uncovered vertices such that the total cost of covering and penalty is minimized. For this problem, we first give a 2Δ-approximation algorithm by using a primal-dual technique, where Δ is the maximal degree of the graph G . Then we transform this problem into a submodular set cover problem, and by applying a known result for the submodular set cover problem we conclude that there is an approximation algorithm with an approximation ratio Δ + 1 Δ+1 .},
  archive      = {J_TCS},
  author       = {Xin Wang and Suogang Gao and Bo Hou and Lidong Wu and Wen Liu},
  doi          = {10.1016/j.tcs.2021.04.017},
  journal      = {Theoretical Computer Science},
  pages        = {126-133},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Approximation algorithms for the submodular edge cover problem with submodular penalties},
  volume       = {871},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Embedded connectivity of ternary n-cubes. <em>TCS</em>,
<em>871</em>, 121–125. (<a
href="https://doi.org/10.1016/j.tcs.2021.04.016">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Let G n Gn be an n -dimensional recursive network. A set F ⊂ V ( G n ) F⊂V(Gn) (resp. F ⊂ E ( G n ) F⊂E(Gn) ) is called a t -embedded vertex cut (resp. t -embedded edge cut) of G n Gn if G n − F Gn−F is disconnected and each vertex of which lies in a t -dimensional subnetwork of G n − F Gn−F . The t -embedded vertex connectivity ζ t ( G n ) ζt(Gn) (resp. t -embedded edge connectivity η t ( G n ) ηt(Gn) ) of G n Gn is the minimum cardinality over all t -embedded vertex cuts (resp. t -embedded edge cuts) in G n Gn , if any. In this paper, we prove that ζ t ( Q n 3 ) = 2 ( n − t ) 3 t ζt(Qn3)=2(n−t)3t for 0 ≤ t ≤ n − 2 0≤t≤n−2 , and η t ( Q n 3 ) = 2 ( n − t ) 3 t ηt(Qn3)=2(n−t)3t for 0 ≤ t ≤ n − 1 0≤t≤n−1 , where Q n 3 Qn3 is the ternary n -cube.},
  archive      = {J_TCS},
  author       = {Yuxing Yang},
  doi          = {10.1016/j.tcs.2021.04.016},
  journal      = {Theoretical Computer Science},
  pages        = {121-125},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Embedded connectivity of ternary n-cubes},
  volume       = {871},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the performance of learned data structures. <em>TCS</em>,
<em>871</em>, 107–120. (<a
href="https://doi.org/10.1016/j.tcs.2021.04.015">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A recent trend in algorithm design consists of augmenting classic data structures with machine learning models, which are better suited to reveal and exploit patterns and trends in the input data so to achieve outstanding practical improvements in space occupancy and time efficiency. This is especially known in the context of indexing data structures for big data where, despite few attempts in evaluating their asymptotic efficiency , theoretical results are yet missing in showing that learned indexes are provably better than classic indexes, such as B-tree s and their variants. In this paper, we present the first mathematically-grounded answer to this problem by exploiting a link with a mean exit time problem over a proper stochastic process which, we show, is related to the space and time complexity of these learned indexes. As a corollary of this general analysis, we show that plugging this result in the (learned) PGM-index, we get a learned data structure which is provably better than B-tree s.},
  archive      = {J_TCS},
  author       = {Paolo Ferragina and Fabrizio Lillo and Giorgio Vinciguerra},
  doi          = {10.1016/j.tcs.2021.04.015},
  journal      = {Theoretical Computer Science},
  pages        = {107-120},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On the performance of learned data structures},
  volume       = {871},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A transformation algorithm to construct a rectangular
floorplan. <em>TCS</em>, <em>871</em>, 94–106. (<a
href="https://doi.org/10.1016/j.tcs.2021.04.014">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A rectangular floorplan (RFP) is a partition of a rectangle R into rectangles R1,R2,…,Rn such that no four of them meet at a point. Rectangular floorplans find their applications in VLSI circuits floorplanning and architectural floorplanning . Let G represent the graph of a rectangular floorplan RFP 1(n) and H be a subgraph of G , where n denotes the number of rectangles in RFP 1(n) . It is well known that every subgraph of G may not admit an RFP, i.e., G does not have a hereditary property . Hence, in this paper, we first derive a necessary and sufficient condition for H to admit a rectangular floorplan RFP 2(n) . Further, if H admits an RFP, we present a linear time transformation algorithm for deriving RFP 2(n) from RFP 1(n) .},
  archive      = {J_TCS},
  author       = {Vinod Kumar and Krishnendra Shekhawat},
  doi          = {10.1016/j.tcs.2021.04.014},
  journal      = {Theoretical Computer Science},
  pages        = {94-106},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A transformation algorithm to construct a rectangular floorplan},
  volume       = {871},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). How good is a two-party election game? <em>TCS</em>,
<em>871</em>, 79–93. (<a
href="https://doi.org/10.1016/j.tcs.2021.04.013">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we propose a simple and intuitive model to investigate the efficiency of the two-party election system, especially regarding the nomination process. Each of the two parties has its own candidates, and each of them brings utilities for the people including the supporters and non-supporters. In an election, each party nominates exactly one of its candidates to compete against the other party&#39;s. The candidate wins the election with higher odds if he or she brings more utility for all the people. We model such competition as a two-party election game such that each party is a player with two or more pure strategies corresponding to its potential candidates, and the payoff of each party is a mixed utility from a selected pair of competing candidates. By looking into the three models, namely, the linear link, Bradley-Terry, and the softmax models, which differ in how to formulate a candidate&#39;s winning odds against the competing candidate, we show that the two-party election game may neither have any pure Nash equilibrium nor a bounded price of anarchy. Nevertheless, by considering the conventional egoism , which states that any candidate benefits his/her party&#39;s supporters more than any candidate from the competing party does, we prove that the two-party election game in both the linear link model and the softmax model always has pure Nash equilibria , and furthermore, the price of anarchy is constantly bounded.},
  archive      = {J_TCS},
  author       = {Chuang-Chieh Lin and Chi-Jen Lu and Po-An Chen},
  doi          = {10.1016/j.tcs.2021.04.013},
  journal      = {Theoretical Computer Science},
  pages        = {79-93},
  shortjournal = {Theor. Comput. Sci.},
  title        = {How good is a two-party election game?},
  volume       = {871},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Inequity aversion pricing over social networks:
Approximation algorithms and hardness results. <em>TCS</em>,
<em>871</em>, 62–78. (<a
href="https://doi.org/10.1016/j.tcs.2021.04.012">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study a revenue maximization problem in the context of social networks. Namely, we generalize a model introduced by Alon, Mansour, and Tennenholtz [2] that captures inequity aversion , i.e., it captures the fact that prices offered to neighboring nodes should not differ significantly. We first provide approximation algorithms for a natural class of instances, where the total revenue is the sum of single-value revenue functions . Our results improve on the current state of the art, especially when the number of distinct prices is small. This applies, for instance, to settings where the seller will only consider a fixed number of discount types or special offers. To complement our positive results, we resolve one of the open questions posed in [2] by establishing APX-hardness for the problem. Surprisingly, we further show that the problem is NP-complete even when the price differences are allowed to be large, or even when the number of allowed distinct prices is as small as three. Finally, we study extensions of the model regarding the demand type of the clients.},
  archive      = {J_TCS},
  author       = {Georgios Amanatidis and Peter Fulla and Evangelos Markakis and Krzysztof Sornat},
  doi          = {10.1016/j.tcs.2021.04.012},
  journal      = {Theoretical Computer Science},
  pages        = {62-78},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Inequity aversion pricing over social networks: Approximation algorithms and hardness results},
  volume       = {871},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021a). Theoretical aspects of equitable partition of networks into
sparse modules. <em>TCS</em>, <em>871</em>, 51–61. (<a
href="https://doi.org/10.1016/j.tcs.2021.04.010">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The problem of partitioning a large complex network equitably into sparse modules with given rules can be modeled by the equitable list d -degenerate coloring of graphs. This paper establishes theoretical results on such a coloring based on a newly proposed conjecture which states that every graph G is equitably d -degenerate k -colorable and equitably d -degenerate k -choosable for every integer k ≥ ( Δ ( G ) + 1 ) / ( d + 1 ) k≥(Δ(G)+1)/(d+1) . This conjecture is strong as it implies the Hajnal-Szemerédi theorem on equitable coloring, the equitable list coloring conjecture (Kostochka, Pelsmajer, and West, 2003), the equitable vertex arboricity conjecture (Wu, Zhang, and Li, 2013), and the equitable list vertex arboricity conjecture (Zhang, 2016). In this paper, we confirm this unified conjecture for globally coupled networks, ( d + 1 ) (d+1) -degenerate graphs, graphs with bounded maximum average degree, and planar graphs with large maximum degree . The equitable d -degenerate k -colorability part of this conjecture is also verified for interval graphs , generalizing a result of Niu, Li, and Zhang (2021).},
  archive      = {J_TCS},
  author       = {Huaqiang Zhang and Xin Zhang},
  doi          = {10.1016/j.tcs.2021.04.010},
  journal      = {Theoretical Computer Science},
  pages        = {51-61},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Theoretical aspects of equitable partition of networks into sparse modules},
  volume       = {871},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Approximate ridesharing of personal vehicles problem.
<em>TCS</em>, <em>871</em>, 30–50. (<a
href="https://doi.org/10.1016/j.tcs.2021.04.009">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {It is important to find ride matches for individuals who participate in ridesharing quickly, and it is equally important to minimize the number of drivers to serve all individuals and minimize the total travel distance of the vehicles. This paper considers the following ridesharing problem: given a set of trips, each trip consists of an individual, a vehicle of the individual and some requirements, select a subset of trips and use the vehicles of selected trips to deliver all individuals to their destinations while satisfying the requirements and achieving some optimization goal. Requirements of trips are specified by parameters including source, destination, vehicle capacity, preferred paths, detour distance and number of stops a driver is willing to make, and time constraints. We consider two optimization problems: minimizing the number of selected vehicles and minimizing total travel distance of the vehicles. We prove that it is NP-hard to approximate both minimization problems within a constant factor if any one of the requirements related to the detour distance, preferred paths, number of stops and time constraints is not satisfied. We give K + 2 2 K+22 -approximation algorithms for minimizing the number of selected vehicles when the requirement related to the number of stops is not satisfied, where K is the largest capacity of all vehicles.},
  archive      = {J_TCS},
  author       = {Qian-Ping Gu and Jiajian Leo Liang and Guochuan Zhang},
  doi          = {10.1016/j.tcs.2021.04.009},
  journal      = {Theoretical Computer Science},
  pages        = {30-50},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Approximate ridesharing of personal vehicles problem},
  volume       = {871},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Collusion-resistant identity-based proxy re-encryption:
Lattice-based constructions in standard model. <em>TCS</em>,
<em>871</em>, 16–29. (<a
href="https://doi.org/10.1016/j.tcs.2021.04.008">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The concept of proxy re-encryption (PRE) dates back to the work of Blaze, Bleumer, and Strauss in 1998. PRE offers delegation of decryption rights, i.e., it securely enables the re-encryption of ciphertexts from one key to another, without relying on trusted parties. PRE allows a semi-trusted third party termed as a “proxy” to securely divert encrypted files of user A (delegator) to user B (delegatee) without revealing any information about the underlying files to the proxy. To eliminate the necessity of having a costly certificate verification process , Green and Ateniese introduced an identity-based PRE (IB-PRE). The potential applicability of IB-PRE sprung up a long line of intensive research from its first instantiation. Unfortunately, till today, there is no collusion-resistant unidirectional IB-PRE secure in the standard model, which can withstand quantum attack. In this paper, we present the first concrete constructions of collusion-resistant unidirectional IB-PRE, for both selective and adaptive identity, which are secure in standard model based on the hardness of learning with errors problem.},
  archive      = {J_TCS},
  author       = {Priyanka Dutta and Willy Susilo and Dung Hoang Duong and Partha Sarathi Roy},
  doi          = {10.1016/j.tcs.2021.04.008},
  journal      = {Theoretical Computer Science},
  pages        = {16-29},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Collusion-resistant identity-based proxy re-encryption: Lattice-based constructions in standard model},
  volume       = {871},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the hardness of covering-interdiction problems.
<em>TCS</em>, <em>871</em>, 1–15. (<a
href="https://doi.org/10.1016/j.tcs.2021.04.007">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We investigate a two player scenario, in which a decision maker locates some facilities in a network, while a second player, called the interdictor, may disrupt the infrastructure by deleting some edges in the network in order to worsen the first player&#39;s objective value. For the case that the locational decision is assessed with the covering objective function, we show that the problem of the interdictor is NP -complete while the one of the locator is Σ 2 p -complete. We also present a variant of the problem obtained by changing the order of the players&#39; actions, which is shown to be Σ 2 p -complete.},
  archive      = {J_TCS},
  author       = {Nicolas Fröhlich and Stefan Ruzika},
  doi          = {10.1016/j.tcs.2021.04.007},
  journal      = {Theoretical Computer Science},
  pages        = {1-15},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On the hardness of covering-interdiction problems},
  volume       = {871},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021f). Editorial. <em>TCS</em>, <em>870</em>, iii. (<a
href="https://doi.org/10.1016/S0304-3975(21)00259-0">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_TCS},
  author       = {Lila Kari ( Editor-in-Chief )},
  doi          = {10.1016/S0304-3975(21)00259-0},
  journal      = {Theoretical Computer Science},
  pages        = {iii},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Editorial},
  volume       = {870},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Streaming ranked-tree-to-string transducers. <em>TCS</em>,
<em>870</em>, 165–187. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.033">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Streaming tree transducers with single-use restriction ( STT sur s STTsurs ) were introduced by Alur and D&#39;Antoni as an analyzable, executable, and expressive model for transforming unranked ordered trees in a single pass. The equivalence problem of STT sur s STTsurs is decidable because their class is as expressive as the class of MSO-definable tree transformations. In this paper, we present streaming ranked-tree-to-string transducers (SRTSTs), based on STT sur s STTsurs : SRTSTs are released from the single-use restriction while their input and output are restricted to ranked trees and strings, respectively. We show that the expressiveness of SRTSTs coincides with that of deterministic top-down tree transducers with regular look-ahead ( yDT R s yDTRs ), whose equivalence problem is known to be decidable. Our proof is done by constructing equivalent transducers in both directions.},
  archive      = {J_TCS},
  author       = {Yuta Takahashi and Kazuyuki Asada and Keisuke Nakano},
  doi          = {10.1016/j.tcs.2020.12.033},
  journal      = {Theoretical Computer Science},
  pages        = {165-187},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Streaming ranked-tree-to-string transducers},
  volume       = {870},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Decision problems and projection languages for restricted
variants of two-dimensional automata. <em>TCS</em>, <em>870</em>,
153–164. (<a href="https://doi.org/10.1016/j.tcs.2020.12.028">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A two-dimensional automaton has a read-only input head that moves in four directions on a finite array of cells labeled by symbols of the input alphabet . A three-way two-dimensional automaton is prohibited from making upward moves, while a two-way two-dimensional automaton can only move downward and rightward. We show that the language emptiness problem for unary three-way nondeterministic two-dimensional automata is NP -complete, and is in P for general-alphabet two-way nondeterministic two-dimensional automata. We also show that the language equivalence and inclusion problems for two-way deterministic two-dimensional automata are decidable, while the language universality, equivalence, and inclusion problems for two-way nondeterministic two-dimensional automata are undecidable. The deterministic case is the first known positive decidability result for a language equivalence problem on two-dimensional automata over a general alphabet. Finally, we discuss the notion of row and column projection languages. We show that the row projection language of a unary three-way nondeterministic two-dimensional automaton is always regular, and that there exists a unary three-way deterministic two-dimensional automaton with a nonregular column projection language. For two-way nondeterministic two-dimensional automata, on the other hand, both the row and column projection languages are always regular.},
  archive      = {J_TCS},
  author       = {Taylor J. Smith and Kai Salomaa},
  doi          = {10.1016/j.tcs.2020.12.028},
  journal      = {Theoretical Computer Science},
  pages        = {153-164},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Decision problems and projection languages for restricted variants of two-dimensional automata},
  volume       = {870},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Two-dimensional pattern matching against local and
regular-like picture languages. <em>TCS</em>, <em>870</em>, 137–152. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.026">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Given a two-dimensional array of symbols and a picture language over a finite alphabet, we investigate how to find rectangular subarrays that belong to the picture language. Two-dimensional pattern matching problems can be formulated by interpreting subarrays as matches and picture languages as patterns. We formulate four particular problems – finding maximum, minimum, any or all match(es) – and describe algorithms solving the problems for basic classes of picture languages, which include local picture languages and picture languages accepted by various types of deterministic two-dimensional finite automata such as four-way, three-way and two-way automata , on-line tessellation automata , and returning finite automata . We also prove that the pattern matching problems cannot be solved for the class of local picture languages in time linear in the input area unless the well known problem of triangle finding in a graph is solvable in quadratic time . This shows a fundamental difference between the complexity of one-dimensional and two-dimensional pattern matching .},
  archive      = {J_TCS},
  author       = {František Mráz and Daniel Průša and Michael Wehar},
  doi          = {10.1016/j.tcs.2020.12.026},
  journal      = {Theoretical Computer Science},
  pages        = {137-152},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Two-dimensional pattern matching against local and regular-like picture languages},
  volume       = {870},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Input-driven multi-counter automata. <em>TCS</em>,
<em>870</em>, 121–136. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.032">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The model of deterministic input-driven multi-counter automata is introduced and studied. On such devices, the input letters uniquely determine the operations on the underlying data structure that is consisting of multiple counters. We study the computational power of the resulting language families and compare them with known language families inside the Chomsky hierarchy. In addition, it is possible to prove a proper counter hierarchy depending on the alphabet size. This means that any input alphabet induces an upper bound which depends on the alphabet size only, such that k + 1 k+1 counters are more powerful than k counters as long as k is less than this bound. The hierarchy interestingly collapses at the level of the bound. Furthermore, we investigate the closure properties of the language families. For input-driven multi-counter automata with 0 or 1 counter, we discuss the computational complexity of their decidable problems. For k ≥ 2 k≥2 counters, the decidability problems of emptiness, finiteness , universality, inclusion, equivalence, regularity, and context-freeness are shown to be non-semidecidable. Finally, we study descriptional complexity aspects of input-driven multi-counter automata. It is shown that a nondeterministic device can be determinized and that 2 n − 1 2n−1 is a necessary and sufficient blow-up in the number of states for the determinization. For the operational state complexity of deterministic input-driven multi-counter automata under Boolean operations, tight bounds on the number of states are established. Finally, it turns out that the size trade-offs between deterministic input-driven multi-counter automata with k + 1 k+1 and k counters are non-recursive, that is, they are not bounded by any recursive function.},
  archive      = {J_TCS},
  author       = {Martin Kutrib and Andreas Malcher and Matthias Wendlandt},
  doi          = {10.1016/j.tcs.2021.01.032},
  journal      = {Theoretical Computer Science},
  pages        = {121-136},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Input-driven multi-counter automata},
  volume       = {870},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Partial derivatives of regular expressions over
alphabet-invariant and user-defined labels. <em>TCS</em>, <em>870</em>,
103–120. (<a href="https://doi.org/10.1016/j.tcs.2020.12.029">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We are interested in regular expressions that represent word relations in an alphabet-invariant way—for example, the set of all word pairs ( u , v ) (u,v) where v is a prefix of u independently of what the alphabet is. Current software systems of formal language objects do not have a mechanism to define such objects. Labelled graphs (transducers and automata) with alphabet-invariant and user-defined labels were considered in a recent paper. In this paper we study derivatives of regular expressions over labels (atomic objects) in some set B. These labels can be any strings as long as the strings represent subsets of a certain monoid . We show that the number of partial derivatives of any type B regular expression is linearly bounded, and that one can define partial derivative labelled graphs, whose transition labels can be elements of another label set X as long as X and B refer to the same monoid . We also show how to use derivatives directly to decide whether a given word is in the language of a regular expression over set specs. Set specs and pairing specs are label sets allowing one to express languages and relations over large alphabets in a natural and concise way such that many algorithms work directly on these labels without the need to expand these labels to linear or quadratic size expressions.},
  archive      = {J_TCS},
  author       = {Stavros Konstantinidis and Nelma Moreira and Rogério Reis},
  doi          = {10.1016/j.tcs.2020.12.029},
  journal      = {Theoretical Computer Science},
  pages        = {103-120},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Partial derivatives of regular expressions over alphabet-invariant and user-defined labels},
  volume       = {870},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Alternation in two-way finite automata. <em>TCS</em>,
<em>870</em>, 75–102. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.011">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The study of alternation in two-way finite automata ( 2 fa s) has been quite non-systematic. Since the 1970&#39;s, various authors with a variety of motivations have studied 2 fa s with various types of alternation and a variety of names, creating a fairly long list of sporadic contributions with little internal consistency. This article attempts to organize the subject into a single unifying framework. We start with a detailed account of all contributions to date, that reveals the large variety of approaches and the lack of consistency between them. We then identify and name four types of automata that these contributions have really studied over the years: general two-way Boolean finite automata ( 2 b fa s); monotone 2 b fa s; basic 2 b fa s; and (monotone basic, or) alternating 2 b fa s ( 2 a fa s). Next, we identify four different ways by which authors have described how such automata compute, each offering a distinct view onto their operation: the circuit view , where computation is modeled by a circuit of Boolean gates; the formula view , where computation is modeled by a Boolean formula over configuration-variables; the run view , where decisions are determined by the existence of appropriate trees of configuration-goal pairs, called “runs”; and the (most classic) tree view , where computation is modeled by a tree of configurations. After carefully defining each 2 b fa type and each view, we prove the following. First, that within each type, every two of the four views are equivalent to each other, in the strong sense that each of them closely mimics the other at every step of the computation. Second, that not all types of 2 b fa s are equivalent: although general 2 b fa s are as powerful as monotone 2 b fa s, and basic 2 b fa s are as powerful as 2 a fa s (up to polynomial differences in the number of states), general 2 b fa s may need exponentially fewer states than 2 a fa s.},
  archive      = {J_TCS},
  author       = {Christos Kapoutsis and Mohammad Zakzok},
  doi          = {10.1016/j.tcs.2020.12.011},
  journal      = {Theoretical Computer Science},
  pages        = {75-102},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Alternation in two-way finite automata},
  volume       = {870},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Power, positive closure, and quotients on convex languages.
<em>TCS</em>, <em>870</em>, 53–74. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.002">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the state complexity and nondeterministic state complexity of the k -th power, positive closure, right quotient, and left quotient on the classes of prefix-, suffix-, factor-, and subword-free, -closed, and -convex regular languages, and on the classes of right, left, two-sided, and all-sided ideal languages. We show that the nondeterministic state complexity of the k -th power is kn for closed and convex languages, and k ( n − 1 ) + 1 k(n−1)+1 in the remaining classes, while its state complexity is n + ( k − 1 ) 2 n − 2 n+(k−1)2n−2 for right ideals, k ( n − 1 ) + 1 k(n−1)+1 for other ideals and factor- and subword-closed languages, and k ( n − 2 ) + 2 k(n−2)+2 for prefix-, factor-, and subword-free languages. We next prove that the nondeterministic state complexity of positive closure is 1 for factor- and subword-closed languages and n for all other classes, while its state complexity is 2 for factor- and subword-closed languages, 2 n − 2 + 1 2n−2+1 for prefix-closed and suffix-free languages, and n for all other considered classes. We also study left and right quotients by a language from the considered class or by a regular language, and get tight upper bounds in all cases except for state complexity of left quotient of all-sided ideals and subword-closed languages by a regular language, and nondeterministic state complexity of left quotient on subword-convex languages. Assuming that both dividend K and divisor L belong to a given class, the upper bound m on the complexity of the right quotient is tight for free, closed, convex, and right ideal languages, while the complexity of the right quotient of two left ideals is one. The nondeterministic state complexity of the left quotient is m + 1 m+1 for left ideal, prefix-free, prefix-closed, and factor convex languages, it is m for suffix-free and suffix-closed languages and it is one for right ideals. If the divisor is an arbitrary regular language, then the upper bound m on the complexity of right quotient is always tight, and the upper bound m + 1 m+1 on the complexity of left quotient is tight unless the dividend is an all-sided ideal, suffix-free, or subword-closed language. In these cases, the complexity of the left quotient is at most m . In four cases, our witnesses are defined over a growing alphabet. All the remaining witnesses are described over a small fixed alphabet, and whenever the binary alphabet is used, it is optimal.},
  archive      = {J_TCS},
  author       = {Michal Hospodár},
  doi          = {10.1016/j.tcs.2021.02.002},
  journal      = {Theoretical Computer Science},
  pages        = {53-74},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Power, positive closure, and quotients on convex languages},
  volume       = {870},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A general architecture of oritatami systems for simulating
arbitrary finite automata. <em>TCS</em>, <em>870</em>, 29–52. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.014">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we propose an architecture of oritatami systems, a mathematical model of RNA cotranscriptional folding, with which one can simulate an arbitrary nondeterministic finite automaton (NFA) in a unified manner. The oritatami system is known to be Turing-universal but the simulation available so far requires 542 bead types and O ( t 4 log 2 ⁡ t ) O(t4log2⁡t) steps in order to simulate t steps of a Turing machine . The architecture we propose employs only 337 bead types and requires just O ( t | Q | 4 | Σ | 2 ) O(t|Q|4|Σ|2) steps to simulate an NFA with a state set Q working on a word of length t over an alphabet Σ.},
  archive      = {J_TCS},
  author       = {Yo-Sub Han and Hwee Kim and Yusei Masuda and Shinnosuke Seki},
  doi          = {10.1016/j.tcs.2020.12.014},
  journal      = {Theoretical Computer Science},
  pages        = {29-52},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A general architecture of oritatami systems for simulating arbitrary finite automata},
  volume       = {870},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Bottom-up unranked tree-to-graph transducers for translation
into semantic graphs. <em>TCS</em>, <em>870</em>, 3–28. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.012">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We develop a finite-state transducer for translating unranked trees into general graphs. This work is motivated by recent progress in semantic parsing for natural language, where sentences are first mapped into tree-shaped syntactic representations , and then these trees are translated into graph semantic representations . We investigate formal properties of our tree-to-graph transducers and develop a polynomial time algorithm for translating a weighted language of input trees into a packed representation, from which best-score graphs can be efficiently recovered.},
  archive      = {J_TCS},
  author       = {Johanna Björklund and Shay B. Cohen and Frank Drewes and Giorgio Satta},
  doi          = {10.1016/j.tcs.2020.12.012},
  journal      = {Theoretical Computer Science},
  pages        = {3-28},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Bottom-up unranked tree-to-graph transducers for translation into semantic graphs},
  volume       = {870},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Special issue on implementation and application of automata.
<em>TCS</em>, <em>870</em>, 1–2. (<a
href="https://doi.org/10.1016/j.tcs.2021.05.001">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_TCS},
  author       = {Galina Jirásková ( Special Issue Guest Editor ) and Cezar Câmpeanu (Special Issue Guest Editor)},
  doi          = {10.1016/j.tcs.2021.05.001},
  journal      = {Theoretical Computer Science},
  pages        = {1-2},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Special issue on implementation and application of automata},
  volume       = {870},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Model independent approach to probabilistic models.
<em>TCS</em>, <em>869</em>, 181–194. (<a
href="https://doi.org/10.1016/j.tcs.2021.04.001">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {There is a lot of research on probabilistic transition systems. There are not many studies in probabilistic process models. The lack of investigation into the interactive aspect of probabilistic processes is mainly due to the difficulty caused by the discrepancy between probabilistic choices and nondeterministic actions. The paper proposes a uniform approach to probabilistic process models and a bisimulation theory for probabilistic concurrency.},
  archive      = {J_TCS},
  author       = {Yuxi Fu},
  doi          = {10.1016/j.tcs.2021.04.001},
  journal      = {Theoretical Computer Science},
  pages        = {181-194},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Model independent approach to probabilistic models},
  volume       = {869},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Optimal majority dynamics for the diffusion of an opinion
when multiple alternatives are available. <em>TCS</em>, <em>869</em>,
156–180. (<a href="https://doi.org/10.1016/j.tcs.2021.03.017">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider opinion diffusion on social graphs where agents hold opinions and where social pressure leads them to conform to the opinion manifested by the majority of their neighbors. Within this setting, we look for dynamics that allows us to maximize the diffusion of a target opinion given the initial opinions of all agents. In particular, we focus on the setting where more than two opinions are available to the agents, and we show that the properties of this setting are entirely different from those characterizing the setting where agents hold binary opinions only. Indeed, while it is well-known that greedy dynamics are always optimal ones in the binary case, this is no longer true in our more general setting and—rather surprisingly—even if just three opinions are available. Moreover, while it is possible to decide in polynomial time if a dynamics leading to consensus exists when agents have two available opinions, the problem becomes computationally intractable with three opinions, regardless of the fraction of agents that have the target opinion as their initial opinion.},
  archive      = {J_TCS},
  author       = {Vincenzo Auletta and Diodato Ferraioli and Gianluigi Greco},
  doi          = {10.1016/j.tcs.2021.03.017},
  journal      = {Theoretical Computer Science},
  pages        = {156-180},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Optimal majority dynamics for the diffusion of an opinion when multiple alternatives are available},
  volume       = {869},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Introducing ⦇ λ ⦈, a λ-calculus for effectful computation.
<em>TCS</em>, <em>869</em>, 108–155. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.038">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present ⦇ ⦈ ⦇ λ ⦈ ⦇λ⦈ , a calculus with special constructions for dealing with effects and handlers. This is an extension of the simply-typed λ -calculus (STLC). We enrich STLC with a type for representing effectful computations alongside with operations to create and process values of this type. The calculus is motivated by natural language modelling , and especially semantic representation . Traditionally, the meaning of a sentence is calculated using λ -terms, but some semantic phenomena need more flexibility. In this article we introduce the calculus and show that the calculus respects the laws of algebraic structures and it enjoys strong normalisation. To do so, confluence is proven using the Combinatory Reduction Systems (CRSs) of Klop and termination using the Inductive Data Type Systems (IDTSs) of Blanqui.},
  archive      = {J_TCS},
  author       = {Jirka Maršík and Maxime Amblard and Philippe de Groote},
  doi          = {10.1016/j.tcs.2021.02.038},
  journal      = {Theoretical Computer Science},
  pages        = {108-155},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Introducing ⦇ λ ⦈, a λ-calculus for effectful computation},
  volume       = {869},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Distance domains: continuity. <em>TCS</em>, <em>869</em>,
85–107. (<a href="https://doi.org/10.1016/j.tcs.2021.01.038">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We take the abstract basis approach to classical domain theory and extend it to quantitative domains. In doing so, we provide dual characterisations of distance domains (some new even in the classical case) as well as unifying and extending previous formal ball dualities, namely the Kostanek-Waszkiewicz and Romaguero-Valero theorems. In passing, we also show that hemimetric spaces admit a hemimetric Smyth completion precisely when they are Noetherian in a natural quantitative sense.},
  archive      = {J_TCS},
  author       = {Tristan Bice},
  doi          = {10.1016/j.tcs.2021.01.038},
  journal      = {Theoretical Computer Science},
  pages        = {85-107},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Distance domains: Continuity},
  volume       = {869},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Calculational design of a regular model checker by abstract
interpretation. <em>TCS</em>, <em>869</em>, 62–84. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.037">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Security monitors have been used to check for safety program properties at runtime, that is for any given execution trace. Such security monitors check a safety temporal property specified by a finite automaton or, equivalently, a regular expression. Checking this safety temporal specification for all possible execution traces, that is the program semantics, is a static analysis problem, more precisely a model checking problem, since model checking specializes in temporal properties. We show that the model checker can be formally designed by calculus, by abstract interpretation of a formal trace semantics of the programming language . The result is a structural sound and complete model checker , which proceeds by induction on the program syntax (as opposed to the more classical approach using computation steps formalized by a transition system). By Rice theorem, further hypotheses or abstractions are needed to get a realistic model checking algorithm .},
  archive      = {J_TCS},
  author       = {Patrick Cousot},
  doi          = {10.1016/j.tcs.2021.01.037},
  journal      = {Theoretical Computer Science},
  pages        = {62-84},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Calculational design of a regular model checker by abstract interpretation},
  volume       = {869},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A weak semantic approach to bisimulation metrics in models
with nondeterminism and continuous state spaces. <em>TCS</em>,
<em>869</em>, 29–61. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.045">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Bisimulation metrics are a successful instrument used to estimate the behavioural distance between probabilistic concurrent systems . They have been defined in both discrete and continuous state space models. However, the weak semantics approach , where non-observable actions are abstracted away, has been adopted only in the discrete case. In this paper we fill this gap and provide a weak bisimulation metric for models with continuous state spaces . A technical difficulty is to provide a suitable notion of weak transition , which requires to lift transitions leaving from states to transitions leaving from a continuous distribution over states. We prove that our weak bisimulation metric is non-expansive , thus allowing for compositional reasoning. We prove that systems at distance zero are equated by a suitable notion of probabilistic weak bisimulation . We apply our theory in a case study where continuous distributions derive from the evolution of the physical environment.},
  archive      = {J_TCS},
  author       = {Ruggero Lanotte and Simone Tini},
  doi          = {10.1016/j.tcs.2020.12.045},
  journal      = {Theoretical Computer Science},
  pages        = {29-61},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A weak semantic approach to bisimulation metrics in models with nondeterminism and continuous state spaces},
  volume       = {869},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Generalised information systems capture l-domains.
<em>TCS</em>, <em>869</em>, 1–28. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.044">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A generalisation of Scott&#39;s information systems [15] is presented that captures exactly all L-domains. The global consistency predicate in Scott&#39;s definition is relativised in such a way that there is a consistency predicate for each atomic proposition (token) saying which finite sets of such statements express information that is consistent with the given statement. It is shown that the states of such generalised information systems form an L-domain, and that each L-domain can be generated in this way, up to isomorphism. Moreover, the equivalence of the category of generalised information systems with the category of L-domains is derived. In addition, it will be seen that from every generalised information system capturing an algebraic bounded-complete domain a corresponding Scott information system can be obtained in an easy and natural way, and vice versa; similarly for Hoofman&#39;s continuous information systems [9] and the continuous bounded-complete domains captured by them; for Chen and Jung&#39;s disjunctive propositional logic [4] and algebraic L-domains (as well as for Wang and Li&#39;s [21] finitary version and Lawson-compact algebraic L-domains); and for Wang and Li&#39;s conjunctive sequent calculi [20] and proper continuous bounded-complete domains. The proofs always contain syntactic translations between the logical calculi involved.},
  archive      = {J_TCS},
  author       = {Dieter Spreen},
  doi          = {10.1016/j.tcs.2020.12.044},
  journal      = {Theoretical Computer Science},
  pages        = {1-28},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Generalised information systems capture L-domains},
  volume       = {869},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). New sufficient conditions on the degree sequences of uniform
hypergraphs. <em>TCS</em>, <em>868</em>, 97–111. (<a
href="https://doi.org/10.1016/j.tcs.2021.04.006">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The study of the degree sequences of k -uniform hypergraphs , usually called k -sequences, has been a longstanding open problem for the case of k &gt; 2 k&amp;gt;2 , and the corresponding decision version was proved to be NP -complete recently in 2018 [15] . The problem can be formalized as follows: Given a non decreasing sequence of positive integers π = ( d 1 , d 2 , … , d n ) π=(d1,d2,…,dn) , can π be the degree sequence of a k -uniform simple hypergraph? If the answer is positive, then the sequence π is said to be k -graphic. For k = 2 k=2 , that is for simple graphs, Erdös and Gallai [16] provided a characterization of the sequences that are 2-graphic (or simply, graphic). From this characterization, a polynomial time algorithm can be designed to reconstruct the incidence matrix of a graph having a given π as degree sequence (provided this graph exists). Due to the result of [15] and assuming P ≠ N P P≠NP , an efficiently computable characterization like the one for k = 2 k=2 does not even exist for the case of 3-uniform hypergraphs . Necessary or sufficient conditions for π to be k -graphic ( k ≥ 3 k≥3 ) can be found in the literature. In this paper we prove some different new conditions: first we provide sufficient and also necessary conditions for the case of k -uniform and (almost) regular hypergraphs. Then, for k = 3 k=3 , we prove sufficient conditions in the case where π can be decomposed into π ′ π′ and π ″ π″ , and π ′ π′ is graphic. Most of the results are obtained by borrowing tools from discrete tomography, a current research field on discrete mathematics .},
  archive      = {J_TCS},
  author       = {Andrea Frosini and Christophe Picouleau and Simone Rinaldi},
  doi          = {10.1016/j.tcs.2021.04.006},
  journal      = {Theoretical Computer Science},
  pages        = {97-111},
  shortjournal = {Theor. Comput. Sci.},
  title        = {New sufficient conditions on the degree sequences of uniform hypergraphs},
  volume       = {868},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Collaborative delivery on a fixed path with homogeneous
energy-constrained agents. <em>TCS</em>, <em>868</em>, 87–96. (<a
href="https://doi.org/10.1016/j.tcs.2021.04.004">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider the problem of collectively delivering a package from a specified source to a designated target location in a graph, using multiple mobile agents . Each agent starts from some vertex of the graph; it can move along the edges of the graph and can pick up the package from a vertex and drop it in another vertex during the course of its movement. However, each agent has limited energy budget allowing it to traverse a path of bounded length B ; thus, multiple agents need to collaborate to move the package to its destination. Given the positions of the agents in the graph and their energy budgets, the problem of finding a feasible movement schedule is called the Collaborative Delivery problem and has been studied before. One of the open questions from previous results is what happens when the delivery must follow a fixed path given in advance. Although this special constraint reduces the search space for feasible solutions, the problem remains NP hard, as the general version of the problem. We consider the optimization version of the problem that asks for the optimal energy budget B per agent which allows for a feasible delivery schedule along a fixed path, given the initial positions of the agents. We provide polynomial time approximation algorithms for both directed and undirected graphs, and establish hardness of approximation for the directed case. Note that the fixed path version of collaborative delivery requires completely different techniques since a single agent may be used multiple times, unlike the general version of collaborative delivery studied before. We show that restricting each agent to a single pickup allows better approximations for fixed path collaborative delivery compared to the original problem. Finally, we provide a polynomial time algorithm for determining a feasible delivery strategy, if any exists, for a given budget B when the number of available agents is bounded by a constant.},
  archive      = {J_TCS},
  author       = {Jérémie Chalopin and Shantanu Das and Yann Disser and Arnaud Labourel and Matúš Mihalák},
  doi          = {10.1016/j.tcs.2021.04.004},
  journal      = {Theoretical Computer Science},
  pages        = {87-96},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Collaborative delivery on a fixed path with homogeneous energy-constrained agents},
  volume       = {868},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). An improved lower bound for competitive graph exploration.
<em>TCS</em>, <em>868</em>, 65–86. (<a
href="https://doi.org/10.1016/j.tcs.2021.04.003">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We give an improved lower bound of 10/3 on the competitive ratio for the exploration of an undirected, edge-weighted graph with a single agent that needs to return to the starting location after visiting all vertices. We assume that the agent has full knowledge of all edges incident to visited vertices, and, in particular, vertices have unique identifiers. Our bound improves a lower bound of 2.5 by Dobrev et al. [10] and also holds for planar graphs , where it complements an upper bound of 16 by Megow et al. [20] . The question whether a constant competitive ratio can be achieved in general remains open.},
  archive      = {J_TCS},
  author       = {Alexander Birx and Yann Disser and Alexander V. Hopp and Christina Karousatou},
  doi          = {10.1016/j.tcs.2021.04.003},
  journal      = {Theoretical Computer Science},
  pages        = {65-86},
  shortjournal = {Theor. Comput. Sci.},
  title        = {An improved lower bound for competitive graph exploration},
  volume       = {868},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Multistage graph problems on a global budget. <em>TCS</em>,
<em>868</em>, 46–64. (<a
href="https://doi.org/10.1016/j.tcs.2021.04.002">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Time-evolving or temporal graphs gain more and more popularity when exploring complex networks. In this context, the multistage view on computational problems is among the most natural frameworks. Roughly speaking, herein one studies the different (time) layers of a temporal graph (effectively meaning that the edge set may change over time, but the vertex set remains unchanged), and one searches for a solution of a given graph problem for each layer. The twist in the multistage setting is that the solutions found must not differ too much between subsequent layers. We relax on this already established notion by introducing a global instead of the local budget view studied so far. More specifically, we allow for few disruptive changes between subsequent layers but request that overall, that is, summing over all layers, the degree of change is moderate. Studying several classical graph problems (both NP-hard and polynomial-time solvable ones) from a parameterized complexity angle, we encounter both fixed-parameter tractability and parameterized hardness results. Surprisingly, we find that sometimes the global multistage versions of NP-hard problems such as Vertex Cover turn out to be computationally more tractable than the ones of polynomial-time solvable problems such as Matching . In addition to time complexity, we also analyze the space efficiency of our algorithms.},
  archive      = {J_TCS},
  author       = {Klaus Heeger and Anne-Sophie Himmel and Frank Kammer and Rolf Niedermeier and Malte Renken and Andrej Sajenko},
  doi          = {10.1016/j.tcs.2021.04.002},
  journal      = {Theoretical Computer Science},
  pages        = {46-64},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Multistage graph problems on a global budget},
  volume       = {868},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Algorithms for gerrymandering over graphs. <em>TCS</em>,
<em>868</em>, 30–45. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.037">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We initiate the systematic algorithmic study for gerrymandering over graphs that was recently introduced by Cohen-Zemach, Lewenberg and Rosenschein. Namely, we study a strategic procedure for a political districting designer to draw electoral district boundaries so that a particular target candidate can win in an election. We focus on the existence of such a strategy under the plurality voting rule, and give interesting contrasts which classify easy and hard instances with respect to polynomial-time solvability. For example, we prove that the problem for trees is strongly NP -complete (thus unlikely to have a pseudo-polynomial-time algorithm), but has a pseudo-polynomial-time algorithm when the number of candidates is constant. Another example is to prove that the problem for complete graphs is NP -complete when the number of electoral districts is two, while is solvable in polynomial time when it is more than two.},
  archive      = {J_TCS},
  author       = {Takehiro Ito and Naoyuki Kamiyama and Yusuke Kobayashi and Yoshio Okamoto},
  doi          = {10.1016/j.tcs.2021.03.037},
  journal      = {Theoretical Computer Science},
  pages        = {30-45},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Algorithms for gerrymandering over graphs},
  volume       = {868},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Profit maximization for competitive social advertising.
<em>TCS</em>, <em>868</em>, 12–29. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.036">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In social advertising, the social platform host may run marketing campaigns for multiple competing clients simultaneously. In this case, each client comes up with a budget and an influence spread requirement. The host runs campaigns by allocating a set of seed nodes for each client. If the influence spread triggered by a seed set meets the requirement, the host can earn the budget from the corresponding client. In this paper, we study the problem of Profit Maximization, considering that different seeds incur different costs. Given all the clients&#39; requirements met, we aim to find the optimal seed allocation with minimum cost. Under the competitive K-LT propagation model , we show the Profit Maximization problem is NP-hard and NP-hard to approximate with any factor. To find a feasible solution, we propose an effective algorithm that iteratively selects a candidate set and obtains an approximate allocation. The experimental results over a real-world dataset validate the effectiveness of the proposed methods.},
  archive      = {J_TCS},
  author       = {Qihao Shi and Can Wang and Deshi Ye and Jiawei Chen and Sheng Zhou and Yan Feng and Chun Chen and Yanhao Huang},
  doi          = {10.1016/j.tcs.2021.03.036},
  journal      = {Theoretical Computer Science},
  pages        = {12-29},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Profit maximization for competitive social advertising},
  volume       = {868},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A (2 + ϵ)k-vertex kernel for the dual coloring problem.
<em>TCS</em>, <em>868</em>, 6–11. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.035">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Given a graph G of n vertices and an integer k , the Dual Coloring problem determines if G is ( n − k ) (n−k) -colorable, i.e., if we can color vertices of G with at most n − k n−k colors so that every vertex obtains exactly one color and every two adjacent vertices have different colors. We derive a kernelization for the Dual Coloring problem with respect to the parameter k . In particular, for any fixed ϵ &gt; 0 ϵ&amp;gt;0 , our kernelization yields a kernel of at most ( 2 + ϵ ) k (2+ϵ)k vertices, improving the currently best result 3 k − 3 3k−3 .},
  archive      = {J_TCS},
  author       = {Wenjun Li and Yang Ding and Yongjie Yang and Guozhen Rong},
  doi          = {10.1016/j.tcs.2021.03.035},
  journal      = {Theoretical Computer Science},
  pages        = {6-11},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A (2 + ϵ)k-vertex kernel for the dual coloring problem},
  volume       = {868},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Comparing consecutive letter counts in multiple context-free
languages. <em>TCS</em>, <em>868</em>, 1–5. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.034">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Context-free grammars are not able to capture cross-serial dependencies occurring in some natural languages. To overcome this issue, Seki et al. introduced a generalization called m -multiple context-free grammars ( m -MCFGs), which deal with m -tuples of strings. We show that m -MCFGs are capable of comparing the number of consecutive occurrences of at most 2 m different letters. In particular, the language { a 1 n 1 a 2 n 2 ⋯ a 2 m + 1 n 2 m + 1 | n 1 ≥ n 2 ≥ … ≥ n 2 m + 1 ≥ 0 } {a1n1a2n2⋯a2m+1n2m+1|n1≥n2≥…≥n2m+1≥0} is ( m + 1 ) (m+1) -multiple context-free, but not m -multiple context-free.},
  archive      = {J_TCS},
  author       = {Florian Lehner and Christian Lindorfer},
  doi          = {10.1016/j.tcs.2021.03.034},
  journal      = {Theoretical Computer Science},
  pages        = {1-5},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Comparing consecutive letter counts in multiple context-free languages},
  volume       = {868},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On sturmian substitutions closed under derivation.
<em>TCS</em>, <em>867</em>, 128–139. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.033">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Occurrences of a factor w in an infinite uniformly recurrent sequence u can be encoded by an infinite sequence over a finite alphabet. This sequence is usually denoted d u ( w ) du(w) and called the derived sequence to w in u . If w is a prefix of a fixed point u of a primitive substitution φ , then by Durand&#39;s result from 1998, the derived sequence d u ( w ) du(w) is fixed by a primitive substitution ψ as well. For a non-prefix factor w , the derived sequence d u ( w ) du(w) is fixed by a substitution only exceptionally. To study this phenomenon we introduce a new notion: A finite set M of substitutions is said to be closed under derivation if the derived sequence d u ( w ) du(w) to any factor w of any fixed point u of φ ∈ M φ∈M is fixed by a morphism ψ ∈ M ψ∈M . In our article we characterize the Sturmian substitutions which belong to a set M closed under derivation. The characterization uses either the slope and the intercept of its fixed point or its S-adic representation.},
  archive      = {J_TCS},
  author       = {Edita Pelantová and Štěpán Starosta},
  doi          = {10.1016/j.tcs.2021.03.033},
  journal      = {Theoretical Computer Science},
  pages        = {128-139},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On sturmian substitutions closed under derivation},
  volume       = {867},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Rational elements of summation semirings. <em>TCS</em>,
<em>867</em>, 101–127. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.032">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The theory of finite automata and rational semiring elements is reconsidered in the setting of summation semirings, traditionally known as Σ-semirings. These generalise complete semirings by allowing infinite sums to be defined just for selected families of elements. A relation of the presented approach to the theory of finite automata over partial Conway semirings is discussed. Equivalence of finite automata over summation semirings to rational expressions and right-linear systems is proved under suitable semantics. Moreover, MSO logics over summation semirings are introduced and proved to be equivalent to finite automata.},
  archive      = {J_TCS},
  author       = {Peter Kostolányi},
  doi          = {10.1016/j.tcs.2021.03.032},
  journal      = {Theoretical Computer Science},
  pages        = {101-127},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Rational elements of summation semirings},
  volume       = {867},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Fan-crossing free graphs and their relationship to other
beyond-planar graphs. <em>TCS</em>, <em>867</em>, 85–100. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.031">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A graph is fan-crossing free if it has a drawing in the plane so that each edge is crossed by independent edges, that is the crossing edges have distinct vertices. On the other hand, it is fan-crossing if the crossing edges have a common vertex, so that they form a fan. Both are prominent examples for beyond-planar graphs. Further well-known beyond-planar classes are the k -planar, k -gap-planar, quasi-planar, and right angle crossing graphs. We use the subdivision, node-to-circle expansion and path-addition operations to distinguish all these graph classes. In particular, we show that the 2-subdivision and the node-to-circle expansion of any graph is fan-crossing free, which does not hold for fan-crossing and k -(gap)-planar graphs, respectively. Thereby, we obtain graphs that are fan-crossing free and neither fan-crossing nor k -(gap)-planar. Finally, we show that some graphs have a unique fan-crossing free embedding, that there are thinned maximal fan-crossing free graphs , and that the recognition problem for fan-crossing free graphs is NP-complete.},
  archive      = {J_TCS},
  author       = {Franz J. Brandenburg},
  doi          = {10.1016/j.tcs.2021.03.031},
  journal      = {Theoretical Computer Science},
  pages        = {85-100},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Fan-crossing free graphs and their relationship to other beyond-planar graphs},
  volume       = {867},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Helly-gap of a graph and vertex eccentricities.
<em>TCS</em>, <em>867</em>, 68–84. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.022">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A new metric parameter for a graph, Helly-gap, is introduced. A graph G is called α -weakly-Helly if any system of pairwise intersecting disks in G has a nonempty common intersection when the radius of each disk is increased by an additive value α . The minimum α for which a graph G is α -weakly-Helly is called the Helly-gap of G and denoted by α(G) . The Helly-gap of a graph G is characterized by distances in the injective hull H(G) , which is a (unique) minimal Helly graph which contains G as an isometric subgraph. This characterization is used as a tool to generalize many eccentricity related results known for Helly graphs ( α(G)=0 ), as well as for chordal graphs ( α(G)≤1 ), distance-hereditary graphs ( α(G)≤1 ) and δ -hyperbolic graphs ( α(G)≤2δ ), to all graphs, parameterized by their Helly-gap α(G) . Several additional graph classes are shown to have a bounded Helly-gap, including AT-free graphs and graphs with bounded tree-length, bounded chordality or bounded αi -metric.},
  archive      = {J_TCS},
  author       = {Feodor F. Dragan and Heather M. Guarnera},
  doi          = {10.1016/j.tcs.2021.03.022},
  journal      = {Theoretical Computer Science},
  pages        = {68-84},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Helly-gap of a graph and vertex eccentricities},
  volume       = {867},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Query-competitive sorting with uncertainty. <em>TCS</em>,
<em>867</em>, 50–67. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.021">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the problem of sorting under incomplete information, when queries are used to resolve uncertainties. Each of n data items has an unknown value, which is known to lie in a given interval. We can pay a query cost to learn the actual value, and we may allow an error threshold in the sorting. The goal is to find a nearly-sorted permutation by performing a minimum-cost set of queries. We show that an offline optimum query set can be found in polynomial time , and that both oblivious and adaptive problems have simple query-competitive algorithms. The query-competitiveness for the oblivious problem is n for uniform query costs, and unbounded for arbitrary costs; for the adaptive problem, the ratio is 2. We then present a unified adaptive strategy for uniform query costs that yields the following improved results: (i) a 3/2-query-competitive randomized algorithm ; (ii) a 5/3-query-competitive deterministic algorithm if the dependency graph has no 2-components after some preprocessing, which has query-competitive ratio 3 / 2 + O ( 1 / k ) 3/2+O(1/k) if the components obtained have size at least k ; and (iii) an exact algorithm if the intervals constitute a laminar family. The first two results have matching lower bounds, and we have a lower bound of 7/5 for large components. We also give a randomized adaptive algorithm with query-competitive factor 1 + 4 3 3 ≈ 1.7698 1+433≈1.7698 for arbitrary query costs, and we show that the 2-query competitive deterministic adaptive algorithm can be generalized for queries returning intervals and for a more general graph problem (which is also a generalization of the vertex cover problem), by using the local ratio technique. Furthermore, we prove that the advice complexity of the adaptive problem is ⌊ n / 2 ⌋ ⌊n/2⌋ if no error threshold is allowed, and ⌈ n / 3 ⋅ lg ⁡ 3 ⌉ ⌈n/3⋅lg⁡3⌉ for the general case. Finally, we present some graph-theoretical results regarding co-threshold tolerance graphs, and we discuss uncertainty variants of some classical interval problems.},
  archive      = {J_TCS},
  author       = {Magnús M. Halldórsson and Murilo Santos de Lima},
  doi          = {10.1016/j.tcs.2021.03.021},
  journal      = {Theoretical Computer Science},
  pages        = {50-67},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Query-competitive sorting with uncertainty},
  volume       = {867},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Fitting a graph to one-dimensional data. <em>TCS</em>,
<em>867</em>, 40–49. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.020">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Given n data points in R d Rd , an appropriate edge-weighted graph connecting the data points finds application in solving clustering, classification, and regression problems . The graph proposed by Daitch, Kelner and Spielman (ICML 2009) can be computed by quadratic programming and hence in polynomial time . While a more efficient algorithm would be preferable, replacing quadratic programming is challenging even for the special case of points in one dimension . We develop a dynamic programming algorithm for this case that runs in O ( n 2 ) O(n2) time under the Real-RAM model, where arithmetic on real numbers takes constant time.},
  archive      = {J_TCS},
  author       = {Siu-Wing Cheng and Otfried Cheong and Taegyoung Lee and Zhengtong Ren},
  doi          = {10.1016/j.tcs.2021.03.020},
  journal      = {Theoretical Computer Science},
  pages        = {40-49},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Fitting a graph to one-dimensional data},
  volume       = {867},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Steiner trees for hereditary graph classes: A treewidth
perspective. <em>TCS</em>, <em>867</em>, 30–39. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.012">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider the classical problems (Edge) Steiner Tree and Vertex Steiner Tree after restricting the input to some class of graphs characterized by a small set of forbidden induced subgraphs . We show a dichotomy for the former problem restricted to ( H 1 , H 2 ) (H1,H2) -free graphs and a dichotomy for the latter problem restricted to H -free graphs. We find that there exists an infinite family of graphs H such that Vertex Steiner Tree is polynomial-time solvable for H -free graphs, whereas there exist only two graphs H for which this holds for Edge Steiner Tree (assuming P ≠ NP P≠NP ). We also find that Edge Steiner Tree is polynomial-time solvable for ( H 1 , H 2 ) (H1,H2) -free graphs if and only if the treewidth of the class of ( H 1 , H 2 ) (H1,H2) -free graphs is bounded (subject to P ≠ NP P≠NP ). To obtain the latter result, we determine all pairs ( H 1 , H 2 ) (H1,H2) for which the class of ( H 1 , H 2 ) (H1,H2) -free graphs has bounded treewidth.},
  archive      = {J_TCS},
  author       = {Hans L. Bodlaender and Nick Brettell and Matthew Johnson and Giacomo Paesani and Daniël Paulusma and Erik Jan van Leeuwen},
  doi          = {10.1016/j.tcs.2021.03.012},
  journal      = {Theoretical Computer Science},
  pages        = {30-39},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Steiner trees for hereditary graph classes: A treewidth perspective},
  volume       = {867},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Two-machine open shop problem with a single server and
set-up time considerations. <em>TCS</em>, <em>867</em>, 13–29. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.009">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We address in this paper the two-machine open shop problem with set-up time considerations to build schedules that minimize the overall completion time, known as the makespan. In the model we are considering, the set-up, handled by a single server, consists of a preparation phase separated from the processing phase. Once the server completes the preparation of a job, it becomes again available for setting up other jobs, leaving the current one to complete its processing. We prove several NP NP -completeness results, exhibit a linear time algorithm for a special case, and develop heuristic and hyper-heuristic algorithms to solve the general problem along with an experimental study.},
  archive      = {J_TCS},
  author       = {Nadia Babou and Djamal Rebaine and Mourad Boudhar},
  doi          = {10.1016/j.tcs.2021.03.009},
  journal      = {Theoretical Computer Science},
  pages        = {13-29},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Two-machine open shop problem with a single server and set-up time considerations},
  volume       = {867},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Parameterized complexity of fair feedback vertex set
problem. <em>TCS</em>, <em>867</em>, 1–12. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.008">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Given a graph G = ( V , E ) G=(V,E) , a subset S ⊆ V ( G ) S⊆V(G) is said to be a feedback vertex set of G if G − S G−S is a forest. In the Feedback Vertex Set (FVS) problem, we are given an undirected graph G , and a positive integer k , the question is whether there exists a feedback vertex set of size at most k . In this paper, we study three variants of the FVS problem: Unrestricted Fair FVS , Restricted Fair FVS , and Relaxed Fair FVS . In Unrestricted Fair FVS , we are given a graph G and a positive integer ℓ , the question is does there exist a feedback vertex set S ⊆ V ( G ) S⊆V(G) (of any size) such that for every vertex v ∈ V ( G ) v∈V(G) , v has at most ℓ neighbours in S . First, we study Unrestricted Fair FVS from different parameterizations such as treewidth, treedepth, and neighbourhood diversity and obtain several results (both tractability and intractability). Next, we study Restricted Fair FVS , where we are also given an integer k in the input and we demand the size of S to be at most k . This problem is trivially NP-complete; we show that Restricted Fair FVS when parameterized by the solution size k and the maximum degree Δ of the graph G , admits a kernel of size O ( Δ k ) O(Δk) . Finally, we study the Relaxed Fair FVS problem, where we want that the size of S is at most k and for every vertex v outside S , v has at most ℓ neighbours in S . We give an FPT algorithm for Relaxed Fair FVS problem running in time c k n O ( 1 ) cknO(1) , for a fixed constant c .},
  archive      = {J_TCS},
  author       = {Lawqueen Kanesh and Soumen Maity and Komal Muluk and Saket Saurabh},
  doi          = {10.1016/j.tcs.2021.03.008},
  journal      = {Theoretical Computer Science},
  pages        = {1-12},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Parameterized complexity of fair feedback vertex set problem},
  volume       = {867},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Minimizing energy on homogeneous processors with shared
memory. <em>TCS</em>, <em>866</em>, 160–170. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.030">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Energy efficiency is a crucial desideratum in the design of computer systems, from small-sized mobile devices with limited battery to large scale data centers. In such computing systems, processors and memory are considered as two major power consumers among all the system components. One recent trend to reduce power consumption is using shared memory in multi-core systems, such architecture has become ubiquitous nowadays. However, implementing the energy-efficient methods to the multi-core processor and the shared memory separately is not trivial. In this work, we consider the energy-efficient task scheduling problem, which coordinates the power consumption of both the multi-core processor and the shared memory, especially focus on the general situation in which the number of tasks is more than the number of cores. We devise an approximation algorithm with guaranteed performance in the multiple cores system. We tackle the problem by first presenting an optimal algorithm when the assignment of tasks to cores is given. Then we propose an approximation assignment for the general task scheduling.},
  archive      = {J_TCS},
  author       = {Vincent Chau and Chi Kit Ken Fong and Shengxin Liu and Elaine Yinling Wang and Yong Zhang},
  doi          = {10.1016/j.tcs.2021.03.030},
  journal      = {Theoretical Computer Science},
  pages        = {160-170},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Minimizing energy on homogeneous processors with shared memory},
  volume       = {866},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Topological stability of kinetic k-centers. <em>TCS</em>,
<em>866</em>, 145–159. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.026">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the k -center problem in a kinetic setting: given a set of continuously moving points P in the plane, determine a set of k (moving) disks that cover P at every time step, such that the disks are as small as possible at any point in time. Whereas the optimal solution over time may exhibit discontinuous changes, many practical applications require the solution to be stable : the disks must move smoothly over time. Existing results on this problem require the disks to move with a bounded speed, but this model allows positive results only for k k&amp;lt;3 . Hence, the results are limited and offer little theoretical insight. Instead, we study the topological stability of k -centers. Topological stability was recently introduced and simply requires the solution to change continuously, but may do so arbitrarily fast. We prove upper and lower bounds on the ratio between the radii of an optimal but unstable solution and the radii of a topologically stable solution—the topological stability ratio—considering various metrics and various optimization criteria . For k = 2 k=2 we provide tight bounds, and for small k &gt; 2 k&amp;gt;2 we can obtain nontrivial lower and upper bounds. Finally, we provide an algorithm to compute the topological stability ratio in polynomial time for constant k .},
  archive      = {J_TCS},
  author       = {Ivor van der Hoog and Marc van Kreveld and Wouter Meulemans and Kevin Verbeek and Jules Wulms},
  doi          = {10.1016/j.tcs.2021.03.026},
  journal      = {Theoretical Computer Science},
  pages        = {145-159},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Topological stability of kinetic k-centers},
  volume       = {866},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Complexity and approximability of the happy set problem.
<em>TCS</em>, <em>866</em>, 123–144. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.023">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper we study the approximability of the Maximum Happy Set problem ( MaxHS ) and the computational complexity of MaxHS on graph classes: For an undirected graph G = ( V , E ) G=(V,E) and a subset S ⊆ V S⊆V of vertices, a vertex v is happy if v and all its neighbors are in S ; otherwise unhappy . Given an undirected graph G = ( V , E ) G=(V,E) and an integer k , the goal of MaxHS is to find a subset S ⊆ V S⊆V of k vertices such that the number of happy vertices is maximized. MaxHS is known to be NP-hard. In this paper, we design a ( 2 Δ + 1 ) (2Δ+1) -approximation algorithm for MaxHS on graphs with maximum degree Δ. Next, we show that the approximation ratio can be improved to Δ if the maximum degree Δ of the input graph is a constant. Then, we show that MaxHS can be solved in polynomial time if the input graph is restricted to block graphs, or interval graphs . We prove nevertheless that MaxHS on bipartite graphs or on cubic graphs remains NP-hard.},
  archive      = {J_TCS},
  author       = {Yuichi Asahiro and Hiroshi Eto and Tesshu Hanaka and Guohui Lin and Eiji Miyano and Ippei Terabaru},
  doi          = {10.1016/j.tcs.2021.03.023},
  journal      = {Theoretical Computer Science},
  pages        = {123-144},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Complexity and approximability of the happy set problem},
  volume       = {866},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Probabilistic analysis of optimization problems on
generalized random shortest path metrics. <em>TCS</em>, <em>866</em>,
107–122. (<a href="https://doi.org/10.1016/j.tcs.2021.03.016">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Simple heuristics often show a remarkable performance in practice for optimization problems . Worst-case analysis often falls short of explaining this performance. Because of this, “beyond worst-case analysis” of algorithms has recently gained a lot of attention, including probabilistic analysis of algorithms. The instances of many optimization problems are essentially a discrete metric space. Probabilistic analysis for such metric optimization problems has nevertheless mostly been conducted on instances drawn from Euclidean space , which provides a structure that is usually heavily exploited in the analysis. However, most instances from practice are not Euclidean. Little work has been done on metric instances drawn from other, more realistic, distributions. Some initial results have been obtained by Bringmann et al. ( Algorithmica , 2013), who have used random shortest path metrics constructed using complete graphs to analyze heuristics. The goal of this paper is to generalize these findings to non-complete graphs, especially Erdős–Rényi random graphs. A random shortest path metric is constructed by drawing independent random edge weights for each edge in the graph and setting the distance between every pair of vertices to the length of a shortest path between them with respect to the drawn weights. For such instances, we prove that the greedy heuristic for the minimum distance maximum matching problem , the nearest neighbor and insertion heuristics for the traveling salesman problem , and a trivial heuristic for the k -median problem all achieve a constant expected approximation ratio. Additionally, we show a polynomial upper bound for the expected number of iterations of the 2-opt heuristic for the traveling salesman problem .},
  archive      = {J_TCS},
  author       = {Stefan Klootwijk and Bodo Manthey and Sander K. Visser},
  doi          = {10.1016/j.tcs.2021.03.016},
  journal      = {Theoretical Computer Science},
  pages        = {107-122},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Probabilistic analysis of optimization problems on generalized random shortest path metrics},
  volume       = {866},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A linear time algorithm for the r-gathering problem on the
line. <em>TCS</em>, <em>866</em>, 96–106. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.015">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we revisit the r -gathering problem. Given sets C and F of points on the plane and distance d ( c , f ) d(c,f) for each c ∈ C c∈C and f ∈ F f∈F , an r -gathering of C to F is an assignment A of C to open facilities F ′ ⊆ F F′⊆F such that r or more members of C are assigned to each open facility. The cost of an r -gathering is max c ∈ C ⁡ d ( c , A ( c ) ) maxc∈C⁡d(c,A(c)) . The r -gathering problem computes the r -gathering minimizing the cost. In this paper we study the r -gathering problem when C and F are on a line and present a O ( | C | + | F | ) O(|C|+|F|) -time algorithm to solve the problem. Our solution is optimal since any algorithm needs to read C and F at least once.},
  archive      = {J_TCS},
  author       = {Anik Sarker and Wing-Kin Sung and M. Sohel Rahman},
  doi          = {10.1016/j.tcs.2021.03.015},
  journal      = {Theoretical Computer Science},
  pages        = {96-106},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A linear time algorithm for the r-gathering problem on the line},
  volume       = {866},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Matching sets of line segments. <em>TCS</em>, <em>866</em>,
82–95. (<a href="https://doi.org/10.1016/j.tcs.2021.03.014">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We give approximation algorithms for matching two sets of line segments in constant dimension. We consider several versions of the problem: Hausdorff distance, bottleneck distance and largest common subset. We study these similarity measures under several sets of transformations: translations in arbitrary dimension, rotations about a fixed point and rigid motions in two dimensions . As opposed to previous theoretical work on this problem, we match segments individually, in other words we regard our two input sets as sets of segments rather than unions of segments.},
  archive      = {J_TCS},
  author       = {Hyeyun Yang and Antoine Vigneron},
  doi          = {10.1016/j.tcs.2021.03.014},
  journal      = {Theoretical Computer Science},
  pages        = {82-95},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Matching sets of line segments},
  volume       = {866},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Shortest covers of all cyclic shifts of a string.
<em>TCS</em>, <em>866</em>, 70–81. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.011">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A factor C of a string S is called a cover of S , if each position of S is contained in an occurrence of C . Breslauer (1992) [3] proposed a well-known O ( n ) O(n) -time algorithm that computes the shortest cover of every prefix of a string of length n . We show an O ( n log ⁡ n ) O(nlog⁡n) -time and O ( n ) O(n) -space algorithm that computes the shortest cover of every cyclic shift of a string of length n and an O ( n ) O(n) -time algorithm that computes the shortest among these covers. We also provide a combinatorial characterization of shortest covers of cyclic shifts of Fibonacci strings that leads to efficient algorithms for computing these covers. We further consider the bound on the number of different lengths of shortest covers of cyclic shifts of the same string of length n . We show that this number is Θ ( log ⁡ n ) Θ(log⁡n) for Fibonacci strings.},
  archive      = {J_TCS},
  author       = {Maxime Crochemore and Costas S. Iliopoulos and Jakub Radoszewski and Wojciech Rytter and Juliusz Straszyński and Tomasz Waleń and Wiktor Zuba},
  doi          = {10.1016/j.tcs.2021.03.011},
  journal      = {Theoretical Computer Science},
  pages        = {70-81},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Shortest covers of all cyclic shifts of a string},
  volume       = {866},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The undirected repetition threshold and undirected pattern
avoidance. <em>TCS</em>, <em>866</em>, 56–69. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.010">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {For a rational number r such that 1 &lt; r ≤ 2 , an undirected r-power is a word of the form x y x ′ , where the word x is nonempty, the word x ′ is in { x , x R } , and we have | x y x ′ | / | x y | = r . The undirected repetition threshold for k letters, denoted URT ( k ) , is the infimum of the set of all r such that undirected r -powers are avoidable on k letters. We first demonstrate that URT ( 3 ) = 7 4 . Then we show that URT ( k ) ≥ k − 1 k − 2 for all k ≥ 4 . We conjecture that URT ( k ) = k − 1 k − 2 for all k ≥ 4 , and we confirm this conjecture for k ∈ { 4 , 5 , … , 21 } . We then consider related problems in pattern avoidance; in particular, we find the undirected avoidability index of every binary pattern. This is an extended version of a paper presented at WORDS 2019, and it contains new and improved results.},
  archive      = {J_TCS},
  author       = {James D. Currie and Lucas Mol},
  doi          = {10.1016/j.tcs.2021.03.010},
  journal      = {Theoretical Computer Science},
  pages        = {56-69},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The undirected repetition threshold and undirected pattern avoidance},
  volume       = {866},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The touring rays and related problems. <em>TCS</em>,
<em>866</em>, 43–55. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.005">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The touring rays problem, which is also known as the traveling salesman problem for rays in the plane, asks to compute the shortest (closed) route that tours or intersects n given rays. We show that it can be reduced to the problem of computing a shortest route that intersects a set of ray-segments, inside a circle; at least one endpoint of every ray-segment is on the circle. Moreover, computing the shortest route intersecting all ray-segments in the circle is related to the solution of the well-known watchman route problem. Our method is further extended to solve the minimum-perimeter intersecting polygon problem, which asks for a (convex) polygon P of minimum perimeter such that for a given set of line segments, P contains at least one point of every line segment. Both of our algorithms run in O ( n 5 ) O(n5) time, and they solve two long-standing open problems in computational geometry.},
  archive      = {J_TCS},
  author       = {Xuehou Tan},
  doi          = {10.1016/j.tcs.2021.03.005},
  journal      = {Theoretical Computer Science},
  pages        = {43-55},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The touring rays and related problems},
  volume       = {866},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Star-critical ramsey number of large cycle and book of
different orders. <em>TCS</em>, <em>866</em>, 37–42. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.004">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {For graphs F , G and H , let F → ( G , H ) F→(G,H) signify that any red/blue edge coloring of F contains either a red G or a blue H . The Ramsey number R ( G , H ) R(G,H) is defined to be the minimum r such that K r → ( G , H ) Kr→(G,H) , and the star-critical Ramsey number R S ( G , H ) RS(G,H) is defined to be the maximum t such that K r ∖ K 1 , t → ( G , H ) Kr∖K1,t→(G,H) , where r = R ( G , H ) r=R(G,H) . In this note, we shall determine R S ( B n , C m ) RS(Bn,Cm) for almost same orders.},
  archive      = {J_TCS},
  author       = {Yan Li and Yusheng Li and Ye Wang},
  doi          = {10.1016/j.tcs.2021.03.004},
  journal      = {Theoretical Computer Science},
  pages        = {37-42},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Star-critical ramsey number of large cycle and book of different orders},
  volume       = {866},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Primitive sets of words. <em>TCS</em>, <em>866</em>, 25–36.
(<a href="https://doi.org/10.1016/j.tcs.2021.03.003">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Given a (finite or infinite) subset X of the free monoid A ⁎ A⁎ over a finite alphabet A , the rank of X is the minimal cardinality of a set F such that X ⊆ F ⁎ X⊆F⁎ . We say that a submonoid M generated by k elements of A ⁎ A⁎ is k-maximal if there does not exist another submonoid generated by at most k words containing M . We call a set X ⊆ A ⁎ X⊆A⁎ primitive if it is the basis of a | X | |X| -maximal submonoid. This definition encompasses the notion of primitive word — in fact, { w } {w} is a primitive set if and only if w is a primitive word. By definition, for any set X , there exists a primitive set Y such that X ⊆ Y ⁎ X⊆Y⁎ . We therefore call Y a primitive root of X . As a main result, we prove that if a set has rank 2, then it has a unique primitive root. To obtain this result, we prove that the intersection of two 2-maximal submonoids is either the empty word or a submonoid generated by one single primitive word. For a single word w , we say that the set { x , y } {x,y} is a bi-root of w if w can be written as a concatenation of copies of x and y and { x , y } {x,y} is a primitive set. We prove that every primitive word w has at most one bi-root { x , y } {x,y} such that | x | + | y | |x|+|y|&amp;lt;|w| . That is, the bi-root of a word is unique provided the word is sufficiently long with respect to the size (sum of lengths) of the root. Our results are also compared to previous approaches that investigate pseudo-repetitions, where a morphic involutive function θ is defined on A ⁎ A⁎ . In this setting, the notions of θ -power, θ -primitive and θ -root are defined, and it is shown that any word has a unique θ -primitive root. This result can be obtained with our approach by showing that a word w is θ -primitive if and only if { w , θ ( w ) } {w,θ(w)} is a primitive set.},
  archive      = {J_TCS},
  author       = {Giuseppa Castiglione and Gabriele Fici and Antonio Restivo},
  doi          = {10.1016/j.tcs.2021.03.003},
  journal      = {Theoretical Computer Science},
  pages        = {25-36},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Primitive sets of words},
  volume       = {866},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Binary intersection formalized. <em>TCS</em>, <em>866</em>,
14–24. (<a href="https://doi.org/10.1016/j.tcs.2021.03.002">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We provide a reformulation and a formalization of the classical result by Juhani Karhumäki characterizing intersections of two languages of the form ⁎ ⁎ { x , y } ⁎ ∩ { u , v } ⁎ {x,y}⁎∩{u,v}⁎ . We use the terminology of morphisms which allows to formulate the result in a shorter and more transparent way, and we formalize the result in the proof assistant Isabelle/HOL.},
  archive      = {J_TCS},
  author       = {Štěpán Holub and Štěpán Starosta},
  doi          = {10.1016/j.tcs.2021.03.002},
  journal      = {Theoretical Computer Science},
  pages        = {14-24},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Binary intersection formalized},
  volume       = {866},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Realization problems on reachability sequences.
<em>TCS</em>, <em>866</em>, 1–13. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.034">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The classical Erdös-Gallai theorem (1960) kicked off the study of graph realizability by characterizing degree sequences. We extend this line of research by investigating realizability of directed acyclic graphs (DAGs) given a sequence of tuples each containing multiple node properties including the degree, reachability value (number of nodes reachable from a given node), depth and height of a node. The most interesting problems are when the sequences contain both a local constraint via degree values and a global constraint via reachability values. We show that, without degree constraints , DAG reachability realization is solvable in linear time, whereas it is strongly NP-complete given upper bounds on in-degree or out-degree. After defining a suitable notion of bicriteria approximation based on consistency, we give two approximation algorithms achieving O ( log ⁡ n ) O(log⁡n) -reachability consistency and O ( log ⁡ n ) O(log⁡n) -degree consistency; the first, randomized, uses LP (Linear Program) rounding, while the second, deterministic, employs a k -set packing heuristic. We end with some future directions of research and a set of conjectures that we hope will motivate further study of realizability with reachability constraints.},
  archive      = {J_TCS},
  author       = {Matthew Dippel and Ravi Sundaram and Akshar Varma},
  doi          = {10.1016/j.tcs.2021.02.034},
  journal      = {Theoretical Computer Science},
  pages        = {1-13},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Realization problems on reachability sequences},
  volume       = {866},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Finding a maximum minimal separator: Graph classes and
fixed-parameter tractability. <em>TCS</em>, <em>865</em>, 131–140. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.006">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the problem of finding a maximum cardinality minimal separator of a graph. This problem is known to be NP-hard even for bipartite graphs . In this paper, we strengthen this hardness by showing that for planar bipartite graphs , the problem remains NP-hard. Moreover, for co-bipartite graphs and for line graphs, the problem also remains NP-hard. On the positive side, we give an algorithm deciding whether an input graph has a minimal separator of size at least k that runs in time 2 O ( k ) n O ( 1 ) 2O(k)nO(1) . We further show that there is no 2 o ( n ) n O ( 1 ) 2o(n)nO(1) -time algorithm unless the Exponential Time Hypothesis (ETH) fails. Finally, we discuss a lower bound for polynomial kernelizations of this problem.},
  archive      = {J_TCS},
  author       = {Tesshu Hanaka and Yasuaki Kobayashi and Yusuke Kobayashi and Tsuyoshi Yagita},
  doi          = {10.1016/j.tcs.2021.03.006},
  journal      = {Theoretical Computer Science},
  pages        = {131-140},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Finding a maximum minimal separator: Graph classes and fixed-parameter tractability},
  volume       = {865},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021a). Differentially private high dimensional sparse covariance
matrix estimation. <em>TCS</em>, <em>865</em>, 119–130. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.001">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we study the problem of estimating the covariance matrix under differential privacy, where the underlying covariance matrix is assumed to be sparse and of high dimensions. We propose a new method, called DP-Thresholding, to achieve a non-trivial ℓ 2 ℓ2 -norm based error bound whose dependence on the dimension drops to logarithmic instead of polynomial, it is significantly better than the existing ones, which add noise directly to the empirical covariance matrix. We also extend the ℓ 2 ℓ2 -norm based error bound to a general ℓ w ℓw -norm based one for any 1 ≤ w ≤ ∞ 1≤w≤∞ , and show that they share the same upper bound asymptotically. Our approach can be easily extended to local differential privacy. Experiments on the synthetic datasets show results that are consistent with theoretical claims.},
  archive      = {J_TCS},
  author       = {Di Wang and Jinhui Xu},
  doi          = {10.1016/j.tcs.2021.03.001},
  journal      = {Theoretical Computer Science},
  pages        = {119-130},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Differentially private high dimensional sparse covariance matrix estimation},
  volume       = {865},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Speeding up the AIFV-2 dynamic programs by two orders of
magnitude using range minimum queries. <em>TCS</em>, <em>865</em>,
99–118. (<a href="https://doi.org/10.1016/j.tcs.2021.02.040">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {AIFV-2 codes are a new method for constructing lossless codes for memoryless sources that provide better worst-case redundancy than Huffman codes . They do this by using two code trees instead of one and also allowing some bounded delay in the decoding process. Known algorithms for constructing AIFV-codes are iterative; at each step they replace the current code tree pair with a “better” one. The current state of the art for performing this replacement is a pair of Dynamic Programming (DP) algorithms that use O ( n 5 ) O(n5) time to fill in two tables, each of size O ( n 3 ) O(n3) (where n is the number of different characters in the source). This paper describes how to reduce the time for filling in the DP tables by two orders of magnitude, down to O ( n 3 ) O(n3) . It does this by introducing a grouping technique that permits separating the Θ ( n 3 ) Θ(n3) -space tables into Θ ( n ) Θ(n) groups, each of size O ( n 2 ) O(n2) , and then using Two-Dimensional Range-Minimum Queries (RMQs) to fill in that group&#39;s table entries in O ( n 2 ) O(n2) time.},
  archive      = {J_TCS},
  author       = {Mordecai Golin and Elfarouk Harb},
  doi          = {10.1016/j.tcs.2021.02.040},
  journal      = {Theoretical Computer Science},
  pages        = {99-118},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Speeding up the AIFV-2 dynamic programs by two orders of magnitude using range minimum queries},
  volume       = {865},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021b). Inferring ground truth from crowdsourced data under local
attribute differential privacy. <em>TCS</em>, <em>865</em>, 85–98. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.039">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Nowadays, crowdsourcing gains an increasing popularity as it can be adopted to solve many challenging question answering tasks that are easy for humans but difficult for computers. Due to the variety in the quality of users, it is important to infer not only the underlying ground truth of these tasks but also the users ability from the answers given by users. This problem is called Ground Truth Inference and has been studied for many years. However, since the answers collected from the users may contain sensitive information , ground truth inference raises serious privacy concern. Due to this reason, the problem of ground truth inference under local differential privacy (LDP) model has been recently studied. However, this problem is still not well understood and even some basic questions have not been solved yet. First, it is still unknown what is the average error of the private estimators to the underlying ground truth. Secondly, we do not know whether we can infer the ability of each user under LDP model and what is the estimation error w.r.t. the underlying users ability. Finally, previous work only shows that their methods have better performance than the private major voting algorithm through experiments. However, there is still no theoretically result which shows this priority formally or mathematically. In this paper, we partially solve these problems by studying the ground truth inference problem under local attribute differential privacy (LADP) model, which is a relaxation of LDP model, and propose a new algorithm called private Dawid-Skene method, which is motivated by the classical Dawid-Skene method. Specifically, we first provide the estimation errors for both ability of users and the ground truth under some assumptions of the problem if the algorithm start with some appropriate initial vector. Moreover, we propose an explicit instance and show that the estimation error of the ground truth achieved by the private major voting algorithm is always greater than the error achieved by our method.},
  archive      = {J_TCS},
  author       = {Di Wang and Jinhui Xu},
  doi          = {10.1016/j.tcs.2021.02.039},
  journal      = {Theoretical Computer Science},
  pages        = {85-98},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Inferring ground truth from crowdsourced data under local attribute differential privacy},
  volume       = {865},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Complexity of modification problems for best match graphs.
<em>TCS</em>, <em>865</em>, 63–84. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.037">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Best match graphs (BMGs) are vertex-colored directed graphs that were introduced to model the relationships of genes (vertices) from different species (colors) given an underlying evolutionary tree that is assumed to be unknown. In real-life applications, BMGs are estimated from sequence similarity data. Measurement noise and approximation errors usually result in empirically determined graphs that in general violate characteristic properties of BMGs. The arc modification problems for BMGs aim at correcting such violations and thus provide a means to improve the initial estimates of best match data. We show here that the arc deletion, arc completion and arc editing problems for BMGs are NP-complete and that they can be formulated and solved as integer linear programs . To this end, we provide a novel characterization of BMGs in terms of triples (binary trees on three leaves) and a characterization of BMGs with two colors in terms of forbidden subgraphs.},
  archive      = {J_TCS},
  author       = {David Schaller and Peter F. Stadler and Marc Hellmuth},
  doi          = {10.1016/j.tcs.2021.02.037},
  journal      = {Theoretical Computer Science},
  pages        = {63-84},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Complexity of modification problems for best match graphs},
  volume       = {865},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Attribute-based proxy re-encryption from standard lattices.
<em>TCS</em>, <em>865</em>, 52–62. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.036">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Attribute-based proxy re-encryption (ABPRE), which combines the notions of proxy re-encryption (PRE) and attribute-based encryption (ABE), allows a semi-trusted proxy to transform a ciphertext under a particular access-policy into a ciphertext under another access policy, without revealing any information about the underlying plaintext. This primitive is very useful in some applications, where encrypted data needs to be stored in untrusted environments , such as cloud storage . In its key-policy flavor, the secret key is associated with an access policy that specifies which type of ciphertexts can be decrypted by that key, where ciphertexts are marked with different sets of attributes. However, all existing key-policy attribute-based proxy re-encryption (KP-ABPRE) schemes are based on classical number-theoretic assumptions, which are vulnerable to quantum attacks. This paper proposes the first KP-ABPRE scheme based on the learning with errors (LWE) problem, which is widely believed to be quantum-resistant. Our scheme is multi-hop, supports polynomial-depth policy circuits and has short private keys, where the size of the keys is dependent only on the depth of the supported policy circuits. In addition, we prove that our scheme is CPA secure in the selective security model, based on the LWE assumption.},
  archive      = {J_TCS},
  author       = {Fucai Luo and Saif Al-Kuwari and Fuqun Wang and Kefei Chen},
  doi          = {10.1016/j.tcs.2021.02.036},
  journal      = {Theoretical Computer Science},
  pages        = {52-62},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Attribute-based proxy re-encryption from standard lattices},
  volume       = {865},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Complexity and bounds for disjunctive total bondage.
<em>TCS</em>, <em>865</em>, 44–51. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.032">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A subset S ⊆ V ( G ) S⊆V(G) is a disjunctive total dominating set if each vertex has a neighbor in S or has at least two vertices in S at distance two from it. The disjunctive total domination number γ t d ( G ) γtd(G) is the minimum cardinality of a disjunctive total dominating set in G . Disjunctive total bondage number , b t d ( G ) btd(G) , of a graph G with no isolated vertex is defined as the minimum cardinality of edge set B ⊆ E ( G ) B⊆E(G) whose deletion obtains a graph G − B G−B with no isolated vertex satisfying γ t d ( G − B ) &gt; γ t d ( G ) γtd(G−B)&amp;gt;γtd(G) . If there is no such set B , it is then defined as b t d ( G ) = ∞ btd(G)=∞ . We, in this paper, present some bounds on disjunctive total bondage. Also, we prove that the disjunctive total bondage problem is NP-complete, even for bipartite graphs .},
  archive      = {J_TCS},
  author       = {Canan Çiftçi},
  doi          = {10.1016/j.tcs.2021.02.032},
  journal      = {Theoretical Computer Science},
  pages        = {44-51},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Complexity and bounds for disjunctive total bondage},
  volume       = {865},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On square factors and critical factors of k-bonacci words on
infinite alphabet. <em>TCS</em>, <em>865</em>, 34–43. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.027">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_TCS},
  author       = {N. Ghareghani and P. Sharifani},
  doi          = {10.1016/j.tcs.2021.02.027},
  journal      = {Theoretical Computer Science},
  pages        = {34-43},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On square factors and critical factors of k-bonacci words on infinite alphabet},
  volume       = {865},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The cardinality constrained inverse center location problems
on tree networks with edge length augmentation. <em>TCS</em>,
<em>865</em>, 12–33. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.026">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In a cardinality constrained inverse center location problem on networks, the goal is to modify the edge lengths at the minimum total cost subject to the given modification bounds so that a prespecified vertex becomes an absolute center location of the underlying network under the perturbed edge lengths and further the cardinality of the modified edge lengths obeys an upper bound. Using a set of self-constructed red-black search trees, as a suitable data structure , we propose novel optimal algorithms with polynomial time complexities for the problem on tree networks under various cost norms.},
  archive      = {J_TCS},
  author       = {Mehran Hasanzadeh and Behrooz Alizadeh and Fahimeh Baroughi},
  doi          = {10.1016/j.tcs.2021.02.026},
  journal      = {Theoretical Computer Science},
  pages        = {12-33},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The cardinality constrained inverse center location problems on tree networks with edge length augmentation},
  volume       = {865},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Throttling processes equivalent to full throttling on trees.
<em>TCS</em>, <em>865</em>, 1–11. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.025">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Consider a discrete-time process on a graph G where a set B of initial vertices are chosen to be colored blue (the remainder being white) and then a time step consists of every currently blue vertex forcing all of its neighbors to become blue; this process stops when every vertex of the graph is blue, and the process is called full forcing. The full throttling number of G is then defined to be the minimum sum of the cardinality of B and the number of time steps needed to complete the forcing process. On trees, the full throttling number is equivalent to the throttling numbers of several other graph processes, such as positive-semidefinite zero forcing, the game of cops and robbers, and the distance domination number (alternately, the k -radius) of a graph. For all of these, it is known that maximum possible throttling number for a tree on n vertices is somewhere between 1.4502n and 142n , with the former exhibited by a family of spiders. After introducing some new ideas and methods for working with throttling on trees, this paper determines the exact full throttling number of all balanced spiders (trees with equal-length paths extending from a center vertex), and proves that their full throttling numbers are bounded above by that of paths of the same order n , which are known to have full throttling number ⌈2n−12⌉ .},
  archive      = {J_TCS},
  author       = {Michael S. Ross},
  doi          = {10.1016/j.tcs.2021.02.025},
  journal      = {Theoretical Computer Science},
  pages        = {1-11},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Throttling processes equivalent to full throttling on trees},
  volume       = {865},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Algorithms and discrete mathematics – celebrating the silver
jubilee of IITG guwahati. <em>TCS</em>, <em>864</em>, 139–140. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.019">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_TCS},
  author       = {Gautam Kumar Das and Subhas C. Nandy and M. Sohel Rahman},
  doi          = {10.1016/j.tcs.2021.03.019},
  journal      = {Theoretical Computer Science},
  pages        = {139-140},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Algorithms and discrete mathematics – celebrating the silver jubilee of IITG guwahati},
  volume       = {864},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Theoretical computer science in italy. <em>TCS</em>,
<em>864</em>, 138. (<a
href="https://doi.org/10.1016/j.tcs.2021.03.018">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_TCS},
  author       = {Alessandra Cherubini and Nicoletta Sabadini and Simone Tini},
  doi          = {10.1016/j.tcs.2021.03.018},
  journal      = {Theoretical Computer Science},
  pages        = {138},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Theoretical computer science in italy},
  volume       = {864},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021a). Parallelized maximization of nonsubmodular function subject
to a cardinality constraint. <em>TCS</em>, <em>864</em>, 129–137. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.035">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In the paper, we consider the problem of maximizing the multilinear extension of a nonsubmodular set function subject to a k -cardinality constraint with adaptive rounds of evaluation queries. We devise an algorithm which achieves a ratio of ( 1 − e − γ 2 − ϵ ) (1−e−γ2−ϵ) and requires O ( log ⁡ n / ϵ 2 ) O(log⁡n/ϵ2) adaptive rounds and O ( n log ⁡ n / ϵ 2 ) O(nlog⁡n/ϵ2) queries, where γ is the continuous generic submodularity ratio that compares favorably in flexibility to the traditional submodularity ratio proposed by Das and Kempe. The key idea of our algorithm is originated from the parallel-greedy algorithm proposed by Chekuri et al., but incorporating with two major changes to retain the performance guarantee: First, identify all good coordinates with the continuous generic submodularity ratio and gradient values approximately as large as the best coordinate, and increase along all these coordinates uniformly; Second, increase x along these coordinates by a dynamical increment whose value depends on γ . The key difficulty of our algorithm is that when the function is nonsubmodular, the set of the best coordinate does not decrease during iterations; while provided submodularity, the decreasing can be ensured by the parallel-greedy algorithm. Our algorithms slightly compromise performance guarantee for the sake of extending to constrained nonsubmodular maximization with parallelism, provided that the state-of-art algorithm for the corresponding submodular version attains an approximation ratio of ( 1 − 1 / e − ϵ ) (1−1/e−ϵ) and requires O ( log ⁡ n / ϵ 2 ) O(log⁡n/ϵ2) adaptive rounds.},
  archive      = {J_TCS},
  author       = {Hongxiang Zhang and Dachuan Xu and Longkun Guo and Jingjing Tan},
  doi          = {10.1016/j.tcs.2021.02.035},
  journal      = {Theoretical Computer Science},
  pages        = {129-137},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Parallelized maximization of nonsubmodular function subject to a cardinality constraint},
  volume       = {864},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Minimum power partial multi-cover on a line. <em>TCS</em>,
<em>864</em>, 118–128. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.033">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper studies the minimum power partial multi-cover problem on a line (MinPowPMC-Line), the goal of which is to find an assignment of powers to sensors such that at least a required number of points are covered up to their covering requirements. We first present an LP method to show that the minimum power multi-cover problem on a line (without partial covering requirement) is solvable in polynomial time . But this method no longer works when facing partial covering requirement. We turn to dynamic programming method to find an optimal solution for MinPowPMC-Line in time O(n4m1+2(crmax)) , where n,m are the number of points and the number of sensors, respectively, and crmax denotes the maximum covering requirement of elements. So, this problem is polynomial-time solvable when crmax is upper bounded by a constant.},
  archive      = {J_TCS},
  author       = {Wei Liang and Menghong Li and Zhao Zhang and Xiaohui Huang},
  doi          = {10.1016/j.tcs.2021.02.033},
  journal      = {Theoretical Computer Science},
  pages        = {118-128},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Minimum power partial multi-cover on a line},
  volume       = {864},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Efficiency and equity in the multi organization scheduling
problem. <em>TCS</em>, <em>864</em>, 103–117. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.031">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider the multi organization scheduling problem (MOSP) [19] : given N organizations owning, each of them, one set of tasks and machines, the aim is to compute a schedule which gathers all the tasks on all the machines, and such that the makespan is minimized. A rationality constraint must be fulfilled: no organization should increase its makespan (the completion time of its last task) compared to the case where it schedules its own tasks (and only its own tasks) on its own machines. We show that cooperation (sharing machines and tasks) can benefit to all the organizations simultaneously, since they may decrease their makespans by a factor of N . We present an algorithm which is ( 1 + ϵ ) (1+ϵ) -approximate, while the makespan of each organization is increased by a factor at most ( 1 + ϵ ) (1+ϵ) . We also study to which extent the rationality constraint (or a relaxed constraint) increases the makespan, compared to problem ( P | | C max ) (P||Cmax) where there is no such a constraint. Finally, we introduce a new problem, which focus on equity: the aim is to return a schedule which fulfills the rationality constraint and which maximizes the factor by which each organization has decreased its makespan. We give an optimal algorithm for this problem in a particular case, and show that it is NP-hard and hard to approximate in the general case. We complete this paper by an efficient heuristic for this problem.},
  archive      = {J_TCS},
  author       = {Martin Durand and Fanny Pascual},
  doi          = {10.1016/j.tcs.2021.02.031},
  journal      = {Theoretical Computer Science},
  pages        = {103-117},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Efficiency and equity in the multi organization scheduling problem},
  volume       = {864},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Two-way deterministic automata with jumping mode.
<em>TCS</em>, <em>864</em>, 92–102. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.030">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The recently introduced one-way jumping automata are strictly more powerful than classical finite automata (FA) while maintaining decidability in most of the important cases. We investigate the extension of the new processing mode to two-way deterministic finite automata (2DFA), resulting in deterministic finite automata which can jump to the nearest letter which they can read, with jumps allowed in either direction. We show that two-way jumping automata are strictly more powerful than one-way jumping ones and that alternative extensions of 2DFA with this jumping mode lead to equivalent machines. We also prove that the class of languages accepted by the new model is not closed under the usual language operations. Finally we show how one could change the model to terminate on every input by using non-erasable end markers.},
  archive      = {J_TCS},
  author       = {Szilárd Zsolt Fazekas and Kaito Hoshi and Akihiro Yamamura},
  doi          = {10.1016/j.tcs.2021.02.030},
  journal      = {Theoretical Computer Science},
  pages        = {92-102},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Two-way deterministic automata with jumping mode},
  volume       = {864},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). K-critical graphs in p5-free graphs. <em>TCS</em>,
<em>864</em>, 80–91. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.029">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Given two graphs H 1 H1 and H 2 H2 , a graph G is ( H 1 , H 2 ) (H1,H2) -free if it contains no induced subgraph isomorphic to H 1 H1 or H 2 H2 . Let P t Pt be the path on t vertices. A graph G is k -vertex-critical if G has chromatic number k but every proper induced subgraph of G has chromatic number less than k . The study of k -vertex-critical graphs for graph classes is an important topic in algorithmic graph theory because if the number of such graphs that are in a given hereditary graph class is finite, then there is a polynomial-time algorithm to decide if a graph in the class is ( k − 1 ) (k−1) -colorable. In this paper, we initiate a systematic study of the finiteness of k -vertex-critical graphs in subclasses of P 5 P5 -free graphs. Our main result is a complete classification of the finiteness of k -vertex-critical graphs in the class of ( P 5 , H ) (P5,H) -free graphs for all graphs H on 4 vertices. To obtain the complete dichotomy, we prove the finiteness for four new graphs H using various techniques – such as Ramsey-type arguments and the dual of Dilworth&#39;s Theorem – that may be of independent interest.},
  archive      = {J_TCS},
  author       = {Kathie Cameron and Jan Goedgebeur and Shenwei Huang and Yongtang Shi},
  doi          = {10.1016/j.tcs.2021.02.029},
  journal      = {Theoretical Computer Science},
  pages        = {80-91},
  shortjournal = {Theor. Comput. Sci.},
  title        = {K-critical graphs in p5-free graphs},
  volume       = {864},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). An approximation algorithm for general energy restricted
sweep coverage problem. <em>TCS</em>, <em>864</em>, 70–79. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.028">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Considerable attention has been paid to sweep coverage in Wireless Sensor Networks (WSNs) for the past few years. In sweep coverage, mobile sensor nodes are scheduled to visit Points of Interests (POIs) periodically. Due to the limited energy of mobile sensors, energy consumption poses an important challenge in sweep coverage. In this paper, we extend the Energy Restricted Sweep Coverage to the General Energy Restricted Sweep Coverage (GERSC) by assuming the unit energy consumption of mobile sensors varies in different road sections. The goal of GERSC is also to minimize the required number of mobile sensors in sweep coverage under the energy constraint. In GERSC, the approximation ratio of the state-of-the-art algorithm named ERSweepCoverage is no longer guaranteed. Therefore, we devise a constant-factor approximation algorithm named IERSC for GERSC. The approximation ratio of IERSC is β [ 3 α m i n ( θ , 1 − θ ) + 1 ] β[3αmin(θ,1−θ)+1] . θ is the predefined parameter of IERSC ranging from 0 to 1. With θ being 1 2 12 , IERSC has the best approximation ratio of ( 6 α + 1 ) β (6α+1)β . Finally, the promising experimental results demonstrate the effectiveness and efficiency of the proposed algorithm.},
  archive      = {J_TCS},
  author       = {Zixiong Nie and Hongwei Du},
  doi          = {10.1016/j.tcs.2021.02.028},
  journal      = {Theoretical Computer Science},
  pages        = {70-79},
  shortjournal = {Theor. Comput. Sci.},
  title        = {An approximation algorithm for general energy restricted sweep coverage problem},
  volume       = {864},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Unified temporal logic. <em>TCS</em>, <em>864</em>, 58–69.
(<a href="https://doi.org/10.1016/j.tcs.2021.02.007">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper proposes a new temporal logic named Unified Temporal Logic (UTL). First, the syntax and semantics of UTL are inductively defined. Further, logic laws in UTL are formalized and proved. Moreover, the normal forms of UTL formulas are defined and proved. To illustrate how to describe properties with UTL, an example of an elevator control system is given. In general, UTL combines the characteristics of Linear Temporal Logic (LTL) and Propositional Projection Temporal Logic (PPTL). So properties involving the “until” construct in LTL and the “chop” construct in PPTL can easily be represented in UTL. In addition, both finite and infinite models (intervals) are supported. With UTL, we are able to specify and verify some practical properties which cannot easily be formalized in LTL and PPTL.},
  archive      = {J_TCS},
  author       = {Nan Zhang and Zhenhua Duan and Cong Tian},
  doi          = {10.1016/j.tcs.2021.02.007},
  journal      = {Theoretical Computer Science},
  pages        = {58-69},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Unified temporal logic},
  volume       = {864},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021a). Independent perfect dominating sets in semi-cayley graphs.
<em>TCS</em>, <em>864</em>, 50–57. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.006">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {An independent perfect dominating set in a graph Γ with vertex set V ( Γ ) V(Γ) is a subset S of V ( Γ ) V(Γ) such that S is an independent set and every vertex in V ( Γ ) ∖ S V(Γ)∖S is adjacent to exactly one vertex in S . In this paper, we first give a necessary and sufficient condition for the existence of independent perfect dominating sets in semi-Cayley graphs of finite groups. Further, we obtain a necessary and sufficient condition for Cayley graphs to have independent perfect dominating sets on two classes non-abelian groups.},
  archive      = {J_TCS},
  author       = {Xiaomeng Wang and Shou-Jun Xu and Xianyue Li},
  doi          = {10.1016/j.tcs.2021.02.006},
  journal      = {Theoretical Computer Science},
  pages        = {50-57},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Independent perfect dominating sets in semi-cayley graphs},
  volume       = {864},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Parameterized complexity of completeness reasoning for
conjunctive queries. <em>TCS</em>, <em>864</em>, 34–49. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.005">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Incompleteness management has become a popular research topic and been viewed in many applications in the area of data quality and data management. Traditional methods for handling incompleteness assume data is totally complete or incomplete. However, in practical applications, data is often partial complete , which means that data is not totally complete but some special parts of the data satisfying given semantic specifications are complete. Intuitively, partial complete data can still give complete answers for queries consistent with the semantic specifications. Therefore, it is highly needed to study the fundamental problems for managing partial complete data. However, as far as known by us, there are only few works focusing on this area. The most important and fundamental problem, completeness reasoning , is studied from the aspect of parameterized complexity by this paper. The completeness reasoning problem, TC-QC (Table Completeness to Query Completeness), is first formally defined and studied by Razniewski et al. [1] . Given completeness statements of data, the goal of the TC-QC problem is to determine whether the result of a special query Q is complete, that is to reason query completeness based on given data completeness. Razniewski et al. have shown that the TC-QC problem is NP- hard even for conjunctive queries , and a natural and interesting question is whether or not TC-QC can be solved efficiently by parameterized algorithms. To answer that, the parameterized complexities of completeness reasoning for conjunctive queries are studied by the paper. First, it is shown that, considering the parameterizations defined by the size of query completeness or table completeness, the parameterized TC-QC problem for conjunctive queries is para-NP- complete , which strongly indicate that the TC-QC problems parameterized by the above two parameters do not admit fixed-parameter tractable algorithms . Then, for more special cases parameterized by different constraints on query structures like degree, tree-width and number of variables, the TC-QC problems are still not fixed parameter tractable. Finally, on the positive side, if each data completeness statement has a constant size bound, the parameterized TC-QC problem defined by the query completeness size can be solved by a fixed-parameter tractable algorithm.},
  archive      = {J_TCS},
  author       = {Xianmin Liu and Jianzhong Li and Yingshu Li and Yuqiang Feng},
  doi          = {10.1016/j.tcs.2021.02.005},
  journal      = {Theoretical Computer Science},
  pages        = {34-49},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Parameterized complexity of completeness reasoning for conjunctive queries},
  volume       = {864},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021a). Finding the size and the diameter of a radio network using
short labels. <em>TCS</em>, <em>864</em>, 20–33. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.004">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The number of nodes of a network, called its size , and the largest distance between nodes of a network, called its diameter , are among the most important network parameters. Knowing the size and/or diameter (or a good upper bound on those parameters) is a prerequisite of many distributed network algorithms, ranging from broadcasting and gossiping, through leader election, to rendezvous and exploration. A radio network is a collection of stations, called nodes, with wireless transmission and receiving capabilities. It is modeled as a simple connected undirected graph whose nodes communicate in synchronous rounds. In each round, a node can either transmit a message to all its neighbors, or stay silent and listen. At the receiving end, a node v hears a message from a neighbor w in a given round, if v listens in this round, and if w is its only neighbor that transmits in this round. If v listens in a round, and two or more neighbors of v transmit in this round, a collision occurs at v . If v transmits in a round, it does not hear anything in this round. Two scenarios are considered in the literature: if listening nodes can distinguish collision from silence (the latter occurs when no neighbor transmits), we say that the network has the collision detection capability, otherwise there is no collision detection. We consider the tasks of size discovery and diameter discovery : finding the size (resp. the diameter) of an unknown radio network with collision detection. All nodes have to output the size (resp. the diameter) of the network, using a deterministic algorithm. Nodes have labels which are (not necessarily distinct) binary strings. The length of a labeling scheme is the largest length of a label. We concentrate on the following problems: Our main result states that the minimum length of a labeling scheme that permits size discovery is Θ ( log ⁡ log ⁡ Δ ) Θ(log⁡log⁡Δ) . The upper bound is proven by designing a size discovery algorithm using a labeling scheme of length O ( log ⁡ log ⁡ Δ ) O(log⁡log⁡Δ) , for all networks of maximum degree Δ. The matching lower bound is proven by constructing a class of graphs (in fact even of trees) of maximum degree Δ, for which any size discovery algorithm must use a labeling scheme of length at least Ω ( log ⁡ log ⁡ Δ ) Ω(log⁡log⁡Δ) on some graph of this class. By contrast, we show that diameter discovery can be done in all radio networks using a labeling scheme of constant length.},
  archive      = {J_TCS},
  author       = {Barun Gorain and Andrzej Pelc},
  doi          = {10.1016/j.tcs.2021.02.004},
  journal      = {Theoretical Computer Science},
  pages        = {20-33},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Finding the size and the diameter of a radio network using short labels},
  volume       = {864},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Improved hardness and approximation results for single
allocation hub location problems. <em>TCS</em>, <em>864</em>, 10–19. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.003">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Given a metric graph G = ( V , E , w ) G=(V,E,w) and an integer k , we aim to find a single allocation k -hub location, which is a spanning subgraph consisting of a clique of size k such that every node outside of the clique is adjacent to exactly one node inside the clique. For various objective functions studied in the literature, we present improved hardness and approximation results.},
  archive      = {J_TCS},
  author       = {Xing Wang and Guangting Chen and Yong Chen and Guohui Lin and Yonghao Wang and An Zhang},
  doi          = {10.1016/j.tcs.2021.02.003},
  journal      = {Theoretical Computer Science},
  pages        = {10-19},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Improved hardness and approximation results for single allocation hub location problems},
  volume       = {864},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Multiple facility location games with envy ratio.
<em>TCS</em>, <em>864</em>, 1–9. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.016">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study deterministic mechanism design without money for k -facility location games with envy ratio on a real line segment, where a set of strategic agents report their locations and a social planner locates k facilities for minimizing the envy ratio. The objective of envy ratio, which is defined as the maximum over the ratios between any two agents&#39; utilities, is derived from fair division to measure the fairness with respect to a certain facility location profile. The problem is studied in two settings. In the homogeneous k -facility location game where k facilities serve the same purpose, we propose a 2 k 2 k − 1 2k2k−1 -approximate deterministic group strategyproof mechanism which is also the best deterministic strategyproof mechanism. In the heterogeneous k -facility location game where each facility serves a different purpose, when k is even, we devise an optimal and group strategyproof mechanism; when k is odd, we provide a k + 1 k − 1 k+1k−1 -approximate deterministic group strategyproof mechanism.},
  archive      = {J_TCS},
  author       = {Wenjing Liu and Yuan Ding and Xin Chen and Qizhi Fang and Qingqin Nong},
  doi          = {10.1016/j.tcs.2021.01.016},
  journal      = {Theoretical Computer Science},
  pages        = {1-9},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Multiple facility location games with envy ratio},
  volume       = {864},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Efficient revocable identity-based encryption with short
public parameters. <em>TCS</em>, <em>863</em>, 127–155. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.024">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Revocation functionality is vital to real-world cryptographic systems for managing their reliability. In the context of identity-based encryption (IBE), Boldyreva, Goyal, and Kumar (ACM CCS 2008) first showed an efficient revocation method for IBE, and such an IBE scheme with the scalable revocation method is called revocable IBE (RIBE). Seo and Emura (PKC 2013) introduced a new security notion, called decryption key exposure resistance (DKER) , which is a desirable security notion for RIBE. However, all existing RIBE schemes that achieve adaptive security with DKER require long public parameters or composite-order bilinear groups. In this paper, we first show an RIBE scheme that (1) satisfies adaptive security; (2) achieves DKER; (3) realizes constant-size public parameters; and (4) is constructed over prime-order bilinear groups. Our core technique relies on Seo and Emura&#39;s one (PKC 2013), which transform the Waters IBE (EUROCRYPT 2005) to the corresponding RIBE scheme. Specifically, we construct an IBE scheme that satisfies constant-size public parameters over prime-order groups and some requirements for the Seo-Emura technique, and then transform the IBE scheme to an RIBE scheme. We also discuss how to extend the proposed RIBE scheme to a chosen-ciphertext secure one and server-aided one (ESORICS 2015).},
  archive      = {J_TCS},
  author       = {Keita Emura and Jae Hong Seo and Yohei Watanabe},
  doi          = {10.1016/j.tcs.2021.02.024},
  journal      = {Theoretical Computer Science},
  pages        = {127-155},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Efficient revocable identity-based encryption with short public parameters},
  volume       = {863},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Squarefree words with interior disposable factors.
<em>TCS</em>, <em>863</em>, 120–126. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.023">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We give a partial answer to a problem of Harju by constructing an infinite ternary squarefree word w with the property that for every k ≥ 3312 k≥3312 there is an interior length- k factor of w that can be deleted while still preserving squarefreeness. We also examine Thue&#39;s famous squarefree word (generated by iterating the map 0 → 012 0→012 , 1 → 02 1→02 , 2 → 1 2→1 ) and, with the aid of the Walnut computer prover, we characterize the positions i for which deleting the symbol appearing at position i preserves squarefreeness.},
  archive      = {J_TCS},
  author       = {Marko Milosevic and Narad Rampersad},
  doi          = {10.1016/j.tcs.2021.02.023},
  journal      = {Theoretical Computer Science},
  pages        = {120-126},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Squarefree words with interior disposable factors},
  volume       = {863},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). New results for the k-secretary problem. <em>TCS</em>,
<em>863</em>, 102–119. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.022">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Suppose that n items arrive online in random order and the goal is to select k of them such that the expected sum of the selected items is maximized. The decision for any item is irrevocable and must be made on arrival without knowing future items. This problem is known as the k-secretary problem , which includes the classical secretary problem with the special case k = 1 k=1 . It is well-known that the latter problem can be solved by a simple algorithm of competitive ratio 1 / e 1/e which is optimal for n → ∞ n→∞ . Existing algorithms beating the threshold of 1 / e 1/e either rely on involved selection policies already for k = 2 k=2 , or assume that k is large. In this paper we present results for the k -secretary problem, considering the interesting and relevant case that k is small. We focus on simple selection algorithms , accompanied by combinatorial analyses. As a main contribution we propose a natural deterministic algorithm designed to have competitive ratios strictly greater than 1 / e 1/e for small k ≥ 2 k≥2 . This algorithm is hardly more complex than the elegant strategy for the classical secretary problem, optimal for k = 1 k=1 , and works for all k ≥ 1 k≥1 . We derive its competitive ratios for k ≤ 100 k≤100 , ranging from 0.41 for k = 2 k=2 to 0.75 for k = 100 k=100 . Moreover, we consider an algorithm proposed earlier in the literature, for which no rigorous analysis is known. We show that its competitive ratio is 0.4168 for k = 2 k=2 , implying that the previous analysis was not tight. Our analysis reveals a surprising combinatorial property of this algorithm, which might be helpful to find a tight analysis for all k .},
  archive      = {J_TCS},
  author       = {Susanne Albers and Leon Ladewig},
  doi          = {10.1016/j.tcs.2021.02.022},
  journal      = {Theoretical Computer Science},
  pages        = {102-119},
  shortjournal = {Theor. Comput. Sci.},
  title        = {New results for the k-secretary problem},
  volume       = {863},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). QUBO formulations of the longest path problem. <em>TCS</em>,
<em>863</em>, 86–101. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.021">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The longest path problem on graphs is an NP-hard optimization problem , and as such, it is not known to have an efficient classical solution in the general case. This study develops two quadratic unconstrained binary optimization (QUBO) formulations of this well-known problem. The first formulation is based on an approach outlined by (Bauckhage et al., 2018) for the shortest path problem and follows simply from the principle of assigning positions on the path to vertices; using k | V | k|V| binary variables, this formulation will find the longest path that visits exactly k of a graph&#39;s | V | |V| vertices, if such a path exists. As a point of theoretical interest, we present a second formulation based on degree constraints that is more complicated, but reduces the dependence of the number of variables on k to logarithmic; specifically, it requires | V | + 2 | E | ⌊ log 2 ⁡ k ⌋ + 3 | E | |V|+2|E|⌊log2⁡k⌋+3|E| binary variables to encode the longest path problem. We adapt these basic formulations for several variants of the standard longest path problem. Scaling factors for penalty terms and preprocessing time required to construct the Q matrix representing the problem are made explicit in the paper.},
  archive      = {J_TCS},
  author       = {Joey McCollum and Thomas Krauss},
  doi          = {10.1016/j.tcs.2021.02.021},
  journal      = {Theoretical Computer Science},
  pages        = {86-101},
  shortjournal = {Theor. Comput. Sci.},
  title        = {QUBO formulations of the longest path problem},
  volume       = {863},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Maximum nash welfare and other stories about EFX.
<em>TCS</em>, <em>863</em>, 69–85. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.020">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider the classic problem of fairly allocating indivisible goods among agents with additive valuation functions and explore the connection between two prominent fairness notions: maximum Nash welfare (MNW) and envy-freeness up to any good (EFX). We establish that an MNW allocation is always EFX as long as there are at most two possible values for the goods, whereas this implication is no longer true for three or more distinct values. As a notable consequence, this proves the existence of EFX allocations for these restricted valuation functions. While the efficient computation of an MNW allocation for two possible values remains an open problem, we present a novel algorithm for directly constructing EFX allocations in this setting. Finally, we study the question of whether an MNW allocation implies any EFX guarantee for general additive valuation functions under a natural new interpretation of approximate EFX allocations.},
  archive      = {J_TCS},
  author       = {Georgios Amanatidis and Georgios Birmpas and Aris Filos-Ratsikas and Alexandros Hollender and Alexandros A. Voudouris},
  doi          = {10.1016/j.tcs.2021.02.020},
  journal      = {Theoretical Computer Science},
  pages        = {69-85},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Maximum nash welfare and other stories about EFX},
  volume       = {863},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Shortest reconfiguration of sliding tokens on subclasses of
interval graphs. <em>TCS</em>, <em>863</em>, 53–68. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.019">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Suppose that two independent sets I b Ib and I r Ir of a graph such that | I b | = | I r | |Ib|=|Ir| are given, and a token is placed on each vertex in I b Ib . The sliding token problem is to determine whether there exists a sequence of independent sets which transforms I b Ib into I r Ir so that each independent set in the sequence results from the previous one by sliding exactly one token along an edge in the graph. The sliding token problem is one of the reconfiguration problems that attract the attention from the viewpoint of theoretical computer science . Recently, the problems that aim at finding a shortest reconfiguration sequence are investigated. In general, even if it is polynomial time solvable to decide whether two instances are reconfigurable into each other, it can be NP-hard to find a shortest sequence between them. In this paper, we show that the problem for finding a shortest sequence between two independent sets is polynomial time solvable for some graph classes which are subclasses of the class of interval graphs . As far as the authors know, this is the first polynomial time algorithm for the shortest sliding token problem for a graph class that requires detours.},
  archive      = {J_TCS},
  author       = {Takeshi Yamada and Ryuhei Uehara},
  doi          = {10.1016/j.tcs.2021.02.019},
  journal      = {Theoretical Computer Science},
  pages        = {53-68},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Shortest reconfiguration of sliding tokens on subclasses of interval graphs},
  volume       = {863},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Ortho-polygon visibility representations of 3-connected
1-plane graphs. <em>TCS</em>, <em>863</em>, 40–52. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.018">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {An ortho-polygon visibility representation (OPVR) of an embedded graph G is an embedding-preserving drawing that maps each vertex of G to a distinct orthogonal polygon and each edge of G to a vertical or horizontal visibility between its end-vertices. An OPVR Γ has vertex complexity k if every polygon of Γ has at most k reflex corners. A 1-plane graph is an embedded graph such that each edge is crossed at most once. It is known that 3-connected 1-plane graphs admit an OPVR with vertex complexity at most 12, while vertex complexity at least 2 may be required in some cases. In this paper, we reduce this gap by showing that vertex complexity 5 is always sufficient, while vertex complexity 4 may be sometimes required. These results are based on the study of the combinatorial properties of the B-, T-, and W-configurations in 3-connected 1-plane graphs. An implication of the upper bound is the existence of a O ˜ ( n 10 7 ) O˜(n107) -time drawing algorithm that computes an OPVR of an n -vertex 3-connected 1-plane graph on an integer grid of size O ( n ) × O ( n ) O(n)×O(n) and with vertex complexity at most 5.},
  archive      = {J_TCS},
  author       = {Giuseppe Liotta and Fabrizio Montecchiani and Alessandra Tappini},
  doi          = {10.1016/j.tcs.2021.02.018},
  journal      = {Theoretical Computer Science},
  pages        = {40-52},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Ortho-polygon visibility representations of 3-connected 1-plane graphs},
  volume       = {863},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Research on a novel construction of probabilistic visual
cryptography scheme (k,n,0,1,1)−PVCS for threshold access structures.
<em>TCS</em>, <em>863</em>, 19–39. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.010">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we propose new algorithms to construct a probabilistic visual cryptography scheme ( k , n , 0 , 1 , 1 ) − PVCS (k,n,0,1,1)−PVCS for threshold access structures based on the deterministic visual cryptography schemes (DVCS) and classify the probabilistic schemes into online and offline ones according to the reference mode of distribution column vectors. First in consideration of the relationship between DVCS and PVCS we propose a new method for expanded DVCS based on a matrix with binary vectors of V n k Vnk as column vectors so as to construct PVCS without pixel expansion. Then, using the extended DVCS we suggest PVCS construction method which does not require storing of the distribution column vectors and delineate the relationship between our online PVCS and visual cryptograms of random grids (VCRG). We also propose a new infinite tree in order to generate binary vectors of V n k Vnk .},
  archive      = {J_TCS},
  author       = {GwangSu Ju and UnGwang Ko},
  doi          = {10.1016/j.tcs.2021.02.010},
  journal      = {Theoretical Computer Science},
  pages        = {19-39},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Research on a novel construction of probabilistic visual cryptography scheme (k,n,0,1,1)−PVCS for threshold access structures},
  volume       = {863},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Orienteering problem with time-windows and updating delay.
<em>TCS</em>, <em>863</em>, 1–18. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.003">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Orienteering Problem with Time Window and Delay ( OPTiWinD ) is a variant of the online orienteering problem. A series of requests appear in various locations while a vehicle moves within the territory to serve them. Each request has a time window during which it can be served and a weight which describes its importance. There is also a minimum delay T between successive requests. The objective is to find a path for the vehicles that maximises the sum of the weights of the requests served. We further assume that the length of each time window is equal to the diameter of the territory. We study the optimal performance and competitive ratio for the set of instances with n requests. We obtain complete resolution for T at least half of the diameter, small values of T or small values of n , as well as partial results in the remaining cases.},
  archive      = {J_TCS},
  author       = {Marc Demange and David Ellison and Bertrand Jouve},
  doi          = {10.1016/j.tcs.2021.01.003},
  journal      = {Theoretical Computer Science},
  pages        = {1-18},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Orienteering problem with time-windows and updating delay},
  volume       = {863},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021g). Editorial. <em>TCS</em>, <em>862</em>, iii. (<a
href="https://doi.org/10.1016/S0304-3975(21)00138-9">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_TCS},
  author       = {Lila Kari ( Editor-in-Chief )},
  doi          = {10.1016/S0304-3975(21)00138-9},
  journal      = {Theoretical Computer Science},
  pages        = {iii},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Editorial},
  volume       = {862},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Spiking neural p systems with target indications.
<em>TCS</em>, <em>862</em>, 250–261. (<a
href="https://doi.org/10.1016/j.tcs.2020.07.016">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Spiking neural P systems (SNP systems) are a class of distributed and parallel computation models, which are inspired by the way in which neurons process information by means of spikes, where a neuron fires and distributes the spikes to all the neurons linked by synapses with the firing neuron. In this work, a new spike distribution mechanism is introduced, where the produced spikes are distributed to a set of neurons indicated by the target indications. The computation power of SNP systems with this new spike distribution mechanism is investigated. It is demonstrated that SNP systems with such a distribution mechanism are Turing universal as both number generators and function computing devices. Moreover, it is shown that 6 neurons (respectively, 15 neurons) are sufficient for constructing a universal SNP system with the proposed spike distribution mechanism as a number generator (respectively, as a function computing device). By comparing with the classical one, it can be found that the proposed spike distribution mechanism is a powerful feature in terms of the number of neurons used to construct universal SNP systems.},
  archive      = {J_TCS},
  author       = {Tingfang Wu and Luping Zhang and Linqiang Pan},
  doi          = {10.1016/j.tcs.2020.07.016},
  journal      = {Theoretical Computer Science},
  pages        = {250-261},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Spiking neural p systems with target indications},
  volume       = {862},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Proof techniques in membrane computing. <em>TCS</em>,
<em>862</em>, 236–249. (<a
href="https://doi.org/10.1016/j.tcs.2020.09.041">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {From the creation of the field of Membrane Computing in 1998, several research lines have been opened. On the one hand, theoretical questions like the computational power and the computational efficiency of P systems have been studied. In this sense, several techniques to demonstrate the ability of these systems to provide solutions to computational problems have been explored. The study of efficient (polynomial-time) solutions to presumably hard problems for finding thin frontiers of efficiency is a very active area. On the other hand, several applications in biology, ecology, economy, robotics and fault diagnosis, among others, have been investigated. Real systems with some characteristics seem to be easy to model with membrane systems due to their behaviour. In this work, a survey of the theoretical part will be given, explaining techniques both in the field of computability theory and in the field of computational complexity theory .},
  archive      = {J_TCS},
  author       = {David Orellana-Martín and Luis Valencia-Cabrera and Mario J. Pérez-Jiménez},
  doi          = {10.1016/j.tcs.2020.09.041},
  journal      = {Theoretical Computer Science},
  pages        = {236-249},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Proof techniques in membrane computing},
  volume       = {862},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the computing powers of l-reductions of insertion
languages. <em>TCS</em>, <em>862</em>, 224–235. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.029">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We investigate the computing power of the following language operation\%: Given two languages L 1 L1 over Σ and L 2 L2 over Γ with Γ ⊂ Σ Γ⊂Σ , we consider the language operation L 1\% L 2 = { u 0 u 1 ⋯ u n | ∃ u = u 0 v 1 u 1 ⋯ v n u n ∈ L 1 and ∃ v i ∈ L 2 ( 1 ≤ ∀ i ≤ n ) } L1\%L2={u0u1⋯un|∃u=u0v1u1⋯vnun∈L1 and ∃vi∈L2(1≤∀i≤n)} . In this case we say that L ( = L 1\% L 2 ) L(=L1\%L2) is the L 2 L2 -reduction of L 1 L1 . This is extended to the language families as follows: L 1\% L 2 = { L 1\% L 2 | L 1 ∈ L 1 , L 2 ∈ L 2 } L1\%L2={L1\%L2|L1∈L1,L2∈L2} . Among many works concerning Dyck-reductions, for the family of recursively enumerable languages RE RE , it was shown that LIN\% { EQ } = RE LIN\%{EQ}=RE (Jantzen &amp; Petersen, 1994) with EQ = { x n x ‾ n | n ∈ N } EQ={xnx‾n|n∈N} and that min - LIN\% { D 2 } = RE LIN\%{D2}=RE (Hirose &amp; Okawa, 1996, and Latteux &amp; Turakainen, 1990), where LIN LIN and min- LIN LIN are the families of linear and minimal linear context-free languages, respectively. In this paper, we show that each recursively enumerable language L can be represented in the form L = K\% D L=K\%D , for some K ∈ INS 3 0 K∈INS30 and a Dyck language D , where INS ⁎ 0 INS⁎0 ( INS 3 0 INS30 ) denotes the family of insertion languages (insertion languages where the maximum length of the string to be inserted is 3). We can refine it as INS ⁎ 0\% { D 2 } = RE INS⁎0\%{D2}=RE , where D 2 D2 denotes the Dyck language over binary alphabet . For context-free languages, we show that INS 3 0\% F = CF INS30\%F=CF , where F F is the family of finite sets. This also derives that INS ⁎ 0\% { MIR } = CF INS⁎0\%{MIR}=CF with MIR = { x x ‾ R | x ∈ { 0 , 1 } ⁎ } MIR={xx‾R|x∈{0,1}⁎} . Further, for regular languages, it is shown that each regular language R can be represented in the form R = K\% F R=K\%F , for some K ∈ INS 2 0 K∈INS20 and a finite set F = { a b b ‾ a ‾ | a ∈ V } F={abb‾a‾|a∈V} . We also present some results which characterize the computability and properties of L L in the framework of L 2 L2 -reduction of L 1 L1 . It is intriguing to note that, from the DNA computing point of view, the notion of L -reduction is naturally motivated by a molecular biological functioning well-known as DNA(RNA) splicing occurring in most eukaryotic genes.},
  archive      = {J_TCS},
  author       = {Fumiya Okubo and Takashi Yokomori},
  doi          = {10.1016/j.tcs.2020.11.029},
  journal      = {Theoretical Computer Science},
  pages        = {224-235},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On the computing powers of L-reductions of insertion languages},
  volume       = {862},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Filters defined by random contexts versus polarization in
networks of evolutionary processors. <em>TCS</em>, <em>862</em>,
214–223. (<a href="https://doi.org/10.1016/j.tcs.2020.08.003">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The filtering process of Networks of Evolutionary Processors (NEP for short) is regulated by random-context conditions or polarization. Both models, the NEPs with random-context filters and the NEPs with polarization, are computationally complete, hence they are equivalent from the computational power point of view. The computationally completeness results have been obtained by simulations of other universal models like Turing machines and 2-tag systems. We start here the study of a direct simulation between the two models. The main result of this paper is that each NEP with random-context filters can be simulated by NEPs with polarization. Furthermore, the simulation preserves the time complexity and the size of the simulating network depends linearly on the size of the simulated network. The converse simulation remains to be investigated.},
  archive      = {J_TCS},
  author       = {Victor Mitrana and Maria C. Negru},
  doi          = {10.1016/j.tcs.2020.08.003},
  journal      = {Theoretical Computer Science},
  pages        = {214-223},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Filters defined by random contexts versus polarization in networks of evolutionary processors},
  volume       = {862},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Reducing control alphabet size for the control of right
linear grammars with unknown behaviors. <em>TCS</em>, <em>862</em>,
193–213. (<a href="https://doi.org/10.1016/j.tcs.2020.11.051">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper deals with the control problem of right linear grammars with unknown behaviors (RLUBs, for short) in which derivation behavior is not determined completely. In particular, we discuss on the size of control alphabets of control systems which regulate RLUBs in order to generate a target string only. We contribute to the reduction of control alphabet size from O(l) to O(log⁡l) , where l is a parameter related to reaction conditions under which RLUBs are chemically implemented.},
  archive      = {J_TCS},
  author       = {Nobuya Kimoto and Shigetaka Nakamura and Ken Komiya and Kenzo Fujimoto and Satoshi Kobayashi},
  doi          = {10.1016/j.tcs.2020.11.051},
  journal      = {Theoretical Computer Science},
  pages        = {193-213},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Reducing control alphabet size for the control of right linear grammars with unknown behaviors},
  volume       = {862},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Relational structures for concurrent behaviours.
<em>TCS</em>, <em>862</em>, 174–192. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.019">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Relational structures based on acyclic relations can successfully model fundamental aspects of concurrent systems behaviour. Examples include Elementary Net systems and Mazurkiewicz traces. There are however cases where more general relational structures are needed. In this paper, we present a general model of relational structures which can be used for a broad class of concurrent behaviours. We demonstrate how this general set-up works for combined order structures which are based on two relations, viz. an acyclic ‘before’ relation and a possibly cyclic ‘not later than’ relation.},
  archive      = {J_TCS},
  author       = {Ryszard Janicki and Jetty Kleijn and Maciej Koutny and Łukasz Mikulski},
  doi          = {10.1016/j.tcs.2020.10.019},
  journal      = {Theoretical Computer Science},
  pages        = {174-192},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Relational structures for concurrent behaviours},
  volume       = {862},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Fundamental results for learning deterministic extended
finite state machines from queries. <em>TCS</em>, <em>862</em>, 160–173.
(<a href="https://doi.org/10.1016/j.tcs.2020.09.028">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Regular language inference, initiated by Angluin, has many developments, including applications in software engineering and testing. However, the capability of finite automata to model the system data is quite limited and, in many cases, extended finite state machine formalisms, that combine the system control with data structures , are used instead. The application of Angluin-style inference algorithms to extended state machines would involve constructing a minimal deterministic extended finite state machine consistent with a deterministic 3-valued deterministic finite automaton . In addition to the usual, accepting and rejecting, states of finite automaton, a 3-valued deterministic finite automaton may have “don&#39;t care” states; the sequences of inputs that reach such states may be considered as accepted or rejected, as is convenient. The aforementioned construction reduces to finding a minimal deterministic finite automaton consistent with a 3-valued deterministic finite automaton, that preserves the deterministic nature of the extended model that also handles the data structure associated with it. This paper investigates fundamental properties of extended finite state machines in relation to Angluin&#39;s language inference problem and provides an inference algorithm for such models.},
  archive      = {J_TCS},
  author       = {Florentin Ipate and Marian Gheorghe and Raluca Lefticaru},
  doi          = {10.1016/j.tcs.2020.09.028},
  journal      = {Theoretical Computer Science},
  pages        = {160-173},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Fundamental results for learning deterministic extended finite state machines from queries},
  volume       = {862},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Disposability in square-free words. <em>TCS</em>,
<em>862</em>, 155–159. (<a
href="https://doi.org/10.1016/j.tcs.2020.07.030">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider words w over the alphabet Σ = { 0 , 1 , 2 } Σ={0,1,2} . It is shown that there are irreducibly square-free words of all lengths n except 4,5,7 and 12. Such a word is square-free (i.e., it has no repetitions uu as factors), but by removing any one internal letter creates a square in the word.},
  archive      = {J_TCS},
  author       = {Tero Harju},
  doi          = {10.1016/j.tcs.2020.07.030},
  journal      = {Theoretical Computer Science},
  pages        = {155-159},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Disposability in square-free words},
  volume       = {862},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Closest substring problems for regular languages.
<em>TCS</em>, <em>862</em>, 144–154. (<a
href="https://doi.org/10.1016/j.tcs.2020.09.005">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Closest Substring problem asks whether there exists a consensus string w of given length ℓ such that each string in a set of strings L has a substring whose edit distance is at most r (called the radius) from w . The Closest Substring problem has been studied for finite sets of strings and is known to be NP -hard. We show that the Closest Substring problem for regular languages represented by nondeterministic finite automata (NFA) is PSPACE -complete. The problem remains PSPACE -hard even when the input is a deterministic finite automaton and the length ℓ and radius r are given in unary. Also we show that the Closest Substring problem for acyclic NFAs lies in the second level of the polynomial-time hierarchy and is both NP -hard and coNP -hard.},
  archive      = {J_TCS},
  author       = {Yo-Sub Han and Sang-Ki Ko and Timothy Ng and Kai Salomaa},
  doi          = {10.1016/j.tcs.2020.09.005},
  journal      = {Theoretical Computer Science},
  pages        = {144-154},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Closest substring problems for regular languages},
  volume       = {862},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Emergence of random selections in evolution of biological
populations. <em>TCS</em>, <em>862</em>, 130–143. (<a
href="https://doi.org/10.1016/j.tcs.2020.08.027">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {If a biological population is fragmented in small isolated groups, there may emerge an evolution phenomenon independent from natural selection. Limited number of individuals and their isolation allow a completely random variation in their genetic frequencies, in such a way to have the predominance of some genes and the disappearance of others in next generations, independently on the convenience of the predominant genes for the individuals. This statistical phenomenon is called founder effect, or bottleneck effect (in ecological dynamics). As an advancement in the study of dynamics of bio-molecular populations, and more in general of biological growing, in this paper we focus on the statistical phenomenon that a small sample of a heterogeneous population of species has a distribution of the species different than that in the original population, and independently on the initial distribution, after few steps of sampling and growing, an homogeneous population emerges, where only one of the initial species is present. This phenomenon is strictly related to the founder effect, attested in species evolution, which describes what happens when a few individuals of a population live isolated for several generations: a new colony is generated by a dominant (called founder) species. In this work we propose a mathematical framework (inspired by the Good Turing estimator) for the above phenomenon, and show its emergence also in molecular and bacterial systems, where generations are observable in short times, and the convergence of the population distribution to a single species (in population genetics this process is called fixation) may be achieved in few operational steps. Some DNA based experiments which exhibit this phenomenon are here presented, together with a couple of experiments carried on bacterial systems of genetically modified E.coli strains. Therefore, a relevant evolutionary phenomenon, already confirmed in the literature of population genetics and species evolution, is here mathematically proved and for the first time observed also in (guided) evolution of nano and micro scale biological populations.},
  archive      = {J_TCS},
  author       = {Giuditta Franco and Vincenzo Manca and Marco Andreolli and Silvia Lampis},
  doi          = {10.1016/j.tcs.2020.08.027},
  journal      = {Theoretical Computer Science},
  pages        = {130-143},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Emergence of random selections in evolution of biological populations},
  volume       = {862},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Remarks on external contextual grammars with selection.
<em>TCS</em>, <em>862</em>, 119–129. (<a
href="https://doi.org/10.1016/j.tcs.2020.07.028">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In an external contextual grammar with selection, contexts are associated with selection languages, and the context ( u , v ) (u,v) can be wrapped around a word w if and only if w belongs to the selection language associated with ( u , v ) (u,v) . In the papers [1] , [3] , [4] , and [6] , some hierarchies are presented if selection languages are taken from subregular language families, defined by automata-theoretic and combinatorial properties, codes, and ideals. In this paper we merge and complete the hierarchies.},
  archive      = {J_TCS},
  author       = {Jürgen Dassow},
  doi          = {10.1016/j.tcs.2020.07.028},
  journal      = {Theoretical Computer Science},
  pages        = {119-129},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Remarks on external contextual grammars with selection},
  volume       = {862},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Relationships between bounded languages, counter machines,
finite-index grammars, ambiguity, and commutative regularity.
<em>TCS</em>, <em>862</em>, 97–118. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.006">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {It is shown that for every language family that is a trio containing only semilinear languages, all bounded languages in it can be accepted by one-way deterministic reversal-bounded multicounter machines ( DCM ). This implies that for every semilinear trio (where these properties are effective), it is possible to decide containment, equivalence, and disjointness concerning its bounded languages. A condition is also provided for when the bounded languages in a semilinear trio coincide exactly with those accepted by DCM machines, and it is used to show that many grammar systems of finite index — such as finite-index matrix grammars ( M fin ) and finite-index ET0L ( ET0L fin ) — have identical bounded languages as DCM . Then connections between ambiguity, counting regularity, and commutative regularity are made, as many machines and grammars that are unambiguous can only generate/accept counting regular or commutatively regular languages. Thus, such a system that can generate/accept a non-counting regular or non-commutatively regular language implies the existence of inherently ambiguous languages over that system. In addition, it is shown that every language generated by an unambiguous M fin has a rational characteristic series in commutative variables, and is counting regular. This result plus the connections are used to demonstrate that the grammar systems M fin and ET0L fin can generate inherently ambiguous languages (over their grammars), as do several machine models. It is also shown that all bounded languages generated by these two grammar systems (those in any semilinear trio) can be generated unambiguously within the systems. Finally, conditions on M fin and ET0L fin languages implying commutative regularity are obtained. In particular, it is shown that every finite-index ED0L language is commutatively regular.},
  archive      = {J_TCS},
  author       = {Arturo Carpi and Flavio D&#39;Alessandro and Oscar H. Ibarra and Ian McQuillan},
  doi          = {10.1016/j.tcs.2020.10.006},
  journal      = {Theoretical Computer Science},
  pages        = {97-118},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Relationships between bounded languages, counter machines, finite-index grammars, ambiguity, and commutative regularity},
  volume       = {862},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the advice complexity of the online dominating set
problem. <em>TCS</em>, <em>862</em>, 81–96. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.022">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A dominating set S of a graph is a set of vertices such that each vertex is in S or has a neighbor in S . The goal of the dominating set problem is to find such a set of minimum cardinality. In the online setting, the graph is revealed vertex by vertex, together with edges to all previously revealed vertices. Advice complexity is a framework to measure the amount of information an online algorithm is lacking. Here, an online algorithm reads advice bits from an infinite binary tape prepared beforehand by an all-knowing oracle. The advice complexity is the total number of advice bits read during the computation. Besides giving some insight into what makes an online problem hard, advice complexity can also be used as a means for proving lower bounds on the competitive ratio achievable by randomized online algorithms. We analyze the advice complexity of the online dominating set problem. For general graphs, we show tight upper and lower bounds for optimality . Then, we use a result for c -competitiveness to prove that no randomized online algorithm can be better than n 1 − ε n1−ε -competitive, for any ε &gt; 0 ε&amp;gt;0 . Finally, we analyze the advice complexity of various graph classes for optimality.},
  archive      = {J_TCS},
  author       = {Hans-Joachim Böckenhauer and Juraj Hromkovič and Sacha Krug and Walter Unger},
  doi          = {10.1016/j.tcs.2021.01.022},
  journal      = {Theoretical Computer Science},
  pages        = {81-96},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On the advice complexity of the online dominating set problem},
  volume       = {862},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021a). A compositional view of derivations as interactive
processes with applications to regulated and distributed rewriting.
<em>TCS</em>, <em>862</em>, 59–80. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.035">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The derivation process in rewriting systems , especially in Chomskyan grammars, can be seen as consisting of four stages: (1) selection of the production to apply from a supply of productions available at that step, (2) check of applicability of the production, possibly on different matches, (3) selection of the match at which to apply the production, (4) actual application. In this paper, we explore the different ways in which models of regulated and distributed rewriting have extended these four basic mechanisms and we propose a unifying perspective on them in terms of interaction between two agents, expressed through a particular form of conditional rewriting systems . This introduces a compositional view of derivation processes, where different components, playing specific roles and exhibiting specific behaviours, can be made to communicate and combined into different models of derivation. Existing models of regulated and distributed rewriting can thus be reformulated in this new framework, and new ones can be obtained.},
  archive      = {J_TCS},
  author       = {Paolo Bottoni and Anna Labella},
  doi          = {10.1016/j.tcs.2020.10.035},
  journal      = {Theoretical Computer Science},
  pages        = {59-80},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A compositional view of derivations as interactive processes with applications to regulated and distributed rewriting},
  volume       = {862},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Computing the multi-string BWT and LCP array in external
memory. <em>TCS</em>, <em>862</em>, 42–58. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.041">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Indexing very large collections of strings, such as those produced by the widespread next generation sequencing technologies, heavily relies on multi-string generalization of the Burrows–Wheeler Transform (BWT): large requirements of in-memory approaches have stimulated recent developments on external memory algorithms. The related problem of computing the Longest Common Prefix (LCP) array of a set of strings is instrumental to compute the suffix-prefix overlaps among strings, which is an essential step for many genome assembly algorithms. In a previous paper, we presented an in-memory divide-and-conquer method for building the BWT and LCP where we merge partial BWTs with a forward approach to sort suffixes. In this paper, we propose an alternative backward strategy to develop an external memory method to simultaneously build the BWT and the LCP array on a collection of m strings of different lengths. The algorithm over a set of strings having constant length k has O ( m k l ) O(mkl) time and I/O volume, using O ( k + m ) O(k+m) main memory, where l is the maximum value in the LCP array.},
  archive      = {J_TCS},
  author       = {Paola Bonizzoni and Gianluca Della Vedova and Yuri Pirola and Marco Previtali and Raffaella Rizzi},
  doi          = {10.1016/j.tcs.2020.11.041},
  journal      = {Theoretical Computer Science},
  pages        = {42-58},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Computing the multi-string BWT and LCP array in external memory},
  volume       = {862},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the longest common prefix of suffixes in an inverse
lyndon factorization and other properties. <em>TCS</em>, <em>862</em>,
24–41. (<a href="https://doi.org/10.1016/j.tcs.2020.10.034">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Lyndon factorization of a word has been largely studied and recently variants of it have been introduced and investigated with different motivations. In particular, the canonical inverse Lyndon factorization ICFL ( w ) ICFL(w) of a word w , introduced in [1] , maintains the main properties of the Lyndon factorization since it can be computed in linear time and it is uniquely determined. In this paper we investigate new properties of this factorization with the aim of exploring their use in some classical queries on w . The main property we prove is related to a classical query on words. We prove that there are relations between the length of the longest common prefix (or longest common extension) lcp ( x , y ) lcp(x,y) of two different suffixes x , y x,y of a word w and the maximum length M M of two consecutive factors of ICFL ( w ) ICFL(w) . More precisely, M M is an upper bound on the length of lcp ( x , y ) lcp(x,y) . A main tool used in the proof of the above result is a property that we state for factors m i mi with nonempty borders in ICFL ( w ) ICFL(w) : a nonempty border of m i mi cannot be a prefix of the next factor m i + 1 mi+1 . Another interesting result relates sorting of global suffixes, i.e., suffixes of a word w , and sorting of local suffixes, i.e., suffixes of products of factors in ICFL ( w ) ICFL(w) . This is the counterpart for ICFL ( w ) ICFL(w) of the compatibility property, proved in [2] , [3] for the Lyndon factorization. Roughly, the compatibility property allows us to extend the mutual order between suffixes of products of the (inverse) Lyndon factors to the suffixes of the whole word. The last property we prove focuses on the Lyndon factorizations of a word and its factors. It suggests that the Lyndon factorizations of two words sharing a common overlap could be used to capture the common overlap of these two words.},
  archive      = {J_TCS},
  author       = {Paola Bonizzoni and Clelia De Felice and Rocco Zaccagnino and Rosalba Zizza},
  doi          = {10.1016/j.tcs.2020.10.034},
  journal      = {Theoretical Computer Science},
  pages        = {24-41},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On the longest common prefix of suffixes in an inverse lyndon factorization and other properties},
  volume       = {862},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Small SNQ p systems with multiple types of spikes.
<em>TCS</em>, <em>862</em>, 14–23. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.014">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We partially answer an open question on small computational devices: how many neurons are needed by a spiking neural P system with communication on request (SNQ P Systems) to achieve universality? We provide an answer in the case when the SNQ P System uses at least 5 types of spikes. Our work shows that 6 neurons are enough to achieve universality as number generators , number accepters and function computation device. We achieve this result by using only two neuron to simulate the instructions labels and one type of spike to emulate a register.},
  archive      = {J_TCS},
  author       = {Florin-Daniel Bîlbîe and Andrei Păun},
  doi          = {10.1016/j.tcs.2020.10.014},
  journal      = {Theoretical Computer Science},
  pages        = {14-23},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Small SNQ p systems with multiple types of spikes},
  volume       = {862},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A new quantum random number generator certified by value
indefiniteness. <em>TCS</em>, <em>862</em>, 3–13. (<a
href="https://doi.org/10.1016/j.tcs.2020.08.014">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper we propose a new ternary QRNG based on measuring located value indefinite observables with probabilities 1 / 4 , 1 / 2 , 1 / 4 1/4,1/2,1/4 and prove that every sequence generated is maximally unpredictable, 3-bi-immune (a stronger form of bi-immunity), and its prefixes are Borel normal. The ternary quantum random digits produced by the QRNG are algorithmically transformed into quantum random bits using an alphabetic morphism which preserves all the above properties.},
  archive      = {J_TCS},
  author       = {José Manuel Agüero Trejo and Cristian S. Calude},
  doi          = {10.1016/j.tcs.2020.08.014},
  journal      = {Theoretical Computer Science},
  pages        = {3-13},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A new quantum random number generator certified by value indefiniteness},
  volume       = {862},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A fascinating rainbow of computation – honoring gheorghe
păun on the occasion of his 70th birthday. <em>TCS</em>, <em>862</em>,
1–2. (<a href="https://doi.org/10.1016/j.tcs.2021.02.041">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_TCS},
  author       = {Lila Kari and Ion Petre and Grzegorz Rozenberg and Arto Salomaa},
  doi          = {10.1016/j.tcs.2021.02.041},
  journal      = {Theoretical Computer Science},
  pages        = {1-2},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A fascinating rainbow of computation – honoring gheorghe păun on the occasion of his 70th birthday},
  volume       = {862},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Constrained routing between non-visible vertices.
<em>TCS</em>, <em>861</em>, 144–154. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.017">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper we study local routing strategies on geometric graphs . Such strategies use geometric properties of the graph like the coordinates of the current and target nodes to route. Specifically, we study routing strategies in the presence of constraints which are obstacles that edges of the graph are not allowed to cross. Let P be a set of n points in the plane and let S be a set of line segments whose endpoints are in P , with no two line segments intersecting properly. We present the first deterministic 1-local O ( 1 ) O(1) -memory routing algorithm that is guaranteed to find a path between two vertices in the visibility graph of P with respect to a set of constraints S . The strategy never looks beyond the direct neighbors of the current node and does not store more than O ( 1 ) O(1) -information to reach the target. We then turn our attention to finding competitive routing strategies. We show that when routing on any triangulation T of P such that S ⊆ T S⊆T , no o ( n ) o(n) -competitive routing algorithm exists when the routing strategy restricts its attention to the triangles intersected by the line segment from the source to the target (a technique commonly used in the unconstrained setting). Finally, we provide an O ( n ) O(n) -competitive deterministic 1-local O ( 1 ) O(1) -memory routing algorithm on any such T , which is optimal in the worst case, given the lower bound.},
  archive      = {J_TCS},
  author       = {Prosenjit Bose and Matias Korman and André van Renssen and Sander Verdonschot},
  doi          = {10.1016/j.tcs.2021.02.017},
  journal      = {Theoretical Computer Science},
  pages        = {144-154},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Constrained routing between non-visible vertices},
  volume       = {861},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). New results on multi-level aggregation. <em>TCS</em>,
<em>861</em>, 133–143. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.016">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In the Multi-Level Aggregation Problem ( MLAP ), requests for service arrive at the nodes of an edge-weighted rooted tree T T . Each service is represented by a subtree X of T T that contains its root. This subtree X serves all requests that are pending in the nodes of X , and the cost of this service is equal to the total weight of X . Each request also incurs a waiting cost between its arrival and service time. The objective is to minimize the total waiting cost of all requests plus the total cost of all service subtrees. The currently best online algorithms for the MLAP achieve competitive ratios polynomial in the tree depth, while the best lower bound is only 3.618. In this paper, we report some progress towards closing this gap, by improving this lower bound and providing several tight bounds for restricted variants of MLAP : (1) We first study a Single-Phase variant of MLAP where all requests are released at the beginning and expire at some unknown time θ , for which we provide an online algorithm with optimal competitive ratio of 4. (2) We prove a lower bound of 4 on the competitive ratio for MLAP , even when the tree is a path. We complement this with a matching upper bound for the deadline variant of MLAP on paths. Additionally, we provide two results for the offline case: (3) We prove that the Single-Phase variant can be solved optimally in polynomial time , and (4) we give a simple 2-approximation algorithm for offline MLAP with deadlines.},
  archive      = {J_TCS},
  author       = {Marcin Bienkowski and Martin Böhm and Jaroslaw Byrka and Marek Chrobak and Christoph Dürr and Lukáš Folwarczný and Łukasz Jeż and Jiří Sgall and Nguyen Kim Thang and Pavel Veselý},
  doi          = {10.1016/j.tcs.2021.02.016},
  journal      = {Theoretical Computer Science},
  pages        = {133-143},
  shortjournal = {Theor. Comput. Sci.},
  title        = {New results on multi-level aggregation},
  volume       = {861},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Identity-based encryption with equality test and
datestamp-based authorization mechanism. <em>TCS</em>, <em>861</em>,
117–132. (<a href="https://doi.org/10.1016/j.tcs.2021.02.015">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Due to the advancement of cloud computing , public key encryption with equality test has become a hot topic in the cryptography community. The notion was extended to the identity-based setting to obtain a new primitive, called identity-based encryption with equality test (IBEET). To the best of our knowledge, there are two categories of authorization mechanisms for IBEET: ciphertext-specified authorization and user-specified authorization. However, these authorizations are not applicable for some scenarios. Motivated by this, we propose in this paper a new primitive, called identity-based encryption with equality test and datestamp-based authorization mechanism (IBEET-DBA). In the primitive, the data owner can control the validity of trapdoor by embedding datestamp into it. The cloud server can only obtain the correct equivalence results on the ciphertexts which are generated within the valid period of trapdoor. In this paper, we formally define this primitive and its security notion. Moreover, we propose the first IBEET-DBA scheme and prove its security.},
  archive      = {J_TCS},
  author       = {Xi-Jun Lin and Qihui Wang and Lin Sun and Haipeng Qu},
  doi          = {10.1016/j.tcs.2021.02.015},
  journal      = {Theoretical Computer Science},
  pages        = {117-132},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Identity-based encryption with equality test and datestamp-based authorization mechanism},
  volume       = {861},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Rumor correction maximization problem in social networks.
<em>TCS</em>, <em>861</em>, 102–116. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.014">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Admittedly, innovations can spread rapidly in online social networks , while the spread of malicious rumors can lead to a series of negative consequences. Therefore, it is necessary to take effective measures to limit the influence of negative information. In reality, people will become an adopter of innovations after being influenced by their friends. Meanwhile, they can be more likely to become a follower if they have received relevant information in advance. Motivated by these observations, we study the rumor correction maximization problem using both seed and boost nodes. We first focus on the boost nodes and propose the Boosting Rumor Correction Maximization (BRCM) problem under the Boosting Independent Cascade model. We prove that the BRCM problem is NP-hard, and the objective function is non-submodular. To handle it, we devise an efficient algorithm with a data-dependent approximation ratio. To explore the seed nodes, the Seed Selection problem and Minimum Seed Selection problem are proposed, respectively. Accordingly, we design two efficient algorithms. Finally, extensive empirical results in three networks manifest the efficiency of our approaches and show superiority over other baselines.},
  archive      = {J_TCS},
  author       = {Yapu Zhang and Wenguo Yang and Ding-Zhu Du},
  doi          = {10.1016/j.tcs.2021.02.014},
  journal      = {Theoretical Computer Science},
  pages        = {102-116},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Rumor correction maximization problem in social networks},
  volume       = {861},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Color-spanning localized query. <em>TCS</em>, <em>861</em>,
85–101. (<a href="https://doi.org/10.1016/j.tcs.2021.02.013">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Let P be a set of n points, where each point is colored with one of the k possible colors. We present efficient algorithms to preprocess P such that for a given query point q , we can quickly identify the smallest color spanning object of the desired type containing q . In this paper, we focus on ( i ) intervals, (ii) axis-parallel square, ( i i i ) (iii) axis-parallel rectangle, ( i v ) (iv) equilateral triangle of fixed orientation and ( v ) circle, as our desired type of objects.},
  archive      = {J_TCS},
  author       = {Ankush Acharyya and Anil Maheshwari and Subhas C. Nandy},
  doi          = {10.1016/j.tcs.2021.02.013},
  journal      = {Theoretical Computer Science},
  pages        = {85-101},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Color-spanning localized query},
  volume       = {861},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The generalized measure of edge fault tolerance in exchanged
crossed cube. <em>TCS</em>, <em>861</em>, 80–84. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.012">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This work considers the h -edge connectivity to measure the fault tolerance of exchanged crossed cube E C Q ( s , t ) ECQ(s,t) , an attractive variant network of hypercube . We get that the h -edge connectivity of E C Q ( s , t ) ECQ(s,t) is 2 h ( s − h + 1 ) 2h(s−h+1) if 0 ≤ h ≤ s − 1 0≤h≤s−1 . It implies that at least 2 h ( s − h + 1 ) 2h(s−h+1) edges have to be removed from E C Q ( s , t ) ECQ(s,t) to get a disconnected graph that contains no vertices with degree less than h .},
  archive      = {J_TCS},
  author       = {Wantao Ning and Hao Li},
  doi          = {10.1016/j.tcs.2021.02.012},
  journal      = {Theoretical Computer Science},
  pages        = {80-84},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The generalized measure of edge fault tolerance in exchanged crossed cube},
  volume       = {861},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). An EPTAS for scheduling fork-join graphs with communication
delay. <em>TCS</em>, <em>861</em>, 66–79. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.011">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper presents an EPTAS for scheduling fork-join task graphs with communication delay on homogeneous processors, denoted as P | fork-join , c i j | C m a x P|fork-join,cij|Cmax in the α | β | γ α|β|γ -notation. The fork-join structure is a basic structure found in many parallel computations. The algorithm uses an integer program as the feasibility test and searches for a solution which would be guaranteed to be within a 1 + ϵ 1+ϵ factor of the optimum. It is shown that this runs in time exponential in terms of 1 / ϵ 1/ϵ and polynomial in terms of the input size. Communication costs are dealt with effectively for this fork-join graph structure. The EPTAS is also adapted to scheduling independent tasks with release times and deadlines, which is denoted as P | r j | L m a x P|rj|Lmax .},
  archive      = {J_TCS},
  author       = {Klaus Jansen and Oliver Sinnen and Huijun Wang},
  doi          = {10.1016/j.tcs.2021.02.011},
  journal      = {Theoretical Computer Science},
  pages        = {66-79},
  shortjournal = {Theor. Comput. Sci.},
  title        = {An EPTAS for scheduling fork-join graphs with communication delay},
  volume       = {861},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Gossiping by energy-constrained mobile agents in tree
networks. <em>TCS</em>, <em>861</em>, 45–65. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.009">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Every node of an edge-weighted tree network contains a data packet. At some nodes are placed mobile agents , each one possessing an amount of energy (not necessarily the same for all agents). While walking along the network, the agents spend the energy proportionally to the distance traveled and collect copies of the data packets present at the visited network nodes. An agent visiting a node deposits there copies of all currently possessed data packets and collects a copy of every data packet present at this node. Two agents meeting at a node may exchange any amount of currently possessed energy. The gossiping problem asks whether it is possible to achieve that a copy of the original data packet of each node may reach every other node of the network. We prove that the gossiping problem can be solved in time O ( k 2 n 2 ) O(k2n2) for an n -node tree network T , where k is the number of agents. Moreover, we prove that in order to compute a gossiping strategy, it is enough to start with a minimum-cost convergecast that ends with all data packets and all remaining energy being present at some node of T , and then finish with a minimum-cost broadcast from this configuration. Thus, we obtain two structural properties of the gossiping problem. First, if a gossiping is feasible and r is the first node receiving all information, then there is one that is a concatenation of a convergecast to r and a broadcast from r . Secondly, it is sufficient to consider only optimal convergecast strategies. This is natural to expect but hard to prove, as locations of agents after a convergecast (moved in this stage) are essential. Hence, the convergecast has to be optimal with regards to both spent energy as well as the resulting configuration of agents, which matters in the next stage.},
  archive      = {J_TCS},
  author       = {Jurek Czyzowicz and Dariusz Dereniowski and Robert Ostrowski and Wojciech Rytter},
  doi          = {10.1016/j.tcs.2021.02.009},
  journal      = {Theoretical Computer Science},
  pages        = {45-65},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Gossiping by energy-constrained mobile agents in tree networks},
  volume       = {861},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021b). Short labeling schemes for topology recognition in wireless
tree networks. <em>TCS</em>, <em>861</em>, 23–44. (<a
href="https://doi.org/10.1016/j.tcs.2021.02.008">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider the problem of topology recognition in wireless (radio) networks modeled as undirected graphs . Topology recognition is a fundamental task in which every node of the network has to output a map of the underlying graph i.e., an isomorphic copy of it, and situate itself in this map. In wireless networks, nodes communicate in synchronous rounds. In each round a node can either transmit a message to all its neighbors, or stay silent and listen. At the receiving end, a node v hears a message from a neighbor w in a given round, if v listens in this round, and if w is its only neighbor that transmits in this round. Nodes have labels which are (not necessarily different) binary strings. Each node knows its label and can use it when executing the algorithm. The length of a labeling scheme is the largest length of a label. We concentrate on wireless networks modeled by trees, and we investigate two problems. Our upper bounds are proven by constructing a topology recognition algorithm using a labeling scheme of length O ( log ⁡ log ⁡ Δ ) O(log⁡log⁡Δ) and using time O ( D Δ ) O(DΔ) . Our lower bounds are proven by constructing a class of trees for which any topology recognition algorithm must use a labeling scheme of length at least Ω ( log ⁡ log ⁡ Δ ) Ω(log⁡log⁡Δ) , and a class of trees for which any topology recognition algorithm using a labeling scheme of length O ( log ⁡ log ⁡ Δ ) O(log⁡log⁡Δ) must use time at least Ω ( D Δ ϵ ) Ω(DΔϵ) , on some tree of this class.},
  archive      = {J_TCS},
  author       = {Barun Gorain and Andrzej Pelc},
  doi          = {10.1016/j.tcs.2021.02.008},
  journal      = {Theoretical Computer Science},
  pages        = {23-44},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Short labeling schemes for topology recognition in wireless tree networks},
  volume       = {861},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On dispersable book embeddings. <em>TCS</em>, <em>861</em>,
1–22. (<a href="https://doi.org/10.1016/j.tcs.2021.01.035">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In a dispersable book embedding , the vertices of a given graph G must be ordered along a line ℓ , called spine , and the edges of G must be drawn in different half-planes bounded by ℓ , called pages of the book , such that: (i) no two edges of the same page cross, and (ii) the graph induced by the edges of each page is 1-regular (or equivalently, a matching). The minimum number of pages needed by any dispersable book embedding of G is referred to as the dispersable book thickness d b t ( G ) of G . Graph G is called dispersable if d b t ( G ) = Δ ( G ) holds (note that Δ ( G ) ≤ d b t ( G ) always holds). Back in 1979, Bernhart and Kainen conjectured that any Δ-regular bipartite graph G is dispersable, i.e., d b t ( G ) = Δ . In this paper, we employ a counting argument to disprove this conjecture for any fixed value of Δ ≥ 3 . Additionally, for the cases Δ = 3 and Δ = 4 we present concrete counterexamples to the conjecture. In particular, we show that the Gray graph, which is 3-regular and bipartite, has dispersable book thickness four (with a computer-aided proof), while the Folkman graph, which is 4-regular and bipartite, has dispersable book thickness five (with a purely combinatorial proof). On the positive side, we prove that 3-regular bipartite planar graphs are dispersable.},
  archive      = {J_TCS},
  author       = {Jawaherul Md. Alam and Michael A. Bekos and Vida Dujmović and Martin Gronemann and Michael Kaufmann and Sergey Pupyrev},
  doi          = {10.1016/j.tcs.2021.01.035},
  journal      = {Theoretical Computer Science},
  pages        = {1-22},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On dispersable book embeddings},
  volume       = {861},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). “Green” barrier coverage with mobile sensors. <em>TCS</em>,
<em>860</em>, 117–134. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.034">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Mobile sensors are located on a barrier represented by a line segment. Each sensor has a single energy source that can be used for both moving and sensing. A sensor consumes energy in movement in proportion to distance traveled, and it expends energy per time unit for sensing in direct proportion to its radius raised to a constant exponent. We address the problem of energy efficient coverage. The input consists of the initial locations of the sensors and a coverage time requirement t . A feasible solution consists of an assignment of destinations and coverage radii to all sensors such that the barrier is covered. We consider two variants of the problem that are distinguished by whether the radii are given as part of the input. In the fixed radii case, we are also given a radii vector ρ , and the radii assignment r must satisfy r i ∈ { 0 , ρ i } ri∈{0,ρi} , for every i , while in the variable radii case the radii assignment is unrestricted. The goal is to cover the barrier for t time in an energy efficient manner. More specifically, we consider two objective functions. In the first the goal is to minimize the sum of the energy spent by all sensors and in the second the goal is to minimize the maximum energy used by any sensor. We present fully polynomial time approximation schemes for the problem of minimizing the energy sum with variable radii and for the problem of minimizing the maximum energy with variable radii. We also show that the latter can be approximated within any additive constant ε &gt; 0 ε&amp;gt;0 . We present a 2-approximation algorithm for the problem of minimizing the maximum energy with fixed radii which also is shown to be strongly NP-hard. We show that the problem of minimizing the energy sum with fixed radii cannot be approximated within a factor of O ( n c ) O(nc) , for any constant c , unless P = NP. Additional results are given for three special cases: (i) sensors are stationary, (ii) free movement, and (iii) uniform fixed radii.},
  archive      = {J_TCS},
  author       = {Amotz Bar-Noy and Thomas Erlebach and Dror Rawitz and Peter Terlecky},
  doi          = {10.1016/j.tcs.2021.01.034},
  journal      = {Theoretical Computer Science},
  pages        = {117-134},
  shortjournal = {Theor. Comput. Sci.},
  title        = {“Green” barrier coverage with mobile sensors},
  volume       = {860},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Paths to trees and cacti. <em>TCS</em>, <em>860</em>,
98–116. (<a href="https://doi.org/10.1016/j.tcs.2021.01.033">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We know that Tree Contraction does not admit a polynomial kernel unless NP ⊆ coNP/poly , while Path Contraction admits a kernel with O ( k ) O(k) vertices. The starting point of this article is the following natural questions: What is the structure of the family of paths that allows Path Contraction to admit a polynomial kernel? Apart from the size of the solution, what other additional parameters should we consider so we can design polynomial kernels for these basic contraction problems? To design polynomial kernels, we consider the family of trees with the bounded number of leaves (note that the family of paths are trees with at most two leaves). In particular, we study Bounded Tree Contraction . Here, an input is a graph G , integers k and ℓ , and the goal is to decide whether, there is a subset F ⊆ E ( G ) F⊆E(G) of size at most k such that G / F G/F is a tree with at most ℓ leaves. We design a kernel with O ( k ℓ ) O(kℓ) vertices and O ( k 2 + k ℓ ) O(k2+kℓ) edges for this problem. We complement this result by giving kernelization lower bound. We also prove similar results for Bounded Out-Tree Contraction and Bounded Cactus Contraction .},
  archive      = {J_TCS},
  author       = {Akanksha Agrawal and Lawqueen Kanesh and Saket Saurabh and Prafullkumar Tale},
  doi          = {10.1016/j.tcs.2021.01.033},
  journal      = {Theoretical Computer Science},
  pages        = {98-116},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Paths to trees and cacti},
  volume       = {860},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The complexity of (e+var)-equilibria, ESR-equilibria, and
SuperE-equilibria for 2-players games with few cost values.
<em>TCS</em>, <em>860</em>, 84–97. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.031">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider 2-players minimization games with very few cost values. Players are risk-averse and play mixed strategies. The players care about minimizing some function other than expectation or minimizing expectation with additional properties: Expectation plus Variance ( E+Var ), or Extended Sharpe Ratio ( ESR ), or Expectation ( E ) with the additional property that Variance is zero ( Var=0 ). These give rise to ( E+Var )- equilibria , to ESR -equilibria , and to SuperE -equilibria , respectively: in an (E+Var) -equilibrium, no player could unilaterally reduce her ( E+Var )-cost; in an ESR -equilibrium, no player could unilaterally reduce her ESR -cost; in a SuperE -equilibrium, Var =0 and no player could unilaterally reduce her E -cost. We show two complexity results:},
  archive      = {J_TCS},
  author       = {Chryssis Georgiou and Marios Mavronicolas and Burkhard Monien},
  doi          = {10.1016/j.tcs.2021.01.031},
  journal      = {Theoretical Computer Science},
  pages        = {84-97},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The complexity of (E+Var)-equilibria, ESR-equilibria, and SuperE-equilibria for 2-players games with few cost values},
  volume       = {860},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Direct product primality testing of graphs is GI-hard.
<em>TCS</em>, <em>860</em>, 72–83. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.029">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We investigate the computational complexity of the graph primality testing problem with respect to the direct product (also known as Kronecker, cardinal or tensor product). In [1] Imrich proves that both primality testing and a unique prime factorization can be determined in polynomial time for (finite) connected and nonbipartite graphs. The author states as an open problem how results on the direct product of nonbipartite, connected graphs extend to bipartite connected graphs and to disconnected ones. In this paper we partially answer this question by proving that the graph isomorphism problem is polynomial-time many-one reducible to the graph compositeness testing problem (the complement of the graph primality testing problem). As a consequence of this result, we prove that the graph isomorphism problem is polynomial-time Turing reducible to the primality testing problem. Our results show that connectedness plays a crucial role in determining the computational complexity of the graph primality testing problem.},
  archive      = {J_TCS},
  author       = {Luca Calderoni and Luciano Margara and Moreno Marzolla},
  doi          = {10.1016/j.tcs.2021.01.029},
  journal      = {Theoretical Computer Science},
  pages        = {72-83},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Direct product primality testing of graphs is GI-hard},
  volume       = {860},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Graph isomorphism restricted by lists. <em>TCS</em>,
<em>860</em>, 51–71. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.027">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The complexity of graph isomorphism ( GraphIso ) is a famous problem in computer science. For graphs G and H , it asks whether they are the same up to a relabeling of vertices. In 1981, Lubiw proved that list restricted graph isomorphism ( ListIso ) is NP -complete: for each u ∈ V ( G ) u∈V(G) , we are given a list L ( u ) ⊆ V ( H ) L(u)⊆V(H) of possible images of u . After 35 years, we revive the study of this problem and consider which results for GraphIso can be modified to solve ListIso . We prove: 1) Under certain conditions, GI -completeness of a class of graphs implies NP -completeness of ListIso . 2) Several combinatorial algorithms for GraphIso can be modified to solve ListIso : for trees, planar graphs , interval graphs , circle graphs , permutation graphs, and bounded treewidth graphs. 3) ListIso is NP -complete for cubic colored graphs with sizes of color classes bounded by 8 with all lists of size at most 3.},
  archive      = {J_TCS},
  author       = {Pavel Klavík and Dušan Knop and Peter Zeman},
  doi          = {10.1016/j.tcs.2021.01.027},
  journal      = {Theoretical Computer Science},
  pages        = {51-71},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Graph isomorphism restricted by lists},
  volume       = {860},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the approximability of robust network design.
<em>TCS</em>, <em>860</em>, 41–50. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.026">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Given the dynamic nature of traffic, we investigate the variant of robust network design where we have to determine the capacity to reserve on each link so that each demand vector belonging to a polyhedral set can be routed. The objective is either to minimize congestion or a linear cost. Routing is assumed to be fractional and dynamic (i.e., dependent on the current traffic vector). We first prove that the robust network design problem with minimum congestion cannot be approximated within any constant factor. Then, using the ETH conjecture, we get a Ω ( log ⁡ n log ⁡ log ⁡ n ) lower bound for the approximability of this problem. This implies that the well-known O ( log ⁡ n ) approximation ratio established by Räcke in 2008 is tight. Using Lagrange relaxation, we obtain a new proof of the O ( log ⁡ n ) approximation . An important consequence of the Lagrange-based reduction and our inapproximability results is that the robust network design problem with linear reservation cost cannot be approximated within any constant ratio. This answers a long-standing open question of Chekuri (2007). We also give another proof of the result of Goyal et al. (2009) stating that the optimal linear cost under static routing can be Ω ( log ⁡ n ) more expensive than the cost obtained under dynamic routing. Finally, we show that even if only two given paths are allowed for each commodity, the robust network design problem with minimum congestion or linear cost is hard to approximate within some constant.},
  archive      = {J_TCS},
  author       = {Yacine Al-Najjar and Walid Ben-Ameur and Jérémie Leguay},
  doi          = {10.1016/j.tcs.2021.01.026},
  journal      = {Theoretical Computer Science},
  pages        = {41-50},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On the approximability of robust network design},
  volume       = {860},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Reducing the ambiguity of parikh matrices. <em>TCS</em>,
<em>860</em>, 23–40. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.025">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Parikh matrix mapping allows us to describe words using matrices. Whilst compact, this description comes with a level of ambiguity since a single matrix may describe multiple words. In this paper, we investigate how considering the Parikh matrices of various transformations of a given word can decrease that ambiguity. More specifically, for any word, we study the Parikh matrix of its projection to a smaller alphabet as well as that of its Lyndon conjugate. Our results demonstrate that ambiguity can often be reduced using these concepts, and we give conditions on when they succeed.},
  archive      = {J_TCS},
  author       = {Jeffery Dick and Laura K. Hutchinson and Robert Mercaş and Daniel Reidenbach},
  doi          = {10.1016/j.tcs.2021.01.025},
  journal      = {Theoretical Computer Science},
  pages        = {23-40},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Reducing the ambiguity of parikh matrices},
  volume       = {860},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Continuous leakage-resilient certificate-based signcryption
scheme and application in cloud computing. <em>TCS</em>, <em>860</em>,
1–22. (<a href="https://doi.org/10.1016/j.tcs.2021.01.024">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Leakage of private information, e.g. the secret keys, has become a serious threat to the security of computing systems. It has become a common requirement that real-world security applications should withstand various leakage attacks, such as side-channel attacks, cold-boot attacks, etc. For example, the above leakage attacks are very common in cloud computing nowadays. Hence, we need a novel method to protect the security of data storage and authorization even if a certain amount of leakage information with respect to the secret state can be obtained by any adversary. In order to achieve the above goal, in this paper, we introduce a continuous leakage-resilient certificate-based signcryption (CBS) scheme, and we prove that our proposed scheme achieves the chosen-ciphertext attacks (CCA) security based on the discrete logarithm assumption and the decisional Diffie-Hellman assumption. Our proposed scheme not only has the ability to resist the continuous leakage attacks, but also enjoys very low computational overheads. Moreover, two concrete continuous leakage-resilient data storage and authorization protocols are generated from the above continuous leakage-resilient CBS scheme: one has a single key generation center and the other generates the keys in a distributed form. Therefore, our protocols with continuous leakage resilience are particularly suitable for data storage and authorization in cloud computing system .},
  archive      = {J_TCS},
  author       = {Yanwei Zhou and Yuan Xu and Zirui Qiao and Bo Yang and Mingwu Zhang},
  doi          = {10.1016/j.tcs.2021.01.024},
  journal      = {Theoretical Computer Science},
  pages        = {1-22},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Continuous leakage-resilient certificate-based signcryption scheme and application in cloud computing},
  volume       = {860},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Optimisation of electrical network configuration: Complexity
and algorithms for ring topologies. <em>TCS</em>, <em>859</em>, 162–173.
(<a href="https://doi.org/10.1016/j.tcs.2021.01.023">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider power distribution networks containing source nodes producing electricity and nodes representing electricity consumers. These sources and these consumers are interconnected by a switched network. Configuring this network consists in deciding which switches are activated and the orientation of the links between these switches, so as to obtain a directed acyclic graph (DAG) from the producer nodes to the consumer nodes. This DAG is valid if the electric flow it induces satisfies the demand of each consumer without exceeding the production capacity of each source and the flow capacity of each switch. We show that the problem of deciding if such a valid DAG exists is NP-complete. In the case where such a valid DAG exists, we study the problem of determining a valid DAG that balances the ratio between the amount of electricity produced and the maximum production capacity for each source. We show that this minimization problem is also NP-complete in the general case but that it becomes polynomial in the case of ring network topologies .},
  archive      = {J_TCS},
  author       = {Dominique Barth and Thierry Mautor and Arnaud de Moissac and Dimitri Watel and Marc-Antoine Weisser},
  doi          = {10.1016/j.tcs.2021.01.023},
  journal      = {Theoretical Computer Science},
  pages        = {162-173},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Optimisation of electrical network configuration: Complexity and algorithms for ring topologies},
  volume       = {859},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Secret sharing schemes for infinite sets of participants: A
new design technique. <em>TCS</em>, <em>859</em>, 149–161. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.019">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We propose a new design technique for constructing secret sharing schemes over a potentially infinite set of participants. Our findings leverage on a nice property of secret sharing schemes for finite sets of participants based on the Chinese remainder theorem : the possibility of providing shares of different sizes to participants. We successful apply the technique to the ( 3 , ∞ ) (3,∞) -threshold access structure. The scheme we exhibit improves over the best construction currently available. Most importantly, the idea underlying the technique is of independent interest. Hopefully, it could be employed for other access structures, and in other areas of secure computation for potentially infinite sets of players.},
  archive      = {J_TCS},
  author       = {Paolo D&#39;Arco and Roberto De Prisco and Alfredo De Santis},
  doi          = {10.1016/j.tcs.2021.01.019},
  journal      = {Theoretical Computer Science},
  pages        = {149-161},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Secret sharing schemes for infinite sets of participants: A new design technique},
  volume       = {859},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On infinite prefix normal words. <em>TCS</em>, <em>859</em>,
134–148. (<a href="https://doi.org/10.1016/j.tcs.2021.01.015">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Prefix normal words are binary words with the property that no factor has more 1s than the prefix of the same length. Finite prefix normal words were introduced in Fici and Lipták (2011) [18] . In this paper, we study infinite prefix normal words and explore their relationship to some known classes of infinite binary words. In particular, we establish a connection between prefix normal words and Sturmian words, between prefix normal words and abelian complexity, and between prefix normality and lexicographic order . 1},
  archive      = {J_TCS},
  author       = {Ferdinando Cicalese and Zsuzsanna Lipták and Massimiliano Rossi},
  doi          = {10.1016/j.tcs.2021.01.015},
  journal      = {Theoretical Computer Science},
  pages        = {134-148},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On infinite prefix normal words},
  volume       = {859},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Computing longest palindromic substring after
single-character or block-wise edits. <em>TCS</em>, <em>859</em>,
116–133. (<a href="https://doi.org/10.1016/j.tcs.2021.01.014">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Palindromes are important objects in strings which have been extensively studied from combinatorial, algorithmic, and bioinformatics points of views. It is known that the length of the longest palindromic substrings (LPSs) of a given string T of length n can be computed in O ( n ) O(n) time by Manacher&#39;s algorithm [12] . In this paper, we consider the problem of finding the LPS after the string is edited. We present an algorithm that uses O ( n ) O(n) time and space for preprocessing, and answers the length of the LPSs in O ( log ⁡ ( min ⁡ { σ , log ⁡ n } ) ) O(log⁡(min⁡{σ,log⁡n})) time after a single character substitution, insertion, or deletion, where σ denotes the number of distinct characters appearing in T . We also propose an algorithm that uses O ( n ) O(n) time and space for preprocessing, and answers the length of the LPSs in O ( ℓ + log ⁡ log ⁡ n ) O(ℓ+log⁡log⁡n) time, after an existing substring in T is replaced by a string of arbitrary length ℓ .},
  archive      = {J_TCS},
  author       = {Mitsuru Funakoshi and Yuto Nakashima and Shunsuke Inenaga and Hideo Bannai and Masayuki Takeda},
  doi          = {10.1016/j.tcs.2021.01.014},
  journal      = {Theoretical Computer Science},
  pages        = {116-133},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Computing longest palindromic substring after single-character or block-wise edits},
  volume       = {859},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Measuring diversity in heterogeneous information networks.
<em>TCS</em>, <em>859</em>, 80–115. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.013">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Diversity is a concept relevant to numerous domains of research varying from ecology, to information theory , and to economics, to cite a few. It is a notion that is steadily gaining attention in the information retrieval, network analysis, and artificial neural networks communities. While the use of diversity measures in network-structured data counts a growing number of applications, no clear and comprehensive description is available for the different ways in which diversities can be measured. In this article, we develop a formal framework for the application of a large family of diversity measures to heterogeneous information networks (HINs), a flexible, widely-used network data formalism. This extends the application of diversity measures, from systems of classifications and apportionments, to more complex relations that can be better modeled by networks. In doing so, we not only provide an effective organization of multiple practices from different domains, but also unearth new observables in systems modeled by heterogeneous information networks. We illustrate the pertinence of our approach by developing different applications related to various domains concerned by both diversity and networks. In particular, we illustrate the usefulness of these new proposed observables in the domains of recommender systems and social media studies, among other fields.},
  archive      = {J_TCS},
  author       = {Pedro Ramaciotti Morales and Robin Lamarche-Perrin and Raphaël Fournier-S&#39;niehotta and Rémy Poulain and Lionel Tabourier and Fabien Tarissan},
  doi          = {10.1016/j.tcs.2021.01.013},
  journal      = {Theoretical Computer Science},
  pages        = {80-115},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Measuring diversity in heterogeneous information networks},
  volume       = {859},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The sum of digits functions of the zeckendorf and the base
phi expansions. <em>TCS</em>, <em>859</em>, 70–79. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.011">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider the sum of digits functions for both base phi, and for the Zeckendorf expansion of the natural numbers. For both sum of digits functions we present morphisms on infinite alphabets such that these functions viewed as infinite words are letter-to-letter projections of fixed points of these morphisms. We characterize the first differences of both functions a) with generalized Beatty sequences, or unions of generalized Beatty sequences, and b) with morphic sequences.},
  archive      = {J_TCS},
  author       = {F. Michel Dekking},
  doi          = {10.1016/j.tcs.2021.01.011},
  journal      = {Theoretical Computer Science},
  pages        = {70-79},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The sum of digits functions of the zeckendorf and the base phi expansions},
  volume       = {859},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Optimal reconfiguration of optimal ladder lotteries.
<em>TCS</em>, <em>859</em>, 57–69. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.009">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A ladder lottery, known as “Amidakuji” in Japan, is a common way to decide an assignment at random. A ladder lottery L of a given permutation is optimal if L has the minimum number of horizontal lines. In this paper, we investigate a reconfiguration problem of optimal ladder lotteries. The reconfiguration problem on a set of optimal ladder lotteries asks, given two optimal ladder lotteries L , L ′ L,L′ of a permutation π , to find a sequence of 〈 L 1 , L 2 , … , L k 〉 〈L1,L2,…,Lk〉 of optimal ladder lotteries of π such that (1) L 1 = L L1=L and L k = L ′ Lk=L′ and (2) L i Li for i = 2 , 3 , … , k i=2,3,…,k is obtained from L i − 1 Li−1 by moving a bar in L i − 1 Li−1 locally. An existing result implies that any two optimal ladder lotteries of a permutation π have a reconfiguration sequence of length O ( n 3 ) O(n3) , where n is the number of elements in π . In this paper, we characterize the minimum length of reconfiguration sequences between two optimal ladder lotteries. Moreover, we present a linear-time algorithm that computes the minimum length.},
  archive      = {J_TCS},
  author       = {Katsuhisa Yamanaka and Takashi Horiyama and Kunihiro Wasa},
  doi          = {10.1016/j.tcs.2021.01.009},
  journal      = {Theoretical Computer Science},
  pages        = {57-69},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Optimal reconfiguration of optimal ladder lotteries},
  volume       = {859},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Reconstruction and verification of chordal graphs with a
distance oracle. <em>TCS</em>, <em>859</em>, 48–56. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.006">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A hidden graph is a graph whose edge set is hidden. A distance oracle of a graph G is a black-box that receives two vertices of G and outputs the distance between the two vertices. Given a hidden graph, the reconstruction problem aims to identify the edges of the hidden graph by accessing a distance oracle, and the verification problem aims to check whether the hidden graph is equal to another given graph (not hidden). If the hidden graph G is a connected chordal graph , a Las Vegas reconstruction algorithm using O ( Δ 3 2 Δ ⋅ n ( 2 Δ + log 2 ⁡ n ) log ⁡ n ) O(Δ32Δ⋅n(2Δ+log2⁡n)log⁡n) distance queries is known, where Δ is the maximum degree of G and n is the number of vertices of G . Improving upon this result, we present a reconstruction algorithm using only O ( Δ 2 n log 2 ⁡ n ) O(Δ2nlog2⁡n) distance queries. As a byproduct, we obtain a deterministic algorithm for the verification of chordal graphs with O ( Δ 2 n log ⁡ n ) O(Δ2nlog⁡n) distance queries. Additionally, we derive a deterministic algorithm of reconstructing connected interval graphs using only O ( Δ n ) O(Δn) distance queries, and prove that reconstructing or verifying a connected interval graph needs Ω ( Δ n ) Ω(Δn) distance queries, which implies that this algorithm is the best possible in terms of the number of distance queries needed.},
  archive      = {J_TCS},
  author       = {Guozhen Rong and Wenjun Li and Yongjie Yang and Jianxin Wang},
  doi          = {10.1016/j.tcs.2021.01.006},
  journal      = {Theoretical Computer Science},
  pages        = {48-56},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Reconstruction and verification of chordal graphs with a distance oracle},
  volume       = {859},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The longest cycle problem is polynomial on interval graphs.
<em>TCS</em>, <em>859</em>, 37–47. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.005">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The longest cycle problem is the problem of finding a cycle with maximal vertices in a graph. Although it is solvable in polynomial time on few trivial graph classes, the longest cycle problem is well known as NP-complete. A lot of efforts have been devoted to the longest cycle problem. To the best of our knowledge however, there are no polynomial algorithms that can solve any of the non-trivial graph classes. Interval graphs, the intersection of chordal graphs and asteroidal triple-free graphs, are known to be the non-trial graph classes that have polynomial algorithm of the longest cycle problem. In 2009, K. Ioannidou, G.B. Mertzios and S.D. Nikolopoulos presented a polynomial algorithm for the longest path problem on interval graphs in Ioannidou et al. (2009) [19] . Inspired by their work, we investigate the longest cycle problem of interval graphs. In this paper, we present the first polynomial algorithm for the longest cycle problem on interval graphs. A dynamic programming approach is proposed in the polynomial algorithm that runs in O ( n 8 ) O(n8) time, where n is the number of vertices of the input graph. Using a similar approach, we design a polynomial algorithm to solve the longest k -thick subgraph problem on interval graphs which will be presented in another separate work. According to the interesting properties of k -thick interval graphs that we discovered (e.g., an interval graph G is traceable if and only if G is 1-thick, G is hamiltonian if and only if G is 2-thick, G is hamiltonian connected if and only if G is 3-thick and so on), the algorithm presented in this paper can be important in studying the spanning connectivity on interval graphs.},
  archive      = {J_TCS},
  author       = {Jianhui Shang and Peng Li and Yi Shi},
  doi          = {10.1016/j.tcs.2021.01.005},
  journal      = {Theoretical Computer Science},
  pages        = {37-47},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The longest cycle problem is polynomial on interval graphs},
  volume       = {859},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Immunization against complete subversion without random
oracles. <em>TCS</em>, <em>859</em>, 1–36. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.002">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We seek constructions of general-purpose immunizers that take arbitrary cryptographic primitives , and transform them into ones that withstand a powerful “malicious but proud” adversary, who attempts to break security by possibly subverting the implementation of all algorithms (including the immunizer itself!), while trying not to be detected. This question is motivated by the recent evidence of cryptographic schemes being intentionally weakened, or designed together with hidden backdoors, e.g. , with the scope of mass surveillance. Our main result is a subversion-secure immunizer in the plain model, that works for a fairly large class of deterministic primitives, i.e. cryptoschemes where a secret (but tamperable ) random source is used to generate the keys and the public parameters, whereas all other algorithms are deterministic. The immunizer relies on an additional independent source of public randomness, which is used to sample a public seed. Assuming the public source is untamperable, and that the subversion of the algorithms is chosen independently of the seed, we can instantiate our immunizer from any one-way function. In case the subversion is allowed to depend on the seed, and the public source is still untamperable, we obtain an instantiation from collision-resistant hash functions . In the more challenging scenario where the public source is also tamperable, we additionally need to assume that the initial cryptographic primitive has sub-exponential security. Previous work in the area only obtained subversion-secure immunization for very restricted classes of primitives, often in weaker models of subversion and using random oracles.},
  archive      = {J_TCS},
  author       = {Giuseppe Ateniese and Danilo Francati and Bernardo Magri and Daniele Venturi},
  doi          = {10.1016/j.tcs.2021.01.002},
  journal      = {Theoretical Computer Science},
  pages        = {1-36},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Immunization against complete subversion without random oracles},
  volume       = {859},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Preface to the special issue on graph searching: Theory and
applications. <em>TCS</em>, <em>858</em>, 145–146. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.036">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_TCS},
  author       = {Spyros Angelopoulos ( Guest Editor ) and Nancy E. Clarke (Guest Editor) and Fedor V. Fomin (Guest Editor) and Archontia C. Giannopoulou (Guest Editor) and Roman Rabinovich (Guest Editor)},
  doi          = {10.1016/j.tcs.2021.01.036},
  journal      = {Theoretical Computer Science},
  pages        = {145-146},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Preface to the special issue on graph searching: Theory and applications},
  volume       = {858},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Selected articles from the 25th international colloquium on
structural information and communication complexity. <em>TCS</em>,
<em>858</em>, 144. (<a
href="https://doi.org/10.1016/j.tcs.2020.09.038">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_TCS},
  author       = {Zvi Lotker and Boaz Patt-Shamir},
  doi          = {10.1016/j.tcs.2020.09.038},
  journal      = {Theoretical Computer Science},
  pages        = {144},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Selected articles from the 25th international colloquium on structural information and communication complexity},
  volume       = {858},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Editorial: Complexity and approximation: In honor of ker-i
ko. <em>TCS</em>, <em>858</em>, 143. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.038">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_TCS},
  author       = {Ding-Zhu Du and Jie Wang},
  doi          = {10.1016/j.tcs.2020.11.038},
  journal      = {Theoretical Computer Science},
  pages        = {143},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Editorial: complexity and approximation: in honor of ker-I ko},
  volume       = {858},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Ostrowski-automatic sequences: Theory and applications.
<em>TCS</em>, <em>858</em>, 122–142. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.018">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We extend the notion of k -automatic sequences to Ostrowski-automatic sequences, and develop a procedure to computationally decide certain combinatorial and enumeration questions about such sequences that can be expressed as predicates in first-order logic. Our primary contribution is the design and implementation of an adder recognizing addition in a generalized Ostrowski numeration system. We also provide applications of our work to several topics in combinatorics on words, including repetitions and pattern avoidance. We partially resolve a previous conjecture about balanced words by Rampersad et al., and make the first progress on an open problem on rich words by Vesti. We also prove some known results about Lucas words using only machine computation.},
  archive      = {J_TCS},
  author       = {Aseem Baranwal and Luke Schaeffer and Jeffrey Shallit},
  doi          = {10.1016/j.tcs.2021.01.018},
  journal      = {Theoretical Computer Science},
  pages        = {122-142},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Ostrowski-automatic sequences: Theory and applications},
  volume       = {858},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Online algorithms for BP functions maximization.
<em>TCS</em>, <em>858</em>, 114–121. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.020">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {BP maximization problem has many applications in machine learning and data science. It can be described as maximizing the sum of a suBmodular function and a suPermodular function (BP) under some constraints, where both functions are nonnegative and monotonic. In this paper, we consider two online cases. The first is a BP maximization problem subject to a uniform matroid constraint when the items arrive one-by-one, for which we offer an online algorithm with constant competitive ratio. The second is a BP maximization problem subject to a partition matroid constraint where each part of the partition arrives in a random order, for which we present two approximation algorithms of both constant competitive ratios, where one is randomized and the other is deterministic.},
  archive      = {J_TCS},
  author       = {Zhicheng Liu and Ling Chen and Hong Chang and Donglei Du and Xiaoyan Zhang},
  doi          = {10.1016/j.tcs.2021.01.020},
  journal      = {Theoretical Computer Science},
  pages        = {114-121},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Online algorithms for BP functions maximization},
  volume       = {858},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Sampling-based dimension reduction for subspace
approximation with outliers. <em>TCS</em>, <em>858</em>, 100–113. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.021">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The subspace approximation problem with outliers, for given n points in d dimensions x 1 , x 2 , … , x n ∈ R d x1,x2,…,xn∈Rd , an integer 1 ≤ k ≤ d 1≤k≤d , and an outlier parameter 0 ≤ α ≤ 1 0≤α≤1 , is to find a k -dimensional linear subspace of R d Rd that minimizes the sum of squared distances to its nearest ( 1 − α ) n (1−α)n points. More generally, the ℓ p ℓp subspace approximation problem with outliers minimizes the sum of p -th powers of distances instead of the sum of squared distances. Even the case of p = 2 p=2 or robust PCA is non-trivial, and previous work requires additional assumptions on the input or generative models for it. Any multiplicative approximation algorithm for the subspace approximation problem with outliers must solve the robust subspace recovery problem, a special case in which the ( 1 − α ) n (1−α)n inliers in the optimal solution are promised to lie exactly on a k -dimensional linear subspace. However, robust subspace recovery is Small Set Expansion (SSE)-hard, and known algorithmic results for robust subspace recovery require strong assumptions on the input, e.g., any d outliers must be linearly independent. In this paper, we show how to extend dimension reduction techniques and bi-criteria approximations based on sampling and coresets to the problem of subspace approximation with outliers. To get around the SSE-hardness of robust subspace recovery, we assume that the squared distance error of the optimal k -dimensional subspace summed over the optimal ( 1 − α ) n (1−α)n inliers is at least δ times its squared-error summed over all n points, for some 0 0&amp;lt;δ≤1−α . Under this assumption, we give an efficient algorithm to find a weak coreset or a subset of poly ( k / ϵ ) log ⁡ ( 1 / δ ) log ⁡ log ⁡ ( 1 / δ ) poly(k/ϵ)log⁡(1/δ)log⁡log⁡(1/δ) points whose span contains a k -dimensional subspace that gives a multiplicative ( 1 + ϵ ) (1+ϵ) -approximation to the optimal solution. Our technique is based on the squared-length sampling algorithm suggested for low-rank approximation problems in the seminal work of Frieze, Kannan, and Vempala [12] . The running time of our algorithm is linear in n and d . Interestingly, our results hold even when the fraction of outliers α is large, as long as the obvious condition 0 0&amp;lt;δ≤1−α is satisfied. We show similar results for subspace approximation with ℓ p ℓp error or more general M-estimator loss functions, and also give an additive approximation for the affine subspace approximation problem.},
  archive      = {J_TCS},
  author       = {Amit Deshpande and Rameshwar Pratap},
  doi          = {10.1016/j.tcs.2021.01.021},
  journal      = {Theoretical Computer Science},
  pages        = {100-113},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Sampling-based dimension reduction for subspace approximation with outliers},
  volume       = {858},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Largest triangle inside a terrain. <em>TCS</em>,
<em>858</em>, 90–99. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.018">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we present an O ( n 2 ) O(n2) time algorithm to find a largest area triangle contained inside a terrain with n vertices. We also present an O ( n log ⁡ n ) O(nlog⁡n) time 1 2 12 -factor approximation algorithm and an O ( 1 ε n log 2 ⁡ n ) O(1εnlog2⁡n) time ( 1 − ε ) (1−ε) -factor approximation scheme for the same.},
  archive      = {J_TCS},
  author       = {Arun Kumar Das and Sandip Das and Joydeep Mukherjee},
  doi          = {10.1016/j.tcs.2020.12.018},
  journal      = {Theoretical Computer Science},
  pages        = {90-99},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Largest triangle inside a terrain},
  volume       = {858},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A computational complexity comparative study of graph
tessellation problems. <em>TCS</em>, <em>858</em>, 81–89. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.045">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A tessellation of a graph is a partition of its vertices into cliques . A tessellation cover of a graph is a set of tessellations that covers all of its edges, and the tessellation cover number, denoted by T ( G ) T(G) , is the size of a smallest tessellation cover. The t -tessellability problem aims to decide whether a graph G has T ( G ) ≤ t T(G)≤t . The number of edges of a maximum induced star of G , denoted by s ( G ) s(G) , is a lower bound on T ( G ) T(G) . In this work we define good tessellable graphs as the graphs G with T ( G ) = s ( G ) T(G)=s(G) , and we introduce the corresponding good tessellable recognition (gtr) problem, which aims to decide whether G is a good tessellable graph. We show that gtr is NP NP -complete not only if T ( G ) T(G) can be obtained in polynomial time or s ( G ) s(G) is fixed, but also when the gap between T ( G ) T(G) and s ( G ) s(G) is large. We establish graph classes that present distinct computational complexities considering problems related to the parameters T ( G ) T(G) and s ( G ) s(G) , and we perform a comparative study of the gtr , t -tessellability , and star size problems, where the star size problem aims to decide whether the number of edges a maximum induced star of a graph is at least a given number.},
  archive      = {J_TCS},
  author       = {Alexandre Abreu and Luís Cunha and Celina de Figueiredo and Luis Kowada and Franklin Marquezino and Renato Portugal and Daniel Posner},
  doi          = {10.1016/j.tcs.2020.11.045},
  journal      = {Theoretical Computer Science},
  pages        = {81-89},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A computational complexity comparative study of graph tessellation problems},
  volume       = {858},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Randomized gathering of asynchronous mobile robots.
<em>TCS</em>, <em>858</em>, 64–80. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.048">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper revisits the widely researched gathering problem for two robots without any agreement on the coordinate system in a scenario which allows randomization in the asynchronous scheduling model. The scheduler is considered to be the adversary which determines the activation schedule of the robots. The adversary comes in three flavors, namely, adaptive offline, adaptive online, and oblivious, based on the knowledge of the outcome of random bits. The robots follow wait-look-compute-move cycle. In this paper, we classify the problems based on the capability of the adversary to control the parameters such as wait time, computation delay and the speed of robots and check the feasibility of gathering in terms of adversarial knowledge and capabilities. First, we show the impossibility of gathering under an adaptive offline adversary with non-negative wait time and non-negative computation delay. Gradually relaxing the adversarial capabilities, we present impossibility of gathering for finite random choices and improbability for infinite random choices for an adaptive online adversary. Under an oblivious adversary, we establish the possibility of gathering with zero computation delay. We improve the runtime of the algorithm by restricting the oblivious adversary to choose wait time and computation delay such that the sum of wait time and computation delay is more than a positive constant. Finally, we also extend our algorithm for multiple robots with merging.},
  archive      = {J_TCS},
  author       = {Debasish Pattanayak and John Augustine and Partha Sarathi Mandal},
  doi          = {10.1016/j.tcs.2020.11.048},
  journal      = {Theoretical Computer Science},
  pages        = {64-80},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Randomized gathering of asynchronous mobile robots},
  volume       = {858},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Strong cliques in diamond-free graphs. <em>TCS</em>,
<em>858</em>, 49–63. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.001">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A strong clique in a graph is a clique intersecting all inclusion-maximal stable sets . Strong cliques play an important role in the study of perfect graphs. We study strong cliques in the class of diamond-free graphs, from both structural and algorithmic points of view. We show that the following five NP -hard or co-NP -hard problems all remain NP -hard or co-NP -hard when restricted to the class of diamond-free graphs: Is a given clique strong? Does the graph have a strong clique? Is every vertex contained in a strong clique? Given a partition of the vertex set into cliques, is every clique in the partition strong? Can the vertex set be partitioned into strong cliques? On the positive side, we show that the following three problems whose computational complexity is open in general can be solved in polynomial time in the class of diamond-free graphs: Does every induced subgraph have a strong clique? Is every maximal clique strong? Is every edge contained in a strong clique? The last two results are derived from a characterization of diamond-free graphs in which every maximal clique is strong, which also implies an improved Erdős-Hajnal property for such graphs.},
  archive      = {J_TCS},
  author       = {Nina Chiarelli and Berenice Martínez-Barona and Martin Milanič and Jérôme Monnot and Peter Muršič},
  doi          = {10.1016/j.tcs.2020.12.001},
  journal      = {Theoretical Computer Science},
  pages        = {49-63},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Strong cliques in diamond-free graphs},
  volume       = {858},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Improved bi-criteria approximation schemes for load
balancing on unrelated machines with cost constraints. <em>TCS</em>,
<em>858</em>, 35–48. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.022">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study a generalized version of the load balancing problem on unrelated machines with cost constraints: Given a set of m machines (of certain types) and a set of n jobs, each job j processed on machine i requires p i , j pi,j time units and incurs a cost c i , j ci,j , and the goal is to find a schedule of jobs to machines, which is defined as an ordered partition of n jobs into m disjoint subsets, in such a way that some objective function of the vector of the completion times of the machines is optimized, subject to the constraint that the total costs by the schedule must be within a given budget B . Motivated by recent results from the literature, our focus is on the case when the number of machine types is a fixed constant and we develop a bi-criteria approximation scheme for the studied problem. Our result generalizes several known results for certain special cases, such as the case with identical machines, or the case with a constant number of machines with cost constraints. Building on the elegant technique recently proposed by Jansen and Maack [1] , we construct a more general approach that can be used to derive approximation schemes for a wider class of load balancing problems with linear constraints .},
  archive      = {J_TCS},
  author       = {Trung Thanh Nguyen and Jörg Rothe},
  doi          = {10.1016/j.tcs.2020.12.022},
  journal      = {Theoretical Computer Science},
  pages        = {35-48},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Improved bi-criteria approximation schemes for load balancing on unrelated machines with cost constraints},
  volume       = {858},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Reallocating multiple facilities on the line. <em>TCS</em>,
<em>858</em>, 13–34. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.028">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the K -Facility Reallocation problem on the real line, where we maintain K facility locations over T stages, based on the stage-dependent locations of n agents. Each agent is connected to the nearest facility at each stage, and the facilities may move from one stage to another, to accommodate different agent locations. The objective is to minimize the connection cost of the agents plus the total moving cost of the facilities, over all stages. The K -Facility Reallocation problem was introduced by de Keijzer and Wojtczak, where they mostly focused on the special case of a single facility. Using an LP-based approach, we present a polynomial time algorithm that computes the optimal solution for any number of facilities. We also consider the online K -Facility Reallocation problem, where the algorithm becomes aware of agent locations in a stage-by-stage fashion. By exploiting an interesting connection to the classical K -server problem, we present a constant-competitive algorithm for K = 2 K=2 facilities.},
  archive      = {J_TCS},
  author       = {Dimitris Fotakis and Loukas Kavouras and Panagiotis Kostopanagiotis and Philip Lazos and Stratis Skoulakis and Nikos Zarifis},
  doi          = {10.1016/j.tcs.2021.01.028},
  journal      = {Theoretical Computer Science},
  pages        = {13-34},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Reallocating multiple facilities on the line},
  volume       = {858},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Improved budgeted connected domination and budgeted
edge-vertex domination. <em>TCS</em>, <em>858</em>, 1–12. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.030">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider the Budgeted version of the classical Connected Dominating Set problem (BCDS). Given a graph G and a budget k , we seek a connected subset of at most k vertices maximizing the number of dominated vertices in G . We improve over the previous ( 1 − e − 1 ) / 13 (1−e−1)/13 state of the art [Khuller, Purohit, and Sarpatwar, SODA 2014 ] by introducing a new method for performing tree decompositions in the analysis of the algorithm. This new approach provides a ( 1 − e − 1 ) / 12 (1−e−1)/12 approximation guarantee. By generalizing the analysis, we are able to obtain a further improvement to ( 1 − e − 7 / 8 ) / 11 (1−e−7/8)/11 . On the other hand, we prove a ( 1 − e − 1 + ϵ ) (1−e−1+ϵ) inapproximability bound, for any ϵ &gt; 0 ϵ&amp;gt;0 , holding also if the subset is required to have a star as a subgraph. In the latter case, we design another algorithm with a matching ( 1 − e − 1 ) (1−e−1) approximation guarantee. Also, we examine the edge-vertex domination variant, where an edge dominates its endpoints and all vertices neighboring them. In Budgeted Edge-Vertex Domination (BEVD), we seek a (not necessarily connected) subset of k edges maximizing the number of dominated vertices in G . We prove a ( 1 − e − 1 ) (1−e−1) -approximation and a ( 1 − e − 1 + ϵ ) (1−e−1+ϵ) -inapproximability by reductions to/from the maximum coverage problem. Finally, we study the “dual” Partial Edge-Vertex Domination (PEVD) problem, and we present a log-approximation by a reduction to the partial cover problem.},
  archive      = {J_TCS},
  author       = {Ioannis Lamprou and Ioannis Sigalas and Vassilis Zissimopoulos},
  doi          = {10.1016/j.tcs.2021.01.030},
  journal      = {Theoretical Computer Science},
  pages        = {1-12},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Improved budgeted connected domination and budgeted edge-vertex domination},
  volume       = {858},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Range partitioning within sublinear time: Algorithms and
lower bounds. <em>TCS</em>, <em>857</em>, 177–191. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.017">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Range partitioning is a typical and mostly used data partitioning method and has became a core operation in most of big data computing platforms. Given an input L of N data items admitting a total order, the goal of range partitioning is to divide the whole input into k ranges containing the same number of data items. There is a trivial lower bound Ω ( N ) Ω(N) for the exact partitioning algorithms, since they need to at least make a full scan of the whole data. In the context of big data computing, even algorithms with O ( N ) O(N) time are not always thought to be efficient enough, the ultimate goal of designing algorithms on big data is usually to solve problems within sublinear time. Therefore, it is well motivated and important to study sublinear algorithms for the range partitioning problem. The paper aims to answer three questions. For the internal memory (RAM) model, since sophisticated sampling based ( ϵ , δ ) (ϵ,δ) -approximation partitioning algorithm with O ( k log ⁡ ( N / δ ) ϵ 2 ) O(klog⁡(N/δ)ϵ2) time cost has been proposed, the first question is what a lower bound we can obtain for sublinear partitioning algorithms. For the external memory (I/O) model, as far as we know, no previous works give external partitioning algorithms with performance guarantee within sublinear time, therefore the two questions are what the upper bound and the lower bound we can achieve for sublinear external partitioning algorithms. To answer the above questions, based on the RAM and I/O model, the paper studies the lower and upper bounds for the range partitioning problem. For the RAM model, a lower bound Ω ( k ( 1 − δ ) ϵ 2 ) Ω(k(1−δ)ϵ2) for the cost of sampling based partitioning algorithms is proved. For the I/O model, two lower bounds of the sampling cost required by sublinear external range partitioning algorithms are proved, which indicate that at least a full scan of the whole input is needed in the worst case and a general sublinear external partitioning algorithm does not exist. Motivated by the hard instances utilized in the proof of lower bounds, a model for describing the input distributions of the range partitioning problem in practical applications is proposed. Finally, for the special cases described by the model, a sublinear external partitioning algorithm with O ( k log ⁡ ( N / δ ) w B ϵ 2 ) O(klog⁡(N/δ)wBϵ2) I/O cost is designed.},
  archive      = {J_TCS},
  author       = {Baoling Ning and Jianzhong Li and Shouxu Jiang},
  doi          = {10.1016/j.tcs.2021.01.017},
  journal      = {Theoretical Computer Science},
  pages        = {177-191},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Range partitioning within sublinear time: Algorithms and lower bounds},
  volume       = {857},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Cops and robbers on oriented toroidal grids. <em>TCS</em>,
<em>857</em>, 166–176. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.012">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The game of cops and robbers is a well-known game played on graphs. In this paper we consider the straight-ahead orientations of 4-regular quadrangulations of the torus and the Klein bottle and we prove that their cop number is bounded by a constant. We also show that the cop number of every k -regularly oriented toroidal grid is at most 13.},
  archive      = {J_TCS},
  author       = {Sebastián González Hermosillo de la Maza and Seyyed Aliasghar Hosseini and Fiachra Knox and Bojan Mohar and Bruce Reed},
  doi          = {10.1016/j.tcs.2021.01.012},
  journal      = {Theoretical Computer Science},
  pages        = {166-176},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Cops and robbers on oriented toroidal grids},
  volume       = {857},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Formalising and implementing boost POSIX regular expression
matching. <em>TCS</em>, <em>857</em>, 147–165. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.010">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Whereas Perl-compatible regular expression matchers typically exhibit some variation of leftmost-greedy semantics, those conforming to the posix standard are prescribed leftmost-longest semantics. However, the posix standard leaves some room for interpretation, and Fowler and Kuklewicz have done experimental work to confirm differences between various posix matchers. The Boost library has an interesting take on the posix standard, where it maximises the leftmost match not with respect to subexpressions of the regular expression pattern, but rather, with respect to capturing groups. In our work, we provide the first formalisation of Boost semantics, analyze the complexity of regular expression matching when using Boost semantics, and provide efficient algorithms for both online and multipass matching.},
  archive      = {J_TCS},
  author       = {Martin Berglund and Willem Bester and Brink van der Merwe},
  doi          = {10.1016/j.tcs.2021.01.010},
  journal      = {Theoretical Computer Science},
  pages        = {147-165},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Formalising and implementing boost POSIX regular expression matching},
  volume       = {857},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). When a dollar makes a BWT. <em>TCS</em>, <em>857</em>,
123–146. (<a href="https://doi.org/10.1016/j.tcs.2021.01.008">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Burrows-Wheeler-Transform (BWT) is a reversible string transformation which plays a central role in text compression and is fundamental in many modern bioinformatics applications. The BWT is a permutation of the characters, which is in general better compressible and allows to answer several different query types more efficiently than the original string. It is easy to see that not every string is a BWT image, and exact characterizations of BWT images are known. We investigate a related combinatorial question. In many applications, a sentinel character $ is added to mark the end of the string, and thus the BWT of a string ending with $ contains exactly one $-character. Given a string w , we ask in which positions, if any, the $-character can be inserted to turn w into the BWT image of a word ending with $. We show that this depends only on the standard permutation of w and present a O ( n log ⁡ n ) O(nlog⁡n) -time algorithm for identifying all such positions, improving on the naive quadratic time algorithm. We also give a combinatorial characterization of such positions and develop bounds on their number and value. This is an extended version of [Giuliani et al. ICTCS 2019].},
  archive      = {J_TCS},
  author       = {Sara Giuliani and Zsuzsanna Lipták and Francesco Masillo and Romeo Rizzi},
  doi          = {10.1016/j.tcs.2021.01.008},
  journal      = {Theoretical Computer Science},
  pages        = {123-146},
  shortjournal = {Theor. Comput. Sci.},
  title        = {When a dollar makes a BWT},
  volume       = {857},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Injective coloring of planar graphs. <em>TCS</em>,
<em>857</em>, 114–122. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.007">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {An injective k -coloring of a graph G is a mapping f : V ( G ) → { 1 , 2 , … , k } f:V(G)→{1,2,…,k} such that for any two vertices v 1 , v 2 ∈ V ( G ) v1,v2∈V(G) , f ( v 1 ) ≠ f ( v 2 ) f(v1)≠f(v2) if N ( v 1 ) ∩ N ( v 2 ) ≠ ∅ N(v1)∩N(v2)≠∅ . The injective chromatic number of a graph G , denoted by χ i ( G ) χi(G) , is the smallest integer k such that G has an injective k -coloring. In this paper, we prove that for a Halin graph G , χ i ( G ) ≤ Δ ( G ) + 2 χi(G)≤Δ(G)+2 . Moreover, χ i ( G ) ≤ Δ ( G ) + 1 χi(G)≤Δ(G)+1 if Δ ( G ) ≥ 6 Δ(G)≥6 . Also, we show that for a triangle-free planar graph G without intersecting 4-cycles, χ i ( G ) ≤ Δ ( G ) + 6 χi(G)≤Δ(G)+6 if Δ ( G ) ≥ 20 Δ(G)≥20 .},
  archive      = {J_TCS},
  author       = {Bu Yuehua and Qi Chentao and Zhu Junlei and Xu Ting},
  doi          = {10.1016/j.tcs.2021.01.007},
  journal      = {Theoretical Computer Science},
  pages        = {114-122},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Injective coloring of planar graphs},
  volume       = {857},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On sets of indefinitely desubstitutable words. <em>TCS</em>,
<em>857</em>, 97–113. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.004">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The stable set associated to a given set S S of nonerasing endomorphisms or substitutions is the set of all right infinite words that can be indefinitely desubstituted over S S . This notion generalizes the notion of sets of fixed points of morphisms . It is linked to S -adicity and to property preserving morphisms . Two main questions are considered. Which known sets of infinite words are stable sets? Which ones are stable sets of a finite set of substitutions? While bringing answers to the previous questions, some new characterizations of several well-known sets of words such as the set of binary balanced words or the set of episturmian words are presented. A characterization of the set of nonerasing endomorphisms that preserve episturmian words is also provided.},
  archive      = {J_TCS},
  author       = {Gwenaël Richomme},
  doi          = {10.1016/j.tcs.2021.01.004},
  journal      = {Theoretical Computer Science},
  pages        = {97-113},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On sets of indefinitely desubstitutable words},
  volume       = {857},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Novel algorithms for maximum DS decomposition. <em>TCS</em>,
<em>857</em>, 87–96. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.041">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {DS decomposition plays an important role in set function optimization problem , because there is DS decomposition for any set function. How to design an efficient and effective algorithm to solve maximizing DS decomposition is a heated problem. In this work, we propose a framework called Parameter Conditioned Greedy Algorithm which has a deterministic version and two random versions. In more detail, this framework uses the difference with parameter decomposition function and combines non-negative condition. Besides, if we set the different parameters, the framework can return solution with different approximation ratio. Also, we choose two special case to show our deterministic algorithm gets f ( S k ) − ( e − 1 − c g ) g ( S k ) ≥ ( 1 − e − 1 ) [ f ( O P T ) − g ( O P T ) ] f(Sk)−(e−1−cg)g(Sk)≥(1−e−1)[f(OPT)−g(OPT)] and f ( S k ) − ( 1 − c g ) g ( S k ) ≥ ( 1 − e − 1 ) f ( O P T ) − g ( O P T ) f(Sk)−(1−cg)g(Sk)≥(1−e−1)f(OPT)−g(OPT) respectively for cardinality constrained problem, where c g cg is the curvature of monotone submodular set function. To speed the deterministic algorithm, we introduce a random sample set whose intersection with the optimal solution is as nonempty as possible. Importantly, it also can get the same approximation ratio as deterministic algorithm under expectation. Further, for maximization DS decomposition without constraint, our another random algorithm gets E [ f ( S k ) − ( e − 1 − c g ) g ( S k ) ] ≥ ( 1 − e − 1 ) [ f ( O P T ) − g ( O P T ) ] E[f(Sk)−(e−1−cg)g(Sk)]≥(1−e−1)[f(OPT)−g(OPT)] and E [ f ( S k ) − ( 1 − c g ) g ( S k ) ] ≥ ( 1 − e − 1 ) f ( O P T ) − g ( O P T ) E[f(Sk)−(1−cg)g(Sk)]≥(1−e−1)f(OPT)−g(OPT) respectively. Because the Parameter Conditioned Algorithm is the general framework, different users can choose the parameters that fit their problem to get a better approximation.},
  archive      = {J_TCS},
  author       = {Shengminjie Chen and Wenguo Yang and Suixiang Gao and Rong Jin},
  doi          = {10.1016/j.tcs.2020.12.041},
  journal      = {Theoretical Computer Science},
  pages        = {87-96},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Novel algorithms for maximum DS decomposition},
  volume       = {857},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Matching influence maximization in social networks.
<em>TCS</em>, <em>857</em>, 71–86. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.040">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Influence maximization (IM) is a widely studied problem in social networks, which aims at finding a seed set with limited size that can maximize the expected number of influenced users. However, existing studies haven&#39;t considered the matching relationship, which refers to such scenarios that influenced users seek matched partners among the influenced users, such as time matching with friends to watch movie, or matching for opposite sex in the blind date. In this paper, we investigate different matching scenarios and propose online-matching ( offline-matching ), in which the matching and influence propagation are simultaneous (asynchronous). For the matching result, we introduce two matched types ‘ s - m a t c h e d matched ’, i.e., i → j i→j and ‘ d - m a t c h e d matched ’, i.e., i ↔ j i↔j . Then, we formulate the matching influence maximization (MM) problem to optimize a limited seed set that maximizes the expected number of matched users. We prove that the MM problem is NP-hard and the computation of the matching influence is #P-hard. Next, we analyze the submodularity of the matching influence. To address the problem, we propose efficient methods OPMM (SAMM) to solve the MM in online-matching (offline-matching) with ( 1 − 1 / e − ϵ ) (1−1/e−ϵ) -approximation ( β ( 1 − 1 / e − ϵ ) β(1−1/e−ϵ) -approximation) guarantee. Experiments on the real-world datasets show our algorithms outperform state of the art algorithms in terms of more accurate matching propagation results.},
  archive      = {J_TCS},
  author       = {Guoyao Rao and Yongcai Wang and Wenping Chen and Deying Li and Weili Wu},
  doi          = {10.1016/j.tcs.2020.12.040},
  journal      = {Theoretical Computer Science},
  pages        = {71-86},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Matching influence maximization in social networks},
  volume       = {857},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A sub-linear time algorithm for approximating
k-nearest-neighbor with full quality guarantee. <em>TCS</em>,
<em>857</em>, 59–70. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.039">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper we propose an algorithm for the approximate k-Nearest-Neighbors problem. According to the existing researches, there are two kinds of approximation criteria. One is the distance criterion, and the other is the recall criterion. All former algorithms suffer the problem that there are no theoretical guarantees for the two approximation criteria. The algorithm proposed in this paper unifies the two kinds of approximation criteria, and has full theoretical guarantees. Furthermore, the query time of the algorithm is sub-linear. As far as we know, it is the first algorithm that achieves both sub-linear query time and full theoretical approximation guarantee.},
  archive      = {J_TCS},
  author       = {Hengzhao Ma and Jianzhong Li},
  doi          = {10.1016/j.tcs.2020.12.039},
  journal      = {Theoretical Computer Science},
  pages        = {59-70},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A sub-linear time algorithm for approximating k-nearest-neighbor with full quality guarantee},
  volume       = {857},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A unified task recommendation strategy for realistic mobile
crowdsourcing system. <em>TCS</em>, <em>857</em>, 43–58. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.034">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A well-designed task recommendation framework aims to protect the data quality as well as increase the task execution results. However, current crowdsourcing systems ignore the fact that there are few duplicate task expectations because of the budget limitation in realistic conditions. Besides, a practical crowdsourcing system needs to recommend new tasks without previous knowledge about the concrete task content due to short task lifespan. Thus, most of the existing studies are not applicable due to the idealized assumptions. In this paper, we formally define the problem and prove it is NP-Hard. For the problem, we design a unified task recommendation system for realistic conditions to address the mentioned problems, Pioneer-Assisted Task RecommendatiON (PATRON) framework. The framework first selects a set of pioneer workers to collect initial knowledge of the new tasks. Then it adopts the k -medoids clustering algorithm to split the workers into subsets based on the worker similarity. Cluster selection and worker pruning provides accurate and efficient recommendations that satisfy the valid recommendation requirements from requesters. Finally, we conducted our experiments based on real datasets from a famous Chinese crowdsourcing platform , Tencent SOHO. The experimental results show the efficiency and accuracy of PATRON compared with three baseline methods from several perspectives, such as recommendation success rate and recommended worker quality.},
  archive      = {J_TCS},
  author       = {Zhiyao Li and Bosen Cheng and Xiaofeng Gao and Huai Chen and Guihai Chen},
  doi          = {10.1016/j.tcs.2020.12.034},
  journal      = {Theoretical Computer Science},
  pages        = {43-58},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A unified task recommendation strategy for realistic mobile crowdsourcing system},
  volume       = {857},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Temporal logic specification mining of programs.
<em>TCS</em>, <em>857</em>, 29–42. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.032">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper proposes a dynamic approach of specification mining for Propositional Projection Temporal Logic (PPTL). To this end, a pattern library is built to collect some common temporal relation among events. Further, several algorithms of specification mining for PPTL are designed. With our approach, PPTL specifications are mined from a trace set of a target program by using patterns in the library. In addition, a specification mining tool PPTLMiner supporting this approach is developed. In practice, given a trace set and user selected patterns, PPTLMiner can capture PPTL specifications of target programs.},
  archive      = {J_TCS},
  author       = {Nan Zhang and Bin Yu and Cong Tian and Zhenhua Duan and Xiaoshuai Yuan},
  doi          = {10.1016/j.tcs.2020.12.032},
  journal      = {Theoretical Computer Science},
  pages        = {29-42},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Temporal logic specification mining of programs},
  volume       = {857},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Optimal wireless charger placement with individual energy
requirement. <em>TCS</em>, <em>857</em>, 16–28. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.027">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Supply energy to battery-powered sensor devices by deploying wireless chargers is a promising way to prolong the operation time of wireless sensor networks, and has attracted much attention recently. Existing works focus on maximizing the total received charging power of the network. However, this may face the unbalanced energy allocation problem, which is not beneficial to prolong the operation time of wireless sensor networks. In this paper, we consider the individual energy requirement of each sensor node, and study the problem of minimum charger placement. That is, we focus on finding a strategy for placing wireless chargers from a given candidate location set, such that each sensor node&#39;s energy requirement can be met, meanwhile the total number of used chargers can be minimized. We deal with the problem under both omnidirectional and directional charging models, and prove its NP-hardness. For the omnidirectional charging case, we present two approximation algorithms which are based on greedy scheme and relax rounding scheme, respectively. We prove that both of the two algorithms have performance guarantees. For the directional charging case, we first extract the candidate orientation set for each candidate location to reduce the search space from infinite to a limited set, and then propose a greedy algorithm that also has a proved performance guarantee. Finally, we validate the performance of our algorithms by performing extensive numerical simulations. Simulation results show the effectiveness of our proposed algorithms.},
  archive      = {J_TCS},
  author       = {Xingjian Ding and Jianxiong Guo and Deying Li and Weili Wu},
  doi          = {10.1016/j.tcs.2020.12.027},
  journal      = {Theoretical Computer Science},
  pages        = {16-28},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Optimal wireless charger placement with individual energy requirement},
  volume       = {857},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Hardness and algorithms of equitable tree-coloring problem
in chordal graphs. <em>TCS</em>, <em>857</em>, 8–15. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.020">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {An equitable tree- k -coloring of a graph is a vertex k -coloring such that each color class induces a forest and the size of any two color classes differs by at most one. In this work, we show that every interval graph G has an equitable tree- k -coloring for any integer k≥⌈(Δ(G)+1)/2⌉ , solving a conjecture of Wu, Zhang and Li (2013) for interval graphs, and furthermore, give a linear-time algorithm for determining whether a proper interval graph admits an equitable tree- k -coloring for a given integer k . For disjoint union of split graphs, or K1,r -free interval graphs with r≥4 , we prove that it is W[1] -hard to decide whether there is an equitable tree- k -coloring when parameterized by number of colors, or by treewidth, number of colors and maximum degree, respectively. On the positive side, we propose a quadratic 2-approximation algorithm for the equitable tree-coloring problem in chordal graphs . Moreover, it is proved that there is no α -approximation algorithm for any α&amp;lt;32 .},
  archive      = {J_TCS},
  author       = {Bei Niu and Bi Li and Xin Zhang},
  doi          = {10.1016/j.tcs.2020.12.020},
  journal      = {Theoretical Computer Science},
  pages        = {8-15},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Hardness and algorithms of equitable tree-coloring problem in chordal graphs},
  volume       = {857},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). I/o-efficient data structures for non-overlapping indexing.
<em>TCS</em>, <em>857</em>, 1–7. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.006">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The non-overlapping indexing problem is defined as follows: pre-process a given text T [ 1 , n ] T[1,n] of length n into a data structure such that whenever a pattern P [ 1 , m ] P[1,m] comes as an input, we can efficiently report the largest set of non-overlapping occurrences of P in T T . The best-known solution is by Cohen and Porat [ISAAC 2009]. The size of their structure is O ( n ) O(n) words and the query time is optimal O ( m + nocc ) O(m+nocc) , where nocc nocc is the output size. Later, Ganguly et al. [CPM 2015 and Algorithmica 2020] proposed a compressed space solution. We study this problem in the cache-oblivious model and present a new data structure of size O ( n log ⁡ n ) O(nlog⁡n) words. It can answer queries in optimal O ( m B + log B ⁡ n + nocc B ) O(mB+logB⁡n+noccB) I/O operations, where B is the block size. The space can be improved to O ( n log M / B ⁡ n ) O(nlogM/B⁡n) in the cache-aware model, where M is the size of main memory. Additionally, we study a generalization of this problem with an additional range [ s , e ] [s,e] constraint. Here the task is to report the largest set of non-overlapping occurrences of P in T T , that are within the range [ s , e ] [s,e] . We present an O ( n log 2 ⁡ n ) O(nlog2⁡n) space data structure in the cache-aware model that can answer queries in optimal O ( m B + log B ⁡ n + nocc [ s , e ] B ) O(mB+logB⁡n+nocc[s,e]B) I/O operations, where nocc [ s , e ] nocc[s,e] is the output size.},
  archive      = {J_TCS},
  author       = {Sahar Hooshmand and Paniz Abedin and M. Oğuzhan Külekci and Sharma V. Thankachan},
  doi          = {10.1016/j.tcs.2020.12.006},
  journal      = {Theoretical Computer Science},
  pages        = {1-7},
  shortjournal = {Theor. Comput. Sci.},
  title        = {I/O-efficient data structures for non-overlapping indexing},
  volume       = {857},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Conflict complexity is lower bounded by block sensitivity.
<em>TCS</em>, <em>856</em>, 169–172. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.038">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {It is shown that conflict complexity of every total Boolean function , recently introduced in [1] to prove a composition theorem of randomized decision tree complexity, is at least a half of its block sensitivity. The paper proposes to compare conflict complexity with certificate complexity and explains why it could be interesting.},
  archive      = {J_TCS},
  author       = {Yaqiao Li},
  doi          = {10.1016/j.tcs.2020.12.038},
  journal      = {Theoretical Computer Science},
  pages        = {169-172},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Conflict complexity is lower bounded by block sensitivity},
  volume       = {856},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Improved algorithm for the locating-chromatic number of
trees. <em>TCS</em>, <em>856</em>, 165–168. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.037">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The concept of the locating-chromatic number for graphs was introduced by Chartrand et al. (2002). In this paper, we propose an algorithm to determine the upper bound of the locating-chromatic number of any tree. This algorithm works much better than the one given by Furuya and Matsumoto (2019).},
  archive      = {J_TCS},
  author       = {Edy Tri Baskoro and Devi Imulia Dian Primaskun},
  doi          = {10.1016/j.tcs.2020.12.037},
  journal      = {Theoretical Computer Science},
  pages        = {165-168},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Improved algorithm for the locating-chromatic number of trees},
  volume       = {856},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Generation of amalgamated free products of cyclic groups by
finite automata over minimal alphabet. <em>TCS</em>, <em>856</em>,
151–164. (<a href="https://doi.org/10.1016/j.tcs.2020.12.036">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Groups of automaton permutations over finite alphabets are considered. Finite automata over minimal possible alphabets that define amalgamated free products of finite cyclic groups are constructed. For any prime p the case of amalgamated free products of cyclic p -groups is considered. In this case it is shown that elements defined by constructed finite automata belong to p -Sylow subgroups of the group of automaton permutations over a p -element alphabet.},
  archive      = {J_TCS},
  author       = {Veronika Prokhorchuk},
  doi          = {10.1016/j.tcs.2020.12.036},
  journal      = {Theoretical Computer Science},
  pages        = {151-164},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Generation of amalgamated free products of cyclic groups by finite automata over minimal alphabet},
  volume       = {856},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On cherry-picking and network containment. <em>TCS</em>,
<em>856</em>, 121–150. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.031">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Phylogenetic networks are used to represent evolutionary scenarios in biology and linguistics. To find the most probable scenario, it may be necessary to compare candidate networks. In particular, one needs to distinguish different networks and determine whether one network is contained in another. In this paper, we introduce cherry-picking networks, a class of networks that can be reduced by a so-called cherry-picking sequence. We then show how to compare such networks using their sequences. We characterize reconstructible cherry-picking networks, which are the networks that are uniquely determined by the sequences that reduce them, making them distinguishable. Furthermore, we show that a cherry-picking network is contained in another cherry picking network if a sequence for the latter network reduces the former network, provided both networks can be reconstructed from their sequences in a similar way (i.e., they are in the same reconstructible class). Lastly, we show that the converse of the above statement holds for tree-child networks, thereby showing that Network Containment , the problem of checking whether a network is contained in another, can be solved by computing cherry picking sequences in linear time for tree-child networks.},
  archive      = {J_TCS},
  author       = {Remie Janssen and Yukihiro Murakami},
  doi          = {10.1016/j.tcs.2020.12.031},
  journal      = {Theoretical Computer Science},
  pages        = {121-150},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On cherry-picking and network containment},
  volume       = {856},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the status sequences of trees. <em>TCS</em>,
<em>856</em>, 110–120. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.030">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The status of a vertex v in a connected graph is the sum of the distances from v to all other vertices. The status sequence of a connected graph is the list of the statuses of all the vertices of the graph. In this paper we investigate the status sequences of trees. Particularly, we show that it is NP-complete to decide whether there exists a tree that has a given sequence of integers as its status sequence. We also present some new results about trees whose status sequences are comprised of a few distinct numbers or many distinct numbers. In this direction, we show that any status injective tree is unique among trees. Finally, we investigate how orbit partitions and equitable partitions relate to the status sequence.},
  archive      = {J_TCS},
  author       = {Aida Abiad and Boris Brimkov and Alexander Grigoriev},
  doi          = {10.1016/j.tcs.2020.12.030},
  journal      = {Theoretical Computer Science},
  pages        = {110-120},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On the status sequences of trees},
  volume       = {856},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Trichotomy for the reconfiguration problem of integer linear
systems. <em>TCS</em>, <em>856</em>, 88–109. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.025">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we consider the reconfiguration problem of integer linear systems. In this problem, we are given an integer linear system I and two feasible solutions s and t of I , and then asked to transform s to t by changing a value of only one variable at a time, while maintaining a feasible solution of I throughout. Z ( I ) Z(I) for I is the complexity index introduced by Kimura and Makino (Discrete Applied Mathematics 200:67–78, 2016), which is defined by the sign pattern of the input matrix. We analyze the complexity of the reconfiguration problem of integer linear systems based on the complexity index Z ( I ) Z(I) of given I . We then show that the problem is (i) solvable in constant time if Z ( I ) Z(I) is less than one, (ii) weakly coNP-complete and pseudo-polynomially solvable if Z ( I ) Z(I) is exactly one, and (iii) PSPACE-complete if Z ( I ) Z(I) is greater than one. Since the complexity indices of Horn and two-variable-par-inequality integer linear systems are at most one, our results imply that the reconfiguration of these systems are in coNP and pseudo-polynomially solvable. Moreover, this is the first result that reveals coNP-completeness for a reconfiguration problem, to the best of our knowledge.},
  archive      = {J_TCS},
  author       = {Kei Kimura and Akira Suzuki},
  doi          = {10.1016/j.tcs.2020.12.025},
  journal      = {Theoretical Computer Science},
  pages        = {88-109},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Trichotomy for the reconfiguration problem of integer linear systems},
  volume       = {856},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Constructing dual-CISTs of folded divide-and-swap cubes.
<em>TCS</em>, <em>856</em>, 75–87. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.023">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_TCS},
  author       = {Yu-Huei Chang and Kung-Jui Pai and Chiun-Chieh Hsu and Jinn-Shyong Yang and Jou-Ming Chang},
  doi          = {10.1016/j.tcs.2020.12.023},
  journal      = {Theoretical Computer Science},
  pages        = {75-87},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Constructing dual-CISTs of folded divide-and-swap cubes},
  volume       = {856},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Generating clause sequences of a CNF formula. <em>TCS</em>,
<em>856</em>, 68–74. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.021">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Given a CNF formula Φ with clauses C 1 , … , C m C1,…,Cm and variables V = { x 1 , … , x n } V={x1,…,xn} , a truth assignment a : V → { 0 , 1 } a:V→{0,1} of Φ leads to a clause sequence σ Φ ( a ) = ( C 1 ( a ) , … , C m ( a ) ) ∈ { 0 , 1 } m σΦ(a)=(C1(a),…,Cm(a))∈{0,1}m where C i ( a ) = 1 Ci(a)=1 if clause C i Ci evaluates to 1 under assignment a , otherwise C i ( a ) = 0 Ci(a)=0 . The set of all possible clause sequences carries a lot of information on the formula, e.g. SAT, MAX-SAT and MIN-SAT can be encoded in terms of finding a clause sequence with extremal properties . We consider a problem posed at Dagstuhl Seminar 19211 “Enumeration in Data Management” (2019) about the generation of all possible clause sequences of a given CNF with bounded dimension. We prove that the problem can be solved in incremental polynomial time . We further give an algorithm with polynomial delay for the class of tractable CNF formulas. We also consider the generation of maximal and minimal clause sequences, and show that generating maximal clause sequences is NP-hard, while minimal clause sequences can be generated with polynomial delay.},
  archive      = {J_TCS},
  author       = {Kristóf Bérczi and Endre Boros and Ondřej Čepek and Khaled Elbassioni and Petr Kučera and Kazuhisa Makino},
  doi          = {10.1016/j.tcs.2020.12.021},
  journal      = {Theoretical Computer Science},
  pages        = {68-74},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Generating clause sequences of a CNF formula},
  volume       = {856},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A hierarchy of local decision. <em>TCS</em>, <em>856</em>,
51–67. (<a href="https://doi.org/10.1016/j.tcs.2020.12.017">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We extend the notion of distributed decision in the framework of distributed network computing, inspired by both the polynomial hierarchy for Turing machines and recent results on so-called distributed graph automata . We show that, by using distributed decision mechanisms based on the interaction between a prover and a disprover , the size of the certificates distributed to the nodes for certifying a given network property can be drastically reduced. For instance, we prove that minimum spanning tree (MST) can be certified with O ( log ⁡ n ) O(log⁡n) -bit certificates in n -node graphs, with just one interaction between the prover and the disprover, while it is known that certifying MST requires Ω ( log 2 ⁡ n ) Ω(log2⁡n) -bit certificates if only the prover can act. The improvement can even be exponential for some simple graph properties. For instance, it is known that certifying the existence of a nontrivial automorphism requires Ω ( n 2 ) Ω(n2) bits if only the prover can act. We show that there is a protocol with two interactions between the prover and the disprover that certifies nontrivial automorphism with O ( log ⁡ n ) O(log⁡n) -bit certificates. These results are achieved by defining and analyzing a local hierarchy of decision which generalizes the classical notions of proof-labeling schemes and locally checkable proofs .},
  archive      = {J_TCS},
  author       = {Laurent Feuilloley and Pierre Fraigniaud and Juho Hirvonen},
  doi          = {10.1016/j.tcs.2020.12.017},
  journal      = {Theoretical Computer Science},
  pages        = {51-67},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A hierarchy of local decision},
  volume       = {856},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Online two-way trading: Randomization and advice.
<em>TCS</em>, <em>856</em>, 41–50. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.016">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider the following online two-way trading problem: given some amount of money and a stock (security) of fluctuating prices, we want to perform a bounded number of speculative trades so as to make the most money. We assume a global fluctuation model, where global limits on the minimum and maximum possible prices are given. Previously, optimal algorithms were established in the deterministic case . In this paper we consider two models that improve the competitiveness: randomized algorithms , and algorithms with advice. In most cases we give close to optimal upper and lower bounds on the competitive ratios .},
  archive      = {J_TCS},
  author       = {Stanley P.Y. Fung},
  doi          = {10.1016/j.tcs.2020.12.016},
  journal      = {Theoretical Computer Science},
  pages        = {41-50},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Online two-way trading: Randomization and advice},
  volume       = {856},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Computational complexity of k-block conjugacy. <em>TCS</em>,
<em>856</em>, 21–40. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.009">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider several computational problems related to conjugacy between subshifts of finite type, restricted to k -block codes: verifying a proposed k -block conjugacy , deciding if two shifts admit a k -block conjugacy, and reducing the representation size of a shift via a k -block conjugacy. We give a polynomial-time algorithm for verification, and show GI GI - and NP NP -hardness for deciding conjugacy and reducing representation size, respectively. Our approach focuses on 1-block conjugacies between vertex shifts, from which we generalize to k -block conjugacies and to edge shifts. We conclude with several open problems.},
  archive      = {J_TCS},
  author       = {Tyler Schrock and Rafael Frongillo},
  doi          = {10.1016/j.tcs.2020.12.009},
  journal      = {Theoretical Computer Science},
  pages        = {21-40},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Computational complexity of k-block conjugacy},
  volume       = {856},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Proofs of conservation inequalities for levin’s notion of
mutual information of 1974. <em>TCS</em>, <em>856</em>, 14–20. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.003">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper we consider Levin&#39;s notion of mutual information in infinite 0-1-sequences, as defined in Levin (1974) [6] . The respective information conservation inequalities were stated in that paper without proofs. Later some proofs appeared in the literature, however no proof of the probabilistic conservation inequality has been published yet. In this paper we prove that inequality and for the sake of completeness we present also short proofs of other properties of the said notion.},
  archive      = {J_TCS},
  author       = {Nikolay Vereshchagin},
  doi          = {10.1016/j.tcs.2020.12.003},
  journal      = {Theoretical Computer Science},
  pages        = {14-20},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Proofs of conservation inequalities for levin&#39;s notion of mutual information of 1974},
  volume       = {856},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Bounds for the capacity error function for unidirectional
channels with noiseless feedback. <em>TCS</em>, <em>856</em>, 1–13. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.049">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In digital systems such as fiber optical communications , the ratio between probability of errors of type 1 → 0 1→0 and 0 → 1 0→1 can be large. Practically, one can assume that only one type of error can occur. These errors are called asymmetric. Unidirectional errors differ from asymmetric type of errors; here both 1 → 0 1→0 and 0 → 1 0→1 type of errors are possible, but in any submitted codeword all the errors are of the same type. This can be generalized for the q -ary case. We consider q -ary unidirectional channels with feedback where the errors have magnitude one and give bounds for the capacity error function. It turns out that the bounds depend on the parity of the alphabet size q . Furthermore, we show that for feedback, the capacity error function for the binary asymmetric channel is different from the symmetric channel. This is in contrast to the behavior of the function without feedback.},
  archive      = {J_TCS},
  author       = {Christian Deppe and Vladimir Lebedev and Georg Maringer},
  doi          = {10.1016/j.tcs.2020.11.049},
  journal      = {Theoretical Computer Science},
  pages        = {1-13},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Bounds for the capacity error function for unidirectional channels with noiseless feedback},
  volume       = {856},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). How to compute digraph width measures on directed co-graphs.
<em>TCS</em>, <em>855</em>, 161–185. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.047">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper we consider the digraph width measures directed path-width, directed tree-width, directed feedback vertex set number, directed feedback arc set number, cycle rank, DAG-depth, DAG-width and Kelly-width of recursively defined digraphs. While the minimization problem for these width measures is generally NP-hard, we prove that it is computable in linear time for all these parameters, except for Kelly-width, when restricted to directed co-graphs. As an important combinatorial tool, we show how these measures can be computed for the disjoint union, order composition, directed union, and series composition of two directed graphs , which further leads to some similarities. Although it is often not possible to compare them in general, we achieved a good comparison between the width measures within this framework. The equality of directed path-width and directed tree-width on directed co-graphs generalizes the known results for undirected co-graphs of Bodlaender and Möhring.},
  archive      = {J_TCS},
  author       = {Frank Gurski and Dominique Komander and Carolin Rehs},
  doi          = {10.1016/j.tcs.2020.11.047},
  journal      = {Theoretical Computer Science},
  pages        = {161-185},
  shortjournal = {Theor. Comput. Sci.},
  title        = {How to compute digraph width measures on directed co-graphs},
  volume       = {855},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Specification and space complexity of collaborative text
editing. <em>TCS</em>, <em>855</em>, 141–160. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.046">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Collaborative text editing systems allow users to concurrently edit a shared document, inserting and deleting elements (e.g., characters or lines). There are a number of protocols for collaborative text editing, but so far there has been no abstract, high-level specification of their desired behavior, which is decoupled from their actual implementation. Several of these protocols have been shown not to satisfy even basic expectations. This paper provides a precise specification of a replicated abstract list object, which models the core functionality of replicated systems for collaborative text editing. We define a strong list specification, which we prove is implemented by an existing protocol, as well as a weak list specification, which admits additional protocol behaviors. A major factor determining the efficiency and practical feasibility of a collaborative text editing protocol is the space overhead of the metadata that the protocol must maintain to ensure correctness. We show that for a large class of list protocols, implementing either the strong or the weak list specification requires a metadata overhead that is at least linear in the number of elements deleted from the list. The class of protocols to which this lower bound applies includes all list protocols that we are aware of, in particular CRDT and OT protocols, and we show that one of these protocols almost matches the bound. The result holds for peer-to-peer protocols, even if the network guarantees causal atomic broadcast. The result also holds for the metadata cost at the clients in client/server protocols. 1},
  archive      = {J_TCS},
  author       = {Hagit Attiya and Sebastian Burckhardt and Alexey Gotsman and Adam Morrison and Hongseok Yang and Marek Zawirski},
  doi          = {10.1016/j.tcs.2020.11.046},
  journal      = {Theoretical Computer Science},
  pages        = {141-160},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Specification and space complexity of collaborative text editing},
  volume       = {855},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Coded equivalence of one-sided topological markov shifts.
<em>TCS</em>, <em>855</em>, 133–140. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.044">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce a notion of coded equivalence in one-sided topological Markov shifts. The notion is inspired by coding theory. One-sided topological conjugacy implies coded equivalence. We will show that coded equivalence implies continuous orbit equivalence of one-sided topological Markov shifts.},
  archive      = {J_TCS},
  author       = {Kengo Matsumoto},
  doi          = {10.1016/j.tcs.2020.11.044},
  journal      = {Theoretical Computer Science},
  pages        = {133-140},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Coded equivalence of one-sided topological markov shifts},
  volume       = {855},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Cryptographic reverse firewalls for interactive proof
systems. <em>TCS</em>, <em>855</em>, 104–132. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.043">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study interactive proof systems (IPSes) in a strong adversarial setting where the machines of honest parties might be corrupted and under control of the adversary. Our aim is to answer the following, seemingly paradoxical, questions: In this paper, we put forward several natural security properties for RFs in the concrete setting of IPSes. As our main contribution, we construct efficient RFs for different IPSes derived from a large class of Sigma protocols that we call malleable . A nice feature of our design is that it is completely transparent, in the sense that our RFs can be directly applied to already deployed IPSes, without the need to re-implement them.},
  archive      = {J_TCS},
  author       = {Chaya Ganesh and Bernardo Magri and Daniele Venturi},
  doi          = {10.1016/j.tcs.2020.11.043},
  journal      = {Theoretical Computer Science},
  pages        = {104-132},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Cryptographic reverse firewalls for interactive proof systems},
  volume       = {855},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Scheduling games with machine-dependent priority lists.
<em>TCS</em>, <em>855</em>, 90–103. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.042">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider a scheduling game on parallel related machines, in which jobs try to minimize their completion time by choosing a machine to be processed on. Each machine uses an individual priority list to decide on the order according to which the jobs on the machine are processed. We prove that it is NP-hard to decide if a pure Nash equilibrium exists and characterize four classes of instances in which a pure Nash equilibrium is guaranteed to exist. For each of these classes, we give an algorithm that computes a Nash equilibrium, we prove that best-response dynamics converge to a Nash equilibrium, and we bound the inefficiency of Nash equilibria with respect to the makespan of the schedule and the sum of completion times. In addition, we show that although a pure Nash equilibrium is guaranteed to exist in instances with identical machines, it is NP-hard to approximate the best Nash equilibrium with respect to both objectives.},
  archive      = {J_TCS},
  author       = {Vipin Ravindran Vijayalakshmi and Marc Schröder and Tami Tamir},
  doi          = {10.1016/j.tcs.2020.11.042},
  journal      = {Theoretical Computer Science},
  pages        = {90-103},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Scheduling games with machine-dependent priority lists},
  volume       = {855},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The vertex-pancyclicity of data center networks.
<em>TCS</em>, <em>855</em>, 74–89. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.027">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The k -dimensional data center network with n -port switches, denoted by D k , n Dk,n , has been proposed for data centers as a server centric network structure. Wang et al. had proved that D k , n Dk,n is Hamiltonian-connected for k ≥ 0 k≥0 and n ≥ 2 n≥2 except for ( k , n ) = ( 1 , 2 ) (k,n)=(1,2) . In this paper, we prove that for any edge ( u , v ) (u,v) in a complete subgraph K n Kn of D k , n Dk,n , there is a cycle of every length from 3 to | V ( D k , n ) | |V(Dk,n)| passing through the edge ( u , v ) (u,v) in D k , n Dk,n for n ≥ 5 n≥5 . As corollaries, we obtained that D k , n Dk,n is vertex-pancyclic and pancyclic.},
  archive      = {J_TCS},
  author       = {Rong-Xia Hao and Zengxian Tian},
  doi          = {10.1016/j.tcs.2020.11.027},
  journal      = {Theoretical Computer Science},
  pages        = {74-89},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The vertex-pancyclicity of data center networks},
  volume       = {855},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Proof of a conjecture on 2-isometric words. <em>TCS</em>,
<em>855</em>, 68–73. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.026">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Let F k Fk be the family of the binary words containing exactly k 0s. Ilić, Klavžar and Rho constructed an infinite subfamily of 2-isometric but not 3-isometric words among F 2 F2 . Wei, Yang and Wang further found there are 2-isometric but not 3-isometric words among F k Fk for all k ∈ { 2 , 5 , 6 } k∈{2,5,6} and k ≥ 8 k≥8 , and they conjectured that F 1 F1 , F 3 F3 , F 4 F4 and F 7 F7 are the only families in which there are not 2-isometric but not 3-isometric words. In the present paper, we show that this conjecture is true, and find all the 2-isometric words among F 5 F5 and F 6 F6 .},
  archive      = {J_TCS},
  author       = {Jianxin Wei},
  doi          = {10.1016/j.tcs.2020.11.026},
  journal      = {Theoretical Computer Science},
  pages        = {68-73},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Proof of a conjecture on 2-isometric words},
  volume       = {855},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Equitable list tree-coloring of bounded treewidth graphs.
<em>TCS</em>, <em>855</em>, 61–67. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.016">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The equitable list tree-coloring model is an useful tool to formulate a structure decomposition problem on the complex network with some security considerations. In this paper, it is proved that the equitable list vertex arboricity of every graph with treewidth ω is at most ⌈ Δ ( G ) / 2 ⌉ + ω − 2 ⌈Δ(G)/2⌉+ω−2 whenever Δ ( G ) ≥ 4 ω + 1 Δ(G)≥4ω+1 , and moreover, if such a graph does not contain K 3 , 3 K3,3 as a topological minor, then its equitable list vertex arboricity is at most ⌈ Δ ( G ) / 2 ⌉ ⌈Δ(G)/2⌉ provided that ω ∈ { 2 , 3 , 4 } ω∈{2,3,4} and Δ ( G ) ≥ 6 ω − 3 Δ(G)≥6ω−3 .},
  archive      = {J_TCS},
  author       = {Yan Li and Xin Zhang},
  doi          = {10.1016/j.tcs.2020.11.016},
  journal      = {Theoretical Computer Science},
  pages        = {61-67},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Equitable list tree-coloring of bounded treewidth graphs},
  volume       = {855},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Bounding game temperature using confusion intervals.
<em>TCS</em>, <em>855</em>, 43–60. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.015">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider bounds for the temperatures of combinatorial games. Our first result gives an upper bound on the temperatures of the positions of a ruleset in terms of the lengths of the confusion intervals of these positions. We give an example to show that this bound is tight. Our second main result is a method to find a bound for the lengths of the confusion intervals. This pair of results constitutes the first general technique to bound temperatures. As examples of the bound and the method, we consider the temperature of subsets of positions in Domineering and Snort .},
  archive      = {J_TCS},
  author       = {Svenja Huntemann and Richard J. Nowakowski and Carlos Pereira dos Santos},
  doi          = {10.1016/j.tcs.2020.11.015},
  journal      = {Theoretical Computer Science},
  pages        = {43-60},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Bounding game temperature using confusion intervals},
  volume       = {855},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Being a permutation is also orthogonal to one-wayness in
quantum world: Impossibilities of quantum one-way permutations from
one-wayness primitives. <em>TCS</em>, <em>855</em>, 16–42. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.013">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, three impossible results for one-way permutations in the quantum world are obtained. The first one is the impossibility of fully black-box reduction from one-way permutations to one-way functions in a quantum setting. The two-oracle method is the main technique adopted in our proof that was originally proposed by Hsiao and Reyzin, and extended later to a quantum setting by Hosoyamada and Yamakawa. Informally this technique involves a pair of oracles, and in our proof, one oracle is chosen as a random function, and the other one is devised for breaking the security of quantum one-way permutation. We show, according to the first oracle, that there is an oracle-aided circuit that is a quantum-secure one-way function. However, we also show, according to the second oracle, that there is no one-way permutation relative to those oracles. It hence claims the impossibility in the quantum setting to construct one-way permutations from one-way functions (even if both input and output are classical). The rest two impossibilities are essential enhancements of the first impossibility: We successfully obtain that it is impossible, in the quantum world, to obtain one-way permutations in a black-box manner from injective adaptive one-way functions, and (respectively) even from injective adaptive trapdoor functions. In order to reach the latter two results, we manage to get over the obstacle of finding the inverse of random injective functions even given the partial invert oracle in the quantum setting. As a result, we get a quantum lower bound of inverting random injective functions in random case. That should be of independent interest in this paper, which might, to authors&#39; knowledge, be the first quantum lower bound of inverting random injective functions given the partial invert oracle.},
  archive      = {J_TCS},
  author       = {Shujiao Cao and Rui Xue},
  doi          = {10.1016/j.tcs.2020.11.013},
  journal      = {Theoretical Computer Science},
  pages        = {16-42},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Being a permutation is also orthogonal to one-wayness in quantum world: Impossibilities of quantum one-way permutations from one-wayness primitives},
  volume       = {855},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the price of stability of some simple graph-based hedonic
games. <em>TCS</em>, <em>855</em>, 1–15. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.012">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider graph-based hedonic games such as simple symmetric fractional hedonic games and social distance games, where a group of utility maximizing players have hedonic preferences over the players&#39; set, and wish to be partitioned into clusters so that they are grouped together with players they prefer. The players are nodes in a connected graph and their preferences are defined so that shorter graph distance implies higher preference. We are interested in Nash equilibria of such games, where no player has an incentive to unilaterally deviate to another cluster, and we focus on the notion of the price of stability. We present new and improved bounds on the price of stability for several graph classes, as well as for a slightly modified utility function.},
  archive      = {J_TCS},
  author       = {Christos Kaklamanis and Panagiotis Kanellopoulos and Konstantinos Papaioannou and Dimitris Patouchas},
  doi          = {10.1016/j.tcs.2020.11.012},
  journal      = {Theoretical Computer Science},
  pages        = {1-15},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On the price of stability of some simple graph-based hedonic games},
  volume       = {855},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Bounded-degree spanners in the presence of polygonal
obstacle. <em>TCS</em>, <em>854</em>, 159–173. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.024">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Let V be a finite set of vertices in the plane and S be a finite set of polygonal obstacles, where the vertices of S are in V . We show how to construct a plane 2-spanner of the visibility graph of V with respect to S . As this graph can have unbounded degree, we modify it in three easy-to-follow steps, in order to bound the degree to 7 at the cost of slightly increasing the spanning ratio to 6.},
  archive      = {J_TCS},
  author       = {André van Renssen and Gladys Wong},
  doi          = {10.1016/j.tcs.2020.12.024},
  journal      = {Theoretical Computer Science},
  pages        = {159-173},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Bounded-degree spanners in the presence of polygonal obstacle},
  volume       = {854},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). FLUID: A common model for semantic structural graph
summaries based on equivalence relations. <em>TCS</em>, <em>854</em>,
136–158. (<a href="https://doi.org/10.1016/j.tcs.2020.12.019">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Summarization is a widespread method for handling very large graphs. The task of structural graph summarization is to compute a concise but meaningful synopsis of the key structural information of a graph. As summaries may be used for many different purposes, there is no single concept or model of graph summaries. We have studied existing structural graph summaries for large-scale (semantic) graphs. Despite their different concepts and purposes, we found commonalities in the graph structures they capture. We use these commonalities to provide for the first time a formally defined common model, FLUID (FLexible graph sUmmarIes for Data graphs), that allows us to flexibly define structural graph summaries. FLUID allows graph summaries to be quickly defined, adapted, and compared for different purposes and datasets. To this end, FLUID provides features of structural summarization based on equivalence relations such as distinction of types and properties, direction of edges, bisimulation, and inference. We conduct a detailed complexity analysis of the features provided by FLUID. We show that graph summaries defined with FLUID can be computed in the worst case in time O ( n 2 ) O(n2) w.r.t. n , the number of edges in the data graph. An empirical analysis of large-scale web graphs with billions of edges indicates a typical running time of Θ ( n ) Θ(n) . Based on the formal FLUID model, one can quickly define and modify various structural graph summaries from the literature and beyond.},
  archive      = {J_TCS},
  author       = {Till Blume and David Richerby and Ansgar Scherp},
  doi          = {10.1016/j.tcs.2020.12.019},
  journal      = {Theoretical Computer Science},
  pages        = {136-158},
  shortjournal = {Theor. Comput. Sci.},
  title        = {FLUID: A common model for semantic structural graph summaries based on equivalence relations},
  volume       = {854},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A note on the geodetic number and the steiner number of
AT-free graphs. <em>TCS</em>, <em>854</em>, 131–135. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.010">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study two graph parameters, namely the geodetic number and the Steiner number, which are related to the concept of convexity. We show that, in asteroidal triple-free graphs, the Steiner number is greater than or equal to the geodetic number. This answers a question posed by Hernando, Jiang, Mora, Pelayo, and Seara in 2005. Besides, we show that the gap between the two parameters can be arbitrarily large even in unit-interval graphs, a proper subclass of AT-free graphs.},
  archive      = {J_TCS},
  author       = {Wing-Kai Hon and Ton Kloks and Hsiang-Hsuan Liu and Hung-Lung Wang and Yue-Li Wang},
  doi          = {10.1016/j.tcs.2020.12.010},
  journal      = {Theoretical Computer Science},
  pages        = {131-135},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A note on the geodetic number and the steiner number of AT-free graphs},
  volume       = {854},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Nested cover-free families for unbounded fault-tolerant
aggregate signatures. <em>TCS</em>, <em>854</em>, 116–130. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.008">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Aggregate signatures are used to create one short proof of authenticity and integrity from a set of digital signatures. However, one invalid signature in the set invalidates the entire aggregate, giving no information on which signatures are valid. Hartung et al. (2016) [6] propose a fault-tolerant aggregate signature scheme based on combinatorial group testing . Given a bound d on the number of invalid signatures among n signatures to be aggregated, this scheme uses d -cover-free families to determine which signatures are invalid. These combinatorial structures guarantee a moderate increase on the size of the aggregate signature that can reach the best possible compression ratio of O ( n log ⁡ n ) O(nlog⁡n) , for fixed d , coming from an information theoretical bound. The case where the total number of signatures grows dynamically (unbounded scheme) was not satisfactorily solved in their original paper, since explicit constructions had constant compression ratios. In the present paper, we propose efficient solutions for the unbounded scheme, relying on sequences of d -cover-free families that we call nested families . Some of our constructions yield high compression ratio close to the best known upper bound. We also propose the use of ( d , λ ) (d,λ) -cover-free families to support the loss of up to λ − 1 λ−1 parts of the aggregate.},
  archive      = {J_TCS},
  author       = {Thais Bardini Idalino and Lucia Moura},
  doi          = {10.1016/j.tcs.2020.12.008},
  journal      = {Theoretical Computer Science},
  pages        = {116-130},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Nested cover-free families for unbounded fault-tolerant aggregate signatures},
  volume       = {854},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A new approach to regular &amp; indeterminate strings.
<em>TCS</em>, <em>854</em>, 105–115. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.007">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper we propose a new, more appropriate definition of regular and indeterminate strings. A regular string is one that is “isomorphic” to a string whose entries all consist of a single letter, but which nevertheless may itself include entries containing multiple letters. A string that is not regular is said to be indeterminate . We begin by proposing a new model for the representation of strings, regular or indeterminate, then go on to describe a linear time algorithm to determine whether or not a string x = x [ 1 . . n ] x=x[1..n] is regular and, if so, to replace it by a lexicographically least (lex-least) string y whose entries are all single letters. Furthermore, we connect the regularity of a string to the transitive closure problem on a graph, which in our special case can be efficiently solved. We then introduce the idea of a feasible palindrome array MP of a string, and prove that every feasible MP corresponds to some (regular or indeterminate) string. We describe an algorithm that constructs a string x corresponding to given feasible MP, while ensuring that whenever possible x is regular and if so, then lex-least. A final section outlines new research directions suggested by this changed perspective on regular and indeterminate strings.},
  archive      = {J_TCS},
  author       = {Felipe A. Louza and Neerja Mhaskar and W.F. Smyth},
  doi          = {10.1016/j.tcs.2020.12.007},
  journal      = {Theoretical Computer Science},
  pages        = {105-115},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A new approach to regular &amp; indeterminate strings},
  volume       = {854},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Mixed-case community detection problem in social networks:
Algorithms and analysis. <em>TCS</em>, <em>854</em>, 94–104. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.005">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The problem of detecting communities is one of the essential problems in the study of social networks. To devise the algorithms of community detection, one should first define high-quality communities. In fact, there are no agreed methods to measure the quality of the community. In this paper, we consider a novel objective function of this problem. Our goal is to maximize not only the average of the sum of edge weights within communities (i.e., average-case) but also the sum of edge weights within the minimum community (i.e., worst-case). To balance both the average-case and worst-case problems, we introduce a parameter into our objective function and call it the mixed-cased community detection problem. For the worst-case, we devise several approximation algorithms , such as the Greedy, Semi-Sandwich Approximation , and Local Search algorithms . For the average-case, an efficient Terminal-based algorithm is proposed. We prove that the best solution between the average-case and worst-case problems still can provide an approximate guarantee for any mixed-case community detection problem. Moreover, we devise a heuristic algorithm for our problem. Finally, we conduct the experiments in three networks. The experimental results indicate that our proposed methods can form a high-quality community partition.},
  archive      = {J_TCS},
  author       = {Yapu Zhang and Jianxiong Guo and Wenguo Yang and Weili Wu},
  doi          = {10.1016/j.tcs.2020.12.005},
  journal      = {Theoretical Computer Science},
  pages        = {94-104},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Mixed-case community detection problem in social networks: Algorithms and analysis},
  volume       = {854},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Multi-matching nested relations. <em>TCS</em>, <em>854</em>,
77–93. (<a href="https://doi.org/10.1016/j.tcs.2020.12.004">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Multi-matching nested relation consists of a sequence of linearly ordered positions, call , internal , and return , augmented with one-to-one, one-to-n or n-to-one matching nested edges from call to return . For clarity, inner-call and inner-return are defined in n-to-one and one-to-n matching nested relations respectively. After word encoding by introducing tagged letters, Multi-matching Nested Words (MNWs) are obtained over a tagged alphabet. Then Multi-matching Nested Expression (MNE) and Multi-matching Nested Traceable Automaton (MNTA) are defined over MNWs. The closure properties of languages over MNWs are studied, including union, intersection, concatenation, Kleene-* and complementation. Moreover, nondeterministic MNTAs are as expressive as deterministic ones. Further, a transformation method from MNTAs to MNEs is proposed, where three kinds of labeled arcs are created for different transitions in order for the specific merging strategies. To specify the requirements of multi-matching nested calls and returns , we propose a temporal logic of Multi-matching Nested CAlls and RETurns (MNCARET). The abstract and matched-abstract versions of modalities are considered. For example, abstract-next operator allows a path to jump from a call to the first matched non- internal , which is the inner-call , inner-return or return , in a one-to-n or n-to-one matching relation while matched-abstract-next operator from a call directly to the matched return . We also present an approach to model check MNCARET formulas for the MNTA model, a subset of pushdown automata . This problem is reduced to the emptiness problem of Büchi MNTAs.},
  archive      = {J_TCS},
  author       = {Jin Liu and Zhenhua Duan and Cong Tian},
  doi          = {10.1016/j.tcs.2020.12.004},
  journal      = {Theoretical Computer Science},
  pages        = {77-93},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Multi-matching nested relations},
  volume       = {854},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021b). Bicriteria algorithms to balance coverage and cost in team
formation under online model. <em>TCS</em>, <em>854</em>, 68–76. (<a
href="https://doi.org/10.1016/j.tcs.2020.12.002">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this work, we investigate online bicriteria algorithms that consider both coverage and cost in the team formation problem, which selects a set of experts with the objective of maximizing the difference of two set functions f − ℓ f−ℓ , where function f is non-negative normalized monotone approximately submodular, and function ℓ is non-negative linear. By exploiting the problem&#39;s combinatorial structure , we present three bicriteria algorithms along with their corresponding competitive analysis. The first two algorithms handle the cases where function f is γ -weakly submodular, and strictly γ -weakly submodular, respectively. The last algorithm is more general by integrating the first two with extra parameters introduced.},
  archive      = {J_TCS},
  author       = {Yijing Wang and Dachuan Xu and Donglei Du and Ran Ma},
  doi          = {10.1016/j.tcs.2020.12.002},
  journal      = {Theoretical Computer Science},
  pages        = {68-76},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Bicriteria algorithms to balance coverage and cost in team formation under online model},
  volume       = {854},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Tight upper and lower bounds on suffix tree breadth.
<em>TCS</em>, <em>854</em>, 63–67. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.037">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The suffix tree — the compacted trie of all the suffixes of a string — is the most important and widely-used data structure in string processing. We consider a natural combinatorial question about suffix trees: for a string S of length n , how many nodes ν S ( d ) νS(d) can there be at (string) depth d in its suffix tree? We prove ν ( n , d ) = max S ∈ Σ n ⁡ ν S ( d ) ν(n,d)=maxS∈Σn⁡νS(d) is O ( ( n / d ) log ⁡ ( n / d ) ) O((n/d)log⁡(n/d)) , and show that this bound is asymptotically tight, describing strings for which ν S ( d ) νS(d) is Ω ( ( n / d ) log ⁡ ( n / d ) ) Ω((n/d)log⁡(n/d)) .},
  archive      = {J_TCS},
  author       = {Golnaz Badkobeh and Paweł Gawrychowski and Juha Kärkkäinen and Simon J. Puglisi and Bella Zhukova},
  doi          = {10.1016/j.tcs.2020.11.037},
  journal      = {Theoretical Computer Science},
  pages        = {63-67},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Tight upper and lower bounds on suffix tree breadth},
  volume       = {854},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A framework for designing space-efficient dictionaries for
parameterized and order-preserving matching. <em>TCS</em>, <em>854</em>,
52–62. (<a href="https://doi.org/10.1016/j.tcs.2020.11.036">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Let P P be a collection of d patterns { P 1 , P 2 , … , P d } {P1,P2,…,Pd} of total length n characters, which are chosen from an alphabet Σ of size σ . Given a text T (over Σ), the dictionary indexing problem is to create a data structure using which we can report all positions j (called occurrences ) where at least one of the patterns P i ∈ P Pi∈P is a match with the same-length substring of T that starts at j . We consider this problem under the following definitions of matching.},
  archive      = {J_TCS},
  author       = {Arnab Ganguly and Wing-Kai Hon and Kunihiko Sadakane and Rahul Shah and Sharma V. Thankachan and Yilin Yang},
  doi          = {10.1016/j.tcs.2020.11.036},
  journal      = {Theoretical Computer Science},
  pages        = {52-62},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A framework for designing space-efficient dictionaries for parameterized and order-preserving matching},
  volume       = {854},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Computing a longest common almost-increasing subsequence of
two sequences. <em>TCS</em>, <em>854</em>, 44–51. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.035">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Given a positive constant c , a sequence S = 〈 s 1 , s 2 , … , s k 〉 S=〈s1,s2,…,sk〉 of k numbers is said to be almost increasing if and only if s i &gt; max 1 ≤ j si&amp;gt;max1≤j&amp;lt;i⁡sj−c for all 1 1&amp;lt;i≤k . A longest common almost-increasing subsequence (LCaIS) between two input sequences is a longest common subsequence that is also an almost increasing sequence. We found out that the existing algorithm proposed by Moosa et al. [1] to find an LCaIS of two sequences without repeated elements gives an incorrect result for some instances. In this work, we present a dynamic programming algorithm that can correctly compute an LCaIS between any two sequences with repeated elements in O ( n m l ) O(nml) time and O ( n m ) O(nm) space, where n and m are the lengths of two input sequences and l is the length of the output LCaIS.},
  archive      = {J_TCS},
  author       = {Toan Thang Ta and Yi-Kung Shieh and Chin Lung Lu},
  doi          = {10.1016/j.tcs.2020.11.035},
  journal      = {Theoretical Computer Science},
  pages        = {44-51},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Computing a longest common almost-increasing subsequence of two sequences},
  volume       = {854},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Multidimensional segment trees can do range updates in
poly-logarithmic time. <em>TCS</em>, <em>854</em>, 30–43. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.034">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Updating and querying on a range is a classical algorithmic problem with a multitude of applications. The Segment Tree data structure is particularly notable in handling the range query and update operations. A Segment Tree divides the range into disjoint segments and merges them together to perform range queries and range updates elegantly. Although this data structure is remarkably potent for 1-dimensional problems, it falls short in higher dimensions . Lazy Propagation enables the operations to be computed in O ( l o g n ) O(logn) time in a single dimension. However, the concept of lazy propagation could not be translated to higher-dimensional cases, which imposes a time complexity of O ( n k − 1 l o g n ) O(nk−1logn) for operations on k -dimensional data. In this work, we have made an attempt to emulate the idea of lazy propagation differently so that it can be applied for 2-dimensional cases. Moreover, the proposed modification should be capable of performing most general aggregate functions similar to the original Segment Tree, and can also be extended to even higher dimensions . Our proposed algorithm manages to perform range sum queries and updates in O ( log 2 ⁡ n ) O(log2⁡n) time for a 2-dimensional problem, which becomes O ( log d ⁡ n ) O(logd⁡n) for a d -dimensional situation.},
  archive      = {J_TCS},
  author       = {Nabil Ibtehaz and M. Kaykobad and M. Sohel Rahman},
  doi          = {10.1016/j.tcs.2020.11.034},
  journal      = {Theoretical Computer Science},
  pages        = {30-43},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Multidimensional segment trees can do range updates in poly-logarithmic time},
  volume       = {854},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Experimental evaluation of algorithms for computing
quasiperiods. <em>TCS</em>, <em>854</em>, 17–29. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.033">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Quasiperiodicity is a generalization of periodicity that was introduced in the early 1990s. Since then, dozens of algorithms for computing various types of quasiperiodicity were proposed. Our work is a step towards answering the general question: “Which algorithm for computing quasiperiods to choose?”. The central notions of quasiperiodicity are covers and seeds. We implement algorithms for computing covers and seeds in the original and in new simplified versions and compare their efficiency on various types of data. We also discuss other known types of quasiperiodicity, distinguish partial covers as currently the most promising for large real-world data, and check their effectiveness using real-world data.},
  archive      = {J_TCS},
  author       = {Patryk Czajka and Jakub Radoszewski},
  doi          = {10.1016/j.tcs.2020.11.033},
  journal      = {Theoretical Computer Science},
  pages        = {17-29},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Experimental evaluation of algorithms for computing quasiperiods},
  volume       = {854},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Parameterized dictionary matching and recognition with one
gap. <em>TCS</em>, <em>854</em>, 1–16. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.017">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Dictionary Matching is a variant of the Pattern Matching problem where multiple patterns are simultaneously matched to a single text. In case where the patterns contain sequences of don&#39;t care symbols, the problem is called Dictionary Matching with Gaps. The problem is related to cyber security, where the patterns represent the malware sequences we want to detect in the text, which may appear in several packets. Another famous variant of Pattern matching is the Parameterized Matching, where two equal-length strings are a parameterized match if there exists a bijection on the alphabets, such that one string matches the other under the bijection . In this paper the problem of Parameterized Dictionary Matching with One Gap is described, which is an extension of the Dictionary Matching with Gaps, where the parameterized match serves as encryption system of the malware sequences. The paper presents two algorithms solving the Parameterized Dictionary Matching with One Gap, for dictionaries with non-uniformly bounded gaps. The first solves the problem with a query time of O ( | T | δ m a x log 2 ⁡ d + o c c ) O(|T|δmaxlog2⁡d+occ) , while the second solution has a query time of O ( | T | δ m a x + o c c ) O(|T|δmax+occ) , where | T | |T| is the size of the text, d is the number of gapped patterns in the dictionary, δ m a x δmax is the difference between the highest upper bound and the lowest lower bound of the gaps and occ is the number of the gapped patterns reported as output. We also suggest the related problem of Parameterized Dictionary Recognition with One Gap, which requires reporting a single parameterized appearance of each gapped pattern. This is of interest in case we want only to know which malware sequences where detected in the text, and not the details of all their appearances in the text, that may be numerous. We present similar algorithms for this problem as well.},
  archive      = {J_TCS},
  author       = {B. Riva Shalom},
  doi          = {10.1016/j.tcs.2020.11.017},
  journal      = {Theoretical Computer Science},
  pages        = {1-16},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Parameterized dictionary matching and recognition with one gap},
  volume       = {854},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Approximation algorithms for spherical k-means problem using
local search scheme. <em>TCS</em>, <em>853</em>, 65–77. (<a
href="https://doi.org/10.1016/j.tcs.2020.06.029">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In the spherical k -means problem (SKMP), which is a well-studied clustering problem in text mining, we are given an n -point set D in d -dimensional unit sphere Sd , and an integer k≤n . The goal is to find a center subset S⊂Sd with |S|≤k that minimizes the sum of cosine dissimilarity measure for each point in D to the nearest center. We prove that any γ -approximation algorithm for the k -means problem (KMP) can be adapted to the SKMP with 2 γ -approximation ratio. It follows that there is a local search (18+ϵ) -approximation algorithm for the SKMP, by leveraging the classical local search (9+ϵ) -approximation algorithm for the KMP. Therefore, an interesting problem arises, that is whether there exists an approximation algorithm using local search scheme directly for the SKMP. In this paper, we present a local search approximation algorithm for the SKMP and prove its performance guarantee is (2(4+7)+ϵ) . We also conduct numerical computation to show the efficiency of the local search approximation algorithm by single-swap operation in the end.},
  archive      = {J_TCS},
  author       = {Dongmei Zhang and Yukun Cheng and Min Li and Yishui Wang and Dachuan Xu},
  doi          = {10.1016/j.tcs.2020.06.029},
  journal      = {Theoretical Computer Science},
  pages        = {65-77},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Approximation algorithms for spherical k-means problem using local search scheme},
  volume       = {853},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A constrained two-stage submodular maximization.
<em>TCS</em>, <em>853</em>, 57–64. (<a
href="https://doi.org/10.1016/j.tcs.2020.05.024">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we investigate the two-stage submodular maximization problem, where there is a collection F = { f 1 , . . . , f m } F={f1,...,fm} of m submodular functions which are defined on the same element ground set Ω. The goal is to select a subset S ⊆ Ω S⊆Ω of size at most ℓ such that 1 m ∑ f ∈ F max T ⊆ S , T ∈ I ⁡ f ( T ) 1m∑f∈FmaxT⊆S,T∈I⁡f(T) is maximized, where I I denotes a specifically-defined independence system. We consider the two-stage submodular maximization with a P -matroid constraint and present a ( 1 / ( P + 1 ) ) ( 1 − 1 / e ( P + 1 ) ) (1/(P+1))(1−1/e(P+1)) -approximation algorithm. Furthermore, we extend the algorithm to the two-stage submodular maximization with a more generalized P -exchange system constraint and show the approximation ratio can be maintained with slightly modifications of the algorithm.},
  archive      = {J_TCS},
  author       = {Ruiqi Yang and Shuyang Gu and Chuangen Gao and Weili Wu and Hua Wang and Dachuan Xu},
  doi          = {10.1016/j.tcs.2020.05.024},
  journal      = {Theoretical Computer Science},
  pages        = {57-64},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A constrained two-stage submodular maximization},
  volume       = {853},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Approximation algorithms for the dynamic k-level facility
location problems. <em>TCS</em>, <em>853</em>, 43–56. (<a
href="https://doi.org/10.1016/j.tcs.2020.05.022">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we first consider a dynamic k -level facility location problem, which is a generalization of the k -level facility location problem when considering time factor. We present a combinatorial primal-dual approximation algorithm for this problem which finds a constant factor approximate solution. Then, we investigative the dynamic k -level facility location problem with submodular penalties and outliers, which extend the existing problem on two fronts, namely from static to dynamic and from without penalties (outliers) to penalties (outliers) allowed. Based on primal-dual technique and the triangle inequality property, we also give two constant factor approximation algorithms for the dynamic problem with submodular penalties and outliers, respectively.},
  archive      = {J_TCS},
  author       = {Limin Wang and Zhao Zhang and Chenchen Wu and Dachuan Xu and Xiaoyan Zhang},
  doi          = {10.1016/j.tcs.2020.05.022},
  journal      = {Theoretical Computer Science},
  pages        = {43-56},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Approximation algorithms for the dynamic k-level facility location problems},
  volume       = {853},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Optimizing flight trajectory of UAV for efficient data
collection in wireless sensor networks. <em>TCS</em>, <em>853</em>,
25–42. (<a href="https://doi.org/10.1016/j.tcs.2020.05.019">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Unmanned Aerial Vehicles (UAVs) are expected to be important components in the upcoming wireless communication field, which are increasingly used as data collectors to gather sensory data from Wireless Sensor Networks (WSNs) due to their high mobility, flexible deployment. Since the storage capacity and lifetime of sensors are increasing with the development of science and technology, sensors can store more and more sensing data about the monitoring area. However, due to the energy limitation of UAVs and a large amount of data carried by sensors, we can not collect all data from WSN within the limited time. Therefore, in this paper, we investigate two problems: (1) without the energy limitation of UAV, how to optimize the trajectory of UAV to minimize the sum of traveling time and data transmission time of UAV while guaranteeing the amount of data collected from each sensor reaches to a certain proportion of the original data, which is called the Minimizing Transportation and Communication Latency (MTCL) problem; (2) given the limited budget of UAV, how to find the optimal trajectory of UAV to maximize the minimum ratio of the collected data to the stored data among all sensors, which is called the Maximizing Data Collection Proportion (MDCP) problem. We first prove that both the problems are NP-Complete. Then we study a special case of the MTCL problem, which is called the MTCL-disjoint problem, in which any pair of data collection areas are disjoint, and we propose an approximation algorithm to solve the MTCL-disjoint problem. Based on the MTCL-disjoint problem, we propose an approximation algorithm for the general MTCL problem. Afterward, an approximation algorithm for the MDCP problem is proposed on the basis of the algorithm for the MTCL problem. Finally, we present numerical results in different scenarios to assess the effectiveness of the proposed algorithms.},
  archive      = {J_TCS},
  author       = {Chuanwen Luo and Wenping Chen and Deying Li and Yongcai Wang and Hongwei Du and Lidong Wu and Weili Wu},
  doi          = {10.1016/j.tcs.2020.05.019},
  journal      = {Theoretical Computer Science},
  pages        = {25-42},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Optimizing flight trajectory of UAV for efficient data collection in wireless sensor networks},
  volume       = {853},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Maximize a monotone function with a generic submodularity
ratio. <em>TCS</em>, <em>853</em>, 16–24. (<a
href="https://doi.org/10.1016/j.tcs.2020.05.018">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Generic submodularity ratio γ is a general measurement to characterize how close a nonnegative monotone set function is to be submodular. In this paper, we make a systematic analysis of greedy algorithms for maximizing a monotone and normalized set function with a generic submodularity ratio γ under Cardinality constraints, Knapsack constraints, Matroid constraints and K -intersection constraints.},
  archive      = {J_TCS},
  author       = {Suning Gong and Qingqin Nong and Tao Sun and Qizhi Fang and Dingzhu Du and Xiaoyu Shao},
  doi          = {10.1016/j.tcs.2020.05.018},
  journal      = {Theoretical Computer Science},
  pages        = {16-24},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Maximize a monotone function with a generic submodularity ratio},
  volume       = {853},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A new approximation algorithm for contig-based genomic
scaffold filling. <em>TCS</em>, <em>853</em>, 7–15. (<a
href="https://doi.org/10.1016/j.tcs.2020.05.017">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Genomic Scaffold Filling problem forms an important class of problems, and has been paid lots of attention in the literature. In this paper, we study one of the Genomic Scaffold Filling problems, called One-sided-GSF-max-BC problem. In this paper, we give a new approximation algorithm for the problem. For any given instance of the One-sided-GSF-max-BC problem, auxiliary graphs are constructed based on the given instance and the relation between maximum matching in auxiliary graphs and optimal solution is studied, which results in an approximation algorithm with ratio 2.57.},
  archive      = {J_TCS},
  author       = {Guanlan Tan and Qilong Feng and Xiangzhong Meng and Jianxin Wang},
  doi          = {10.1016/j.tcs.2020.05.017},
  journal      = {Theoretical Computer Science},
  pages        = {7-15},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A new approximation algorithm for contig-based genomic scaffold filling},
  volume       = {853},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On approximation algorithm for the edge metric dimension
problem. <em>TCS</em>, <em>853</em>, 2–6. (<a
href="https://doi.org/10.1016/j.tcs.2020.05.005">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we study the edge metric dimension problem (EMDP). We establish a potential function and give a corresponding greedy algorithm with approximation ratio 1+ln⁡n+ln⁡(log2⁡n) , where n is the number of vertices in the graph G .},
  archive      = {J_TCS},
  author       = {Yufei Huang and Bo Hou and Wen Liu and Lidong Wu and Stephen Rainwater and Suogang Gao},
  doi          = {10.1016/j.tcs.2020.05.005},
  journal      = {Theoretical Computer Science},
  pages        = {2-6},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On approximation algorithm for the edge metric dimension problem},
  volume       = {853},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Special issue on the international conference on algorithmic
aspects in information and management 2019 (AAIM’19). <em>TCS</em>,
<em>853</em>, 1. (<a
href="https://doi.org/10.1016/j.tcs.2021.01.001">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_TCS},
  author       = {Xiaoming Sun and Jialin Zhang},
  doi          = {10.1016/j.tcs.2021.01.001},
  journal      = {Theoretical Computer Science},
  pages        = {1},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Special issue on the international conference on algorithmic aspects in information and management 2019 (AAIM&#39;19)},
  volume       = {853},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the area requirements of planar straight-line orthogonal
drawings of ternary trees. <em>TCS</em>, <em>852</em>, 197–211. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.032">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we study the area requirements of planar straight-line orthogonal drawings of ternary trees. We prove that every ternary tree admits such a drawing in sub-quadratic area. Further, we present upper bounds, the outcomes of an experimental evaluation, and a conjecture on the area requirements of planar straight-line orthogonal drawings of complete ternary trees. Finally, we present a polynomial lower bound on the length of the minimum side of any planar straight-line orthogonal drawing of a complete ternary tree.},
  archive      = {J_TCS},
  author       = {Barbara Covella and Fabrizio Frati and Maurizio Patrignani},
  doi          = {10.1016/j.tcs.2020.11.032},
  journal      = {Theoretical Computer Science},
  pages        = {197-211},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On the area requirements of planar straight-line orthogonal drawings of ternary trees},
  volume       = {852},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On bounded linear codes and the commutative equivalence.
<em>TCS</em>, <em>852</em>, 185–196. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.031">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The problem of the commutative equivalence of semigroups generated by semi-linear languages is studied. In particular conditions ensuring that the Kleene closure of a bounded semi-linear code is commutatively equivalent to a regular language are investigated.},
  archive      = {J_TCS},
  author       = {Arturo Carpi and Flavio D&#39;Alessandro},
  doi          = {10.1016/j.tcs.2020.11.031},
  journal      = {Theoretical Computer Science},
  pages        = {185-196},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On bounded linear codes and the commutative equivalence},
  volume       = {852},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Fixed-parameter algorithms for the weighted max-cut problem
on embedded 1-planar graphs. <em>TCS</em>, <em>852</em>, 172–184. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.030">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We propose two fixed-parameter tractable algorithms for the weighted Max-Cut problem on embedded 1-planar graphs parameterized by the crossing number k of the given embedding. A graph is called 1-planar if it can be drawn in the plane with at most one crossing per edge. Our algorithms recursively reduce a 1-planar graph to at most 3 k 3k planar graphs , using edge removal and node contraction. Our main algorithm then solves the Max-Cut problem for the planar graphs using the FCE-MaxCut introduced by Liers and Pardella [23] . In the case of non-negative edge weights, we suggest a variant that allows to solve the planar instances with any planar Max-Cut algorithm. We show that a maximum cut in the given 1-planar graph can be derived from the solutions for the planar graphs. Our algorithms compute a maximum cut in an embedded weighted 1-planar graph with n nodes and k edge crossings in time O ( 3 k ⋅ n 3 / 2 log ⁡ n ) O(3k⋅n3/2log⁡n) .},
  archive      = {J_TCS},
  author       = {Christine Dahn and Nils M. Kriege and Petra Mutzel and Julian Schilling},
  doi          = {10.1016/j.tcs.2020.11.030},
  journal      = {Theoretical Computer Science},
  pages        = {172-184},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Fixed-parameter algorithms for the weighted max-cut problem on embedded 1-planar graphs},
  volume       = {852},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Optimal skeleton and reduced huffman trees. <em>TCS</em>,
<em>852</em>, 157–171. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.025">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A skeleton Huffman tree is a Huffman tree from which all full subtrees of depth h ≥ 1 h≥1 have been pruned. Skeleton Huffman trees are used to save storage and enhance processing time in several applications such as decoding, compressed pattern matching and wavelet trees for random access. A reduced skeleton tree prunes the skeleton Huffman tree further to an even smaller tree. The resulting more compact trees can be used to further enhance the time and space complexities of the corresponding algorithms. However, it is shown that the straightforward ways of basing the constructions of a skeleton tree as well as that of a reduced skeleton tree on a canonical Huffman tree do not necessarily yield the least number of nodes. New algorithms for achieving such trees are given.},
  archive      = {J_TCS},
  author       = {Shmuel T. Klein and Jakub Radoszewski and Tamar C. Serebro and Dana Shapira},
  doi          = {10.1016/j.tcs.2020.11.025},
  journal      = {Theoretical Computer Science},
  pages        = {157-171},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Optimal skeleton and reduced huffman trees},
  volume       = {852},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Space-efficient construction of compressed suffix trees.
<em>TCS</em>, <em>852</em>, 138–156. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.024">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We show how to build several data structures of central importance to string processing by taking as input the Burrows-Wheeler transform (BWT) and using small extra working space. Let n be the text length and σ be the alphabet size. We first provide two algorithms that enumerate all LCP values and suffix tree intervals in O ( n log ⁡ σ ) O(nlog⁡σ) time using just o ( n log ⁡ σ ) o(nlog⁡σ) bits of working space on top of the input re-writable BWT. Using these algorithms as building blocks , for any parameter 0 0&amp;lt;ϵ≤1 we show how to build the PLCP bitvector and the balanced parentheses representation of the suffix tree topology in O ( n ( log ⁡ σ + ϵ − 1 ⋅ log ⁡ log ⁡ n ) ) O(n(log⁡σ+ϵ−1⋅log⁡log⁡n)) time using at most n log ⁡ σ ⋅ ( ϵ + o ( 1 ) ) nlog⁡σ⋅(ϵ+o(1)) bits of working space on top of the input re-writable BWT and the output. For example, we can build a compressed suffix tree from the BWT using just succinct working space (i.e. o ( n log ⁡ σ ) o(nlog⁡σ) bits) and Θ ( n log ⁡ σ + n ( log ⁡ log ⁡ n ) 1 + δ ) Θ(nlog⁡σ+n(log⁡log⁡n)1+δ) time, for any constant δ &gt; 0 δ&amp;gt;0 . This improves the previous most space-efficient algorithms, which worked in O ( n ) O(n) bits and O ( n log ⁡ n ) O(nlog⁡n) time. We also consider the problem of merging BWTs of string collections, and provide a solution running in O ( n log ⁡ σ ) O(nlog⁡σ) time and using just o ( n log ⁡ σ ) o(nlog⁡σ) bits of working space. An efficient implementation of our LCP construction and BWT merge algorithms uses (in RAM) as few as n bits on top of a packed representation of the input/output and process data as fast as 2.92 megabases per second.},
  archive      = {J_TCS},
  author       = {Nicola Prezza and Giovanna Rosone},
  doi          = {10.1016/j.tcs.2020.11.024},
  journal      = {Theoretical Computer Science},
  pages        = {138-156},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Space-efficient construction of compressed suffix trees},
  volume       = {852},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Towards a real time algorithm for parameterized longest
common prefix computation. <em>TCS</em>, <em>852</em>, 132–137. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.023">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Parameterized matching has proven to be an efficient and useful tool for detecting code duplications. This paper presents a technique for calculating parameterized Longest Common Prefix ( p l c p plcp ) in constant time based on the knowledge about the p l c p plcp of the following suffixes. Using this technique, online p-suffix tree construction can be done in worst case time O ( log ⁡ n ) O(log⁡n) per input symbol. Searching for a pattern of length m in the resulting suffix tree takes O ( min ⁡ { m log ⁡ ( | Σ | + | Π | ) , m + log ⁡ n } + m τ Π + t o c c ) O(min⁡{mlog⁡(|Σ|+|Π|),m+log⁡n}+mτΠ+tocc) time, where t o c c tocc is the number of occurrences of the pattern, and τ Π τΠ depends on Π. For constant-sized Π, τ Π = 1 τΠ=1 , for polynomial-sized Π, τ Π = log ⁡ log ⁡ | Π | τΠ=log⁡log⁡|Π| , and for unbounded Π, τ Π = log ⁡ | Π | τΠ=log⁡|Π| .},
  archive      = {J_TCS},
  author       = {Amihood Amir and Eitan Kondratovsky},
  doi          = {10.1016/j.tcs.2020.11.023},
  journal      = {Theoretical Computer Science},
  pages        = {132-137},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Towards a real time algorithm for parameterized longest common prefix computation},
  volume       = {852},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Automedian sets of permutations: Direct sum and shuffle.
<em>TCS</em>, <em>852</em>, 121–131. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.022">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Given a set A ⊆ S n A⊆Sn of m permutations of { 1 , 2 , … , n } {1,2,…,n} and a distance function d , the median problem consists in finding the set M ( A ) M(A) of all the permutations that are the “closest” of this set A A . In this article we study the automedian case of the problem, i.e. when A = M ( A ) A=M(A) , under the Kendall- τ distance. We show that automedian sets of permutations are closed under the direct sum operation and also, when some balancing properties are imposed on these sets, under the shuffle operation. These results allow us to derive a parallel algorithm that computes the medians of any separable set of permutations in O ( k ! + m n ) O(k!+mn) , where k is the length of its longest inseparable component.},
  archive      = {J_TCS},
  author       = {Charles Desharnais and Sylvie Hamel},
  doi          = {10.1016/j.tcs.2020.11.022},
  journal      = {Theoretical Computer Science},
  pages        = {121-131},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Automedian sets of permutations: Direct sum and shuffle},
  volume       = {852},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The maximum colorful arborescence problem: How
(computationally) hard can it be? <em>TCS</em>, <em>852</em>, 104–120.
(<a href="https://doi.org/10.1016/j.tcs.2020.11.021">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Given a vertex-colored arc-weighted directed acyclic graph G , the Maximum Colorful Subtree problem (or MCS ) aims at finding an arborescence of maximum weight in G , in which no color appears more than once. The problem was originally introduced in [1] in the context of de novo identification of metabolites by tandem mass spectrometry. However, a thorough analysis of the initial motivation shows that the formal definition of MCS should be amended, since the input graph G actually possesses extra properties, which have been unexploited so far. This leads us to describe in this paper a more precise model that we call Maximum Colorful Arborescence ( MCA ), which we extensively study in terms of algorithmic complexity . In particular, we show that exploiting the implied Color Hierarchy Graph of the input graph G can lead to exact polynomial algorithms and approximation algorithms . We also develop Fixed-Parameter Tractable ( FPT FPT ) algorithms for the problem parameterized by the “dual parameter” ℓ C ℓC , defined as the minimum number of vertices of G which are not kept in the solution.},
  archive      = {J_TCS},
  author       = {Guillaume Fertin and Julien Fradin and Géraldine Jean},
  doi          = {10.1016/j.tcs.2020.11.021},
  journal      = {Theoretical Computer Science},
  pages        = {104-120},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The maximum colorful arborescence problem: How (computationally) hard can it be?},
  volume       = {852},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Influence maximization in the presence of vulnerable nodes:
A ratio perspective. <em>TCS</em>, <em>852</em>, 84–103. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.020">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Influence maximization is a key problem seeking to identify users who will diffuse information to influence the largest number of other users in a social network. A drawback of the influence maximization problem is that it could be socially irresponsible to influence users many of whom would be harmed, due to their demographics, health conditions, or socioeconomic characteristics (e.g., predominantly overweight people influenced to buy junk food). Motivated by this drawback and by the fact that some of these vulnerable users will be influenced inadvertently, we introduce the problem of finding a set of users ( seeds ) that limits the influence to vulnerable users while maximizing the influence to the non-vulnerable users. We define a measure that captures the quality of a set of seeds as an additively smoothed ratio ( ASR ) between the expected number of influenced non-vulnerable users and the expected number of influenced vulnerable users. Then, we develop methods which aim to find a set of seeds that maximizes the measure: greedy heuristics , an approximation algorithm , as well as several variations of the approximation algorithm . We evaluate our methods on synthetic and real-world datasets and demonstrate they substantially outperform a state-of-the-art competitor in terms of both effectiveness and efficiency. We also demonstrate that the variations of our approximation algorithm offer different trade-offs between effectiveness and efficiency.},
  archive      = {J_TCS},
  author       = {Huiping Chen and Grigorios Loukides and Solon P. Pissis and Hau Chan},
  doi          = {10.1016/j.tcs.2020.11.020},
  journal      = {Theoretical Computer Science},
  pages        = {84-103},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Influence maximization in the presence of vulnerable nodes: A ratio perspective},
  volume       = {852},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Maximal unbordered factors of random strings. <em>TCS</em>,
<em>852</em>, 78–83. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.019">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A border of a string is a non-empty prefix of the string that is also a suffix of the string, and a string is unbordered if it has no border other than itself. Loptev, Kucherov, and Starikovskaya [CPM&#39;15] conjectured the following: If we pick a string of length n from a fixed non-unary alphabet uniformly at random, then the expected maximum length of its unbordered factors is n − O ( 1 ) . We confirm this conjecture by proving that the expected value is, in fact, n − O ( σ − 1 ) , where σ is the size of the alphabet. This immediately implies that we can find such a maximal unbordered factor in linear time on average. However, we go further and show that the optimum average-case running time is in Ω ( n ) ∩ O ( n log σ ⁡ n ) due to analogous bounds by Czumaj and Gąsieniec [CPM&#39;00] for the problem of computing the shortest period of a uniformly random string.},
  archive      = {J_TCS},
  author       = {Patrick Hagge Cording and Travis Gagie and Mathias Bæk Tejs Knudsen and Tomasz Kociumaka},
  doi          = {10.1016/j.tcs.2020.11.019},
  journal      = {Theoretical Computer Science},
  pages        = {78-83},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Maximal unbordered factors of random strings},
  volume       = {852},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Revisiting the prefer-same and prefer-opposite de bruijn
sequence constructions. <em>TCS</em>, <em>852</em>, 73–77. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.018">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present a simple greedy algorithm to construct the prefer-same de Bruijn sequence and prove that it is equivalent to the more complex algorithm first stated by Eldert et al. without proof (Eldert et al., 1958 [3] ), and later by Fredricksen (Fredricksen, 1982 [5] ). Then we prove that the resulting sequence has the lexicographically largest run-length representation among all de Bruijn sequences. Furthermore, we prove that the sequence resulting from a prefer-opposite greedy construction has the lexicographically smallest run-length representation among all de Bruijn sequences.},
  archive      = {J_TCS},
  author       = {Abbas Alhakim and Evan Sala and Joe Sawada},
  doi          = {10.1016/j.tcs.2020.11.018},
  journal      = {Theoretical Computer Science},
  pages        = {73-77},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Revisiting the prefer-same and prefer-opposite de bruijn sequence constructions},
  volume       = {852},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Time-energy tradeoffs for evacuation by two robots in the
wireless model. <em>TCS</em>, <em>852</em>, 61–72. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.014">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Two robots stand at the origin of the infinite line and are tasked with searching collaboratively for an exit at an unknown location on the line. They can travel at maximum speed b and can change speed or direction at any time. The two robots can communicate with each other at any distance and at any time. The task is completed when the last robot arrives at the exit and evacuates. We study time-energy tradeoffs for the above evacuation problem. The evacuation time is the time it takes the last robot to reach the exit. The energy it takes for a robot to travel a distance x at speed s is measured as x s 2 xs2 . The total and makespan evacuation energies are respectively the sum and maximum of the energy consumption of the two robots while executing the evacuation algorithm. Assuming that the maximum speed is b , and the evacuation time is at most cd , where d is the distance of the exit from the origin and c is some positive real number, we study the problem of minimizing the total energy consumption of the robots. We prove that the problem is solvable only for b c ≥ 3 bc≥3 . For the case b c = 3 bc=3 , we give an optimal algorithm, and give upper bounds on the energy for the case b c &gt; 3 bc&amp;gt;3 . We also consider the problem of minimizing the evacuation time when the available energy is bounded by Δ. Surprisingly, when Δ is a constant, independent of the distance d of the exit from the origin, we prove that evacuation is possible in time O ( d 3 / 2 log ⁡ d ) O(d3/2log⁡d) , and this is optimal up to a logarithmic factor. When Δ is linear in d , we give upper bounds on the evacuation time.},
  archive      = {J_TCS},
  author       = {Jurek Czyzowicz and Konstantinos Georgiou and Ryan Killick and Evangelos Kranakis and Danny Krizanc and Manuel Lafond and Lata Narayanan and Jaroslav Opatrny and Sunil Shende},
  doi          = {10.1016/j.tcs.2020.11.014},
  journal      = {Theoretical Computer Science},
  pages        = {61-72},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Time-energy tradeoffs for evacuation by two robots in the wireless model},
  volume       = {852},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A continuous strategy for collisionless gathering.
<em>TCS</em>, <em>852</em>, 41–60. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.037">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Over the past decades, the Gathering problem , which asks to gather a group of robots in finite time given some restrictions, has been intensively studied. In this paper, we are given a group of n autonomous, dimensionless, deterministic, and anonymous robots, with bounded viewing range. Assuming a continuous time model , the goal is to gather these robots into one point in finite time. We introduce a simple convergence criterion that defines a new class of algorithms which perform gathering in O ( n d ) O(nd) time, where d is the diameter of the initial robot configuration. We show that some gathering algorithms in the literature belong to this class and propose two new algorithms that belong to this class and have quadratic running time, namely, Go-To-The-Relative-Center algorithm (GTRC) and Safe-Go-To-The-Relative-Center algorithm (S-GTRC). We prove that the latter can perform gathering without collision by using a slightly more complex robot model: non oblivious, chiral, and luminous (i.e. robots have observable external memory, as in [8] ). We also consider a variant of the Gathering problem, the Near-Gathering problem, in which robots must get close to each other without colliding. We show that S-GTRC solves the Near-Gathering problem in quadratic time and assumes a weaker robot model than the one assumed in the current state-of-the-art.},
  archive      = {J_TCS},
  author       = {Shouwei Li and Christine Markarian and Friedhelm Meyer auf der Heide and Pavel Podlipyan},
  doi          = {10.1016/j.tcs.2020.10.037},
  journal      = {Theoretical Computer Science},
  pages        = {41-60},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A continuous strategy for collisionless gathering},
  volume       = {852},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The impact of the gabriel subgraph of the visibility graph
on the gathering of mobile autonomous robots. <em>TCS</em>,
<em>852</em>, 29–40. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.009">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we reconsider the well-known discrete, round-based Go-To-The-Center algorithm due to Ando, Suzuki, and Yamashita [2] for gathering n autonomous mobile robots with limited viewing range in the plane. Remarquably, this algorithm exploits the fact that during its execution, many collisions of robots occur. Such collisions are interpreted as a success because it is assumed that such collided robots behave the same from now on. This is acceptable under the assumption that each robot is represented by a single point. Otherwise, collisions should be avoided. In this paper, we consider a continuous Go-To-The-Center algorithm in which the robots continuously observe the positions of their neighbors and adapt their speed (assuming a speed limit) and direction. Our first results are time bounds of O ( n 2 ) O(n2) for gathering in two dimensions Euclidean space , and Θ ( n ) Θ(n) for the one dimension . Our main contribution is the introduction and evaluation of a continuous algorithm which performs Go-To-The-Center considering only the neighbors of a robot with respect to the Gabriel subgraph of the visibility graph, i.e. Go-To-The-Gabriel-Center algorithm. We show that this modification still correctly executes gathering in one and two dimensions , with the same time bounds as above. Simulations exhibit a severe difference of the behavior of the Go-To-The-Center and the Go-To-The-Gabriel-Center algorithms: Whereas lots of collisions occur during a run of the Go-To-The-Center algorithm, typically only one, namely the final collision occurs during a run of the Go-To-The-Gabriel-Center algorithm. We can prove this “collisionless property” of the Go-To-The-Gabriel-Center algorithm for one dimension . In two-dimensional Euclidean space , we conjecture that the “collisionless property” holds for almost every initial configuration . We support our conjecture with measurements obtained from the simulation where robots execute both continuous Go-To-The-Center and Go-To-The-Gabriel-Center algorithms.},
  archive      = {J_TCS},
  author       = {Shouwei Li and Friedhelm Meyer auf der Heide and Pavel Podlipyan},
  doi          = {10.1016/j.tcs.2020.11.009},
  journal      = {Theoretical Computer Science},
  pages        = {29-40},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The impact of the gabriel subgraph of the visibility graph on the gathering of mobile autonomous robots},
  volume       = {852},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Treasure evacuation with one robot on a disk. <em>TCS</em>,
<em>852</em>, 18–28. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.008">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A robot is located at a point in the plane. A treasure and an exit, both stationary, are located at unknown (to the robot) positions both at distance one from the robot. Starting from its initial position, the robot aims to fetch the treasure to the exit. At any time the robot can move anywhere on the disk with constant speed. The robot detects an interesting point (treasure or exit) only if it passes over the exact location of that point. Given that an adversary controls the locations of both the treasure and the exit on the perimeter, we are interested in designing algorithms that minimize the treasure-evacuation time, i.e. the time it takes for the treasure to be discovered and brought to the exit by the robot. This seemingly simple treasure evacuation problem turns out to be surprisingly challenging. In this paper we differentiate how the robot&#39;s knowledge of the distance between the two interesting points affects the overall evacuation time. We demonstrate the difference between knowing only a lower bound of the distance versus knowing its the exact value, and provide search algorithms for both cases. In the former case we provide an algorithm which is shown to be optimal. In the latter case we give an algorithm which is off from the optimal algorithm (that does not know the locations of the treasure and the exit) by no more than 4 2 + 3 π + 2 6 2 + 2 π + 2 ≤ 1.019 42+3π+262+2π+2≤1.019 multiplicatively, or π 2 − 2 ≤ 0.157 π2−2≤0.157 additively.},
  archive      = {J_TCS},
  author       = {Konstantinos Georgiou and George Karakostas and Evangelos Kranakis},
  doi          = {10.1016/j.tcs.2020.11.008},
  journal      = {Theoretical Computer Science},
  pages        = {18-28},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Treasure evacuation with one robot on a disk},
  volume       = {852},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On continuous one-way functions. <em>TCS</em>, <em>852</em>,
1–17. (<a href="https://doi.org/10.1016/j.tcs.2020.10.031">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The existence of one-way functions seems to depend, intuitively, on certain irregular properties of polynomial-time computable functions. Therefore, for functions with continuity properties, it suggests that all such functions are not one-way. It is shown here that in the formal complexity theory of real functions, this nonexistence of continuous one-way functions can be proved for one-to-one one-dimensional real functions, but fails for one-to-one two-dimensional real functions, if certain strong discrete one-way functions exist. Furthermore, for k -to-one functions, we can prove the existence of four-to-one one-dimensional one-way functions under the same assumption of the existence of strong discrete one-way functions. (A function f is k -to-one if for any y there exist at most k distinct values x such that f ( x ) = y f(x)=y .)},
  archive      = {J_TCS},
  author       = {Ker-I Ko and Lidong Wu},
  doi          = {10.1016/j.tcs.2020.10.031},
  journal      = {Theoretical Computer Science},
  pages        = {1-17},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On continuous one-way functions},
  volume       = {852},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021h). Editorial. <em>TCS</em>, <em>851</em>, iii. (<a
href="https://doi.org/10.1016/S0304-3975(20)30733-7">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_TCS},
  author       = {Lila Kari ( Editor-in-Chief )},
  doi          = {10.1016/S0304-3975(20)30733-7},
  journal      = {Theoretical Computer Science},
  pages        = {iii},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Editorial},
  volume       = {851},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Power of uninitialized qubits in shallow quantum circuits.
<em>TCS</em>, <em>851</em>, 129–153. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.039">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study uninitialized qubits, whose initial state is arbitrary and unknown, in relation to the computational power of shallow quantum circuits . To do this, we consider uniform families of shallow quantum circuits with n input qubits, O ( log ⁡ n ) O(log⁡n) initialized ancillary qubits, and n O ( 1 ) nO(1) uninitialized ancillary qubits, where the input qubits only act as control qubits . We show that such a circuit with depth O ( ( log ⁡ n ) 2 ) O((log⁡n)2) can compute any symmetric Boolean function on n bits that is computable by a uniform family of polynomial-size classical circuits. Since it is unlikely that this can be done with only O ( log ⁡ n ) O(log⁡n) initialized ancillary qubits, our result provides evidence that the presence of uninitialized ancillary qubits increases the computational power of shallow quantum circuits with only O ( log ⁡ n ) O(log⁡n) initialized ancillary qubits. On the other hand, to understand the limitations of uninitialized qubits, we focus on sub-logarithmic-depth quantum circuits and show the impossibility of computing the parity function on n bits.},
  archive      = {J_TCS},
  author       = {Yasuhiro Takahashi and Seiichiro Tani},
  doi          = {10.1016/j.tcs.2020.11.039},
  journal      = {Theoretical Computer Science},
  pages        = {129-153},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Power of uninitialized qubits in shallow quantum circuits},
  volume       = {851},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A simplified run time analysis of the univariate marginal
distribution algorithm on LeadingOnes. <em>TCS</em>, <em>851</em>,
121–128. (<a href="https://doi.org/10.1016/j.tcs.2020.11.028">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {With elementary means, we prove a stronger run time guarantee for the univariate marginal distribution algorithm (UMDA) optimizing the LeadingOnes benchmark function in the desirable regime with low genetic drift. If the population size is at least quasilinear, then, with high probability , the UMDA samples the optimum in a number of iterations that is linear in the problem size divided by the logarithm of the UMDA&#39;s selection rate. This improves over the previous guarantee, obtained by Dang and Lehre (2015) via the deep level-based population method, both in terms of the run time and by demonstrating further run time gains from small selection rates. Under similar assumptions, we prove a lower bound that matches our upper bound up to constant factors.},
  archive      = {J_TCS},
  author       = {Benjamin Doerr and Martin S. Krejca},
  doi          = {10.1016/j.tcs.2020.11.028},
  journal      = {Theoretical Computer Science},
  pages        = {121-128},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A simplified run time analysis of the univariate marginal distribution algorithm on LeadingOnes},
  volume       = {851},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A fixed point theorem in rough semi-linear uniform spaces.
<em>TCS</em>, <em>851</em>, 111–120. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.011">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The fixed point theory has applications in various fields of science and engineering. In this paper, we introduce the concept of fixed points in the framework of rough set theory and discuss its application in the contraction of digital images. We scrutinize a rough semi-linear uniform space and prove a fixed point theorem for a rough semi-linear uniform space.},
  archive      = {J_TCS},
  author       = {Pankaj Kumar Singh and Surabhi Tiwari},
  doi          = {10.1016/j.tcs.2020.11.011},
  journal      = {Theoretical Computer Science},
  pages        = {111-120},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A fixed point theorem in rough semi-linear uniform spaces},
  volume       = {851},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the trace subshifts of fractional multiplication
automata. <em>TCS</em>, <em>851</em>, 92–110. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.010">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We address the dynamics of the cellular automaton (CA) that multiplies by p / q p/q in base pq (for coprime p &gt; q &gt; 1 p&amp;gt;q&amp;gt;1 ) by studying its trace subshift. We present a conjugacy of the trace to a previously studied base- p / q p/q numeration system. We also show that the trace subshift is not synchronizing and in particular not sofic. As a byproduct we compute its complexity function and we conclude by presenting an example of a sofic shift with the same complexity function.},
  archive      = {J_TCS},
  author       = {Johan Kopra},
  doi          = {10.1016/j.tcs.2020.11.010},
  journal      = {Theoretical Computer Science},
  pages        = {92-110},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On the trace subshifts of fractional multiplication automata},
  volume       = {851},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Computational power of dynamic threshold neural p systems
for generating string languages. <em>TCS</em>, <em>851</em>, 77–91. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.021">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Inspired from spiking and dynamic mechanisms of neurons, dynamic threshold neural P systems (DTNP systems) have been developed and their computational completeness as number-generating/accepting devices and function computing devices has been investigated. However, a universality result of DTNP systems as language generators has not been established so far. This paper discusses computational power of DTNP systems as language generators. We first discuss the relationship between the languages generated by DTNP systems and finite languages, and then prove that regular languages can be generated by finite DTNP systems. Moreover, we prove that recursively enumerable languages can be characterized by projections of inverse-morphic images of the languages generated by DTNP systems.},
  archive      = {J_TCS},
  author       = {Yue Huang and Wenmei Yi and Hong Peng and Jun Wang and Xiaohui Luo and Qian Yang},
  doi          = {10.1016/j.tcs.2020.10.021},
  journal      = {Theoretical Computer Science},
  pages        = {77-91},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Computational power of dynamic threshold neural p systems for generating string languages},
  volume       = {851},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Local-entity resolution for building location-based social
networks by using stay points. <em>TCS</em>, <em>851</em>, 62–76. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.013">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The quality of a location-based social network (LBSN) is mainly related to the granularity of information on the users&#39; location. When LBSN is built using stay points, it presents much more information since GPS logs convey more users&#39; mobility information. However, the main challenge in building LBSN using stay points is to define local-vertices. This problem is known as local-entity resolution. This local-vertices could represent venues with semantic information like parks, restaurants, among others. The most common way to resolve local-entity is by applying clustering algorithms to group nearby stay points into local-vertices. However, in this case, only geographic information is used, which makes it very difficult to separate geographically close venues into distinct local-vertices. This paper addresses this gap and presents a novel approach that uses the coarsening stage of a multilevel optimization scheme to build LBSNs by using stay points. The experimental evaluation carried out indicates that our approach has advantages compared to usual clustering methods to represent real-world features.},
  archive      = {J_TCS},
  author       = {Diego Minatel and Vinícius Ferreira and Alneu de Andrade Lopes},
  doi          = {10.1016/j.tcs.2020.10.013},
  journal      = {Theoretical Computer Science},
  pages        = {62-76},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Local-entity resolution for building location-based social networks by using stay points},
  volume       = {851},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Safe functional systems through integrity types and verified
assembly. <em>TCS</em>, <em>851</em>, 39–61. (<a
href="https://doi.org/10.1016/j.tcs.2020.09.039">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Building a trustworthy life-critical embedded system requires deep reasoning about the potential effects that sequences of machine instructions can have on full system operation. Rather than trying to analyze complete binaries and the countless ways their instructions can interact with one another — memory, side effects, control registers, implicit state, etc. — we explore a new approach. We propose an architecture controlled by a thin computational layer designed to tightly correspond with the lambda calculus, drawing on principles of functional programming to bring the assembly much closer to myriad reasoning frameworks, such as the Coq proof assistant. This approach allows assembly-level verified versions of critical code to operate safely in tandem with arbitrary code, including imperative and unverified system components, without the need for large supporting trusted computing bases. We demonstrate that this computational layer can be built in such a way as to simultaneously provide full programmability and compact, precise, and complete semantics, while still using hardware resources comparable to normal embedded systems. To demonstrate the practicality of this approach, our FPGA-implemented prototype runs an embedded medical application which monitors and treats life-threatening arrhythmias. Though the system integrates untrusted and imperative components, our architecture allows for the formal verification of multiple properties of the end-to-end system. We present a proof of correctness of the assembly-level implementation of the core algorithm in Coq, the integrity of trusted data via a non-interference proof, and a guarantee that our prototype meets critical timing requirements.},
  archive      = {J_TCS},
  author       = {Michael Christensen and Joseph McMahan and Lawton Nichols and Jared Roesch and Timothy Sherwood and Ben Hardekopf},
  doi          = {10.1016/j.tcs.2020.09.039},
  journal      = {Theoretical Computer Science},
  pages        = {39-61},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Safe functional systems through integrity types and verified assembly},
  volume       = {851},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Exponential upper bounds for the runtime of randomized
search heuristics. <em>TCS</em>, <em>851</em>, 24–38. (<a
href="https://doi.org/10.1016/j.tcs.2020.09.032">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We argue that proven exponential upper bounds on runtimes, an established area in classic algorithms, are interesting also in heuristic search and we prove several such results. We show that any of the algorithms randomized local search, Metropolis algorithm , simulated annealing, and (1+1) evolutionary algorithm can optimize any pseudo-Boolean weakly monotonic function under a large set of noise assumptions in a runtime that is at most exponential in the problem dimension n . This drastically extends a previous such result, limited to the (1+1) EA, the LeadingOnes function, and one-bit or bit-wise prior noise with noise probability at most 1/2, and at the same time simplifies its proof. With the same general argument, among others, we also derive a sub-exponential upper bound for the runtime of the ( 1 , λ ) (1,λ) evolutionary algorithm on the OneMax problem when the offspring population size λ is logarithmic, but below the efficiency threshold. To show that our approach can also deal with non-trivial parent population sizes, we prove an exponential upper bound for the runtime of the mutation-based version of the simple genetic algorithm on the OneMax benchmark, matching a known exponential lower bound.},
  archive      = {J_TCS},
  author       = {Benjamin Doerr},
  doi          = {10.1016/j.tcs.2020.09.032},
  journal      = {Theoretical Computer Science},
  pages        = {24-38},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Exponential upper bounds for the runtime of randomized search heuristics},
  volume       = {851},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Fault diagnosability of bicube networks under the PMC
diagnostic model. <em>TCS</em>, <em>851</em>, 14–23. (<a
href="https://doi.org/10.1016/j.tcs.2020.09.012">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A network&#39;s fault diagnosability is the maximum number of nodes (or processors) that are allowed to fail, while still being able to be identified by analyzing the syndrome of mutual testing, under the well-known PMC diagnostic model. It is a crucial indicator of the network&#39;s reliability. The original definition of diagnosability is often too strict to realistically reflect a network&#39;s robustness, because it is limited by the network&#39;s minimum degree. To better measure the actual reliability, many variants of diagnosability have been proposed, with g-extra diagnosability being one of the most noticeable diagnostic strategies. In this paper, we determine both the diagnosability and g -extra diagnosability for Bicube B Q n BQn , a recently proposed variant of the classic hypercube . We first show that the diagnosability for B Q n BQn , the n -dimensional Bicube, is n ; and then prove that the g -extra diagnosability for B Q n BQn is ( g + 1 ) n − g − ( g 2 ) (g+1)n−g−(g2) .},
  archive      = {J_TCS},
  author       = {Jiafei Liu and Shuming Zhou and Zhendong Gu and Qianru Zhou and Dajin Wang},
  doi          = {10.1016/j.tcs.2020.09.012},
  journal      = {Theoretical Computer Science},
  pages        = {14-23},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Fault diagnosability of bicube networks under the PMC diagnostic model},
  volume       = {851},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Improved lower bounds for the radio number of trees.
<em>TCS</em>, <em>851</em>, 1–13. (<a
href="https://doi.org/10.1016/j.tcs.2020.05.023">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Let G be a graph with diameter d . A radio labelling of G is a function f that assigns to each vertex with a non-negative integer such that the following holds for all vertices u , v u,v : | f ( u ) − f ( v ) | ⩾ d + 1 − d ( u , v ) |f(u)−f(v)|⩾d+1−d(u,v) , where d ( u , v ) d(u,v) is the distance between u and v . The span of f is the absolute difference of the largest and smallest values in f ( V ) f(V) . The radio number of G is the minimum span of a radio labelling admitted by G . For trees, a general lower bound of the radio number was given by Liu [10] , which has been used to prove special families of trees whose radio number is equal to this bound [1] , [6] , [9] , [10] . In this article, we present improved lower bounds for some trees whose radio number exceeds Liu&#39;s lower bound. Some of these new bounds are sharp for special families of trees, including complete binary trees [9] and odd paths [11] . Moreover, using these new bounds, we extend the known results of Halasza and Tuza [6] on complete level-wise regular trees.},
  archive      = {J_TCS},
  author       = {Daphne Der-Fen Liu and Laxman Saha and Satyabrata Das},
  doi          = {10.1016/j.tcs.2020.05.023},
  journal      = {Theoretical Computer Science},
  pages        = {1-13},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Improved lower bounds for the radio number of trees},
  volume       = {851},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Beyond pointwise submodularity: Non-monotone adaptive
submodular maximization in linear time. <em>TCS</em>, <em>850</em>,
249–261. (<a href="https://doi.org/10.1016/j.tcs.2020.11.007">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we study the non-monotone adaptive submodular maximization problem subject to a cardinality constraint. We first revisit the adaptive random greedy algorithm proposed in [13] , where they show that this algorithm achieves a 1 / e 1/e approximation ratio if the objective function is adaptive submodular and pointwise submodular. It is not clear whether the same guarantee holds under adaptive submodularity (without resorting to pointwise submodularity) or not. Our first contribution is to show that the adaptive random greedy algorithm achieves a 1 / e 1/e approximation ratio under adaptive submodularity. One limitation of the adaptive random greedy algorithm is that it requires O ( n × k ) O(n×k) value oracle queries, where n is the size of the ground set and k is the cardinality constraint. Our second contribution is to develop the first linear-time algorithm for the non-monotone adaptive submodular maximization problem. Our algorithm achieves a 1 / e − ϵ 1/e−ϵ approximation ratio (this bound is improved to 1 − 1 / e − ϵ 1−1/e−ϵ for monotone case), using only O ( n ϵ − 2 log ⁡ ϵ − 1 ) O(nϵ−2log⁡ϵ−1) value oracle queries. Notably, O ( n ϵ − 2 log ⁡ ϵ − 1 ) O(nϵ−2log⁡ϵ−1) is independent of the cardinality constraint. For the monotone case, we propose a faster algorithm that achieves a 1 − 1 / e − ϵ 1−1/e−ϵ approximation ratio in expectation with O ( n log ⁡ 1 ϵ ) O(nlog⁡1ϵ) value oracle queries. We also generalize our study by considering a partition matroid constraint, and develop a linear-time algorithm for monotone and fully adaptive submodular functions.},
  archive      = {J_TCS},
  author       = {Shaojie Tang},
  doi          = {10.1016/j.tcs.2020.11.007},
  journal      = {Theoretical Computer Science},
  pages        = {249-261},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Beyond pointwise submodularity: Non-monotone adaptive submodular maximization in linear time},
  volume       = {850},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A combinatorial view on string attractors. <em>TCS</em>,
<em>850</em>, 236–248. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.006">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The notion of string attractor has recently been introduced in [Prezza, 2017] and studied in [Kempa and Prezza, 2018] to provide a unifying framework for known dictionary-based compressors. A string attractor for a word w = w 1 w 2 ⋯ w n w=w1w2⋯wn is a subset Γ of the positions { 1 , … , n } {1,…,n} , such that all distinct factors of w have an occurrence crossing at least one of the elements of Γ. In this paper we explore the notion of string attractor by focusing on its combinatorial properties. In particular, we show how the size of the smallest string attractor of a word varies when combinatorial operations are applied and we deduce that such a measure is not monotone. Moreover, we introduce a circular variant of the notion of string attractor to provide a characterization of the conjugacy classes of standard Sturmian words.},
  archive      = {J_TCS},
  author       = {Sabrina Mantaci and Antonio Restivo and Giuseppe Romana and Giovanna Rosone and Marinella Sciortino},
  doi          = {10.1016/j.tcs.2020.11.006},
  journal      = {Theoretical Computer Science},
  pages        = {236-248},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A combinatorial view on string attractors},
  volume       = {850},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Finding maximum sum segments in sequences with uncertainty.
<em>TCS</em>, <em>850</em>, 221–235. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.005">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Given a sequence of n numbers and two positive integers L and U with L ≤ U L≤U , the maximum sum segment problem is to find a segment of the sequence with length between L and U such that the sum of numbers in this segment is maximized. In this paper, we introduce the concept of uncertainty into the maximum sum segment problem, where each of the n numbers of the sequence is not given as an exact value but as an interval characterizing the possible range of its value. In such a sequence with uncertainty, we are interested in segments that have potentiality to be maximum sum segments. A segment is a potential maximum sum segment if there exists a possible assignment scenario of the uncertain numbers such that the segment has maximum sum under this assignment. We define the maximum sum segment with uncertainty ( MSSU ) problem, which consists of two sub-problems: (1) reporting all potential maximum sum segments; and (2) counting the total number of those segments. For the case that L = 1 L=1 and U = n U=n , we propose an O ( n + K ) O(n+K) -time algorithm for the reporting problem and an O ( n ) O(n) -time algorithm for the counting problem , where K is the number of potential maximum sum segments. For general L and U , we give an O ( n ( U − L ) ) O(n(U−L)) -time algorithm for either the reporting or the counting problem . Note that we assume the word-RAM model of computation .},
  archive      = {J_TCS},
  author       = {Hung-I Yu and Tien-Ching Lin and D.T. Lee},
  doi          = {10.1016/j.tcs.2020.11.005},
  journal      = {Theoretical Computer Science},
  pages        = {221-235},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Finding maximum sum segments in sequences with uncertainty},
  volume       = {850},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Exploration of dynamic tori by multiple agents.
<em>TCS</em>, <em>850</em>, 202–220. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.004">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Mobile agents (agents) are objects which can migrate autonomously in a distributed system and execute actions at visited nodes. One of the most fundamental problems of agents is exploration, which requires that each node should be visited by at least one agent. For a long time, researchers focus on exploration of static networks while exploration of dynamic networks has been studied recently. In this paper, we consider exploration of a dynamic torus under some constraints on the dynamics (or topology changes). An n × m n×m torus ( 3 ≤ n ≤ m 3≤n≤m ) is considered as a collection of n row rings and m column rings. The constraint on the dynamics is that each ring should be 1-interval connected, which allows at most one link to be missing at any time in each ring. For the n × m n×m dynamic torus, we propose exploration algorithms with and without the link presence detection. With the link presence detection, an agent can detect which incident links are missing (if some link is missing) before determining its next move. On the other hand, without the link presence detection, an agent has to determine its next move without knowing which incident links are missing, which makes the agent stay on the same node when it tries to move through a missing link. The main contribution of this paper is to clarify the necessary and sufficient number of agents to explore an n × m n×m dynamic torus with and without the link presence detection. Specifically, it is proven that, without the link presence detection, n + 1 n+1 agents are necessary and sufficient to explore the n × m n×m dynamic torus. It also proven that, with the link presence detection, ⌈ n / 2 ⌉ + 1 ⌈n/2⌉+1 agents are necessary and sufficient when n ≠ 4 n≠4 and, ⌈ n / 2 ⌉ + 2 ⌈n/2⌉+2 (i.e., four) agents are necessary and sufficient when n = 4 n=4 to explore the n × m n×m dynamic torus. With respect to the time complexity, we propose asymptotically time-optimal algorithms with and without the link presence detection.},
  archive      = {J_TCS},
  author       = {Tsuyoshi Gotoh and Yuichi Sudo and Fukuhito Ooshita and Hirotsugu Kakugawa and Toshimitsu Masuzawa},
  doi          = {10.1016/j.tcs.2020.11.004},
  journal      = {Theoretical Computer Science},
  pages        = {202-220},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Exploration of dynamic tori by multiple agents},
  volume       = {850},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Optimal run problem for weighted register automata.
<em>TCS</em>, <em>850</em>, 185–201. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.003">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Register automata (RA) are a computational model that can handle data values by adding registers to finite automata. Recently, weighted register automata (WRA) were proposed by extending RA so that weights can be specified for transitions. In this paper, we first investigate decidability and complexity of decision problems on the weights of runs in WRA. We then propose an algorithm for the optimal run problem related to the above decision problems. For this purpose, we use a register type as an abstraction of the contents of registers, which is determined by binary relations (such as =, &lt;, etc.) handled by WRA. Also, we introduce a subclass where both the applicability of transition rules and the weights of transitions are determined only by a register type. We present a method of transforming a given WRA satisfying the assumption to a weighted directed graph such that the optimal run of WRA and the minimum weight path of the graph correspond to each other. Lastly, we discuss the optimal run problem for weighted timed automata as an example.},
  archive      = {J_TCS},
  author       = {Hiroyuki Seki and Reo Yoshimura and Yoshiaki Takata},
  doi          = {10.1016/j.tcs.2020.11.003},
  journal      = {Theoretical Computer Science},
  pages        = {185-201},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Optimal run problem for weighted register automata},
  volume       = {850},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Computational complexity of the 2-connected steiner network
problem in the ℓp plane. <em>TCS</em>, <em>850</em>, 168–184. (<a
href="https://doi.org/10.1016/j.tcs.2020.11.002">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The geometric 2-connected Steiner network problem asks for a shortest bridgeless network spanning a given set of terminals in the plane such that the total length of all edges of the network, as measured in the ℓ p ℓp metric, is a minimum. Using reduction from the problem of deciding the Hamiltonicity of planar cubic bipartite graphs we show that this problem is NP-hard (and NP-complete when discretised) for any constant p ≥ 2 p≥2 or p = 1 p=1 . Our reduction shows that the geometric 2-connected spanning network problem, i.e., the analogous problem without Steiner points, is also NP-hard for p ≥ 2 p≥2 or p = 1 p=1 .},
  archive      = {J_TCS},
  author       = {C.J. Ras and M. Brazil and D.A. Thomas},
  doi          = {10.1016/j.tcs.2020.11.002},
  journal      = {Theoretical Computer Science},
  pages        = {168-184},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Computational complexity of the 2-connected steiner network problem in the ℓp plane},
  volume       = {850},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The linear time-branching time spectrum of equivalences for
stochastic systems with non-determinism. <em>TCS</em>, <em>850</em>,
148–167. (<a href="https://doi.org/10.1016/j.tcs.2020.11.001">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper studies the linear time-branching time spectrum of equivalences for a subclass of interactive Markov chains (IMCs) that are not subject to any further synchronization. This subclass of IMCs is known as closed IMCs. We define several variants of trace equivalence by performing button pushing experiments on stochastic trace machines. We establish the relation between these equivalences and also compare them with bisimulation for closed IMCs. Next, we define several variants of stutter trace equivalence for closed IMCs. We perform button pushing experiments with stutter insensitive stochastic trace machines to obtain these equivalences. We investigate the relationship among these stutter trace equivalences and also compare them with weak bisimulation for closed IMCs. We discuss the relation between several strong and weak trace equivalences defined in this paper. Next, we use these results to sketch the linear time-branching time spectrum of equivalences for IMCs. Finally, we prove that maximum and minimum probabilities of satisfying properties specified using metric temporal logic (MTL) formulas are preserved under some of these trace and stutter trace equivalences.},
  archive      = {J_TCS},
  author       = {Arpit Sharma},
  doi          = {10.1016/j.tcs.2020.11.001},
  journal      = {Theoretical Computer Science},
  pages        = {148-167},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The linear time-branching time spectrum of equivalences for stochastic systems with non-determinism},
  volume       = {850},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). The h-restricted connectivity of the generalized hypercubes.
<em>TCS</em>, <em>850</em>, 135–147. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.036">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Connectivity is an important index in evaluating the reliability and fault tolerant ability of interconnection network . However the traditional connectivity is inappropriate for large scale multiprocessor systems . The h -restricted connectivity, as a generalization of traditional connectivity, was proposed to estimate the reliability of interconnection networks more accurately. For an interconnection network G and a positive integer h , the cardinality of a vertex subset F is called the h-restricted connectivity of G , denoted κ h ( G ) κh(G) , if F is the minimum vertex set subject to that G − F G−F is disconnected and δ ( G − F ) ≥ h δ(G−F)≥h . In this paper, we investigate the h -restricted connectivity of the generalized hypercube G ( m r , m r − 1 , … , m 1 ) G(mr,mr−1,…,m1) . Specially, we determine that κ h ( G ( m r , m r − 1 , … , m 1 ) ) = ( h + 1 ) κ ( G ( m r , m r − 1 , … , m 1 ) ) − m max h κh(G(mr,mr−1,…,m1))=(h+1)κ(G(mr,mr−1,…,m1))−mmaxh for 1 ≤ h ≤ min ⁡ { ⌊ m r 2 ⌋ − 1 , m min − 1 , r } 1≤h≤min⁡{⌊mr2⌋−1,mmin−1,r} , where κ ( G ( m r , m r − 1 , … , m 1 ) ) κ(G(mr,mr−1,…,m1)) is the connectivity of the generalized hypercube , m max = max ⁡ { m r , m r − 1 , … , m 1 } mmax=max⁡{mr,mr−1,…,m1} and m min = min ⁡ { m r , m r − 1 , … , m 1 } mmin=min⁡{mr,mr−1,…,m1} .},
  archive      = {J_TCS},
  author       = {Xiaowang Li and Shuming Zhou and Xia Guo and Tianlong Ma},
  doi          = {10.1016/j.tcs.2020.10.036},
  journal      = {Theoretical Computer Science},
  pages        = {135-147},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The h-restricted connectivity of the generalized hypercubes},
  volume       = {850},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Fault-tolerant complete visibility for asynchronous robots
with lights under one-axis agreement. <em>TCS</em>, <em>850</em>,
116–134. (<a href="https://doi.org/10.1016/j.tcs.2020.10.033">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider the distributed setting of N autonomous mobile robots that operate in Look-Compute-Move (LCM) cycles and communicate with other robots using colored lights following the robots with lights model. We assume obstructed visibility under which a robot cannot see another robot if a third robot is positioned between them on the straight line connecting them. We study the fundamental Complete Visibility problem of repositioning N robots, starting from N distinct points, on a plane so that each robot is visible to all others. We are interested in fault-tolerant algorithms. We study fault-tolerance with respect to failures on the mobility of robots. Therefore, any algorithm for Complete Visibility is required to provide visibility between all non-faulty robots (i.e., no three non-faulty robots are collinear and no faulty robot is between two non-faulty robots on the straight line connecting them), independently of the behavior of the faulty ones. We model mobility failures as crash faults in which each faulty robot may stop its movement at any time and, once it stopped moving, it will remain stationary indefinitely thereafter. There exists an algorithm for this problem that tolerates a single faulty robot in the semi-synchronous setting under both-axis agreement. In that algorithm, the light of the faulty robot does not need to work correctly after the robot experiences fault. In this article, we assume the model in which, even after a robot experiences fault, its light still operates correctly and provide the first algorithm for Complete Visibility that tolerates f ≤ N f≤N faulty robots in the asynchronous setting under one-axis agreement. The proposed algorithm has many interesting properties.},
  archive      = {J_TCS},
  author       = {Pavan Poudel and Aisha Aljohani and Gokarna Sharma},
  doi          = {10.1016/j.tcs.2020.10.033},
  journal      = {Theoretical Computer Science},
  pages        = {116-134},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Fault-tolerant complete visibility for asynchronous robots with lights under one-axis agreement},
  volume       = {850},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Better 3-coloring algorithms: Excluding a triangle and a
seven vertex path. <em>TCS</em>, <em>850</em>, 98–115. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.032">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present an algorithm to color a graph G with no triangle and no induced 7-vertex path (i.e., a { P 7 , C 3 } {P7,C3} -free graph), where every vertex is assigned a list of possible colors which is a subset of { 1 , 2 , 3 } {1,2,3} . While this is a special case of the problem solved in Bonomo et al. (2018) [1] , that does not require the absence of triangles, the algorithm here is both faster and conceptually simpler. The complexity of the algorithm is O ( | V ( G ) | 5 ( | V ( G ) | + | E ( G ) | ) ) O(|V(G)|5(|V(G)|+|E(G)|)) , and if G is bipartite, it improves to O ( | V ( G ) | 2 ( | V ( G ) | + | E ( G ) | ) ) O(|V(G)|2(|V(G)|+|E(G)|)) . Moreover, we prove that there are finitely many minimal obstructions to list 3-coloring { P t , C 3 } {Pt,C3} -free graphs if and only if t ≤ 7 t≤7 . This implies the existence of a polynomial time certifying algorithm for list 3-coloring in { P 7 , C 3 } {P7,C3} -free graphs. We furthermore determine other cases of t , ℓ t,ℓ , and k such that the family of minimal obstructions to list k -coloring in { P t , C ℓ } {Pt,Cℓ} -free graphs is finite.},
  archive      = {J_TCS},
  author       = {Flavia Bonomo-Braberman and Maria Chudnovsky and Jan Goedgebeur and Peter Maceli and Oliver Schaudt and Maya Stein and Mingxian Zhong},
  doi          = {10.1016/j.tcs.2020.10.032},
  journal      = {Theoretical Computer Science},
  pages        = {98-115},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Better 3-coloring algorithms: Excluding a triangle and a seven vertex path},
  volume       = {850},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). XML navigation and transformation by tree-walking automata
and transducers with visible and invisible pebbles. <em>TCS</em>,
<em>850</em>, 40–97. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.030">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The pebble tree automaton and the pebble tree transducer are enhanced by additionally allowing an unbounded number of “invisible” pebbles (as opposed to the usual “visible” ones). The resulting pebble tree automata recognize the regular tree languages (i.e., can validate all generalized DTD&#39;s) and hence can find all matches of MSO definable patterns. Moreover, when viewed as a navigational device, they lead to an XPath-like formalism that has a path expression for every MSO definable binary pattern. The resulting pebble tree transducers can apply arbitrary MSO definable tests to (the observable part of) their configurations, they (still) have a decidable typechecking problem, and they can model the recursion mechanism of XSLT. The time complexity of the typechecking problem for conjunctive queries that use MSO definable patterns can often be reduced through the use of invisible pebbles.},
  archive      = {J_TCS},
  author       = {Joost Engelfriet and Hendrik Jan Hoogeboom and Bart Samwel},
  doi          = {10.1016/j.tcs.2020.10.030},
  journal      = {Theoretical Computer Science},
  pages        = {40-97},
  shortjournal = {Theor. Comput. Sci.},
  title        = {XML navigation and transformation by tree-walking automata and transducers with visible and invisible pebbles},
  volume       = {850},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Characterization of the lengths of binary circular words
containing no squares other than 00, 11, and 0101. <em>TCS</em>,
<em>850</em>, 30–39. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.029">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We characterize exactly the lengths of binary circular words containing no squares other than 00, 11, and 0101.},
  archive      = {J_TCS},
  author       = {James D. Currie and Jesse T. Johnson},
  doi          = {10.1016/j.tcs.2020.10.029},
  journal      = {Theoretical Computer Science},
  pages        = {30-39},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Characterization of the lengths of binary circular words containing no squares other than 00, 11, and 0101},
  volume       = {850},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Structure connectivity and substructure connectivity of
wheel networks. <em>TCS</em>, <em>850</em>, 20–29. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.028">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Consider a graph G and its connected subgraph T . The T -structure connectivity κ ( G ; T ) of G is the cardinality of a minimum set of subgraphs in G , whose removal disconnects G and each element in the set is isomorphic to T . The T -substructure connectivity κ s ( G ; T ) of G is the cardinality of a minimum set of subgraphs in G , whose removal disconnects G and each element in the set is isomorphic to a connected subgraph of T . In G , the standard connectivity κ ( G ) is regarded as a simplification of both κ ( G ; T ) and κ s ( G ; T ) . The wheel network, denoted by C W n , is an attractive interconnected network prototype for multiple CPU systems. In this paper, we determine κ ( C W n ; P 2 k + 1 ) (resp. κ s ( C W n ; P 2 k + 1 ) ) for n ≥ 5 and k + 1 ≤ 2 n − 4 , κ ( C W n ; P 2 k ) (resp. κ s ( C W n ; P 2 k ) ) for n ≥ 6 and k ≤ 2 n − 4 and a lower bound of κ ( C W n ; C 2 k ) (resp. κ s ( C W n ; C 2 k ) ) for n ≥ 6 and k ≤ 2 n − 4 .},
  archive      = {J_TCS},
  author       = {Wei Feng and Shiying Wang},
  doi          = {10.1016/j.tcs.2020.10.028},
  journal      = {Theoretical Computer Science},
  pages        = {20-29},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Structure connectivity and substructure connectivity of wheel networks},
  volume       = {850},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Global total k-domination: Approximation and hardness
results. <em>TCS</em>, <em>850</em>, 1–19. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.027">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A subset D ⊆ V D⊆V of a graph G = ( V , E ) G=(V,E) is called a global total k -dominating set of G if D is a total k -dominating set of both G and the complement G ‾ G‾ of G . The Minimum Global Total k -Domination problem is to find a global total k -dominating set of minimum cardinality of the input graph G and Decide Global Total k -Domination problem is the decision version of Minimum Global Total k -Domination problem. The Decide Global Total k -Domination problem is known to be NP -complete for general graphs as well as for bipartite graphs . In this paper, we strengthen the NP -completeness result of Decide Global Total k -Domination problem by showing that this problem remains NP -complete for perfect elimination bipartite graphs , star-convex bipartite graphs and doubly chordal graphs . On the positive side, we give a polynomial time algorithm for the Minimum Global Total k -Domination problem for chordal bipartite graphs, which is a subclass of bipartite graphs. We propose a 2 ( 1 + ln ⁡ | V | ) 2(1+ln⁡|V|) -approximation algorithm for the Minimum Global Total k -Domination problem for any graph. We show that Minimum Global Total k -Domination problem cannot be approximated within ( 1 − ϵ ) ln ⁡ | V | (1−ϵ)ln⁡|V| for any ϵ &gt; 0 ϵ&amp;gt;0 unless P = NP P=NP for any integer k ≥ 1 k≥1 . We further show that for bipartite graphs, Minimum Global Total k -Domination problem cannot be approximated within ( 1 6 − ϵ ) ln ⁡ | V | (16−ϵ)ln⁡|V| for any ϵ &gt; 0 ϵ&amp;gt;0 unless P = NP P=NP for any k ≥ 1 k≥1 . Finally, we show that the Minimum Global Total k -Domination problem is APX -complete for bounded degree bipartite graphs for any fixed integer k ≥ 1 k≥1 .},
  archive      = {J_TCS},
  author       = {B.S. Panda and Pooja Goyal},
  doi          = {10.1016/j.tcs.2020.10.027},
  journal      = {Theoretical Computer Science},
  pages        = {1-19},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Global total k-domination: Approximation and hardness results},
  volume       = {850},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Approximability of the independent feedback vertex set
problem for bipartite graphs. <em>TCS</em>, <em>849</em>, 227–236. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.026">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Given an undirected graph G with n vertices, the independent feedback vertex set problem is to find a vertex subset F of G with the minimum number of vertices such that F is both an independent set and a feedback vertex set of G , if it exists. This problem is known to be NP-hard for bipartite planar graphs of maximum degree four. In this paper, we study the approximability of the problem. We first show that, for any fixed ε &gt; 0 ε&amp;gt;0 , unless P = NP P=NP , there exists no polynomial-time n 1 − ε n1−ε -approximation algorithm even for bipartite planar graphs. We then give an α ( Δ − 1 ) / 2 α(Δ−1)/2 -approximation algorithm for bipartite graphs G of maximum degree Δ, which runs in t ( α , G ) + O ( Δ n ) t(α,G)+O(Δn) time, under the assumption that there is an α -approximation algorithm for the original feedback vertex set problem on bipartite graphs which runs in t ( α , G ) t(α,G) time. This algorithmic result also yields a polynomial-time (exact) algorithm for the independent feedback vertex set problem on bipartite graphs of maximum degree three.},
  archive      = {J_TCS},
  author       = {Yuma Tamura and Takehiro Ito and Xiao Zhou},
  doi          = {10.1016/j.tcs.2020.10.026},
  journal      = {Theoretical Computer Science},
  pages        = {227-236},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Approximability of the independent feedback vertex set problem for bipartite graphs},
  volume       = {849},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Exploring the topological entropy of formal languages.
<em>TCS</em>, <em>849</em>, 210–226. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.025">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce the notions of topological entropy of a formal language and of a topological automaton. We show that the entropy function is surjective and bound the entropy of languages accepted by deterministic ε -free push-down automata with an arbitrary amount of stacks.},
  archive      = {J_TCS},
  author       = {Florian Starke},
  doi          = {10.1016/j.tcs.2020.10.025},
  journal      = {Theoretical Computer Science},
  pages        = {210-226},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Exploring the topological entropy of formal languages},
  volume       = {849},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Reliability and hybrid diagnosis of exchanged hypercube.
<em>TCS</em>, <em>849</em>, 202–209. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.024">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The exchanged hypercube , denoted by E H ( s , t ) EH(s,t) where s , t ≥ 1 s,t≥1 are two positive integers, is a variant of hypercube network. The reliability and diagnosis capability of exchanged hypercubes have been investigated in this paper. First, we studied the h-extra connectivity and h-extra edge connectivity of E H ( s , t ) EH(s,t) which can reflect its fault tolerance ability; Second, we studied the h-restricted vertex diagnosability and r-restricted edge diagnosability of E H ( s , t ) EH(s,t) under the hybrid diagnosis model, a model recently proposed by Zhu et al. for fault diagnosis in hybrid fault circumstances.},
  archive      = {J_TCS},
  author       = {Nianpeng Zhang and Qiang Zhu},
  doi          = {10.1016/j.tcs.2020.10.024},
  journal      = {Theoretical Computer Science},
  pages        = {202-209},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Reliability and hybrid diagnosis of exchanged hypercube},
  volume       = {849},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Note on rg-conditional diagnosability of hypercube.
<em>TCS</em>, <em>849</em>, 197–201. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.023">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The g -good-neighbor conditional diagnosability, which specifies at least g fault-free neighbors for each fault-free node, is a very important metric in system-level diagnosis. Recently, the g -good-neighbor conditional diagnosabilities of many networks have been investigated. To enhance the g -good-neighbor conditional diagnosability, the R g Rg -conditional diagnosability, which requires at least g fault-free neighbors for each node, has been proposed by Guo et al. [1] (2020) recently. And they establish the R g Rg -conditional diagnosability of the hypercubes under the PMC model. In this paper, we present some counterexamples for the proof of lower bound on the R g Rg -conditional diagnosability of the hypercubes under the PMC model, which is crucial to the original main result. And we further utilize known results to give a reasonable lower bound for the R g Rg -conditional diagnosability of hypercubes.},
  archive      = {J_TCS},
  author       = {Yihong Wang and Cheng-Kuan Lin and Qianru Zhou and Shuming Zhou},
  doi          = {10.1016/j.tcs.2020.10.023},
  journal      = {Theoretical Computer Science},
  pages        = {197-201},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Note on rg-conditional diagnosability of hypercube},
  volume       = {849},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On generalized highly potential words. <em>TCS</em>,
<em>849</em>, 184–196. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.022">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The number of palindromic factors of a given finite word is bounded above by its length increased by 1. The difference between this upper bound and the actual number of palindromic factors of a given word is called the palindromic defect (or only defect ) of a given word (by definition, the defect is always nonnegative). Though the definition of defect fundamentally relies on finiteness of a given word, it can be naturally extended to infinite words. There are many results in the literature about words of defect 0, but there are significantly less results about infinite words of finite positive defect. In this article we construct a new family of infinite words whose defect is finite, and in many cases positive (with fully characterized cases when the defect is 0). All the words from our family have the set of factors closed under reversal, and each of them is either periodic (which is a less interesting case, and explicitly characterized), or recurrent but not uniformly recurrent. The fact that they are not uniformly recurrent (unless they are periodic) is of a particular significance since: first, there are some results and examples here and there featuring uniformly recurrent words of finite defect, while next to nothing is known about aperiodic words that are not uniformly recurrent; second, it is known that any uniformly recurrent word of finite defect is a morphic image of some word of zero defect, which suggests that uniformly recurrent words are in a way pretty “tame,” and that those that are not uniformly recurrent are an unexplored territory that deserves a closer look.},
  archive      = {J_TCS},
  author       = {Kristina Ago and Bojan Bašić and Stefan Hačko and Danijela Mitrović},
  doi          = {10.1016/j.tcs.2020.10.022},
  journal      = {Theoretical Computer Science},
  pages        = {184-196},
  shortjournal = {Theor. Comput. Sci.},
  title        = {On generalized highly potential words},
  volume       = {849},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Approximating max k-uncut via LP-rounding plus greed, with
applications to densest k-subgraph. <em>TCS</em>, <em>849</em>, 173–183.
(<a href="https://doi.org/10.1016/j.tcs.2020.10.018">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Max k -Uncut problem arose from the study of homophily of large-scale networks. Given an n -vertex undirected graph G = ( V , E ) G=(V,E) with nonnegative weights defined on edges and a positive integer k , the Max k -Uncut problem asks to find a partition { V 1 , V 2 , ⋯ , V k } {V1,V2,⋯,Vk} of V such that the total weight of edges that are not cut is maximized. This problem is the complement of the classic Min k -Cut problem, and was proved to have surprisingly rich connection to the Densest k -Subgraph problem. In this paper, we give an approximation algorithm for Max k -Uncut using a non-uniform approach combining LP-rounding and the greedy strategy. The algorithm partitions the vertices of G into at least ( 1 − 1 e ) k (1−1e)k parts in expectation, and achieves a good expected approximation ratio 1 2 ( 1 + ( n − k n ) 2 ) 12(1+(n−kn)2) .},
  archive      = {J_TCS},
  author       = {Peng Zhang and Zhendong Liu},
  doi          = {10.1016/j.tcs.2020.10.018},
  journal      = {Theoretical Computer Science},
  pages        = {173-183},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Approximating max k-uncut via LP-rounding plus greed, with applications to densest k-subgraph},
  volume       = {849},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Conditional diagnosability of cayley graphs generated by
wheel graphs under the PMC model. <em>TCS</em>, <em>849</em>, 163–172.
(<a href="https://doi.org/10.1016/j.tcs.2020.10.017">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Fault diagnosis of systems is an important area of study in the design and maintenance of multiprocessor systems . In 2005, Lai et al. [12] introduced conditional diagnosability under the assumption that all the neighbors of any processor in a multiprocessor system cannot be faulty at the same time. In this paper, we completely determine the conditional diagnosability of Cayley graphs generated by wheel graphs W G n WGn under the PMC model.},
  archive      = {J_TCS},
  author       = {Yulong Wei and Min Xu},
  doi          = {10.1016/j.tcs.2020.10.017},
  journal      = {Theoretical Computer Science},
  pages        = {163-172},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Conditional diagnosability of cayley graphs generated by wheel graphs under the PMC model},
  volume       = {849},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Propagation tree decompositions and linearly independent
vertices. <em>TCS</em>, <em>849</em>, 159–162. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.016">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We explore the relationship between propagation tree decompositions of a graph of a given size and the OS-sets of the same size, showing that each can generate the other. We give a short constructive proof that the OS-sets are in bijective correspondence with a subset of the propagation tree decompositions .},
  archive      = {J_TCS},
  author       = {Lon Mitchell},
  doi          = {10.1016/j.tcs.2020.10.016},
  journal      = {Theoretical Computer Science},
  pages        = {159-162},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Propagation tree decompositions and linearly independent vertices},
  volume       = {849},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Arbitrary pattern formation by asynchronous opaque robots
with lights. <em>TCS</em>, <em>849</em>, 138–158. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.015">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Arbitrary Pattern Formation problem asks for a distributed algorithm that moves a set of autonomous mobile robots to form any arbitrary pattern given as input. The robots are assumed to be autonomous, anonymous and identical. They operate in Look-Compute-Move cycles under an asynchronous scheduler. The robots do not have access to any global coordinate system. The movement of the robots is assumed to be rigid , which means that each robot is able to reach its desired destination without interruption. The existing literature that investigates this problem, considers robots with unobstructed visibility. This work considers the problem in the more realistic obstructed visibility model, where the view of a robot can be obstructed by the presence of other robots. The robots are assumed to be punctiform and equipped with visible lights that can assume a constant number of predefined colors. We have studied the problem in two settings based on the level of consistency among the local coordinate systems of the robots: two axis agreement (they agree on the direction and orientation of both coordinate axes) and one axis agreement (they agree on the direction and orientation of only one coordinate axis). In both settings, we have provided a full characterization of initial configurations from where any arbitrary pattern can be formed.},
  archive      = {J_TCS},
  author       = {Kaustav Bose and Manash Kumar Kundu and Ranendu Adhikary and Buddhadeb Sau},
  doi          = {10.1016/j.tcs.2020.10.015},
  journal      = {Theoretical Computer Science},
  pages        = {138-158},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Arbitrary pattern formation by asynchronous opaque robots with lights},
  volume       = {849},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A topological perspective on distributed network algorithms.
<em>TCS</em>, <em>849</em>, 121–137. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.012">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {More than two decades ago, combinatorial topology was shown to be useful for analyzing distributed fault-tolerant algorithms in shared memory systems and in message passing systems. In this work, we show that combinatorial topology can also be useful for analyzing distributed algorithms in failure-free networks of arbitrary structure. To illustrate this, we analyze consensus, set-agreement, and approximate agreement in networks, and derive lower bounds for these problems under classical computational settings, such as the local model and dynamic networks.},
  archive      = {J_TCS},
  author       = {Armando Castañeda and Pierre Fraigniaud and Ami Paz and Sergio Rajsbaum and Matthieu Roy and Corentin Travers},
  doi          = {10.1016/j.tcs.2020.10.012},
  journal      = {Theoretical Computer Science},
  pages        = {121-137},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A topological perspective on distributed network algorithms},
  volume       = {849},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Gathering robots in graphs: The central role of
synchronicity. <em>TCS</em>, <em>849</em>, 99–120. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.011">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Gathering task for k robots disposed on the n vertices of a graph G requires robots to move toward a common vertex from where they do not move anymore. When dealing with very weak robots in terms of capabilities, considering synchronous or asynchronous settings may heavily affect the feasibility of the problem. In fact, even though dealing with asynchronous robots in general requires more sophisticated strategies with respect to the synchronous counterpart, sometimes it comes out that asynchronous robots simply cannot solve the problem whereas synchronous robots can. We study general properties of graphs that can be exploited in order to accomplish the gathering task in the synchronous setting, obtaining an interesting and innovative sufficient condition for the feasibility of the gathering task in graphs, regardless the topology. Furthermore, we consider dense and symmetric graphs like complete and complete bipartite graphs where in general the topology does not allow to distinguish vertices where to finalize the gathering. In such topologies, we fully characterize the solvability of the gathering task in the synchronous setting by suitably combining some strategies arising from the general approach with specific techniques dictated by the considered topologies. From the lower bound point of view in terms of number of synchronous time units required to accomplish the gathering task, in general nothing better than Ω ( D G ) Ω(DG) , with D G DG being the diameter of the input graph G , can be provided. For both complete and complete bipartite graphs , we prove a lower bound of Ω ( log ϕ ⁡ k ) Ω(logϕ⁡k) , with ϕ being the well-known golden ratio. Combined with the provided algorithms, this reveals to be asymptotically tight for complete graphs while for complete bipartite graphs an additive factor of δ ( k ) δ(k) is achieved, with δ ( k ) δ(k) being the function that returns the number of divisors of the integer k .},
  archive      = {J_TCS},
  author       = {Serafino Cicerone and Gabriele Di Stefano and Alfredo Navarra},
  doi          = {10.1016/j.tcs.2020.10.011},
  journal      = {Theoretical Computer Science},
  pages        = {99-120},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Gathering robots in graphs: The central role of synchronicity},
  volume       = {849},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Revocable identity-based encryption with bounded decryption
key exposure resistance: Lattice-based construction and more.
<em>TCS</em>, <em>849</em>, 64–98. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.010">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In general, identity-based encryption (IBE) does not support an efficient revocation procedure. In ACM CCS&#39;08, Boldyreva et al. proposed revocable identity-based encryption (RIBE), which enables us to efficiently revoke (malicious) users in IBE. In PKC 2013, Seo and Emura introduced an additional security notion for RIBE, called decryption key exposure resistance (DKER). Roughly speaking, RIBE with DKER guarantees that the security is not compromised even if an adversary gets (a number of) short-term decryption keys. Therefore, DKER captures realistic scenarios and is an important notion. In this paper, we introduce bounded decryption key exposure resistance (B-DKER), where an adversary is allowed to get a-priori bounded number of short-term decryption keys in the security game. B-DKER is a weak version of DKER, but it seems to be sufficient for practical use. We obtain the following results: Our two constructions rely on cover free families to satisfy B-DKER, whereas all the existing works rely on the key re-randomization property to achieve DKER.},
  archive      = {J_TCS},
  author       = {Atsushi Takayasu and Yohei Watanabe},
  doi          = {10.1016/j.tcs.2020.10.010},
  journal      = {Theoretical Computer Science},
  pages        = {64-98},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Revocable identity-based encryption with bounded decryption key exposure resistance: Lattice-based construction and more},
  volume       = {849},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Fast algorithms for single and multiple pattern cartesian
tree matching. <em>TCS</em>, <em>849</em>, 47–63. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.009">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Cartesian tree matching is the problem of finding every substring of a given text which has the same Cartesian tree as that of a given pattern. In this paper we propose fast algorithms for single and multiple pattern Cartesian tree matching by introducing new representations and encodings. For single pattern Cartesian tree matching, we present the framework of a binary filtration method and an efficient verification technique. Any exact string matching algorithm can be used as a filtration for Cartesian tree matching in our framework. For multiple pattern Cartesian tree matching, we present two fingerprinting methods, i.e., the parent-distance encoding and the binary encoding. By combining an efficient fingerprinting method and a conventional multiple string matching algorithm , we can efficiently solve multiple pattern Cartesian tree matching. By experiments we show that our matching algorithms provide good performances for both single and multiple pattern Cartesian tree matching.},
  archive      = {J_TCS},
  author       = {Siwoo Song and Geonmo Gu and Cheol Ryu and Simone Faro and Thierry Lecroq and Kunsoo Park},
  doi          = {10.1016/j.tcs.2020.10.009},
  journal      = {Theoretical Computer Science},
  pages        = {47-63},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Fast algorithms for single and multiple pattern cartesian tree matching},
  volume       = {849},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Near-gathering of energy-constrained mobile agents.
<em>TCS</em>, <em>849</em>, 35–46. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.008">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the task of gathering k energy-constrained mobile agents in an undirected edge-weighted graph. Each agent is initially placed on an arbitrary node and has a limited amount of energy, which constrains the distance it can move. Since this may render gathering at a single point impossible, we study three variants of near-gathering : The goal is to move the agents into a configuration that minimizes either (i) the radius of a ball containing all agents, (ii) the maximum distance between any two agents, or (iii) the average distance between the agents. We prove that (i) is polynomial-time solvable, (ii) has a polynomial-time 2-approximation with a matching NP-hardness lower bound, while (iii) admits a polynomial-time 2 ( 1 − 1 k ) 2(1−1k) -approximation, but no FPTAS , unless P = NP P=NP . We extend some of our results to additive approximation .},
  archive      = {J_TCS},
  author       = {Andreas Bärtschi and Evangelos Bampas and Jérémie Chalopin and Shantanu Das and Christina Karousatou and Matúš Mihalák},
  doi          = {10.1016/j.tcs.2020.10.008},
  journal      = {Theoretical Computer Science},
  pages        = {35-46},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Near-gathering of energy-constrained mobile agents},
  volume       = {849},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Breaking the linear-memory barrier in MPC: Fast MIS on trees
with strongly sublinear memory. <em>TCS</em>, <em>849</em>, 22–34. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.007">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Recently, studying fundamental graph problems in the Massively Parallel Computation ( MPC MPC ) framework, inspired by the MapReduce paradigm, has gained a lot of attention. An assumption common to a vast majority of approaches is to allow Ω ˜ ( n ) Ω˜(n) memory per machine, where n is the number of nodes in the graph and Ω ˜ Ω˜ hides polylogarithmic factors. However, as pointed out by Karloff et al. [SODA&#39;10] and Czumaj et al. [STOC&#39;18], it might be unrealistic for a single machine to have linear or only slightly sublinear memory. In this paper, we thus study a more practical variant of the MPC MPC model which only requires substantially sublinear or even subpolynomial memory per machine. In contrast to the linear-memory MPC MPC model and also to streaming algorithms, in this low-memory MPC MPC setting, a single machine will only see a small number of nodes in the graph. We introduce a new and strikingly simple technique to cope with this imposed locality. In particular, we show that the Maximal Independent Set ( MIS MIS ) problem can be solved efficiently, that is, in O ( log 3 ⁡ log ⁡ n ) O(log3⁡log⁡n) rounds, when the input graph is a tree. This constitutes an almost exponential speed-up over the low-memory MPC MPC algorithm in O ˜ ( log ⁡ n ) O˜(log⁡n) rounds in a concurrent work by Ghaffari and Uitto [SODA&#39;19] and substantially reduces the local memory from Ω ˜ ( n ) Ω˜(n) required by the recent O ( log ⁡ log ⁡ n ) O(log⁡log⁡n) -round MIS MIS algorithm of Ghaffari et al. [PODC&#39;18] to n ε nε for any ε &gt; 0 ε&amp;gt;0 , without incurring a significant loss in the round complexity. Moreover, it demonstrates how to make use of the all-to-all communication in the MPC model to almost exponentially improve on the corresponding bound in the LOCAL LOCAL and PRAM PRAM models by Lenzen and Wattenhofer [PODC&#39;11].},
  archive      = {J_TCS},
  author       = {Sebastian Brandt and Manuela Fischer and Jara Uitto},
  doi          = {10.1016/j.tcs.2020.10.007},
  journal      = {Theoretical Computer Science},
  pages        = {22-34},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Breaking the linear-memory barrier in MPC: Fast MIS on trees with strongly sublinear memory},
  volume       = {849},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Local distance constrained bribery in voting. <em>TCS</em>,
<em>849</em>, 1–21. (<a
href="https://doi.org/10.1016/j.tcs.2020.10.005">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Studying complexity of various bribery problems has been one of the main research focus in computational social choice. In all the models of bribery studied so far, the briber has to pay every voter some amount of money depending on what the briber wants the voter to report and the briber has some budget at her disposal. Although these models successfully capture many real world applications, in many other scenarios, the voters may be unwilling to deviate too much from their true preferences. In this paper, we study the computational complexity of the problem of finding a preference profile which is as close to the true preference profile as possible and still achieves the briber&#39;s goal subject to budget constraints. We call this problem Local Distance constrained $bribery . We consider three important measures of distances, namely, swap distance, footrule distance, and maximum displacement distance, and resolve the complexity of the optimal bribery problem for many common voting rules. We show that the problem is polynomial time solvable for the plurality and veto voting rules for all the three measures of distance. On the other hand, we prove that the problem is NP -complete for a class of scoring rules which includes the Borda voting rule, maximin, Copelandα for any α∈[0,1] , and Bucklin voting rules for all the three measures of distance even when the distance allowed per voter is 1 for the swap and maximum displacement distances and 2 for the footrule distance even without the budget constraints (which corresponds to having an infinite budget). For the k -approval voting rule for any constant k&amp;gt;1 and the simplified Bucklin voting rule, we show that the problem is NP -complete for the swap distance even when the distance allowed is 2 and for the footrule distance even when the distance allowed is 4 even without the budget constraints. We complement these hardness results by showing that the problem for the k -approval and simplified Bucklin voting rules is polynomial time solvable for the swap distance if the distance allowed is 1 and for the footrule distance if the distance allowed is at most 3. For the k -approval voting rule for the maximum displacement distance for any constant k&amp;gt;1 , and for the simplified Bucklin voting rule for the maximum displacement distance, we show that the problem is NP -complete (with the budget constraints) and, without the budget constraints, they are polynomial time solvable.},
  archive      = {J_TCS},
  author       = {Palash Dey},
  doi          = {10.1016/j.tcs.2020.10.005},
  journal      = {Theoretical Computer Science},
  pages        = {1-21},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Local distance constrained bribery in voting},
  volume       = {849},
  year         = {2021},
}
</textarea>
</details></li>
</ul>

</body>
</html>
