<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>JAR_complex_beauty</title>
  <style>
    html {font-size: 22px;}
    body {margin: 0 auto; max-width: 76em;}
    #copyID {font-size: 18px;}
  </style>
  <script>
    function copy(element) {
      if (element.type == "button"){
      element.type="text";
      }
      element.style.color="black";
      element.style.backgroundColor="#C7EDCC";
      element.select();
      element.setSelectionRange(0, 99999);
      navigator.clipboard.writeText(element.value);
      window.getSelection().removeAllRanges();
      element.type="button";
    }
  </script>
</head>
<body>

<h2 id="jar---37">JAR - 37</h2>
<ul>
<li><details>
<summary>
(2021). Experiences from exporting major proof assistant libraries.
<em>JAR</em>, <em>65</em>(8), 1265‚Äì1298. (<a
href="https://doi.org/10.1007/s10817-021-09604-0">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The interoperability of proof assistants and the integration of their libraries is a highly valued but elusive goal in the field of theorem proving. As a preparatory step, in previous work, we translated the libraries of multiple proof assistants, specifically the ones of Coq, HOL Light, IMPS, Isabelle, Mizar, and PVS into a universal format: OMDoc/MMT. Each translation presented great theoretical, technical, and social challenges, some universal and some system-specific, some solvable and some still open. In this paper, we survey these challenges and compare and evaluate the solutions we chose. We believe similar library translations will be an essential part of any future system interoperability solution, and our experiences will prove valuable to others undertaking such efforts.},
  archive      = {J_JAR},
  author       = {Kohlhase, Michael and Rabe, Florian},
  doi          = {10.1007/s10817-021-09604-0},
  journal      = {Journal of Automated Reasoning},
  number       = {8},
  pages        = {1265-1298},
  shortjournal = {J. Auto. Reasoning},
  title        = {Experiences from exporting major proof assistant libraries},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Formalization of ring theory in PVS. <em>JAR</em>,
<em>65</em>(8), 1231‚Äì1263. (<a
href="https://doi.org/10.1007/s10817-021-09593-0">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper presents a PVS development of relevant results of the theory of rings. The PVS theory includes complete proofs of the three classical isomorphism theorems for rings, and characterizations of principal, prime and maximal ideals. Algebraic concepts and properties are specified and formalized as generally as possible allowing in this manner their application to other algebraic structures. The development provides the required elements to formalize important algebraic theorems. In particular, the paper presents the formalization of the general algebraic-theoretical version of the Chinese remainder theorem (CRT) for the theory of rings, as given in abstract algebra textbooks, proved as a consequence of the first isomorphism theorem. Also, the PVS theory includes a formalization of the number-theoretical version of CRT for the structure of integers, which is the version of CRT found in formalizations. CRT for integers is obtained as a consequence of the general version of CRT for the theory of rings.},
  archive      = {J_JAR},
  author       = {de Lima, Thaynara Arielly and Galdino, Andr√© Luiz and Avelar, Andr√©ia Borges and Ayala-Rinc√≥n, Mauricio},
  doi          = {10.1007/s10817-021-09593-0},
  journal      = {Journal of Automated Reasoning},
  number       = {8},
  pages        = {1231-1263},
  shortjournal = {J. Auto. Reasoning},
  title        = {Formalization of ring theory in PVS},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Derivational complexity and context-sensitive rewriting.
<em>JAR</em>, <em>65</em>(8), 1191‚Äì1229. (<a
href="https://doi.org/10.1007/s10817-021-09603-1">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Context-sensitive rewriting is a restriction of rewriting where reduction steps are allowed on specific arguments $$\mu (f)\subseteq {1,\ldots ,k}$$ of k-ary function symbols f only. Terms which cannot be further rewritten in this way are called $$\mu $$ -normal forms. For left-linear term rewriting systems (TRSs), the so-called normalization via $$\mu $$ -normalization procedure provides a systematic way to obtain normal forms by the stepwise computation and combination of intermediate $$\mu $$ -normal forms. In this paper, we show how to obtain bounds on the derivational complexity of computations using this procedure by using bounds on the derivational complexity of context-sensitive rewriting. Two main applications are envisaged: Normalization via $$\mu $$ -normalization can be used with non-terminating TRSs where the procedure still terminates; on the other hand, it can be used to improve on bounds of derivational complexity of terminating TRSs as it discards many rewritings.},
  archive      = {J_JAR},
  author       = {Lucas, Salvador},
  doi          = {10.1007/s10817-021-09603-1},
  journal      = {Journal of Automated Reasoning},
  number       = {8},
  pages        = {1191-1229},
  shortjournal = {J. Auto. Reasoning},
  title        = {Derivational complexity and context-sensitive rewriting},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Human-centered automated proof search. <em>JAR</em>,
<em>65</em>(8), 1153‚Äì1190. (<a
href="https://doi.org/10.1007/s10817-021-09594-z">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Human-centered automated proof search aims to capture structures of ordinary mathematical proofs and discover human strategies that are used (implicitly) in their construction. We analyze the ways of two theorem provers for approaching that goal. One, the G&amp;G-prover, is presented in Ganesalingam and Gowers (J Autom Reason 58(2):253‚Äì291, 2017); the other, Sieg‚Äôs AProS system, is described in Sieg and Walsh (Rev Symb Logic 1-35, 2019). Both systems make explicit, via their underlying logical calculi, the goal-directedness and bi-directionality of proof construction. However, the calculus for the G&amp;G-prover is a weak fragment of minimal first-order logic, whereas AProS uses complete calculi for intuitionist and classical first-order logic. The strategies for the construction of proofs are dramatically different as well. The G&amp;G-prover uses a waterfall strategy and is thus restricted to problems that can be solved without backtracking. The AProS strategies, by contrast, support a complete search procedure with backtracking. These divergences are rooted in the fact that the concrete goals of the systems are different: The G&amp;G-prover is to yield write-ups indistinguishable from good mathematical writing; AProS is to yield humanly intelligible formal proofs by logically and mathematically motivated strategies. In our final Programmatic remarks, we sketch a plausible, but difficult project for achieving more fully G&amp;G‚Äôs broad goals by radically separating proof search from proof translation: one could use AProS for the proof search and then exploit the strategic structure of the completed proof as the deterministic underpinning for its translation into a natural language.},
  archive      = {J_JAR},
  author       = {Sieg, Wilfried and Derakhshan, Farzaneh},
  doi          = {10.1007/s10817-021-09594-z},
  journal      = {Journal of Automated Reasoning},
  number       = {8},
  pages        = {1153-1190},
  shortjournal = {J. Auto. Reasoning},
  title        = {Human-centered automated proof search},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021a). An automatically verified prototype of the tokeneer ID
station specification. <em>JAR</em>, <em>65</em>(8), 1125‚Äì1151. (<a
href="https://doi.org/10.1007/s10817-021-09602-2">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Tokeneer project was an initiative set forth by the National Security Agency (NSA, USA) to be used as a demonstration that developing highly secure systems can be made by applying rigorous methods in a cost-effective manner. Altran UK was selected by NSA to carry out the development of the Tokeneer ID Station. The company wrote a Z specification later implemented in the SPARK Ada programming language, which was verified using the SPARK Examiner toolset. In this paper, we show that the Z specification can be readily and naturally encoded in the $${log}$$ set constraint language, thereby generating a functional prototype. Furthermore, we show that $${log}$$ ‚Äôs automated proving capabilities can discharge all the proof obligations concerning state invariants as well as important security properties. As a consequence, the prototype can be regarded as correct with respect to the verified properties. This provides empirical evidence that Z users can use $${log}$$ to generate correct prototypes from their Z specifications. In turn, these prototypes enable or simplify some verification activities discussed in the paper.},
  archive      = {J_JAR},
  author       = {Cristi√°, Maximiliano and Rossi, Gianfranco},
  doi          = {10.1007/s10817-021-09602-2},
  journal      = {Journal of Automated Reasoning},
  number       = {8},
  pages        = {1125-1151},
  shortjournal = {J. Auto. Reasoning},
  title        = {An automatically verified prototype of the tokeneer ID station specification},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Handling transitive relations in first-order automated
reasoning. <em>JAR</em>, <em>65</em>(8), 1097‚Äì1124. (<a
href="https://doi.org/10.1007/s10817-021-09605-z">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present a number of alternative ways of handling transitive binary relations that commonly occur in first-order problems, in particular equivalence relations, total orders, and transitive relations in general. We show how such relations can be discovered syntactically in an input theory, and how they can be expressed in alternative ways. We experimentally evaluate different such ways on problems from the TPTP, using resolution-based reasoning tools as well as instance-based tools. Our conclusions are that (1) it is beneficial to consider different treatments of binary relations as a user, and that (2) reasoning tools could benefit from using a preprocessor or even built-in support for certain types of binary relations.},
  archive      = {J_JAR},
  author       = {Claessen, Koen and Lilliestr√∂m, Ann},
  doi          = {10.1007/s10817-021-09605-z},
  journal      = {Journal of Automated Reasoning},
  number       = {8},
  pages        = {1097-1124},
  shortjournal = {J. Auto. Reasoning},
  title        = {Handling transitive relations in first-order automated reasoning},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Optimization modulo the theories of signed bit-vectors and
floating-point numbers. <em>JAR</em>, <em>65</em>(7), 1071‚Äì1096. (<a
href="https://doi.org/10.1007/s10817-021-09600-4">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Optimization modulo theories (OMT) is an important extension of SMT which allows for finding models that optimize given objective functions, typically consisting in linear-arithmetic or Pseudo-Boolean terms. However, many SMT and OMT applications, in particular from SW and HW verification, require handling bit-precise representations of numbers, which in SMT are handled by means of the theory of bit-vectors ( $${{\mathcal {B}}}{{\mathcal {V}}}$$ ) for the integers and that of floating-point numbers ( $$\mathcal {FP}$$ ) for the reals respectively. Whereas an approach for OMT with (unsigned) $${{\mathcal {B}}}{{\mathcal {V}}}$$ objectives has been proposed by Nadel &amp; Ryvchin, unfortunately we are not aware of any existing approach for OMT with $$\mathcal {FP}$$ objectives. In this paper we fill this gap, and we address for the first time $$\text {OMT}$$ with $$\mathcal {FP}$$ objectives. We present a novel OMT approach, based on the novel concept of attractor and dynamic attractor, which extends the work of Nadel and Ryvchin to work with signed- $${{\mathcal {B}}}{{\mathcal {V}}}$$ objectives and, most importantly, with $$\mathcal {FP}$$ objectives. We have implemented some novel $$\text {OMT}$$ procedures on top of OptiMathSAT and tested them on modified problems from the SMT-LIB repository. The empirical results support the validity and feasibility of our novel approach.},
  archive      = {J_JAR},
  author       = {Trentin, Patrick and Sebastiani, Roberto},
  doi          = {10.1007/s10817-021-09600-4},
  journal      = {Journal of Automated Reasoning},
  number       = {7},
  pages        = {1071-1096},
  shortjournal = {J. Auto. Reasoning},
  title        = {Optimization modulo the theories of signed bit-vectors and floating-point numbers},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Distilling the requirements of g√∂del‚Äôs incompleteness
theorems with a proof assistant. <em>JAR</em>, <em>65</em>(7),
1027‚Äì1070. (<a
href="https://doi.org/10.1007/s10817-021-09599-8">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present an abstract development of G√∂del‚Äôs incompleteness theorems, performed with the help of the Isabelle/HOL proof assistant. We analyze sufficient conditions for the applicability of our theorems to a partially specified logic. In addition to the usual benefits of generality, our abstract perspective enables a comparison between alternative approaches from the literature. These include Rosser‚Äôs variation of the first theorem, Jeroslow‚Äôs variation of the second theorem, and the ≈öwierczkowski‚ÄìPaulson semantics-based approach. As part of the validation of our framework, we upgrade Paulson‚Äôs Isabelle proof to produce a mechanization of the second theorem that does not assume soundness in the standard model, and in fact does not rely on any notion of model or semantic interpretation.},
  archive      = {J_JAR},
  author       = {Popescu, Andrei and Traytel, Dmitriy},
  doi          = {10.1007/s10817-021-09599-8},
  journal      = {Journal of Automated Reasoning},
  number       = {7},
  pages        = {1027-1070},
  shortjournal = {J. Auto. Reasoning},
  title        = {Distilling the requirements of g√∂del‚Äôs incompleteness theorems with a proof assistant},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Towards satisfiability modulo parametric bit-vectors.
<em>JAR</em>, <em>65</em>(7), 1001‚Äì1025. (<a
href="https://doi.org/10.1007/s10817-021-09598-9">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Many SMT solvers implement efficient SAT-based procedures for solving fixed-size bit-vector formulas. These techniques, however, cannot be used directly to reason about bit-vectors of symbolic bit-width. To address this shortcoming, we propose a translation from bit-vector formulas with parametric bit-width to formulas in a logic supported by SMT solvers that includes non-linear integer arithmetic, uninterpreted functions, and universal quantification. While this logic is undecidable, our approach can still solve many formulas that arise in practice by capitalizing on advances in SMT solving for non-linear arithmetic and universally quantified formulas. We provide several case studies in which we have applied this approach with promising results, including the bit-width independent verification of invertibility conditions, compiler optimizations, and bit-vector rewrite rules.},
  archive      = {J_JAR},
  author       = {Niemetz, Aina and Preiner, Mathias and Reynolds, Andrew and Zohar, Yoni and Barrett, Clark and Tinelli, Cesare},
  doi          = {10.1007/s10817-021-09598-9},
  journal      = {Journal of Automated Reasoning},
  number       = {7},
  pages        = {1001-1025},
  shortjournal = {J. Auto. Reasoning},
  title        = {Towards satisfiability modulo parametric bit-vectors},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Automata terms in a lazy WSkS decision procedure.
<em>JAR</em>, <em>65</em>(7), 971‚Äì999. (<a
href="https://doi.org/10.1007/s10817-021-09597-w">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We propose a lazy decision procedure for the logic WS $$k$$ S. It builds a¬†term-based symbolic representation of the state space of the tree automaton (TA) constructed by the classical WS $$k$$ S decision procedure. The classical decision procedure transforms the symbolic representation into a¬†TA via a¬†bottom-up traversal and then tests its language non-emptiness, which corresponds to satisfiability of the formula. On the other hand, we start evaluating the representation from the top, construct the state space on the fly, and utilize opportunities to prune away parts of the state space irrelevant to the language emptiness test. In order to do so, we needed to extend the notion of language terms (denoting language derivatives) used in our previous procedure for the linear fragment of the logic (the so-called WS1S) into automata terms. We implemented our decision procedure and identified classes of formulae on which our prototype implementation is significantly faster than the classical procedure implemented in the Mona tool.},
  archive      = {J_JAR},
  author       = {Havlena, Vojtƒõch and Hol√≠k, Luk√°≈° and Leng√°l, Ond≈ôej and Vojnar, Tom√°≈°},
  doi          = {10.1007/s10817-021-09597-w},
  journal      = {Journal of Automated Reasoning},
  number       = {7},
  pages        = {971-999},
  shortjournal = {J. Auto. Reasoning},
  title        = {Automata terms in a lazy WSkS decision procedure},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Model completeness, uniform interpolants and superposition
calculus. <em>JAR</em>, <em>65</em>(7), 941‚Äì969. (<a
href="https://doi.org/10.1007/s10817-021-09596-x">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Uniform interpolants have been largely studied in non-classical propositional logics since the nineties; a successive research line within the automated reasoning community investigated uniform quantifier-free interpolants (sometimes referred to as ‚Äúcovers‚Äù) in first-order theories. This further research line is motivated by the fact that uniform interpolants offer an effective solution to tackle quantifier elimination and symbol elimination problems, which are central in model checking infinite state systems. This was first pointed out in ESOP 2008 by Gulwani and Musuvathi, and then by the authors of the present contribution in the context of recent applications to the verification of data-aware processes. In this paper, we show how covers are strictly related to model completions, a well-known topic in model theory. We also investigate the computation of covers within the Superposition Calculus, by adopting a constrained version of the calculus and by defining appropriate settings and reduction strategies. In addition, we show that computing covers is computationally tractable for the fragment of the language used when tackling the verification of data-aware processes. This observation is confirmed by analyzing the preliminary results obtained using the mcmt tool to verify relevant examples of data-aware processes. These examples can be found in the last version of the tool distribution.},
  archive      = {J_JAR},
  author       = {Calvanese, Diego and Ghilardi, Silvio and Gianola, Alessandro and Montali, Marco and Rivkin, Andrey},
  doi          = {10.1007/s10817-021-09596-x},
  journal      = {Journal of Automated Reasoning},
  number       = {7},
  pages        = {941-969},
  shortjournal = {J. Auto. Reasoning},
  title        = {Model completeness, uniform interpolants and superposition calculus},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Superposition with lambdas. <em>JAR</em>, <em>65</em>(7),
893‚Äì940. (<a href="https://doi.org/10.1007/s10817-021-09595-y">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We designed a superposition calculus for a clausal fragment of extensional polymorphic higher-order logic that includes anonymous functions but excludes Booleans. The inference rules work on $$\beta \eta $$ -equivalence classes of $$\lambda $$ -terms and rely on higher-order unification to achieve refutational completeness. We implemented the calculus in the Zipperposition prover and evaluated it on TPTP and Isabelle benchmarks. The results suggest that superposition is a suitable basis for higher-order reasoning.},
  archive      = {J_JAR},
  author       = {Bentkamp, Alexander and Blanchette, Jasmin and Tourret, Sophie and Vukmiroviƒá, Petar and Waldmann, Uwe},
  doi          = {10.1007/s10817-021-09595-y},
  journal      = {Journal of Automated Reasoning},
  number       = {7},
  pages        = {893-940},
  shortjournal = {J. Auto. Reasoning},
  title        = {Superposition with lambdas},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Preface: Special issue of selected extended papers of CADE
2019. <em>JAR</em>, <em>65</em>(7), 891‚Äì892. (<a
href="https://doi.org/10.1007/s10817-021-09601-3">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_JAR},
  author       = {Fontaine, Pascal},
  doi          = {10.1007/s10817-021-09601-3},
  journal      = {Journal of Automated Reasoning},
  number       = {7},
  pages        = {891-892},
  shortjournal = {J. Auto. Reasoning},
  title        = {Preface: Special issue of selected extended papers of CADE 2019},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021c). Automated reasoning with restricted intensional sets.
<em>JAR</em>, <em>65</em>(6), 809‚Äì890. (<a
href="https://doi.org/10.1007/s10817-021-09589-w">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Intensional sets, i.e., sets given by a property rather than by enumerating elements, are widely recognized as a key feature to describe complex problems (see, e.g., specification languages such as B and Z). Notwithstanding, very few tools exist supporting high-level automated reasoning on general formulas involving intensional sets. In this paper we present a decision procedure for a first-order logic language offering both extensional and (a restricted form of) intensional sets (RIS). RIS are introduced as first-class citizens of the language, and set-theoretical operators on RIS are dealt with as constraints. Syntactic restrictions on RIS guarantee that the denoted sets are finite. The language of RIS, called $${\mathcal {L}}_\mathcal {RIS}$$ , is parametric with respect to any first-order theory $${\mathcal {X}}$$ providing at least equality and a decision procedure for $${\mathcal {X}}$$ -formulas. In particular, we consider the instance of $${\mathcal {L}}_\mathcal {RIS}$$ when $${\mathcal {X}}$$ is the theory of hereditarily finite sets and binary relations. We also present a working implementation of this instance as part of the $${log}$$ tool, and we show through a number of examples and two case studies that, although RIS are a subclass of general intensional sets, they are still sufficiently expressive as to encode and solve many interesting problems. Finally, an extensive empirical evaluation provides evidence that the tool can be used in practice.},
  archive      = {J_JAR},
  author       = {Cristi√°, Maximiliano and Rossi, Gianfranco},
  doi          = {10.1007/s10817-021-09589-w},
  journal      = {Journal of Automated Reasoning},
  number       = {6},
  pages        = {809-890},
  shortjournal = {J. Auto. Reasoning},
  title        = {Automated reasoning with restricted intensional sets},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Extensional higher-order paramodulation in leo-III.
<em>JAR</em>, <em>65</em>(6), 775‚Äì807. (<a
href="https://doi.org/10.1007/s10817-021-09588-x">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Leo-III is an automated theorem prover for extensional type theory with Henkin semantics and choice. Reasoning with primitive equality is enabled by adapting paramodulation-based proof search to higher-order logic. The prover may cooperate with multiple external specialist reasoning systems such as first-order provers and SMT solvers. Leo-III is compatible with the TPTP/TSTP framework for input formats, reporting results and proofs, and standardized communication between reasoning systems, enabling, e.g., proof reconstruction from within proof assistants such as Isabelle/HOL. Leo-III supports reasoning in polymorphic first-order and higher-order logic, in many quantified normal modal logics, as well as in different deontic logics. Its development had initiated the ongoing extension of the TPTP infrastructure to reasoning within non-classical logics.},
  archive      = {J_JAR},
  author       = {Steen, Alexander and Benzm√ºller, Christoph},
  doi          = {10.1007/s10817-021-09588-x},
  journal      = {Journal of Automated Reasoning},
  number       = {6},
  pages        = {775-807},
  shortjournal = {J. Auto. Reasoning},
  title        = {Extensional higher-order paramodulation in leo-III},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). On the importance of domain model configuration for
automated planning engines. <em>JAR</em>, <em>65</em>(6), 727‚Äì773. (<a
href="https://doi.org/10.1007/s10817-021-09592-1">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The development of domain-independent planners within the AI planning community is leading to ‚Äúoff-the-shelf‚Äù technology that can be used in a wide range of applications. Moreover, it allows a modular approach‚Äîin which planners and domain knowledge are modules of larger software applications‚Äîthat facilitates substitutions or improvements of individual modules without changing the rest of the system. This approach also supports the use of reformulation and configuration techniques, which transform how a model is represented in order to improve the efficiency of plan generation. In this article, we investigate how the performance of domain-independent planners is affected by domain model configuration, i.e. the order in which elements are ordered in the model, particularly in the light of planner comparisons. We then introduce techniques for the online and offline configuration of domain models, and we analyse the impact of domain model configuration on other reformulation approaches, such as macros.},
  archive      = {J_JAR},
  author       = {Vallati, Mauro and Chrpa, Luk√°≈° and McCluskey, Thomas Leo and Hutter, Frank},
  doi          = {10.1007/s10817-021-09592-1},
  journal      = {Journal of Automated Reasoning},
  number       = {6},
  pages        = {727-773},
  shortjournal = {J. Auto. Reasoning},
  title        = {On the importance of domain model configuration for automated planning engines},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Automated discovery of geometric theorems based on vector
equations. <em>JAR</em>, <em>65</em>(6), 711‚Äì726. (<a
href="https://doi.org/10.1007/s10817-021-09591-2">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Automated discovery of geometric theorems has attracted considerable attention from the research community. In this paper, a new method is proposed to discover geometric theorems automatically. This method first generates vector equations based on given geometric relations about a geometric figure and then transforms the vector equations into a system of homogeneous linear equations; after computing the determinants of the coefficient matrices corresponding to the system of equations, the elimination method is applied to obtain a large number of geometric relationships. The test on more than 200 geometric problems shows that the geometric relationships discovered automatically by the proposed method are of obvious geometric meaning.},
  archive      = {J_JAR},
  author       = {Peng, Xicheng and Chen, Qihang and Zhang, Jingzhong and Chen, Mao},
  doi          = {10.1007/s10817-021-09591-2},
  journal      = {Journal of Automated Reasoning},
  number       = {6},
  pages        = {711-726},
  shortjournal = {J. Auto. Reasoning},
  title        = {Automated discovery of geometric theorems based on vector equations},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Certified quantum computation in isabelle/HOL. <em>JAR</em>,
<em>65</em>(5), 691‚Äì709. (<a
href="https://doi.org/10.1007/s10817-020-09584-7">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this article we present an ongoing effort to formalise quantum algorithms and results in quantum information theory using the proof assistant Isabelle/HOL. Formal methods being critical for the safety and security of algorithms and protocols, we foresee their widespread use for quantum computing in the future. We have developed a large library for quantum computing in Isabelle based on a matrix representation for quantum circuits, successfully formalising the no-cloning theorem, quantum teleportation, Deutsch‚Äôs algorithm, the Deutsch‚ÄìJozsa algorithm and the quantum Prisoner‚Äôs Dilemma. We discuss the design choices made and report on an outcome of our work in the field of quantum game theory.},
  archive      = {J_JAR},
  author       = {Bordg, Anthony and Lachnitt, Hanna and He, Yijun},
  doi          = {10.1007/s10817-020-09584-7},
  journal      = {Journal of Automated Reasoning},
  number       = {5},
  pages        = {691-709},
  shortjournal = {J. Auto. Reasoning},
  title        = {Certified quantum computation in Isabelle/HOL},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Craig interpolation with clausal first-order tableaux.
<em>JAR</em>, <em>65</em>(5), 647‚Äì690. (<a
href="https://doi.org/10.1007/s10817-021-09590-3">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We develop foundations for computing Craig-Lyndon interpolants of two given formulas with first-order theorem provers that construct clausal tableaux. Provers that can be understood in this way include efficient machine-oriented systems based on calculi of two families: goal-oriented such as model elimination and the connection method, and bottom-up such as the hypertableau calculus. We present the first interpolation method for first-order proofs represented by closed tableaux that proceeds in two stages, similar to known interpolation methods for resolution proofs. The first stage is an induction on the tableau structure, which is sufficient to compute propositional interpolants. We show that this can linearly simulate different prominent propositional interpolation methods that operate by an induction on a resolution deduction tree. In the second stage, interpolant lifting, quantified variables that replace certain terms (constants and compound terms) by variables are introduced. We justify the correctness of interpolant lifting (for the case without built-in equality) abstractly on the basis of Herbrand‚Äôs theorem and for a different characterization of the formulas to be lifted than in the literature. In addition, we discuss various subtle aspects that are relevant for the investigation and practical realization of first-order interpolation based on clausal tableaux.},
  archive      = {J_JAR},
  author       = {Wernhard, Christoph},
  doi          = {10.1007/s10817-021-09590-3},
  journal      = {Journal of Automated Reasoning},
  number       = {5},
  pages        = {647-690},
  shortjournal = {J. Auto. Reasoning},
  title        = {Craig interpolation with clausal first-order tableaux},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Schematic refutations of formula schemata. <em>JAR</em>,
<em>65</em>(5), 599‚Äì645. (<a
href="https://doi.org/10.1007/s10817-020-09583-8">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Proof schemata are infinite sequences of proofs which are defined inductively. In this paper we present a general framework for schemata of terms, formulas and unifiers and define a resolution calculus for schemata of quantifier-free formulas. The new calculus generalizes and improves former approaches to schematic deduction. As an application of the method we present a schematic refutation formalizing a proof of a weak form of the pigeon hole principle.},
  archive      = {J_JAR},
  author       = {Cerna, David M. and Leitsch, Alexander and Lolic, Anela},
  doi          = {10.1007/s10817-020-09583-8},
  journal      = {Journal of Automated Reasoning},
  number       = {5},
  pages        = {599-645},
  shortjournal = {J. Auto. Reasoning},
  title        = {Schematic refutations of formula schemata},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). An isabelle/HOL formalisation of the SPARC instruction set
architecture and the TSO memory model. <em>JAR</em>, <em>65</em>(4),
569‚Äì598. (<a href="https://doi.org/10.1007/s10817-020-09579-4">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The SPARC instruction set architecture (ISA) has been used in various processors in workstations, embedded systems, and in mission-critical industries such as aviation and space engineering. Hence, it is important to provide formal frameworks that facilitate the verification of hardware and software that run on or interface with these processors. In this work, we give the first formal model for multi-core SPARC ISA and Total Store Ordering (TSO) memory model in Isabelle/HOL. We present two levels of modelling for the ISA: The low-level ISA model, which is executable, covers many features specific to SPARC processors, such as delayed-write for control registers, windowed general registers, and more complex memory access. We have tested our model extensively against a LEON3 simulation board, the test covers both single-step executions and sequential execution of programs. We also prove some important properties for our formal model, including a non-interference property for the LEON3 processor. The high-level ISA model is an abstraction of the low-level model and it provides an interface for memory operations in multi-core processors. On top of the high-level ISA model, we formalise two TSO memory models: one is an adaptation of the axiomatic SPARC TSO model (Sindhu et al. in Formal specification of memory models, Springer, Boston, 1992; SPARC in The SPARC architecture manual version 8, 1992. http://gaisler.com/doc/sparcv8.pdf ), the other is a new operational TSO model which is suitable for verifying execution results. We prove that the operational model is sound and complete with respect to the axiomatic model. Finally, we give verification examples with two case studies drawn from the SPARCv9 manual.},
  archive      = {J_JAR},
  author       = {H√≥u, Zh√© and Sanan, David and Tiu, Alwen and Liu, Yang and Hoa, Koh Chuen and Dong, Jin Song},
  doi          = {10.1007/s10817-020-09579-4},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {569-598},
  shortjournal = {J. Auto. Reasoning},
  title        = {An Isabelle/HOL formalisation of the SPARC instruction set architecture and the TSO memory model},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Formalising <span class="math display"><em>ùõ¥</em></span>
-protocols and commitment schemes using CryptHOL. <em>JAR</em>,
<em>65</em>(4), 521‚Äì567. (<a
href="https://doi.org/10.1007/s10817-020-09581-w">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Machine-checked proofs of security are important to increase the rigour of provable security. In this work we present a formalised theory of two fundamental two party cryptographic primitives: $$\varSigma $$ -protocols and Commitment Schemes. $$\varSigma $$ -protocols allow a prover to convince a verifier that they possess some knowledge without leaking information about the knowledge. Commitment schemes allow a committer to commit to a message and keep it secret until revealing it at a later time. We use CryptHOL¬†(Lochbihler in Archive of formal proofs, 2017) to formalise both primitives and prove secure multiple examples namely; the Schnorr, Chaum-Pedersen and Okamoto $$\varSigma $$ -protocols as well as a construction that allows for compound (AND and OR) $$\varSigma $$ -protocols and the Pedersen and Rivest commitment schemes. A highlight of the work is a formalisation of the construction of commitment schemes from $$\varSigma $$ -protocols (Damgard in Lecture notes, 2002). We formalise this proof at an abstract level using the modularity available in Isabelle/HOL and CryptHOL. This way, the proofs of the instantiations come for free.},
  archive      = {J_JAR},
  author       = {Butler, D. and Lochbihler, A. and Aspinall, D. and Gasc√≥n, A.},
  doi          = {10.1007/s10817-020-09581-w},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {521-567},
  shortjournal = {J. Auto. Reasoning},
  title        = {Formalising $$\varSigma $$ -protocols and commitment schemes using CryptHOL},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). A decidable class of security protocols for both
reachability and equivalence properties. <em>JAR</em>, <em>65</em>(4),
479‚Äì520. (<a href="https://doi.org/10.1007/s10817-020-09582-9">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We identify a new decidable class of security protocols, both for reachability and equivalence properties. Our result holds for an unbounded number of sessions and for protocols with nonces. It covers all standard cryptographic primitives. Our class sets up three main assumptions. (i) Protocols need to be ‚Äúsimple‚Äù, meaning that an attacker can precisely identify from which participant and which session a message originates from. We also consider protocols with no else branches (only positive test). (ii) Protocols should be type-compliant, which is intuitively guaranteed as soon as two encrypted messages of the protocol cannot be confused. (iii) Finally, we define the notion of a dependency graph, which, given a protocol, characterises how actions depend on the other ones (both sequential dependencies and data dependencies are taken into account). Whenever the graph is acyclic, then the protocol falls into our class. We show that many protocols of the literature belong to our decidable class, including for example some of the protocols embedded in the biometric passport.},
  archive      = {J_JAR},
  author       = {Cortier, V√©ronique and Delaune, St√©phanie and Sundararajan, Vaishnavi},
  doi          = {10.1007/s10817-020-09582-9},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {479-520},
  shortjournal = {J. Auto. Reasoning},
  title        = {A decidable class of security protocols for both reachability and equivalence properties},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021b). Automated proof of bell‚ÄìLaPadula security properties.
<em>JAR</em>, <em>65</em>(4), 463‚Äì478. (<a
href="https://doi.org/10.1007/s10817-020-09577-6">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Almost 50 years ago, D. E. Bell and L. LaPadula published the first formal model of a secure system, known today as the Bell‚ÄìLaPadula (BLP) model. BLP is described as a state machine by means of first-order logic and set theory. The authors also formalize two state invariants known as security condition and *-property. Bell and LaPadula prove that all the state transitions preserve these invariants. In this paper we present a fully automated proof of the security condition and the *-property for all the model operations. The model and the proofs are coded in the $${log}$$ tool. As far as we know this is the first time such proofs are automated. Besides, we show that the $${log}$$ model is also an executable prototype. Therefore we are providing an automatically verified executable prototype of BLP.},
  archive      = {J_JAR},
  author       = {Cristi√°, Maximiliano and Rossi, Gianfranco},
  doi          = {10.1007/s10817-020-09577-6},
  journal      = {Journal of Automated Reasoning},
  number       = {4},
  pages        = {463-478},
  shortjournal = {J. Auto. Reasoning},
  title        = {Automated proof of Bell‚ÄìLaPadula security properties},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Correction to: A unifying view on SMT-based software
verification. <em>JAR</em>, <em>65</em>(3), 461. (<a
href="https://doi.org/10.1007/s10817-020-09585-6">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The article ‚ÄúA Unifying View on SMT-Based Software Verification‚Äù, written by Dirk Beyer, Matthias Dangl, and Philipp Wendler, was originally published Online First without Open Access},
  archive      = {J_JAR},
  author       = {Beyer, Dirk and Dangl, Matthias and Wendler, Philipp},
  doi          = {10.1007/s10817-020-09585-6},
  journal      = {Journal of Automated Reasoning},
  number       = {3},
  pages        = {461},
  shortjournal = {J. Auto. Reasoning},
  title        = {Correction to: A unifying view on SMT-based software verification},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Higher-order quantifier elimination, counter simulations and
fault-tolerant systems. <em>JAR</em>, <em>65</em>(3), 425‚Äì460. (<a
href="https://doi.org/10.1007/s10817-020-09578-5">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We develop quantifier elimination procedures for fragments of higher order logic arising from the formalization of distributed systems (especially of fault-tolerant ones). Such procedures can be used in symbolic manipulations like the computation of pre/post images and of projections. We show in particular that our procedures are quite effective in producing counter abstractions that can be model-checked using standard SMT technology. In fact, very often in the current literature verification tasks for distributed systems are accomplished via counter abstractions. Such abstractions can sometimes be justified via simulations and bisimulations. In this work, we supply logical foundations to this practice, by our technique for second order quantifier elimination. We implemented our procedure for a simplified (but still expressive) subfragment and we showed that our method is able to successfully handle verification benchmarks from various sources with interesting performances.},
  archive      = {J_JAR},
  author       = {Ghilardi, Silvio and Pagani, Elena},
  doi          = {10.1007/s10817-020-09578-5},
  journal      = {Journal of Automated Reasoning},
  number       = {3},
  pages        = {425-460},
  shortjournal = {J. Auto. Reasoning},
  title        = {Higher-order quantifier elimination, counter simulations and fault-tolerant systems},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Decidable <span
class="math display">‚àÉ<sup>*</sup>‚àÄ<sup>*</sup></span> first-order
fragments of linear rational arithmetic with uninterpreted predicates.
<em>JAR</em>, <em>65</em>(3), 357‚Äì423. (<a
href="https://doi.org/10.1007/s10817-020-09567-8">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {First-order linear rational arithmetic enriched with uninterpreted predicates yields an interesting and very expressive modeling language. However, already the presence of a single uninterpreted predicate symbol of arity one or greater renders the associated satisfiability problem undecidable. We identify two decidable fragments, both based on the Bernays‚ÄìSch√∂nfinkel‚ÄìRamsey prefix class. Due to the inherent infiniteness of the underlying domain, a finite model property in the usual sense cannot be established. Nevertheless, we show that satisfiable sentences always have a model that can be described by finite means. To this end, we restrict the syntax of arithmetic atoms. In the first fragment that is presented, arithmetic operations are only allowed over terms without universally quantified variables. In the second fragment, arithmetic atoms are essentially confined to difference constraints over universally quantified variables with bounded range. We will call such atoms bounded difference constraints. As bounded intervals over the rationals still comprise infinitely many values, a trivial instantiation procedure is not sufficient to solve the satisfiability problem. After a slight shift of perspective, the positive decidability result for the first fragment can be restated in the framework of combinations of theories over non-disjoint vocabularies. More precisely, we combine first-order theories that share a dense total order without endpoints.},
  archive      = {J_JAR},
  author       = {Voigt, Marco},
  doi          = {10.1007/s10817-020-09567-8},
  journal      = {Journal of Automated Reasoning},
  number       = {3},
  pages        = {357-423},
  shortjournal = {J. Auto. Reasoning},
  title        = {Decidable $${\exists }^*{\forall }^*$$ first-order fragments of linear rational arithmetic with uninterpreted predicates},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). CoCon: A conference management system with formally verified
document confidentiality. <em>JAR</em>, <em>65</em>(2), 321‚Äì356. (<a
href="https://doi.org/10.1007/s10817-020-09566-9">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present a case study in formally verified security for realistic systems: the information flow security verification of the functional kernel of a web application, the CoCon conference management system. We use the Isabelle theorem prover to specify and verify fine-grained confidentiality properties, as well as complementary safety and ‚Äútraceback‚Äù properties. The challenges posed by this development in terms of expressiveness have led to bounded-deducibility security, a novel security model and verification method generally applicable to systems describable as input/output automata.},
  archive      = {J_JAR},
  author       = {Popescu, Andrei and Lammich, Peter and Hou, Ping},
  doi          = {10.1007/s10817-020-09566-9},
  journal      = {Journal of Automated Reasoning},
  number       = {2},
  pages        = {321-356},
  shortjournal = {J. Auto. Reasoning},
  title        = {CoCon: A conference management system with formally verified document confidentiality},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Machine learning guidance for connection tableaux.
<em>JAR</em>, <em>65</em>(2), 287‚Äì320. (<a
href="https://doi.org/10.1007/s10817-020-09576-7">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Connection calculi allow for very compact implementations of goal-directed proof search. We give an overview of our work related to connection tableaux calculi: first, we show optimised functional implementations of connection tableaux proof search, including a consistent Skolemisation procedure for machine learning. Then, we show two guidance methods based on machine learning, namely reordering of proof steps with Naive Bayesian probabilities, and expansion of a proof search tree with Monte Carlo Tree Search.},
  archive      = {J_JAR},
  author       = {F√§rber, Michael and Kaliszyk, Cezary and Urban, Josef},
  doi          = {10.1007/s10817-020-09576-7},
  journal      = {Journal of Automated Reasoning},
  number       = {2},
  pages        = {287-320},
  shortjournal = {J. Auto. Reasoning},
  title        = {Machine learning guidance for connection tableaux},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). TacticToe: Learning to prove with tactics. <em>JAR</em>,
<em>65</em>(2), 257‚Äì286. (<a
href="https://doi.org/10.1007/s10817-020-09580-x">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We implement an automated tactical prover TacticToe on top of the HOL4 interactive theorem prover. TacticToe learns from human proofs which mathematical technique is suitable in each proof situation. This knowledge is then used in a Monte Carlo tree search algorithm to explore promising tactic-level proof paths. On a single CPU, with a time limit of 60¬†s, TacticToe proves 66.4\% of the 7164 theorems in HOL4‚Äôs standard library, whereas E¬†prover with auto-schedule solves 34.5\%. The success rate rises to 69.0\% by combining the results of TacticToe and E¬†prover.},
  archive      = {J_JAR},
  author       = {Gauthier, Thibault and Kaliszyk, Cezary and Urban, Josef and Kumar, Ramana and Norrish, Michael},
  doi          = {10.1007/s10817-020-09580-x},
  journal      = {Journal of Automated Reasoning},
  number       = {2},
  pages        = {257-286},
  shortjournal = {J. Auto. Reasoning},
  title        = {TacticToe: Learning to prove with tactics},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Mechanisation of the AKS algorithm. <em>JAR</em>,
<em>65</em>(2), 205‚Äì256. (<a
href="https://doi.org/10.1007/s10817-020-09563-y">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The AKS algorithm (by Agrawal, Kayal and Saxena) is a significant theoretical result, establishing ‚ÄúPRIMES in P‚Äù by a brilliant application of ideas from finite fields. This paper describes an implementation of the AKS algorithm in our theorem prover HOL4, together with a proof of its correctness and its computational complexity. The complexity analysis is based on a conservative computation model using a writer monad. The method is elementary, but enough to show that our implementation of the AKS algorithm takes a number of execution steps bounded by a polynomial function of the input size. This establishes formally that the AKS algorithm indeed shows ‚ÄúPRIMES is in P‚Äù.},
  archive      = {J_JAR},
  author       = {Chan, Hing Lun and Norrish, Michael},
  doi          = {10.1007/s10817-020-09563-y},
  journal      = {Journal of Automated Reasoning},
  number       = {2},
  pages        = {205-256},
  shortjournal = {J. Auto. Reasoning},
  title        = {Mechanisation of the AKS algorithm},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Unbounded-time safety verification of guarded LTI models
with inputs by abstract acceleration. <em>JAR</em>, <em>65</em>(2),
157‚Äì203. (<a href="https://doi.org/10.1007/s10817-020-09562-z">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Reachability analysis of dynamical models is a relevant problem that has seen much progress in the last decades, however with clear limitations pertaining to the nature of the dynamics and the soundness of the results. This article focuses on sound safety verification of unbounded-time (infinite-horizon) linear time-invariant (LTI) models with inputs using reachability analysis. We achieve this using counterexample-guided Abstract Acceleration: this approach over-approximates the reachability tube of the LTI model over an unbounded time horizon by using abstraction, possibly finding concrete counterexamples for refinement based on the given safety specification. The technique is applied to a number of LTI models and the results show robust performance when compared to state-of-the-art tools.},
  archive      = {J_JAR},
  author       = {Cattaruzza, Dario and Abate, Alessandro and Schrammel, Peter and Kroening, Daniel},
  doi          = {10.1007/s10817-020-09562-z},
  journal      = {Journal of Automated Reasoning},
  number       = {2},
  pages        = {157-203},
  shortjournal = {J. Auto. Reasoning},
  title        = {Unbounded-time safety verification of guarded LTI models with inputs by abstract acceleration},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Message from the new editor-in-chief. <em>JAR</em>,
<em>65</em>(2), 155. (<a
href="https://doi.org/10.1007/s10817-021-09587-y">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_JAR},
  author       = {Blanchette, Jasmin},
  doi          = {10.1007/s10817-021-09587-y},
  journal      = {Journal of Automated Reasoning},
  number       = {2},
  pages        = {155},
  shortjournal = {J. Auto. Reasoning},
  title        = {Message from the new editor-in-chief},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Building strategies into QBF proofs. <em>JAR</em>,
<em>65</em>(1), 125‚Äì154. (<a
href="https://doi.org/10.1007/s10817-020-09560-1">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Strategy extraction is of great importance for quantified Boolean formulas (QBF), both in solving and proof complexity. So far in the QBF literature, strategy extraction has been algorithmically performed from proofs. Here we devise the first QBF system where (partial) strategies are built into the proof and are piecewise constructed by simple operations along with the derivation. This has several advantages: (1) lines of our calculus have a clear semantic meaning as they are accompanied by semantic objects; (2) partial strategies are represented succinctly (in contrast to some previous approaches); (3) our calculus has strategy extraction by design; and (4) the partial strategies allow new sound inference steps which are disallowed in previous central QBF calculi such as Q-Resolution and long-distance Q-Resolution. The last item (4) allows us to show an exponential separation between our new system and the previously studied reductionless long-distance resolution calculus. Our approach also naturally lifts to dependency QBFs (DQBF), where it yields the first sound and complete CDCL-style calculus for DQBF, thus opening future avenues into CDCL-based DQBF solving.},
  archive      = {J_JAR},
  author       = {Beyersdorff, Olaf and Blinkhorn, Joshua and Mahajan, Meena},
  doi          = {10.1007/s10817-020-09560-1},
  journal      = {Journal of Automated Reasoning},
  number       = {1},
  pages        = {125-154},
  shortjournal = {J. Auto. Reasoning},
  title        = {Building strategies into QBF proofs},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). HO <span class="math display"><em>œÄ</em></span> in coq.
<em>JAR</em>, <em>65</em>(1), 75‚Äì124. (<a
href="https://doi.org/10.1007/s10817-020-09553-0">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present a formalization of HO $$\pi $$ in Coq, a process calculus where messages carry processes. Such a higher-order calculus features two very different kinds of binder: process input, similar to $$\lambda $$ -abstraction, and name restriction, whose scope can be expanded by communication. For the latter, we compare four approaches to represent binders: locally nameless, de Bruijn indices, nominal, and Higher-Order Abstract Syntax. In each case, we formalize strong context bisimilarity and prove it is compatible, i.e., closed under every context, using Howe‚Äôs method, based on several proof schemes we developed in a previous paper.},
  archive      = {J_JAR},
  author       = {Ambal, Guillaume and Lenglet, Sergue√Ø and Schmitt, Alan},
  doi          = {10.1007/s10817-020-09553-0},
  journal      = {Journal of Automated Reasoning},
  number       = {1},
  pages        = {75-124},
  shortjournal = {J. Auto. Reasoning},
  title        = {HO $$\pi $$ in coq},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Formalization of the poincar√© disc model of hyperbolic
geometry. <em>JAR</em>, <em>65</em>(1), 31‚Äì73. (<a
href="https://doi.org/10.1007/s10817-020-09551-2">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We describe formalization of the Poincar√© disc model of hyperbolic geometry within the Isabelle/HOL proof assistant. The model is defined within the complex projective line $$\mathbb {C}{}P^1$$ and is shown to satisfy Tarski‚Äôs axioms except for Euclid‚Äôs axiom‚Äîit is shown to satisfy it‚Äôs negation, and, moreover, to satisfy the existence of limiting parallels axiom.},
  archive      = {J_JAR},
  author       = {Simiƒá, Danijela and Mariƒá, Filip and Boutry, Pierre},
  doi          = {10.1007/s10817-020-09551-2},
  journal      = {Journal of Automated Reasoning},
  number       = {1},
  pages        = {31-73},
  shortjournal = {J. Auto. Reasoning},
  title        = {Formalization of the poincar√© disc model of hyperbolic geometry},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
<li><details>
<summary>
(2021). Formalization of euler‚Äìlagrange equation set based on
variational calculus in HOL light. <em>JAR</em>, <em>65</em>(1), 1‚Äì29.
(<a href="https://doi.org/10.1007/s10817-020-09549-w">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {As the theoretical foundation of Lagrangian mechanics, Euler‚ÄìLagrange equation sets are widely applied in building mathematical models of physical systems, especially in solving dynamics problems. However, their preconditions are often not fully satisfied in practice. Therefore, it is necessary to verify their applications. The purpose of the present work is to conduct such verification by establishing a formal theorem library of Lagrangian mechanics in HOL Light. For this purpose, some basic concepts such as functional variation and the necessary conditions for functional extreme are formalized. Then, the fundamental lemma of variational calculus is formally verified and some new constuctors and destructors are proposed. Finally, the Euler‚ÄìLagrange equation set is formalized. To validate the formalization, the formalization results are applied to verify the least resistance problem of gas flow. The present work not only lays a necessary and solid foundation for application involving Lagrangian mechanics but also extends the HOL Light theorem library.},
  archive      = {J_JAR},
  author       = {Guan, Yong and Zhang, Jingzhi and Wang, Guohui and Li, Ximeng and Shi, Zhiping and Li, Yongdong},
  doi          = {10.1007/s10817-020-09549-w},
  journal      = {Journal of Automated Reasoning},
  number       = {1},
  pages        = {1-29},
  shortjournal = {J. Auto. Reasoning},
  title        = {Formalization of Euler‚ÄìLagrange equation set based on variational calculus in HOL light},
  volume       = {65},
  year         = {2021},
}
</textarea>
</details></li>
</ul>

</body>
</html>
