<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>JACM_complex_beauty</title>
  <style>
    html {font-size: 22px;}
    body {margin: 0 auto; max-width: 76em;}
    #copyID {font-size: 18px;}
  </style>
  <script>
    function copy(element) {
      if (element.type == "button"){
      element.type="text";
      }
      element.style.color="black";
      element.style.backgroundColor="#C7EDCC";
      element.select();
      element.setSelectionRange(0, 99999);
      navigator.clipboard.writeText(element.value);
      window.getSelection().removeAllRanges();
      element.type="button";
    }
  </script>
</head>
<body>

<h2 id="jacm---41">JACM - 41</h2>
<ul>
<li><details>
<summary>
(2020). The reachability problem for petri nets is not elementary.
<em>JACM</em>, <em>68</em>(1), 7:1–28. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {Petri nets, also known as vector addition systems, are a long established model of concurrency with extensive applications in modeling and analysis of hardware, software, and database systems, as well as chemical, biological, and business processes. The central algorithmic problem for Petri nets is reachability: whether from the given initial configuration there exists a sequence of valid execution steps that reaches the given final configuration. The complexity of the problem has remained unsettled since the 1960s, and it is one of the most prominent open questions in the theory of verification. Decidability was proved by Mayr in his seminal STOC 1981 work, and, currently, the best published upper bound is non-primitive recursive Ackermannian of Leroux and Schmitz from Symposium on Logic in Computer Science 2019. We establish a non-elementary lower bound, i.e., that the reachability problem needs a tower of exponentials of time and space. Until this work, the best lower bound has been exponential space, due to Lipton in 1976. The new lower bound is a major breakthrough for several reasons. Firstly, it shows that the reachability problem is much harder than the coverability (i.e., state reachability) problem, which is also ubiquitous but has been known to be complete for exponential space since the late 1970s. Secondly, it implies that a plethora of problems from formal languages, logic, concurrent systems, process calculi, and other areas, which are known to admit reductions from the Petri nets reachability problem, are also not elementary. Thirdly, it makes obsolete the current best lower bounds for the reachability problems for two key extensions of Petri nets: with branching and with a pushdown stack.We develop a construction that uses arbitrarily large pairs of values with ratio R to provide zero testable counters that are bounded by&amp;nbsp;R. At the heart of our proof is then a novel gadget, the so-called factorial amplifier that, assuming availability of counters that are zero testable and bounded by&amp;nbsp;k, guarantees to produce arbitrarily large pairs of values whose ratio is exactly the factorial of&amp;nbsp;k. Repeatedly composing the factorial amplifier with itself by means of the former construction enables us to compute, in linear time, Petri nets that simulate Minsky machines whose counters are bounded by a tower of exponentials, which yields the non-elementary lower bound. By refining this scheme further, we, in fact, already establish hardness for h-exponential space for Petri nets with h + 13 counters.},
  archive  = {J_JACM},
  author   = {Czerwi\&#39;{n}ski, Wojciech and Lasota, S\l{}awomir and Lazi\&#39;{c}, Ranko and Leroux, J\&#39;{E}r\^{o}me and Mazowiecki, Filip},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {1},
  pages    = {7:1-28},
  title    = {The reachability problem for petri nets is not elementary},
  volume   = {68},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Game semantics for interface middleweight java.
<em>JACM</em>, <em>68</em>(1), 4:1–51. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {We consider an object calculus in which open terms interact with the environment through interfaces. The calculus is intended to capture the essence of contextual interactions of Middleweight Java code. Using game semantics, we provide fully abstract models for the induced notions of contextual approximation and equivalence. These are the first denotational models of this kind.},
  archive  = {J_JACM},
  author   = {Murawski, Andrzej S. and Tzevelekos, Nikos},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {1},
  pages    = {4:1-51},
  title    = {Game semantics for interface middleweight java},
  volume   = {68},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Enhanced phase clocks, population protocols, and fast space
optimal leader election. <em>JACM</em>, <em>68</em>(1), 2:1–21. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {The model of population protocols refers to the growing in popularity theoretical framework suitable for studying pairwise interactions within a large collection of simple indistinguishable entities, frequently called agents. In this article, the emphasis is on the space complexity of fast leader election in population protocols governed by the random scheduler, which uniformly at random selects pairwise interactions between n agents.One of the main results of this article is the first fast space optimal leader election protocol, which works with high probability. The new protocol operates in parallel time O(log2 n) equivalent to O(nlog2 n) sequential pairwise interactions with each agent’s memory space limited to O(log log n) states. This double logarithmic space utilisation matches asymptotically the lower bound ½log log n on the number of states utilised by agents in any leader election algorithm with the running time o(npolylog n); see Reference [7].Our new solution expands also on the classical concept of phase clocks used to synchronise and to coordinate computations in distributed algorithms. In particular, we formalise the concept and provide a rigorous analysis of phase clocks operating in nested modes. Our arguments are also valid for phase clocks propelled by multiple leaders. The combination of the two results in the first time-space efficient leader election algorithm. We also provide a complete formal argumentation, indicating that our solution is always correct, fast, and it works with high probability.},
  archive  = {J_JACM},
  author   = {G\k{a}sieniec, Leszek and Stachowiak, Grzegorz},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {1},
  pages    = {2:1-21},
  title    = {Enhanced phase clocks, population protocols, and fast space optimal leader election},
  volume   = {68},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). On small-depth frege proofs for tseitin for grids.
<em>JACM</em>, <em>68</em>(1), 1:1–31. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {We prove that a small-depth Frege refutation of the Tseitin contradiction on the grid requires subexponential size. We conclude that polynomial size Frege refutations of the Tseitin contradiction must use formulas of almost logarithmic depth.},
  archive  = {J_JACM},
  author   = {H\r{a}stad, Johan},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {1},
  pages    = {1:1-31},
  title    = {On small-depth frege proofs for tseitin for grids},
  volume   = {68},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Polynomiality for bin packing with a constant number of item
types. <em>JACM</em>, <em>67</em>(6), 38:1–21. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {We consider the bin packing problem with d different item sizes si and item multiplicities ai, where all numbers are given in binary encoding. This problem formulation is also known as the one-dimensional cutting stock problem. In this work, we provide an algorithm that, for constant d, solves bin packing in polynomial time. This was an open problem for all dge 3. In fact, for constant d our algorithm solves the following problem in polynomial time: Given two d-dimensional polytopes P and Q, find the smallest number of integer points in P whose sum lies in Q. Our approach also applies to high multiplicity scheduling problems in which the number of copies of each job type is given in binary encoding and each type comes with certain parameters such as release dates, processing times, and deadlines. We show that a variety of high multiplicity scheduling problems can be solved in polynomial time if the number of job types is constant.},
  archive  = {J_JACM},
  author   = {Goemans, Michel X. and Rothvoss, Thomas},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {6},
  pages    = {38:1-21},
  title    = {Polynomiality for bin packing with a constant number of item types},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). A constant-factor approximation algorithm for the asymmetric
traveling salesman problem. <em>JACM</em>, <em>67</em>(6), 37:1–53. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {We give a constant-factor approximation algorithm for the asymmetric traveling salesman problem (ATSP). Our approximation guarantee is analyzed with respect to the standard LP relaxation, and thus our result confirms the conjectured constant integrality gap of that relaxation.The main idea of our approach is a reduction to Subtour Partition Cover, an easier problem obtained by significantly relaxing the general connectivity requirements into local connectivity conditions. We first show that any algorithm for Subtour Partition Cover can be turned into an algorithm for ATSP while only losing a small constant factor in the performance guarantee. Next, we present a reduction from general ATSP instances to structured instances, on which we then solve Subtour Partition Cover, yielding our constant-factor approximation algorithm for ATSP.},
  archive  = {J_JACM},
  author   = {Svensson, Ola and Tarnawski, Jakub and V\&#39;{e}gh, L\&#39;{a}szl\&#39;{o} A.},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {6},
  pages    = {37:1-53},
  title    = {A constant-factor approximation algorithm for the asymmetric traveling salesman problem},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Approximating edit distance within constant factor in truly
sub-quadratic time. <em>JACM</em>, <em>67</em>(6), 36:1–22. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {Edit distance is a measure of similarity of two strings based on the minimum number of character insertions, deletions, and substitutions required to transform one string into the other. The edit distance can be computed exactly using a dynamic programming algorithm that runs in quadratic time. Andoni, Krauthgamer, and Onak (2010) gave a nearly linear time algorithm that approximates edit distance within approximation factor poly(log n).In this article, we provide an algorithm with running time \~{O}(n2−2/7) that approximates the edit distance within a constant factor.},
  archive  = {J_JACM},
  author   = {Chakraborty, Diptarka and Das, Debarati and Goldenberg, Elazar and Kouck\&#39;{y}, Michal and Saks, Michael},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {6},
  pages    = {36:1-22},
  title    = {Approximating edit distance within constant factor in truly sub-quadratic time},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Semantic optimization of conjunctive queries. <em>JACM</em>,
<em>67</em>(6), 34:1–60. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {This work deals with the problem of semantic optimization of the central class of conjunctive queries (CQs). Since CQ evaluation is NP-complete, a long line of research has focussed on identifying fragments of CQs that can be efficiently evaluated. One of the most general restrictions corresponds to generalized hypetreewidth bounded by a fixed constant k ≥ 1; the associated fragment is denoted GHWk. A CQ is semantically in GHWk if it is equivalent to a CQ in GHWk. The problem of checking whether a CQ is semantically in GHWk has been studied in the constraint-free case, and it has been shown to be NP-complete. However, in case the database is subject to constraints such as tuple-generating dependencies (TGDs) that can express, e.g., inclusion dependencies, or equality-generating dependencies (EGDs) that capture, e.g., key dependencies, a CQ may turn out to be semantically in GHWk under the constraints, while not being semantically in GHWk without the constraints. This opens avenues to new query optimization techniques. In this article, we initiate and develop the theory of semantic optimization of CQs under constraints. More precisely, we study the following natural problem: Given a CQ and a set of constraints, is the query semantically in GHWk, for a fixed k ≥ 1, under the constraints, or, in other words, is the query equivalent to one that belongs to GHWk over all those databases that satisfy the constraints? We show that, contrary to what one might expect, decidability of CQ containment is a necessary but not a sufficient condition for the decidability of the problem in question. In particular, we show that checking whether a CQ is semantically in GHW1 is undecidable in the presence of full TGDs (i.e., Datalog rules) or EGDs. In view of the above negative results, we focus on the main classes of TGDs for which CQ containment is decidable and that do not capture the class of full TGDs, i.e., guarded, non-recursive, and sticky sets of TGDs, and show that the problem in question is decidable, while its complexity coincides with the complexity of CQ containment. We also consider key dependencies over unary and binary relations, and we show that the problem in question is decidable in elementary time. Furthermore, we investigate whether being semantically in GHWk alleviates the cost of query evaluation. Finally, in case a CQ is not semantically in GHWk, we discuss how it can be approximated via a CQ that falls in GHWk in an optimal way. Such approximations might help finding “quick” answers to the input query when exact evaluation is intractable.},
  archive  = {J_JACM},
  author   = {Barcel\&#39;{o}, Pablo and Figueira, Diego and Gottlob, Georg and Pieris, Andreas},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {6},
  pages    = {34:1-60},
  title    = {Semantic optimization of conjunctive queries},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). A unified translation of linear temporal logic to
ω-automata. <em>JACM</em>, <em>67</em>(6), 33:1–61. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {We present a unified translation of linear temporal logic (LTL) formulas into deterministic Rabin automata (DRA), limit-deterministic B\&quot;{u}chi automata (LDBA), and nondeterministic B\&quot;{u}chi automata (NBA). The translations yield automata of asymptotically optimal size (double or single exponential, respectively). All three translations are derived from one single Master Theorem of purely logical nature. The Master Theorem decomposes the language of a formula into a positive Boolean combination of languages that can be translated into ω-automata by elementary means. In particular, Safra’s, ranking, and breakpoint constructions used in other translations are not needed. We further give evidence that this theoretical clean and compositional approach does not lead to large automata per se and in fact in the case of DRAs yields significantly smaller automata compared to the previously known approach using determinisation of NBAs.},
  archive  = {J_JACM},
  author   = {Esparza, Javier and K\v{r}et\&#39;{\i}nsk\&#39;{y}, Jan and Sickert, Salomon},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {6},
  pages    = {33:1-61},
  title    = {A unified translation of linear temporal logic to ω-automata},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Near-optimal sample complexity bounds for robust learning of
gaussian mixtures via compression schemes. <em>JACM</em>,
<em>67</em>(6), 32:1–42. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {We introduce a novel technique for distribution learning based on a notion of sample compression. Any class of distributions that allows such a compression scheme can be learned with few samples. Moreover, if a class of distributions has such a compression scheme, then so do the classes of products and mixtures of those distributions.As an application of this technique, we prove that ˜Θ(kd2/ε2) samples are necessary and sufficient for learning a mixture of k Gaussians in Rd, up to error ε in total variation distance. This improves both the known upper bounds and lower bounds for this problem. For mixtures of axis-aligned Gaussians, we show that \~{O}(kd/ε2) samples suffice, matching a known lower bound. Moreover, these results hold in an agnostic learning (or robust estimation) setting, in which the target distribution is only approximately a mixture of Gaussians. Our main upper bound is proven by showing that the class of Gaussians in Rd admits a small compression scheme.},
  archive  = {J_JACM},
  author   = {Ashtiani, Hassan and Ben-David, Shai and Harvey, Nicholas J. A. and Liaw, Christopher and Mehrabian, Abbas and Plan, Yaniv},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {6},
  pages    = {32:1-42},
  title    = {Near-optimal sample complexity bounds for robust learning of gaussian mixtures via compression schemes},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Automating resolution is NP-hard. <em>JACM</em>,
<em>67</em>(5), 31:1–17. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {We show that the problem of finding a Resolution refutation that is at most polynomially longer than a shortest one is NP-hard. In the parlance of proof complexity, Resolution is not automatable unless P = NP. Indeed, we show that it is NP-hard to distinguish between formulas that have Resolution refutations of polynomial length and those that do not have subexponential length refutations. This also implies that Resolution is not automatable in subexponential time or quasi-polynomial time unless&amp;nbsp;NP is included in SUBEXP or QP, respectively.},
  archive  = {J_JACM},
  author   = {Atserias, Albert and M\&quot;{u}ller, Moritz},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {5},
  pages    = {31:1-17},
  title    = {Automating resolution is NP-hard},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). A proof of the CSP dichotomy conjecture. <em>JACM</em>,
<em>67</em>(5), 30:1–78. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {Many natural combinatorial problems can be expressed as constraint satisfaction problems. This class of problems is known to be NP-complete in general, but certain restrictions on the form of the constraints can ensure tractability. The standard way to parameterize interesting subclasses of the constraint satisfaction problem is via finite constraint languages. The main problem is to classify those subclasses that are solvable in polynomial time and those that are NP-complete. It was conjectured that if a constraint language has a weak near-unanimity polymorphism then the corresponding constraint satisfaction problem is tractable; otherwise, it is NP-complete.In the article, we present an algorithm that solves Constraint Satisfaction Problem in polynomial time for constraint languages having a weak near unanimity polymorphism, which proves the remaining part of the conjecture.1},
  archive  = {J_JACM},
  author   = {Zhuk, Dmitriy},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {5},
  pages    = {30:1-78},
  title    = {A proof of the CSP dichotomy conjecture},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020b). Invited articles foreword. <em>JACM</em>, <em>67</em>(5),
29:1–1. (<a href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive = {J_JACM},
  author  = {Tardos, Eva},
  doi     = {10.1145/3372419},
  journal = {J. ACM},
  number  = {5},
  pages   = {29:1-1},
  title   = {Invited articles foreword},
  volume  = {67},
  year    = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Universally composable security. <em>JACM</em>,
<em>67</em>(5), 28:1–94. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {This work presents a general framework for describing cryptographic protocols and analyzing their security. The framework allows specifying the security requirements of practically any cryptographic task in a unified and systematic way. Furthermore, in this framework the security of protocols is preserved under a general composition operation, called universal composition. The proposed framework with its security-preserving composition operation allows for modular design and analysis of complex cryptographic protocols from simpler building blocks. Moreover, within this framework, protocols are guaranteed to maintain their security in any context, even in the presence of an unbounded number of arbitrary protocol sessions that run concurrently in an adversarially controlled manner. This is a useful guarantee, which allows arguing about the security of cryptographic protocols in complex and unpredictable environments such as modern communication networks.},
  archive  = {J_JACM},
  author   = {Canetti, Ran},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {5},
  pages    = {28:1-94},
  title    = {Universally composable security},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Parallelism in randomized incremental algorithms.
<em>JACM</em>, <em>67</em>(5), 27:1–27. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {In this article, we show that many sequential randomized incremental algorithms are in fact parallel. We consider algorithms for several problems, including Delaunay triangulation, linear programming, closest pair, smallest enclosing disk, least-element lists, and strongly connected components.We analyze the dependencies between iterations in an algorithm and show that the dependence structure is shallow with high probability or that, by violating some dependencies, the structure is shallow and the work is not increased significantly. We identify three types of algorithms based on their dependencies and present a framework for analyzing each type. Using the framework gives work-efficient polylogarithmic-depth parallel algorithms for most of the problems that we study.This article shows the first incremental Delaunay triangulation algorithm with optimal work and polylogarithmic depth. This result is important, since most implementations of parallel Delaunay triangulation use the incremental approach. Our results also improve bounds on strongly connected components and least-element lists and significantly simplify parallel algorithms for several problems.},
  archive  = {J_JACM},
  author   = {Blelloch, Guy E. and Gu, Yan and Shun, Julian and Sun, Yihan},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {5},
  pages    = {27:1-27},
  title    = {Parallelism in randomized incremental algorithms},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Oracle-efficient online learning and auction design.
<em>JACM</em>, <em>67</em>(5), 26:1–57. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {We consider the design of computationally efficient online learning algorithms in an adversarial setting in which the learner has access to an offline optimization oracle. We present an algorithm called Generalized Follow-the-Perturbed-Leader and provide conditions under which it is oracle-efficient while achieving vanishing regret. Our results make significant progress on an open problem raised by Hazan and Koren [31], who showed that oracle-efficient algorithms do not exist in general&amp;nbsp;[30] and asked whether one can identify properties under which oracle-efficient online learning may be possible.Our auction-design framework considers an auctioneer learning an optimal auction for a sequence of adversarially selected valuations with the goal of achieving revenue that is almost as good as the optimal auction in hindsight, among a class of auctions. We give oracle-efficient learning results for: (1) VCG auctions with bidder-specific reserves in single-parameter settings, (2) envy-free item pricing in multi-item auctions, and (3) s-level auctions of Morgenstern and Roughgarden [43] for single-item settings. The last result leads to an approximation of the overall optimal Myerson auction when bidders’ valuations are drawn according to a fast-mixing Markov process, extending prior work that only gave such guarantees for the i.i.d. setting.Finally, we derive various extensions, including: (1) oracle-efficient algorithms for the contextual learning setting in which the learner has access to side information (such as bidder demographics), (2) learning with approximate oracles such as those based on Maximal-in-Range algorithms, and (3) no-regret bidding in simultaneous auctions, resolving an open problem of Daskalakis and Syrgkanis [14].},
  archive  = {J_JACM},
  author   = {Dud\&#39;{\i}k, Miroslav and Haghtalab, Nika and Luo, Haipeng and Schapire, Robert E. and Syrgkanis, Vasilis and Vaughan, Jennifer Wortman},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {5},
  pages    = {26:1-57},
  title    = {Oracle-efficient online learning and auction design},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Forcing and calculi for hybrid logics. <em>JACM</em>,
<em>67</em>(4), 25:1–55. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {The definition of institution formalizes the intuitive notion of logic in a category-based setting. Similarly, the concept of stratified institution provides an abstract approach to Kripke semantics. This includes hybrid logics, a type of modal logics expressive enough to allow references to the nodes/states/worlds of the models regarded as relational structures, or multi-graphs. Applications of hybrid logics involve many areas of research, such as computational linguistics, transition systems, knowledge representation, artificial intelligence, biomedical informatics, semantic networks, and ontologies. The present contribution sets a unified foundation for developing formal verification methodologies to reason about Kripke structures by defining proof calculi for a multitude of hybrid logics in the framework of stratified institutions. To prove completeness, the article introduces a forcing technique for stratified institutions with nominal and frame extraction and studies a forcing property based on syntactic consistency. The proof calculus is shown to be complete and the significance of the general results is exhibited on a couple of benchmark examples of hybrid logical systems.},
  archive  = {J_JACM},
  author   = {G\u{a}in\u{a}, Daniel},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {4},
  pages    = {25:1-55},
  title    = {Forcing and calculi for hybrid logics},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). A simple and approximately optimal mechanism for an additive
buyer. <em>JACM</em>, <em>67</em>(4), 24:1–40. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {We consider a monopolist seller with n heterogeneous items, facing a single buyer. The buyer has a value for each item drawn independently according to (non-identical) distributions, and her value for a set of items is additive. The seller aims to maximize his revenue.We suggest using the a priori better of two simple pricing methods: selling the items separately, each at its optimal price, and bundling together, in which the entire set of items is sold as one bundle at its optimal price. We show that for any distribution, this mechanism achieves a constant-factor approximation to the optimal revenue. Beyond its simplicity, this is the first computationally tractable mechanism to obtain a constant-factor approximation for this multi-parameter problem. We additionally discuss extensions to multiple buyers and to valuations that are correlated across items.},
  archive  = {J_JACM},
  author   = {Babaioff, Moshe and Immorlica, Nicole and Lucier, Brendan and Weinberg, S. Matthew},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {4},
  pages    = {24:1-40},
  title    = {A simple and approximately optimal mechanism for an additive buyer},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). The log-approximate-rank conjecture is false. <em>JACM</em>,
<em>67</em>(4), 23:1–28. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {We construct a simple and total Boolean function F = f ○ XOR on 2n variables that has only O(√n) spectral norm, O(n2) approximate rank, and O(n2.5) approximate nonnegative rank. We show it has polynomially large randomized bounded-error communication complexity of Ω(√n). This yields the first exponential gap between the logarithm of the approximate rank and randomized communication complexity for total functions. Thus, F witnesses a refutation of the log-approximate-rank conjecture that was posed by Lee and Shraibman as a very natural analogue for randomized communication of the still unresolved log-rank conjecture for deterministic communication. The best known previous gap for any total function between the two measures is a recent 4th-power separation by G\&quot;{o}\&quot;{o}s et al.Additionally, our function F refutes Grolmusz’s conjecture&amp;nbsp;and a variant of the log-approximate-nonnegative-rank conjecture suggested recently by Kol et&amp;nbsp;al., both of which are implied by the log-approximate-rank conjecture. The complement of F has exponentially large approximate nonnegative rank. This answers a question of Lee [32], showing that approximate nonnegative rank can be exponentially larger than approximate rank. The inner function F also falsifies a conjecture about parity measures of Boolean functions made by Tsang et al. The latter conjecture implied the log-rank conjecture for XOR functions.We are pleased to note that shortly after we published our results, two independent groups of researchers, Anshu et al. and Sinha and de Wolf, used our function F to prove that the quantum-log-rank conjecture is also false by showing that F has Ω(n1/6) quantum communication complexity.},
  archive  = {J_JACM},
  author   = {Chattopadhyay, Arkadev and Mande, Nikhil S. and Sherif, Suhail},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {4},
  pages    = {23:1-28},
  title    = {The log-approximate-rank conjecture is false},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Planar graphs have bounded queue-number. <em>JACM</em>,
<em>67</em>(4), 22:1–38. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {We show that planar graphs have bounded queue-number, thus proving a conjecture of Heath et&amp;nbsp;al. [66] from 1992. The key to the proof is a new structural tool called layered partitions, and the result that every planar graph has a vertex-partition and a layering, such that each part has a bounded number of vertices in each layer, and the quotient graph has bounded treewidth. This result generalises for graphs of bounded Euler genus. Moreover, we prove that every graph in a minor-closed class has such a layered partition if and only if the class excludes some apex graph. Building on this work and using the graph minor structure theorem, we prove that every proper minor-closed class of graphs has bounded queue-number.Layered partitions have strong connections to other topics, including the following two examples. First, they can be interpreted in terms of strong products. We show that every planar graph is a subgraph of the strong product of a path with some graph of bounded treewidth. Similar statements hold for all proper minor-closed classes. Second, we give a simple proof of the result by DeVos et&amp;nbsp;al. [31] that graphs in a proper minor-closed class have low treewidth colourings.},
  archive  = {J_JACM},
  author   = {Dujmovi\&#39;{c}, Vida and Joret, Gwena\&quot;{e}l and Micek, Piotr and Morin, Pat and Ueckerdt, Torsten and Wood, David R.},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {4},
  pages    = {22:1-38},
  title    = {Planar graphs have bounded queue-number},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Planar graph perfect matching is in NC. <em>JACM</em>,
<em>67</em>(4), 21:1–34. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {Is perfect matching in NC? That is, is there a deterministic fast parallel algorithm for it? This has been an outstanding open question in theoretical computer science for over three decades, ever since the discovery of RNC perfect matching algorithms. Within this question, the case of planar graphs has remained an enigma: On the one hand, counting the number of perfect matchings is far harder than finding one (the former is #P-complete and the latter is in P), and on the other, for planar graphs, counting has long been known to be in NC whereas finding one has resisted a solution.In this article, we give an NC algorithm for finding a perfect matching in a planar graph. Our algorithm uses the above-stated fact about counting perfect matchings in a crucial way. Our main new idea is an NC algorithm for finding a face of the perfect matching polytope at which a set (which could be polynomially large) of conditions, involving constraints of the polytope, are simultaneously satisfied. Several other ideas are also needed, such as finding, in NC, a point in the interior of the minimum-weight face of this polytope and finding a balanced tight odd set.},
  archive  = {J_JACM},
  author   = {Anari, Nima and Vazirani, Vijay V.},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {4},
  pages    = {21:1-34},
  title    = {Planar graph perfect matching is in NC},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Embeddability in r3 is NP-hard. <em>JACM</em>,
<em>67</em>(4), 20:1–29. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {We prove that the problem of deciding whether a two- or three-dimensional simplicial complex embeds into R3 is NP-hard. Our construction also shows that deciding whether a 3-manifold with boundary tori admits an S3 filling is NP-hard. The former stands in contrast with the lower-dimensional cases, which can be solved in linear time, and the latter with a variety of computational problems in 3-manifold topology, for example, unknot or 3-sphere recognition, which are in NP ∩ co- NP. (Membership of the latter problem in co-NP assumes the Generalized Riemann Hypotheses.) Our reduction encodes a satisfiability instance into the embeddability problem of a 3-manifold with boundary tori, and relies extensively on techniques from low-dimensional topology, most importantly Dehn fillings of manifolds with boundary tori.},
  archive  = {J_JACM},
  author   = {Mesmay, Arnaud de and Rieck, Yo’av and Sedgwick, Eric and Tancer, Martin},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {4},
  pages    = {20:1-29},
  title    = {Embeddability in r3 is NP-hard},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Scene grammars, factor graphs, and belief propagation.
<em>JACM</em>, <em>67</em>(4), 19:1–41. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {We describe a general framework for probabilistic modeling of complex scenes and for inference from ambiguous observations. The approach is motivated by applications in image analysis and is based on the use of priors defined by stochastic grammars. We define a class of grammars that capture relationships between the objects in a scene and provide important contextual cues for statistical inference. The distribution over scenes defined by a probabilistic scene grammar can be represented by a graphical model, and this construction can be used for efficient inference with loopy belief propagation.We show experimental results with two applications. One application involves the reconstruction of binary contour maps. Another application involves detecting and localizing faces in images. In both applications, the same framework leads to robust inference algorithms that can effectively combine local information to reason about a scene.},
  archive  = {J_JACM},
  author   = {Chua, Jeroen and Felzenszwalb, Pedro F.},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {4},
  pages    = {19:1-41},
  title    = {Scene grammars, factor graphs, and belief propagation},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). A near-linear time ε-approximation algorithm for geometric
bipartite matching. <em>JACM</em>, <em>67</em>(3), 18:1–19. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {For point sets A, B ⊂ Rd, ∣A∣ = ∣B∣ = n, and for a parameter ε &amp;gt; 0, we present a Monte Carlo algorithm that computes, in O(npoly(log n, 1/ε)) time, an ε-approximate perfect matching of A and B under any Lp-norm with high probability; the previously best-known algorithm takes Ω(n3/2) time. We approximate the Lp-norm using a distance function, d(⋅, ⋅) based on a randomly shifted quad-tree. The algorithm iteratively generates an approximate minimum-cost augmenting path under d(⋅, ⋅) in time proportional, within a polylogarithmic factor, to the length of the path. We show that the total length of the augmenting paths generated by the algorithm is O(n/ε)log n), implying that the running time of our algorithm is O(npoly(log n, 1/ε)).},
  archive  = {J_JACM},
  author   = {Raghvendra, Sharath and Agarwal, Pankaj K.},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {3},
  pages    = {18:1-19},
  title    = {A near-linear time ε-approximation algorithm for geometric bipartite matching},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Fully online matching. <em>JACM</em>, <em>67</em>(3),
17:1–25. (<a href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {We introduce a fully online model of maximum cardinality matching in which all vertices arrive online. On the arrival of a vertex, its incident edges to previously arrived vertices are revealed. Each vertex has a deadline that is after all its neighbors’ arrivals. If a vertex remains unmatched until its deadline, then the algorithm must irrevocably either match it to an unmatched neighbor or leave it unmatched. The model generalizes the existing one-sided online model and is motivated by applications including ride-sharing platforms, real-estate agency, and so on.We show that the Ranking algorithm by Karp et al. (STOC 1990) is 0.5211-competitive in our fully online model for general graphs. Our analysis brings a novel charging mechanic into the randomized primal dual technique by Devanur et al. (SODA 2013), allowing a vertex other than the two endpoints of a matched edge to share the gain. To our knowledge, this is the first analysis of Ranking that beats 0.5 on general graphs in an online matching problem, a first step toward solving the open problem by Karp et al. (STOC 1990) about the optimality of Ranking on general graphs. If the graph is bipartite, then we show a tight competitive ratio ≈0.5671 of Ranking. Finally, we prove that the fully online model is strictly harder than the previous model as no online algorithm can be 0.6317 &amp;lt; 1- 1/e-competitive in our model, even for bipartite graphs.},
  archive  = {J_JACM},
  author   = {Huang, Zhiyi and Kang, Ning and Tang, Zhihao Gavin and Wu, Xiaowei and Zhang, Yuhao and Zhu, Xue},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {3},
  pages    = {17:1-25},
  title    = {Fully online matching},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Representative sets and irrelevant vertices: New tools for
kernelization. <em>JACM</em>, <em>67</em>(3), 16:1–50. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {We continue the development of matroid-based techniques for kernelization, initiated by the present authors [47]. We significantly extend the usefulness of matroid theory in kernelization by showing applications of a result on representative sets due to Lov\&#39;{a}sz [51] and Marx [53]. As a first result, we show how representative sets can be used to derive a polynomial kernel for the elusive ALMOST 2-SAT problem (where the task is to remove at most k clauses to make a 2-CNF formula satisfiable), solving a major open problem in kernelization. This result also yields a new O(√log OPT)-approximation for the problem, improving on the O(√log n)-approximation of Agarwal et al. [3] and an implicit O(log OPT)-approximation due to Even et al. [24].We further apply the representative sets tool to the problem of finding irrelevant vertices in graph cut problems, that is, vertices that can be made undeletable without affecting the answer to the problem. This gives the first significant progress towards a polynomial kernel for the MULTIWAY CUT problem; in particular, we get a kernel of O(ks+1) vertices for MULTIWAY CUT instances with at most s terminals. Both these kernelization results have significant spin-off effects, producing the first polynomial kernels for a range of related problems.More generally, the irrelevant vertex results have implications for covering min cuts in graphs. For a directed graph G=(V,E) and sets S, T ⊆ V, let r be the size of a minimum (S,T)-vertex cut (which may intersect S and T). We can find a set Z ⊆ V of size O(|S| . |T| . r) that contains a minimum (A,B)-vertex cut for every A ⊆ S, B ⊆ T. Similarly, for an undirected graph G=(V,E), a set of terminals X ⊆ V, and a constant s, we can find a set Z⊆ V of size O(|X|s+1) that contains a minimum multiway cut for every partition of X into at most s pairwise disjoint subsets. Both results are polynomial time. We expect this to have further applications; in particular, we get direct, reduction rule-based kernelizations for all problems above, in contrast to the indirect compression-based kernel previously given for ODD CYCLE TRANSVERSAL [47].All our results are randomized, with failure probabilities that can be made exponentially small in n, due to needing a representation of a matroid to apply the representative sets tool.},
  archive  = {J_JACM},
  author   = {Kratsch, Stefan and Wahlstr\&quot;{o}M, Magnus},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {3},
  pages    = {16:1-50},
  title    = {Representative sets and irrelevant vertices: New tools for kernelization},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020b). Distributed exact shortest paths in sublinear time.
<em>JACM</em>, <em>67</em>(3), 15:1–36. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {The distributed single-source shortest paths problem is one of the most fundamental and central problems in the message-passing distributed computing. Classical Bellman-Ford algorithm solves it in O(n) time, where n is the number of vertices in the input graph G. Peleg and Rubinovich [49] showed a lower bound of ˜Ω(D + √ n) for this problem, where D is the hop-diameter of G.Whether or not this problem can be solved in O(n) time when D is relatively small is a major open question. Despite intensive research [10, 17, 33, 41, 45] that yielded near-optimal algorithms for the approximate variant of this problem, no progress was reported for the original problem.In this article, we answer this question in the affirmative. We devise an algorithm that requires O((n log n)5/6) time, for D = O(√ n log n), and O(D1/3 ⋅ (n log n)2/3) time, for larger D. This running time is sublinear in n in almost the entire range of parameters, specifically, for D = o(n/ log2 n).We also generalize our result in two directions. One is when edges have bandwidth b ≥ 1, and the other is the s-sources shortest paths problem. For both problems, our algorithm provides bounds that improve upon the previous state-of-the-art in almost the entire range of parameters. In particular, we provide an all-pairs shortest paths algorithm that requires O(n5/3 ⋅ log 2/3 n) time, even for b = 1, for all values of D.We also devise the first algorithm with non-trivial complexity guarantees for computing exact shortest paths in the multipass semi-streaming model of computation.From the technical viewpoint, our distributed algorithm computes a hopset G′′ of a skeleton graph G′ of G without first computing G′ itself. We then conduct a Bellman-Ford exploration in G′ ∪ G′′, while computing the required edges of G′ on the fly. As a result, our distributed algorithm computes exactly those edges of G′ that it really needs, rather than computing approximately the entire G′.},
  archive  = {J_JACM},
  author   = {Elkin, Michael},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {3},
  pages    = {15:1-36},
  title    = {Distributed exact shortest paths in sublinear time},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). The power of shunning: Efficient asynchronous byzantine
agreement revisited*. <em>JACM</em>, <em>67</em>(3), 14:1–59. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {The problem of Byzantine Agreement (BA) is of interest to both the distributed computing and cryptography communities. Following well-known results from distributed computing literature, the BA problem in the asynchronous network setting encounters inevitable non-termination issues. The impasse is overcome via randomization that allows construction of BA protocols in two flavors of termination guarantee—with overwhelming probability and with probability one. The latter type, termed as almost-surely terminating BA, is the main focus of this article. An eluding problem in the domain of almost-surely terminating BA is achieving a constant expected running time. Our primary contribution in this work makes significant progress in this direction.In a setting with n parties and an adversary with unbounded computing power controlling at most t parties in a Byzantine fashion, we present two almost-surely terminating BA protocols in the asynchronous setting:○ With the optimal resilience of t &amp;lt; n/3, our first protocol runs for an expected O(n) time. The existing protocols in the same setting either run for an expected O(n2) time (Abraham et al., PODC 2008) or require exponential computing power from the honest parties (Wang, CoRR 2015). In terms of communication complexity, our construction outperforms all the known constructions with t &amp;lt; n/3 that offer almost-surely terminating feature.○ With the resilience of t &amp;lt; n/3 + ϵ for any ϵ &amp;gt; 0, our second protocol runs for an expected O(1/ϵ) time. The expected running time of our protocol turns constant when ϵ is a constant fraction. The known constructions with a constant expected running time either require ϵ to be at least 1 (Feldman-Micali, STOC 1988 and Patra-Pandu Rangan, PODC 2010), implying t &amp;lt; n/4, or call for exponential computing power from the parties (Wang, CoRR 2015).We follow the traditional route of building BA via common coin protocol that in turn reduces to Asynchronous Verifiable Secret-Sharing (AVSS). Our constructions are built on a variant of AVSS that is termed as shunning. A shunning AVSS fails to offer the properties of AVSS when the corrupt parties strike, but allows the honest parties to locally detect and shun a set of corrupt parties for any future communication. Our shunning AVSS with t &amp;lt; n/3 and t &amp;lt; n/3 + ϵ guarantee Ω(n) and, respectively, Ω(ϵ t2) conflicts to be revealed when failure occurs. Turning this shunning AVSS to a common coin protocol efficiently constitutes yet another contribution of this work.As a secondary contribution, we show the power of the shunning technique and present a highly efficient cryptographically secure shunning AVSS, which is used further to design an asynchronous BA protocol with the optimal resilience of t &amp;lt; n/3 in the cryptographic setting. Our construct achieves an amortized expected communication complexity of O(n2) bits for reaching agreement on a single bit while consuming a constant expected running time. This property has been achieved for the first time in the cryptographic setting and that, too, with standard cryptographic assumptions. The best-known existing construction (Cachin et al., CCS 2002), while still needing more communication complexity than ours, is proven secure only in the Random-Oracle Model (ROM).},
  archive  = {J_JACM},
  author   = {Bangalore, Laasya and Choudhury, Ashish and Patra, Arpita},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {3},
  pages    = {14:1-59},
  title    = {The power of shunning: Efficient asynchronous byzantine agreement revisited*},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020a). A simple deterministic distributed MST algorithm with
near-optimal time and message complexities. <em>JACM</em>,
<em>67</em>(2), 13:1–15. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {The distributed minimum spanning tree (MST) problem is one of the most central and fundamental problems in distributed graph algorithms. Kutten and Peleg devised an algorithm with running time O(D + √n ⋅ log* n), where D is the hop diameter of the input n-vertex m-edge graph, and with message complexity O(m + n3/2). Peleg and Rubinovich showed that the running time of the algorithm of Kutten and Peleg is essentially tight and asked if one can achieve near-optimal running time together with near-optimal message complexity. In a recent breakthrough, Pandurangan et al. answered this question in the affirmative and devised a randomized algorithm with time \~{O}(D+ √ n) and message complexity \~{O}(m). They asked if such a simultaneous time- and message optimality can be achieved by a deterministic algorithm. In this article, building on the work of Pandurangan et al., we answer this question in the affirmative and devise a deterministic algorithm that computes MST in time O((D + √ n) ⋅ log n) using O(m ⋅ log n + n log n cdot log* n) messages. The polylogarithmic factors in the time and message complexities of our algorithm are significantly smaller than the respective factors in the result of Pandurangan et al. In addition, our algorithm and its analysis are very simple and self-contained as opposed to rather complicated previous sublinear-time algorithms. Finally, we use our new algorithm to devise a randomized MST algorithm with running time \~{O}(μ (G,ω) + √ n) and message complexity \~{O}(|E|), where μ-radius μ (G,ω) ≤ D is a graph parameter, which is typically much smaller than D. This improves a previous bound from Elkin.},
  archive  = {J_JACM},
  author   = {Elkin, M.},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {2},
  pages    = {13:1-15},
  title    = {A simple deterministic distributed MST algorithm with near-optimal time and message complexities},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020a). Invited article foreword. <em>JACM</em>, <em>67</em>(2),
12:1–1. (<a href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive = {J_JACM},
  author  = {Tardos, Eva},
  doi     = {10.1145/3372419},
  journal = {J. ACM},
  number  = {2},
  pages   = {12:1-1},
  title   = {Invited article foreword},
  volume  = {67},
  year    = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Polynomial counting in anonymous dynamic networks with
applications to anonymous dynamic algebraic computations. <em>JACM</em>,
<em>67</em>(2), 11:1–17. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {Starting with with work of Michail et al., the problem of Counting the number of nodes in Anonymous Dynamic Networks has attracted a lot of attention. The problem is challenging because nodes are indistinguishable (they lack identifiers and execute the same program), and the topology may change arbitrarily from round to round of communication, as long as the network is connected in each round. The problem is central in distributed computing, as the number of participants is frequently needed to make important decisions, including termination, agreement, synchronization, among others. A variety of distributed algorithms built on top of mass-distribution techniques have been presented, analyzed, and experimentally evaluated; some of them assumed additional knowledge of network characteristics, such as bounded degree or given upper bound on the network size. However, the question of whether Counting can be solved deterministically in sub-exponential time remained open. In this work, we answer this question positively by presenting Methodical Counting, which runs in polynomial time and requires no knowledge of network characteristics. Moreover, we also show how to extend Methodical Counting to compute the sum of input values and more complex functions without extra cost. Our analysis leverages previous work on random walks in evolving graphs, combined with carefully chosen alarms in the algorithm that control the process and its parameters. To the best of our knowledge, our Counting algorithm and its extensions to other algebraic and Boolean functions are the first that can be implemented in practice with worst-case guarantees.},
  archive  = {J_JACM},
  author   = {Kowalski, Dariusz R. and Mosteiro, Miguel A.},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {2},
  pages    = {11:1-17},
  title    = {Polynomial counting in anonymous dynamic networks with applications to anonymous dynamic algebraic computations},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). A simpler and faster strongly polynomial algorithm for
generalized flow maximization. <em>JACM</em>, <em>67</em>(2), 10:1–26.
(<a href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {We present a new strongly polynomial algorithm for generalized flow maximization that is significantly simpler and faster than the previous strongly polynomial algorithm [34]. For the uncapacitated problem formulation, the complexity bound O(mn(m+n log n)log (n2/m)) improves on the previous estimate by almost a factor O(n2). Even for small numerical parameter values, our running time bound is comparable to the best weakly polynomial algorithms. The key new technical idea is relaxing the primal feasibility conditions. This allows us to work almost exclusively with integral flows, in contrast to all previous algorithms for the problem.},
  archive  = {J_JACM},
  author   = {Olver, Neil and V\&#39;{e}gh, L\&#39;{a}szl\&#39;{o} A.},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {2},
  pages    = {10:1-26},
  title    = {A simpler and faster strongly polynomial algorithm for generalized flow maximization},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Frege systems for quantified boolean logic. <em>JACM</em>,
<em>67</em>(2), 9:1–36. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {We define and investigate Frege systems for quantified Boolean formulas (QBF). For these new proof systems, we develop a lower bound technique that directly lifts circuit lower bounds for a circuit class C to the QBF Frege system operating with lines from C. Such a direct transfer from circuit to proof complexity lower bounds has often been postulated for propositional systems but had not been formally established in such generality for any proof systems prior to this work. This leads to strong lower bounds for restricted versions of QBF Frege, in particular an exponential lower bound for QBF Frege systems operating with AC0[p] circuits. In contrast, any non-trivial lower bound for propositional AC0[p]-Frege constitutes a major open problem.Improving these lower bounds to unrestricted QBF Frege tightly corresponds to the major problems in circuit complexity and propositional proof complexity. In particular, proving a lower bound for QBF Frege systems operating with arbitrary P/poly circuits is equivalent to either showing a lower bound for P/poly or for propositional extended Frege (which operates with P/poly circuits). We also compare our new QBF Frege systems to standard sequent calculi for QBF and establish a correspondence to intuitionistic bounded arithmetic.},
  archive  = {J_JACM},
  author   = {Beyersdorff, Olaf and Bonacina, Ilario and Chew, Leroy and Pich, Jan},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {2},
  pages    = {9:1-36},
  title    = {Frege systems for quantified boolean logic},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Deterministic factorization of sparse polynomials with
bounded individual degree. <em>JACM</em>, <em>67</em>(2), 8:1–28. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {In this article, we study the problem of deterministic factorization of sparse polynomials. We show that if f ∈ F[x1,x2,… ,xn] is a polynomial with s monomials, with individual degrees of its variables bounded by d, then f can be deterministically factored in time spoly(d)log n. Prior to our work, the only efficient factoring algorithms known for this class of polynomials were randomized, and other than for the cases of d=1 and d=2, only exponential time-deterministic factoring algorithms were known.A crucial ingredient in our proof is a quasi-polynomial sparsity bound for factors of sparse polynomials of bounded individual degree. In particular, we show that if f is an s-sparse polynomial in n variables, with individual degrees of its variables bounded by d, then the sparsity of each factor of f is bounded by s(9 d2 log n). This is the first non-trivial bound on factor sparsity for d&amp;gt; 2. Our sparsity bound uses techniques from convex geometry, such as the theory of Newton polytopes and an approximate version of the classical Carath\&#39;{e}odory’s Theorem.Our work addresses and partially answers a question of von zur Gathen and Kaltofen [1985] who asked whether a quasi-polynomial bound holds for the sparsity of factors of sparse polynomials.},
  archive  = {J_JACM},
  author   = {Bhargava, Vishwas and Saraf, Shubhangi and Volkovich, Ilya},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {2},
  pages    = {8:1-28},
  title    = {Deterministic factorization of sparse polynomials with bounded individual degree},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Approximating generalized network design under
(dis)economies of scale with applications to energy efficiency.
<em>JACM</em>, <em>67</em>(1), 7:1–33. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {In a generalized network design (GND) problem, a set of resources are assigned (non-exclusively) to multiple requests. Each request contributes its weight to the resources it uses and the total load on a resource is then translated to the cost it incurs via a resource-specific cost function. Motivated by energy efficiency applications, recently, there is a growing interest in GND using cost functions that exhibit (dis)economies of scale ((D)oS), namely, cost functions that appear subadditive for small loads and superadditive for larger loads.The current article advances the existing literature on approximation algorithms for GND problems with (D)oS cost functions in various aspects: (1) while the existing results are restricted to routing requests in undirected graphs, identifying the resources with the graph’s edges, the current article presents a generic approximation framework that yields approximation results for a much wider family of requests (including various types of Steiner tree and Steiner forest requests) in both directed and undirected graphs, where the resources can be identified with either the edges or the vertices; (2) while the existing results assume that a request contributes the same weight to each resource it uses, our approximation framework allows for unrelated weights, thus providing the first non-trivial approximation for the problem of scheduling unrelated parallel machines with (D)oS cost functions; (3) while most of the existing approximation algorithms are based on convex programming, our approximation framework is fully combinatorial and runs in strongly polynomial time; (4) the family of (D)oS cost functions considered in the current article is more general than the one considered in the existing literature, providing a more accurate abstraction for practical energy conservation scenarios; and (5) we obtain the first approximation ratio for GND with (D)oS cost functions that depends only on the parameters of the resources’ technology and does not grow with the number of resources, the number of requests, or their weights. The design of our approximation framework relies heavily on Roughgarden’s smoothness toolbox [43], thus demonstrating the possible usefulness of this toolbox in the area of approximation algorithms.},
  archive  = {J_JACM},
  author   = {Emek, Yuval and Kutten, Shay and Lavi, Ron and Shi, Yangguang},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {1},
  pages    = {7:1-33},
  title    = {Approximating generalized network design under (Dis)Economies of scale with applications to energy efficiency},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Differential equation invariance axiomatization.
<em>JACM</em>, <em>67</em>(1), 6:1–66. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {This article proves the completeness of an axiomatization for differential equation invariants described by Noetherian functions. First, the differential equation axioms of differential dynamic logic are shown to be complete for reasoning about analytic invariants. Completeness crucially exploits differential ghosts, which introduce additional variables that can be chosen to evolve freely along new differential equations. Cleverly chosen differential ghosts are the proof-theoretical counterpart of dark matter. They create a new hypothetical state, whose relationship to the original state variables satisfies invariants that did not exist before. The reflection of these new invariants in the original system then enables its analysis.An extended axiomatization with existence and uniqueness axioms is complete for all local progress properties, and, with a real induction axiom, is complete for all semianalytic invariants. This parsimonious axiomatization serves as the logical foundation for reasoning about invariants of differential equations. Indeed, it is precisely this logical treatment that enables the generalization of completeness to the Noetherian case.},
  archive  = {J_JACM},
  author   = {Platzer, Andr\&#39;{e} and Tan, Yong Kiam},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {1},
  pages    = {6:1-66},
  title    = {Differential equation invariance axiomatization},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Detecting an odd hole. <em>JACM</em>, <em>67</em>(1),
5:1–12. (<a href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {We give a polynomial-time algorithm to test whether a graph contains an induced cycle with length more than three and odd.},
  archive  = {J_JACM},
  author   = {Chudnovsky, Maria and Scott, Alex and Seymour, Paul and Spirkl, Sophie},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {1},
  pages    = {5:1-12},
  title    = {Detecting an odd hole},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Foundations of context-aware preference propagation.
<em>JACM</em>, <em>67</em>(1), 4:1–43. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {Preferences are a fundamental ingredient in a variety of fields, ranging from economics to computer science, for deciding the best choices among possible alternatives. Contexts provide another important aspect to be considered in the selection of the best choices, since, very often, preferences are affected by context. In particular, the problem of preference propagation from more generic to more specific contexts naturally arises. Such a problem has only been addressed in a very limited way and always resorts to practical, ad hoc approaches. To fill this gap, in this article, we analyze preference propagation in a principled way and adopt an abstract context model without making any specific assumptions on how preferences are stated. Our framework only requires that the contexts form a partially ordered set and that preferences define a strict partial order on the objects of interest. We first formalize the basic properties that any propagation process should satisfy. We then introduce an algebraic model for preference propagation that relies on two abstract operators for combining preferences, and, under mild assumptions, we prove that the only possible interpretations for such operators are the well-known Pareto and Prioritized composition. We then study several propagation methods based on such operators and precisely characterize them in terms of the stated properties. We finally identify a method meeting all the requirements, on the basis of which we provide an efficient algorithm for preference propagation.},
  archive  = {J_JACM},
  author   = {Ciaccia, Paolo and Martinenghi, Davide and Torlone, Riccardo},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {1},
  pages    = {4:1-43},
  title    = {Foundations of context-aware preference propagation},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Silence. <em>JACM</em>, <em>67</em>(1), 3:1–26. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {The cost of communication is a substantial factor affecting the scalability of many distributed applications. Every message sent can incur a cost in storage, computation, energy, and bandwidth. Consequently, reducing the communication costs of distributed applications is highly desirable. The best way to reduce message costs is by communicating without sending any messages whatsoever. This article initiates a rigorous investigation into the use of silence in synchronous settings, in which processes can fail. We formalize sufficient conditions for information transfer using silence, as well as necessary conditions for particular cases of interest. This allows us to identify message patterns that enable communication through silence. In particular, a pattern called a silent choir is identified, and shown to be central to information transfer via silence in failure-prone systems. The power of the new framework is demonstrated on the atomic commitment problem (AC). A complete characterization of the tradeoff between message complexity and round complexity in the synchronous model with crash failures is provided, in terms of lower bounds and matching protocols. In particular, a new message-optimal AC protocol is designed using silence, in which processes decide in three rounds in the common case. This significantly improves on the best previously known message-optimal AC protocol, in which decisions were performed in Θ(n) rounds.And in the naked light I sawTen thousand people, maybe morePeople talking without speaking…People writing songs that voices never shareAnd no one daredDisturb the sound of silencePaul Simon, 1964},
  archive  = {J_JACM},
  author   = {Goren, Guy and Moses, Yoram},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {1},
  pages    = {3:1-26},
  title    = {Silence},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Fully functional suffix trees and optimal text searching in
BWT-runs bounded space. <em>JACM</em>, <em>67</em>(1), 2:1–54. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {Indexing highly repetitive texts—such as genomic databases, software repositories and versioned text collections—has become an important problem since the turn of the millennium. A relevant compressibility measure for repetitive texts is r, the number of runs in their Burrows-Wheeler Transforms (BWTs). One of the earliest indexes for repetitive collections, the Run-Length FM-index, used O(r) space and was able to efficiently count the number of occurrences of a pattern of length m in a text of length n (in O(m log log n) time, with current techniques). However, it was unable to locate the positions of those occurrences efficiently within a space bounded in terms of r. In this article, we close this long-standing problem, showing how to extend the Run-Length FM-index so that it can locate the occ occurrences efficiently (in O(occ log log n) time) within O(r) space. By raising the space to O(r log log n), our index counts the occurrences in optimal time, O(m), and locates them in optimal time as well, O(m + occ). By further raising the space by an O(w/ log σ) factor, where σ is the alphabet size and w = Ω (log n) is the RAM machine size in bits, we support count and locate in O(⌈ m log (σ)/w ⌉) and O(⌈ m log (σ)/w ⌉ + occ) time, which is optimal in the packed setting and had not been obtained before in compressed space. We also describe a structure using O(r log (n/r)) space that replaces the text and extracts any text substring of length ℓ in the almost-optimal time O(log (n/r)+ℓ log (σ)/w). Within that space, we similarly provide access to arbitrary suffix array, inverse suffix array, and longest common prefix array cells in time O(log (n/r)), and extend these capabilities to full suffix tree functionality, typically in O(log (n/r)) time per operation. Our experiments show that our O(r)-space index outperforms the space-competitive alternatives by 1--2 orders of magnitude in time. Competitive implementations of the original FM-index are outperformed by 1--2 orders of magnitude in space and/or 2--3 in time.},
  archive  = {J_JACM},
  author   = {Gagie, Travis and Navarro, Gonzalo and Prezza, Nicola},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {1},
  pages    = {2:1-54},
  title    = {Fully functional suffix trees and optimal text searching in BWT-runs bounded space},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
<li><details>
<summary>
(2020). Matrix multiplication, a little faster. <em>JACM</em>,
<em>67</em>(1), 1:1–31. (<a
href="https://doi.org/10.1145/3372419">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract = {Strassen’s algorithm (1969) was the first sub-cubic matrix multiplication algorithm. Winograd (1971) improved the leading coefficient of its complexity from 6 to 7. There have been many subsequent asymptotic improvements. Unfortunately, most of these have the disadvantage of very large, often gigantic, hidden constants. Consequently, Strassen-Winograd’s O(nlog27) algorithm often outperforms other fast matrix multiplication algorithms for all feasible matrix dimensions. The leading coefficient of Strassen-Winograd’s algorithm has been generally believed to be optimal for matrix multiplication algorithms with a 2 \texttimes{} 2 base case, due to the lower bounds by Probert (1976) and Bshouty (1995).Surprisingly, we obtain a faster matrix multiplication algorithm, with the same base case size and asymptotic complexity as Strassen-Winograd’s algorithm, but with the leading coefficient reduced from 6 to 5. To this end, we extend Bodrato’s (2010) method for matrix squaring, and transform matrices to an alternative basis. We also prove a generalization of Probert’s and Bshouty’s lower bounds that holds under change of basis, showing that for matrix multiplication algorithms with a 2 \texttimes{} 2 base case, the leading coefficient of our algorithm cannot be further reduced, and is therefore optimal. We apply our method to other fast matrix multiplication algorithms, improving their arithmetic and communication costs by significant constant factors.},
  archive  = {J_JACM},
  author   = {Karstadt, Elaye and Schwartz, Oded},
  doi      = {10.1145/3372419},
  journal  = {J. ACM},
  number   = {1},
  pages    = {1:1-31},
  title    = {Matrix multiplication, a little faster},
  volume   = {67},
  year     = {2020},
}
</textarea>
</details></li>
</ul>

</body>
</html>
