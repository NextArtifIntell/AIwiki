<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>TCS_complex_beauty</title>
  <style>
    html {font-size: 22px;}
    body {margin: 0 auto; max-width: 76em;}
    #copyID {font-size: 18px;}
  </style>
  <script>
    function copy(element) {
      if (element.type == "button"){
      element.type="text";
      }
      element.style.color="black";
      element.style.backgroundColor="#C7EDCC";
      element.select();
      element.setSelectionRange(0, 99999);
      navigator.clipboard.writeText(element.value);
      window.getSelection().removeAllRanges();
      element.type="button";
    }
  </script>
</head>
<body>

<h2 id="tcs---7">TCS - 7</h2>
<ul>
<li><details>
<summary>
(2025). A theory of fine-grained lineage for functions on structured
objects. <em>TCS</em>, <em>1039</em>, 115192. (<a
href="https://doi.org/10.1016/j.tcs.2025.115192">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Lineage is the process of keeping track of the relationship between the inputs of a data processing task and the parts of the output they contribute to produce. Depending on its precise definition, lineage can be seen as a form of database provenance, a means of tracking information flow in computer programs, or be used to express causality and provide counter-examples for the falsity of a logical statement. In this paper, we establish the formal foundations of a notion of lineage for arbitrary abstract functions manipulating objects that are “composite” –that is, can be made of multiple other objects. Three definitions of lineage over functions are formally defined, respectively called explanation, participation and extraction; we then establish explanation relationships for a set of elementary functions, and for compositions thereof. A fully functional implementation of these concepts is finally presented and experimentally evaluated.},
  archive      = {J_TCS},
  author       = {Sylvain Hallé and Hugo Tremblay},
  doi          = {10.1016/j.tcs.2025.115192},
  journal      = {Theoretical Computer Science},
  month        = {6},
  pages        = {115192},
  shortjournal = {Theor. Comput. Sci.},
  title        = {A theory of fine-grained lineage for functions on structured objects},
  volume       = {1039},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Improved algorithms for optimal k sink location on path
networks. <em>TCS</em>, <em>1039</em>, 115190. (<a
href="https://doi.org/10.1016/j.tcs.2025.115190">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We address the problem of placing k sinks on dynamic-flow path networks with n vertices so as to minimize their maximum evacuation completion time. We develop two different algorithms that, when all edges have the same capacity, run respectively in O ( n + k 2 log 2 ⁡ n ) and O ( n log ⁡ n ) time. When the edge capacities can be different, i.e., are general , they run respectively in O ( n log ⁡ n + k 2 log 4 ⁡ n ) and O ( n log 3 ⁡ n ) time. These algorithms improve upon the previously most efficient algorithms, which had time complexities O ( k n ) and O ( k n log 2 ⁡ n ) , respectively, for the uniform and general edge capacity models. The improvements are achieved by moving from a dynamic programming based approach to a parametric-search based one.},
  archive      = {J_TCS},
  author       = {Binay Bhattacharya and Mordecai J. Golin and Yuya Higashikawa and Tsunehiko Kameda and Naoki Katoh},
  doi          = {10.1016/j.tcs.2025.115190},
  journal      = {Theoretical Computer Science},
  month        = {6},
  pages        = {115190},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Improved algorithms for optimal k sink location on path networks},
  volume       = {1039},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). The reliability of (n,k)-star network in terms of
non-inclusive fault pattern. <em>TCS</em>, <em>1039</em>, 115189. (<a
href="https://doi.org/10.1016/j.tcs.2025.115189">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Reliability assessment is of significant importance in the design maintenance and improvement of multiprocessor systems which take interconnection networks as underlying topologies. System-level diagnosis is a primary strategy to identify faulty processors by analyzing the syndrome of testing in a system. The newly proposed non-inclusive diagnosability greatly enhances the ability in evaluating the reliability of interconnection networks when comparing to the classical diagnosability. In this article, we first study the non-inclusive diagnosability and the non-inclusive 1-extra diagnosability of ( n , k ) -star network under the MM* model, respectively. Then we design a fast and adaptive non-inclusive fault identification algorithm to identify faulty nodes and fault-free nodes in the ( n , k ) -star network. Furthermore, we implement simulation experiments in terms of TNR, TPR, ACCR, FNR, FPR and F1. Simulation results demonstrate that our proposed method achieves excellent performance in fault detection and network reliability.},
  archive      = {J_TCS},
  author       = {Qigong Chen and Jiafei Liu and Chia-Wei Lee and Jingli Wu and Gaoshi Li},
  doi          = {10.1016/j.tcs.2025.115189},
  journal      = {Theoretical Computer Science},
  month        = {6},
  pages        = {115189},
  shortjournal = {Theor. Comput. Sci.},
  title        = {The reliability of (n,k)-star network in terms of non-inclusive fault pattern},
  volume       = {1039},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Opinion diffusion in graphs: An adversarial approach.
<em>TCS</em>, <em>1039</em>, 115188. (<a
href="https://doi.org/10.1016/j.tcs.2025.115188">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce and study a novel majority-based opinion diffusion model. Consider a graph G , which represents a social network. Assume that initially a subset of nodes, called seed nodes or early adopters, are colored either black or white, which correspond to positive or negative opinion regarding a consumer product or a technological innovation. Then, in each round an uncolored node, which is adjacent to at least one colored node, chooses the most frequent color among its neighbors. Consider a marketing campaign which advertises a product of poor quality and its ultimate goal is that more than half of the population believe in the quality of the product at the end of the opinion diffusion process. We focus on three types of attackers which can select the seed nodes in a deterministic or random fashion and manipulate almost half of them to adopt a positive opinion toward the product (that is, to choose black color). We say that an attacker succeeds if a majority of nodes are black at the end of the process. Our main purpose is to characterize classes of graphs where an attacker cannot succeed. In particular, we prove that if the maximum degree of the underlying graph is not too large or if it has strong expansion properties, then it is fairly resilient to such attacks. Furthermore, we prove tight bounds on the stabilization time of the process (that is, the number of rounds it needs to end) in both settings of choosing the seed nodes deterministically and randomly. We also provide several hardness results for some optimization problems regarding stabilization time and choice of seed nodes.},
  archive      = {J_TCS},
  author       = {Ahad N. Zehmakan},
  doi          = {10.1016/j.tcs.2025.115188},
  journal      = {Theoretical Computer Science},
  month        = {6},
  pages        = {115188},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Opinion diffusion in graphs: An adversarial approach},
  volume       = {1039},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Cost-sharing games with rank-based utilities. <em>TCS</em>,
<em>1039</em>, 115186. (<a
href="https://doi.org/10.1016/j.tcs.2025.115186">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Studies in behavioral science show that individuals are often concerned primarily about their relative welfare, rather than their absolute well-being. In this paper we define and study a variant of congestion games that reflects this phenomenon. In a cost-sharing game with rank-based utilities (CSRB-game, for short), the players are partitioned into competition sets , and the goal of every player is to minimize its cost relative to its competitors . Specifically, the primary goal of a player is to minimize the rank of its cost among its competitors, while minimizing the cost itself is a secondary objective. We show that CSRB-games are significantly different from classical cost-sharing games, and that competition may lead to a poor outcome. In particular, singleton CSRB-games need not have a pure Nash equilibrium, and even when a NE exists, natural dynamics may not converge to a NE, and the price of stability is linear in the number of players. We then analyze several natural restricted classes of singleton CSRB-games, for which we present positive results. We provide tight characterization of classes for which a NE exists and can be computed efficiently, and bound the equilibrium inefficiency, based on the competition structure, the number of players and resources, the uniformity of resources&#39; costs, and the strategy space of competing players.},
  archive      = {J_TCS},
  author       = {Shaul Rosner and Tami Tamir},
  doi          = {10.1016/j.tcs.2025.115186},
  journal      = {Theoretical Computer Science},
  month        = {6},
  pages        = {115186},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Cost-sharing games with rank-based utilities},
  volume       = {1039},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Self-stabilizing multivalued consensus in the presence of
byzantine faults and asynchrony. <em>TCS</em>, <em>1039</em>, 115184.
(<a href="https://doi.org/10.1016/j.tcs.2025.115184">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Consensus, abstracting myriad problems in which processes must agree on a single value, is one of the most celebrated problems of fault-tolerant distributed computing. Consensus applications include fundamental services for the Cloud and Blockchain environments, and in such challenging environments, malicious behaviors are often modeled as adversarial Byzantine faults. At OPODIS 2010, Mostéfaoui and Raynal (in short, MR) presented a Byzantine-tolerant solution to consensus in which the decided value cannot be proposed only by Byzantine processes. MR has optimal resilience coping with up to t &lt; n / 3 Byzantine nodes over n processes. MR provides this multivalued consensus object (which accepts proposals taken from a finite set of values), assuming the availability of a single binary consensus object (which accepts proposals taken from the set { 0 , 1 } ). This work, which focuses on multivalued consensus, aims to design an even more robust solution than MR. Our proposal expands MR&#39;s fault-model with self-stabilization, a vigorous notion of fault-tolerance. In addition to tolerating Byzantine, self-stabilizing systems can automatically recover after arbitrary transient-faults occur. These faults represent any violation of the assumptions according to which the system was designed to operate (provided that the algorithm code remains intact). To the best of our knowledge, we propose the first self-stabilizing solution for multivalued consensus for asynchronous message-passing systems prone to Byzantine failures. Our solution has an O ( t ) stabilization time from arbitrary transient faults.},
  archive      = {J_TCS},
  author       = {Romaric Duvignau and Michel Raynal and Elad Michael Schiller},
  doi          = {10.1016/j.tcs.2025.115184},
  journal      = {Theoretical Computer Science},
  month        = {6},
  pages        = {115184},
  shortjournal = {Theor. Comput. Sci.},
  title        = {Self-stabilizing multivalued consensus in the presence of byzantine faults and asynchrony},
  volume       = {1039},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). K-shortest simple paths in bounded treewidth graphs.
<em>TCS</em>, <em>1039</em>, 115182. (<a
href="https://doi.org/10.1016/j.tcs.2025.115182">www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The k -shortest simple paths problem asks to compute a set of top- k shortest simple paths from a source to a sink in a graph G = ( V , E ) with | V | = n vertices and | E | = m edges. The most well-known algorithm for solving this problem is due to Yen (1971) with time complexity in O ( k n ( m + n log ⁡ n ) ) and the fastest algorithm is due to Gotthilf and Lewenstein (2009) with time complexity in O ( k n ( m + n log ⁡ log ⁡ n ) ) . For bounded treewidth graphs, Eppstein and Kurz (2017) lowered the computational complexity to O ( k n ) by retrieving paths from the k smallest solutions of a monadic second-order formula, and to O ( n + k log ⁡ ( n ) ) to retrieve the k shortest simple distances only. In this paper, we provide an algorithm that answers k -shortest simple distances in O ( k + n ) time on graphs with treewidth at most 2, and a constructive algorithm, simpler than that of Eppstein and Kurz, that solves the k -shortest simple paths problem in O ( k n ) time on bounded treewidth graphs.},
  archive      = {J_TCS},
  author       = {David Coudert and Andrea D&#39;Ascenzo and Clément Rambaud},
  doi          = {10.1016/j.tcs.2025.115182},
  journal      = {Theoretical Computer Science},
  month        = {6},
  pages        = {115182},
  shortjournal = {Theor. Comput. Sci.},
  title        = {K-shortest simple paths in bounded treewidth graphs},
  volume       = {1039},
  year         = {2025},
}
</textarea>
</details></li>
</ul>

</body>
</html>
